<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Penguins Explorer â€“ Inspect Viz</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../examples/general/bias-parameter/index.html" rel="next">
<link href="../../../examples/inspect/tool-usage/index.html" rel="prev">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-e1c87ef72309dee44858cc0136017002.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>
<style type="text/css">
.cell {
  display: flex;
  flex-direction: column-reverse;
}
.code-with-filename {
  margin-top: 1em;
}
</style>


</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Inspect Viz</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Getting Started</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../components-plots.html"> 
<span class="menu-text">Components</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../publishing.html"> 
<span class="menu-text">Publishing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../reference/index.html"> 
<span class="menu-text">Reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../../examples/index.html" aria-current="page"> 
<span class="menu-text">Examples</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../examples/general/penguins/index.html">General</a></li><li class="breadcrumb-item"><a href="../../../examples/general/penguins/index.html">Penguins Explorer</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Examples</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Inspect</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/evals-summary/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Evals Summary</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/tool-usage/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tool Usage</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">General</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/penguins/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Penguins Explorer</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/bias-parameter/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bias Parameter</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/seattle-weather/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Seattle Weather</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/athletes-regression/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Athletes (Regression)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/athletes-errorbars/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Athletes (Error Bars)</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../examples/general/penguins/index.html">General</a></li><li class="breadcrumb-item"><a href="../../../examples/general/penguins/index.html">Penguins Explorer</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Penguins Explorer</h1>
<p class="subtitle lead">Dataset: <a href="penguins.parquet">penguins.parquet</a></p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Use the species drop down to see only points for a particular species. Use the x and y drop downs to explore differnet variables.</p>
<div id="5e9585e5" class="cell" data-execution_count="1">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>Code</strong></pre>
</div>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz <span class="im">import</span> Data, Param</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.<span class="bu">input</span> <span class="im">import</span> select</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.layout <span class="im">import</span> hconcat, vconcat</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.mark <span class="im">import</span> dot</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.plot <span class="im">import</span> plot</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.table <span class="im">import</span> table</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>penguins <span class="op">=</span> Data.from_file(<span class="st">"penguins.parquet"</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> [<span class="st">"body_mass"</span>, <span class="st">"flipper_length"</span>, <span class="st">"bill_depth"</span>, <span class="st">"bill_length"</span>]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>x_axis <span class="op">=</span> Param(<span class="st">"body_mass"</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>y_axis <span class="op">=</span> Param(<span class="st">"flipper_length"</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>vconcat(</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    hconcat(</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        select(penguins, label<span class="op">=</span><span class="st">"Species"</span>, column<span class="op">=</span><span class="st">"species"</span>),</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        select(label<span class="op">=</span><span class="st">"X"</span>, options<span class="op">=</span>axes, target<span class="op">=</span>x_axis),</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        select(label<span class="op">=</span><span class="st">"Y"</span>, options<span class="op">=</span>axes, target<span class="op">=</span>y_axis)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    plot(</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        dot(penguins, x<span class="op">=</span>x_axis, y<span class="op">=</span>y_axis, stroke<span class="op">=</span><span class="st">"species"</span>, symbol<span class="op">=</span><span class="st">"species"</span>),</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        grid<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        x_label<span class="op">=</span><span class="st">"Body mass (g) â†’"</span>,</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        y_label<span class="op">=</span><span class="st">"â†‘ Flipper length (mm)"</span>,</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        legend<span class="op">=</span><span class="st">"symbol"</span>,</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    table(penguins)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell-output cell-output-display" data-execution_count="1">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"95802f42392c4111a5e92b4a2a24150f","version_major":2,"version_minor":1,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>



</main> <!-- /main -->
<script type="application/vnd.jupyter.widget-state+json">
{"state":{"0e200d7ac2834af8abe97f71b11451ea":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"5cac6a153aab4d83907d2ed2c1656fcc":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FB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LFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_9f8c6d1fbff743e1bc73954a3f3764ce","spec":"","tabbable":null,"tables":{},"tooltip":null}},"5e85bfc599184c12af6f9522d553ba52":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FB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LFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_a5874bd748da4c60a8383c52b0ec4dbc","spec":"","tabbable":null,"tables":{},"tooltip":null}},"5fc72644b63a40ccbe058a7905fa3990":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FB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LFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_6e9bc52d6461465c9088468fbdcce252","spec":"","tabbable":null,"tables":{},"tooltip":null}},"686f5c3bfb824a0db725b128337b8580":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"6e9bc52d6461465c9088468fbdcce252":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"7eeb2461dc6547fda8bd0de2447b823d":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"8627f4696ff44c52a564633239dc6ed1":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"\n\n.mosaic-widget fieldset {\n    display: inline-flex;\n    align-items: flex-start;\n    gap: 0.5rem;\n    border: none;\n    margin: 0;\n    padding: 0;\n}\n\n.mosaic-widget fieldset>label {\n    display: inline-flex;\n    align-items: center;\n}\n\n.mosaic-widget fieldset>label>input[type=\"radio\"] {\n    margin-right: 0.25rem;\n}\n\n.mosaic-widget fieldset>legend {\n    font-size: inherit;\n    margin: 0;\n}\n\n.mosaic-widget {\n    margin-top: 10px;\n    margin-bottom: 0.5rem;\n}\n\n.mosaic-widget label {\n    display: inline-flex;\n    align-items: center;\n    white-space: nowrap;\n    margin-bottom: 10px;\n}\n\n.mosaic-widget label>select,\n.mosaic-widget .input-search,\n.mosaic-widget .ts-wrapper,\nlabel>input[type=\"range\"] {\n    margin-left: 0.25rem;\n    margin-right: 0.5rem;\n}\n\n.mosaic-widget .input-search {\n    width: 150px;\n}\n\n.mosaic-widget label>input[type=\"range\"] {\n    margin-right: 0.25rem;\n}\n\n\n.mosaic-widget .slider-input {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-right: 0.5rem;\n}\n\n.mosaic-widget .slider-input label {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.mosaic-widget .slider-input .noUi-target {\n    margin: 0;\n}\n\n.mosaic-widget .slider-input .slider-value {\n    margin: 0;\n    margin-bottom: 10px;\n}\n\n.vscode-dark .mosaic-widget {\n    color: rgb(52, 58, 64);\n}\n\n/* nouislider */\n\n.noUi-target,\n.noUi-target * {\n    -webkit-touch-callout: none;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-user-select: none;\n    -ms-touch-action: none;\n    touch-action: none;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box\n}\n\n.noUi-target {\n    position: relative\n}\n\n.noUi-base,\n.noUi-connects {\n    width: 100%;\n    height: 100%;\n    position: relative;\n    z-index: 1\n}\n\n.noUi-connects {\n    overflow: hidden;\n    z-index: 0\n}\n\n.noUi-connect,\n.noUi-origin {\n    will-change: transform;\n    position: absolute;\n    z-index: 1;\n    top: 0;\n    right: 0;\n    height: 100%;\n    width: 100%;\n    -ms-transform-origin: 0 0;\n    -webkit-transform-origin: 0 0;\n    -webkit-transform-style: preserve-3d;\n    transform-origin: 0 0;\n    transform-style: flat\n}\n\n.noUi-txt-dir-rtl.noUi-horizontal .noUi-origin {\n    left: 0;\n    right: auto\n}\n\n.noUi-vertical .noUi-origin {\n    top: -100%;\n    width: 0\n}\n\n.noUi-horizontal .noUi-origin {\n    height: 0\n}\n\n.noUi-handle {\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    position: absolute\n}\n\n.noUi-touch-area {\n    height: 100%;\n    width: 100%\n}\n\n.noUi-state-tap .noUi-connect,\n.noUi-state-tap .noUi-origin {\n    -webkit-transition: transform .3s;\n    transition: transform .3s\n}\n\n.noUi-state-drag * {\n    cursor: inherit !important\n}\n\n.noUi-horizontal {\n    height: 18px\n}\n\n.noUi-horizontal .noUi-handle {\n    width: 34px;\n    height: 28px;\n    right: -17px;\n    top: -6px\n}\n\n.noUi-vertical {\n    width: 18px\n}\n\n.noUi-vertical .noUi-handle {\n    width: 28px;\n    height: 34px;\n    right: -6px;\n    bottom: -17px\n}\n\n.noUi-txt-dir-rtl.noUi-horizontal .noUi-handle {\n    left: -17px;\n    right: auto\n}\n\n.noUi-target {\n    background: #FAFAFA;\n    border-radius: 4px;\n    border: 1px solid #D3D3D3;\n    box-shadow: inset 0 1px 1px #F0F0F0, 0 3px 6px -5px #BBB\n}\n\n.noUi-connects {\n    border-radius: 3px\n}\n\n.noUi-connect {\n    background: #3FB8AF\n}\n\n.noUi-draggable {\n    cursor: ew-resize\n}\n\n.noUi-vertical .noUi-draggable {\n    cursor: ns-resize\n}\n\n.noUi-handle {\n    border: 1px solid #D9D9D9;\n    border-radius: 3px;\n    background: #FFF;\n    cursor: default;\n    box-shadow: inset 0 0 1px #FFF, inset 0 1px 7px #EBEBEB, 0 3px 6px -3px #BBB\n}\n\n.noUi-active {\n    box-shadow: inset 0 0 1px #FFF, inset 0 1px 7px #DDD, 0 3px 6px -3px #BBB\n}\n\n.noUi-handle:after,\n.noUi-handle:before {\n    content: \"\";\n    display: block;\n    position: absolute;\n    height: 14px;\n    width: 1px;\n    background: #E8E7E6;\n    left: 14px;\n    top: 6px\n}\n\n.noUi-handle:after {\n    left: 17px\n}\n\n.noUi-vertical .noUi-handle:after,\n.noUi-vertical .noUi-handle:before {\n    width: 14px;\n    height: 1px;\n    left: 6px;\n    top: 14px\n}\n\n.noUi-vertical .noUi-handle:after {\n    top: 17px\n}\n\n[disabled] .noUi-connect {\n    background: #B8B8B8\n}\n\n[disabled] .noUi-handle,\n[disabled].noUi-handle,\n[disabled].noUi-target {\n    cursor: not-allowed\n}\n\n.noUi-pips,\n.noUi-pips * {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box\n}\n\n.noUi-pips {\n    position: absolute;\n    color: #999\n}\n\n.noUi-value {\n    position: absolute;\n    white-space: nowrap;\n    text-align: center\n}\n\n.noUi-value-sub {\n    color: #ccc;\n    font-size: 10px\n}\n\n.noUi-marker {\n    position: absolute;\n    background: #CCC\n}\n\n.noUi-marker-sub {\n    background: #AAA\n}\n\n.noUi-marker-large {\n    background: #AAA\n}\n\n.noUi-pips-horizontal {\n    padding: 10px 0;\n    height: 80px;\n    top: 100%;\n    left: 0;\n    width: 100%\n}\n\n.noUi-value-horizontal {\n    -webkit-transform: translate(-50%, 50%);\n    transform: translate(-50%, 50%)\n}\n\n.noUi-rtl .noUi-value-horizontal {\n    -webkit-transform: translate(50%, 50%);\n    transform: translate(50%, 50%)\n}\n\n.noUi-marker-horizontal.noUi-marker {\n    margin-left: -1px;\n    width: 2px;\n    height: 5px\n}\n\n.noUi-marker-horizontal.noUi-marker-sub {\n    height: 10px\n}\n\n.noUi-marker-horizontal.noUi-marker-large {\n    height: 15px\n}\n\n.noUi-pips-vertical {\n    padding: 0 10px;\n    height: 100%;\n    top: 0;\n    left: 100%\n}\n\n.noUi-value-vertical {\n    -webkit-transform: translate(0, -50%);\n    transform: translate(0, -50%);\n    padding-left: 25px\n}\n\n.noUi-rtl .noUi-value-vertical {\n    -webkit-transform: translate(0, 50%);\n    transform: translate(0, 50%)\n}\n\n.noUi-marker-vertical.noUi-marker {\n    width: 5px;\n    height: 2px;\n    margin-top: -1px\n}\n\n.noUi-marker-vertical.noUi-marker-sub {\n    width: 10px\n}\n\n.noUi-marker-vertical.noUi-marker-large {\n    width: 15px\n}\n\n.noUi-tooltip {\n    display: block;\n    position: absolute;\n    border: 1px solid #D9D9D9;\n    border-radius: 3px;\n    background: #fff;\n    color: #000;\n    padding: 5px;\n    text-align: center;\n    white-space: nowrap\n}\n\n.noUi-horizontal .noUi-tooltip {\n    -webkit-transform: translate(-50%, 0);\n    transform: translate(-50%, 0);\n    left: 50%;\n    bottom: 120%\n}\n\n.noUi-vertical .noUi-tooltip {\n    -webkit-transform: translate(0, -50%);\n    transform: translate(0, -50%);\n    top: 50%;\n    right: 120%\n}\n\n.noUi-horizontal .noUi-origin>.noUi-tooltip {\n    -webkit-transform: translate(50%, 0);\n    transform: translate(50%, 0);\n    left: auto;\n    bottom: 10px\n}\n\n.noUi-vertical .noUi-origin>.noUi-tooltip {\n    -webkit-transform: translate(0, -18px);\n    transform: translate(0, -18px);\n    top: auto;\n    right: 28px\n}\n\n.noUi-round {\n    height: 10px;\n}\n\n.noUi-round .noUi-connect {\n    background: #c0392b;\n}\n\n.noUi-round .noUi-handle {\n    height: 18px;\n    width: 18px;\n    top: -5px;\n    right: -9px;\n    /* half the width */\n    border-radius: 9px;\n}\n\n.bslib-sidebar-layout .collapse-toggle {\n    right: 0;\n}\n\n.toolbar {\n    row-gap: 0.7rem;\n}\n\n.panel-input {\n    display: inline-block;\n}\n\n.toolbar .mosaic-widget,\n.panel-input .mosaic-widget,\n.toolbar .mosaic-widget label,\n.panel-input .mosaic-widget label {\n    margin-top: 0;\n    margin-bottom: 0;\n}\n\n\n.mosaic-widget .sidebar-fullwidth {\n    margin-bottom: 0;\n}\n\n\n.sidebar .mosaic-widget fieldset>legend,\n.panel-sidebar .mosaic-widget fieldset>legend {\n    margin-bottom: 0.2rem;\n}\n\n.sidebar .mosaic-widget label>select,\n.panel-sidebar .mosaic-widget label>select,\n.sidebar .mosaic-widget .input-search,\n.panel-sidebar .mosaic-widget .input-search,\n.sidebar .mosaic-widget label>input[type=\"range\"],\n.panel-sidebar .mosaic-widget label>input[type=\"range\"],\n.panel-sidebar .mosaic-widget .ts-wrapper,\n.sidebar .mosaic-widget .ts-wrapper {\n    margin-left: 0;\n    margin-right: 0;\n}\n\n.panel-sidebar .mosaic-widget .sidebar-fullwidth,\n.sidebar .mosaic-widget .sidebar-fullwidth,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth>*,\n.sidebar .mosaic-widget .sidebar-fullwidth>*,\n.sidebar .mosaic-widget .sidebar-fullwidth .ts-wrapper,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .ts-wrapper,\n.sidebar .mosaic-widget .sidebar-fullwidth .slider-input,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .slider-input {\n    width: 100%;\n}\n\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .noUi-target,\n.sidebar .mosaic-widget .sidebar-fullwidth .noUi-target {\n    width: 96% !important;\n}\n\n.sidebar .mosaic-widget fieldset,\n.panel-sidebar .mosaic-widget fieldset,\n.sidebar .mosaic-widget .sidebar-fullwidth label,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth label,\n.sidebar .mosaic-widget .slider-input,\n.panel-sidebar .mosaic-widget .slider-input {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 0.1rem;\n}\n\n.mosaic-widget>div>div>label {\n    min-height: 40px;\n}\n\n.mosaic-widget .input-search {\n    padding: .375rem .75rem;\n    border: 1px solid var(--bs-border-color);\n    border-radius: var(--bs-border-radius);\n}\n\n/* remove small top and bottom margin when widgets appear in cards */\n.card-body .mosaic-widget {\n    margin: 0;\n}\n\n/* remove border from ag-grid wrapper (table) when in card */\n.card-body .mosaic-widget .ag-root-wrapper {\n    border: none;\n}\n\n.card-body .mosaic-widget .inspect-viz-table {\n    height: 100%;\n}\n\n.mosaic-widget .inspect-viz-table {\n    --ag-foreground-color: var(--bs-body-color);\n    --ag-background-color: var(--bs-body-bg);\n    --ag-accent-color: var(--bs-primary);\n    --ag-font-family: var(--bs-font-sans-serif);\n    --ag-font-size: var(--bs-font-size-base);\n}\n\n.cell-output-display:not(.no-overflow-x) {\n    overflow-x: visible;\n}\n\n.ts-control {\n    border: 1px solid var(--bs-border-color);\n    border-radius: var(--bs-border-radius);\n    box-shadow: none;\n    box-sizing: border-box;\n    flex-wrap: wrap;\n    overflow: hidden;\n    padding: .375rem .75rem;\n    position: relative;\n    width: 100%;\n    z-index: 1\n}\n\n.ts-wrapper.multi.has-items .ts-control {\n    padding: calc(.375rem - 1px) .75rem calc(.375rem - 4px)\n}\n\n.full .ts-control {\n    background-color: var(--bs-body-bg)\n}\n\n.disabled .ts-control,\n.disabled .ts-control * {\n    cursor: default !important\n}\n\n.focus .ts-control {\n    box-shadow: none\n}\n\n.ts-control>* {\n    display: inline-block;\n    vertical-align: initial\n}\n\n.ts-wrapper.multi .ts-control>div {\n    background: #efefef;\n    border: 0 solid #dee2e6;\n    color: #343a40;\n    cursor: pointer;\n    margin: 0 3px 3px 0;\n    padding: 1px 5px\n}\n\n.ts-wrapper.multi .ts-control>div.active {\n    background: #0d6efd;\n    border: 0 solid transparent;\n    color: #fff\n}\n\n.ts-wrapper.multi.disabled .ts-control>div,\n.ts-wrapper.multi.disabled .ts-control>div.active {\n    background: #fff;\n    border: 0 solid #fff;\n    color: #878787\n}\n\n.ts-control>input {\n    background: none !important;\n    border: 0 !important;\n    box-shadow: none !important;\n    display: inline-block !important;\n    flex: 1 1 auto;\n    line-height: inherit !important;\n    margin: 0 !important;\n    max-height: none !important;\n    max-width: 100% !important;\n    min-height: 0 !important;\n    min-width: 7rem;\n    padding: 0 !important;\n    text-indent: 0 !important;\n    -webkit-user-select: auto !important;\n    -moz-user-select: auto !important;\n    -ms-user-select: auto !important;\n    user-select: auto !important\n}\n\n.ts-control>input::-ms-clear {\n    display: none\n}\n\n.ts-control>input:focus {\n    outline: none !important\n}\n\n.has-items .ts-control>input {\n    margin: 0 4px !important\n}\n\n.ts-control.rtl {\n    text-align: right\n}\n\n.ts-control.rtl.single .ts-control:after {\n    left: calc(.75rem + 5px);\n    right: auto\n}\n\n.ts-control.rtl .ts-control>input {\n    margin: 0 4px 0 -2px !important\n}\n\n.disabled .ts-control {\n    background-color: var(--bs-secondary-bg);\n    opacity: .5\n}\n\n.input-hidden .ts-control>input {\n    left: -10000px;\n    opacity: 0;\n    position: absolute\n}\n\n.ts-dropdown {\n    background: var(--bs-body-bg);\n    border: 1px solid #d0d0d0;\n    border-radius: 0 0 var(--bs-border-radius) var(--bs-border-radius);\n    border-top: 0;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, .1);\n    box-sizing: border-box;\n    left: 0;\n    margin: .25rem 0 0;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 10\n}\n\n.ts-dropdown [data-selectable] {\n    cursor: pointer;\n    overflow: hidden\n}\n\n.ts-dropdown [data-selectable] .highlight {\n    background: rgba(255, 237, 40, .4);\n    border-radius: 1px\n}\n\n.ts-dropdown .create,\n.ts-dropdown .no-results,\n.ts-dropdown .optgroup-header,\n.ts-dropdown .option {\n    padding: 3px .75rem\n}\n\n.ts-dropdown .option,\n.ts-dropdown [data-disabled],\n.ts-dropdown [data-disabled] [data-selectable].option {\n    cursor: inherit;\n    opacity: .5\n}\n\n.ts-dropdown [data-selectable].option {\n    cursor: pointer;\n    opacity: 1\n}\n\n.ts-dropdown .optgroup:first-child .optgroup-header {\n    border-top: 0\n}\n\n.ts-dropdown .optgroup-header {\n    background: var(--bs-body-bg);\n    color: #6c757d;\n    cursor: default\n}\n\n.ts-dropdown .active {\n    background-color: var(--bs-tertiary-bg)\n}\n\n.ts-dropdown .active,\n.ts-dropdown .active.create {\n    color: var(--bs-body-color)\n}\n\n.ts-dropdown .create {\n    color: rgba(52, 58, 64, .5)\n}\n\n.ts-dropdown .spinner {\n    display: inline-block;\n    height: 30px;\n    margin: 3px .75rem;\n    width: 30px\n}\n\n.ts-dropdown .spinner:after {\n    animation: lds-dual-ring 1.2s linear infinite;\n    border-color: #d0d0d0 transparent;\n    border-radius: 50%;\n    border-style: solid;\n    border-width: 5px;\n    content: \" \";\n    display: block;\n    height: 24px;\n    margin: 3px;\n    width: 24px\n}\n\n@keyframes lds-dual-ring {\n    0% {\n        transform: rotate(0deg)\n    }\n\n    to {\n        transform: rotate(1turn)\n    }\n}\n\n.ts-dropdown-content {\n    max-height: 200px;\n    overflow: hidden auto;\n    scroll-behavior: smooth\n}\n\n.ts-wrapper.plugin-drag_drop .ts-dragging {\n    color: transparent !important\n}\n\n.ts-wrapper.plugin-drag_drop .ts-dragging>* {\n    visibility: hidden !important\n}\n\n.plugin-checkbox_options:not(.rtl) .option input {\n    margin-right: .5rem\n}\n\n.plugin-checkbox_options.rtl .option input {\n    margin-left: .5rem\n}\n\n.plugin-clear_button {\n    --ts-pr-clear-button: 1em\n}\n\n.plugin-clear_button .clear-button {\n    background: transparent !important;\n    cursor: pointer;\n    margin-right: 0 !important;\n    opacity: 0;\n    position: absolute;\n    right: calc(.75rem - 5px);\n    top: 50%;\n    transform: translateY(-50%);\n    transition: opacity .5s\n}\n\n.plugin-clear_button.form-select .clear-button,\n.plugin-clear_button.single .clear-button {\n    right: max(var(--ts-pr-caret), .75rem)\n}\n\n.plugin-clear_button.focus.has-items .clear-button,\n.plugin-clear_button:not(.disabled):hover.has-items .clear-button {\n    opacity: 1\n}\n\n.ts-wrapper .dropdown-header {\n    background: color-mix(var(--bs-body-bg), #d0d0d0, 85%);\n    border-bottom: 1px solid #d0d0d0;\n    border-radius: var(--bs-border-radius) var(--bs-border-radius) 0 0;\n    padding: 6px .75rem;\n    position: relative\n}\n\n.ts-wrapper .dropdown-header-close {\n    color: #343a40;\n    font-size: 20px !important;\n    line-height: 20px;\n    margin-top: -12px;\n    opacity: .4;\n    position: absolute;\n    right: .75rem;\n    top: 50%\n}\n\n.ts-wrapper .dropdown-header-close:hover {\n    color: #000\n}\n\n.plugin-dropdown_input.focus.dropdown-active .ts-control {\n    border: 1px solid var(--bs-border-color);\n    box-shadow: none;\n    box-shadow: var(--bs-box-shadow-inset)\n}\n\n.plugin-dropdown_input .dropdown-input {\n    background: transparent;\n    border: solid #d0d0d0;\n    border-width: 0 0 1px;\n    box-shadow: none;\n    display: block;\n    padding: .375rem .75rem;\n    width: 100%\n}\n\n.plugin-dropdown_input.focus .ts-dropdown .dropdown-input {\n    border-color: #86b7fe;\n    box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .25);\n    outline: 0\n}\n\n.plugin-dropdown_input .items-placeholder {\n    border: 0 !important;\n    box-shadow: none !important;\n    width: 100%\n}\n\n.plugin-dropdown_input.dropdown-active .items-placeholder,\n.plugin-dropdown_input.has-items .items-placeholder {\n    display: none !important\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items .ts-control>input {\n    min-width: 0\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input {\n    flex: none;\n    min-width: 4px\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input::-ms-input-placeholder {\n    color: transparent\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input::placeholder {\n    color: transparent\n}\n\n.ts-dropdown.plugin-optgroup_columns .ts-dropdown-content {\n    display: flex\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup {\n    border-right: 1px solid #f2f2f2;\n    border-top: 0;\n    flex-basis: 0;\n    flex-grow: 1;\n    min-width: 0\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup:last-child {\n    border-right: 0\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup:before {\n    display: none\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup-header {\n    border-top: 0\n}\n\n.ts-wrapper.plugin-remove_button .item {\n    align-items: center;\n    display: inline-flex\n}\n\n.ts-wrapper.plugin-remove_button .item .remove {\n    border-radius: 0 2px 2px 0;\n    box-sizing: border-box;\n    color: inherit;\n    display: inline-block;\n    padding: 0 5px;\n    text-decoration: none;\n    vertical-align: middle\n}\n\n.ts-wrapper.plugin-remove_button .item .remove:hover {\n    background: rgba(0, 0, 0, .05)\n}\n\n.ts-wrapper.plugin-remove_button.disabled .item .remove:hover {\n    background: none\n}\n\n.ts-wrapper.plugin-remove_button .remove-single {\n    font-size: 23px;\n    position: absolute;\n    right: 0;\n    top: 0\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item {\n    padding-right: 0 !important\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item .remove {\n    border-left: 1px solid #dee2e6;\n    margin-left: 5px\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item.active .remove {\n    border-left-color: transparent\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl).disabled .item .remove {\n    border-left-color: #fff\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item {\n    padding-left: 0 !important\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item .remove {\n    border-right: 1px solid #dee2e6;\n    margin-right: 5px\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item.active .remove {\n    border-right-color: transparent\n}\n\n.ts-wrapper.plugin-remove_button.rtl.disabled .item .remove {\n    border-right-color: #fff\n}\n\n:root {\n    --ts-pr-clear-button: 0px;\n    --ts-pr-caret: 0px;\n    --ts-pr-min: .75rem\n}\n\n.ts-wrapper.single .ts-control,\n.ts-wrapper.single .ts-control input {\n    cursor: pointer\n}\n\n.ts-control:not(.rtl) {\n    padding-right: max(var(--ts-pr-min), var(--ts-pr-clear-button) + var(--ts-pr-caret)) !important\n}\n\n.ts-control.rtl {\n    padding-left: max(var(--ts-pr-min), var(--ts-pr-clear-button) + var(--ts-pr-caret)) !important\n}\n\n.ts-wrapper {\n    position: relative\n}\n\n.ts-control,\n.ts-control input,\n.ts-dropdown {\n    color: #343a40;\n    font-family: inherit;\n    font-size: inherit;\n    line-height: 1.5\n}\n\n.ts-control,\n.ts-wrapper.single.input-active .ts-control {\n    background: var(--bs-body-bg);\n    cursor: text\n}\n\n.ts-hidden-accessible {\n    border: 0 !important;\n    clip: rect(0 0 0 0) !important;\n    -webkit-clip-path: inset(50%) !important;\n    clip-path: inset(50%) !important;\n    overflow: hidden !important;\n    padding: 0 !important;\n    position: absolute !important;\n    white-space: nowrap !important;\n    width: 1px !important\n}\n\n.ts-dropdown,\n.ts-dropdown.form-control,\n.ts-dropdown.form-select {\n    background: var(--bs-body-bg);\n    border: 1px solid var(--bs-border-color-translucent);\n    border-radius: .375rem;\n    box-shadow: 0 6px 12px rgba(0, 0, 0, .175);\n    height: auto;\n    padding: 0;\n    z-index: 1000\n}\n\n.ts-dropdown .optgroup-header {\n    font-size: .875rem;\n    line-height: 1.5\n}\n\n.ts-dropdown .optgroup:first-child:before {\n    display: none\n}\n\n.ts-dropdown .optgroup:before {\n    border-top: 1px solid var(--bs-border-color-translucent);\n    content: \" \";\n    display: block;\n    height: 0;\n    margin: .5rem -.75rem;\n    overflow: hidden\n}\n\n.ts-dropdown .create {\n    padding-left: .75rem\n}\n\n.ts-dropdown-content {\n    padding: 5px 0\n}\n\n.ts-control {\n    align-items: center;\n    display: flex;\n    transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out\n}\n\n@media (prefers-reduced-motion:reduce) {\n    .ts-control {\n        transition: none\n    }\n}\n\n.focus .ts-control {\n    border-color: #86b7fe;\n    box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .25);\n    outline: 0\n}\n\n.ts-control .item {\n    align-items: center;\n    display: flex\n}\n\n.ts-wrapper.is-invalid,\n.was-validated .invalid,\n.was-validated :invalid+.ts-wrapper {\n    border-color: var(--bs-form-invalid-color)\n}\n\n.ts-wrapper.is-invalid:not(.single),\n.was-validated .invalid:not(.single),\n.was-validated :invalid+.ts-wrapper:not(.single) {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3E%3Ccircle cx='6' cy='6' r='4.5'/%3E%3Cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3E%3Ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3E%3C/svg%3E\");\n    background-position: right calc(.375em + .1875rem) center;\n    background-repeat: no-repeat;\n    background-size: calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-invalid.single,\n.was-validated .invalid.single,\n.was-validated :invalid+.ts-wrapper.single {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\"), url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3E%3Ccircle cx='6' cy='6' r='4.5'/%3E%3Cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3E%3Ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3E%3C/svg%3E\");\n    background-position: right .75rem center, center right 2.25rem;\n    background-repeat: no-repeat;\n    background-size: 16px 12px, calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-invalid.focus .ts-control,\n.was-validated .invalid.focus .ts-control,\n.was-validated :invalid+.ts-wrapper.focus .ts-control {\n    border-color: var(--bs-form-invalid-color);\n    box-shadow: 0 0 0 .25rem rgba(var(--bs-form-invalid-color), .25)\n}\n\n.ts-wrapper.is-valid,\n.was-validated .valid,\n.was-validated :valid+.ts-wrapper {\n    border-color: var(--bs-form-valid-color)\n}\n\n.ts-wrapper.is-valid:not(.single),\n.was-validated .valid:not(.single),\n.was-validated :valid+.ts-wrapper:not(.single) {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23198754' d='M2.3 6.73.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1'/%3E%3C/svg%3E\");\n    background-position: right calc(.375em + .1875rem) center;\n    background-repeat: no-repeat;\n    background-size: calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-valid.single,\n.was-validated .valid.single,\n.was-validated :valid+.ts-wrapper.single {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\"), url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23198754' d='M2.3 6.73.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1'/%3E%3C/svg%3E\");\n    background-position: right .75rem center, center right 2.25rem;\n    background-repeat: no-repeat;\n    background-size: 16px 12px, calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-valid.focus .ts-control,\n.was-validated .valid.focus .ts-control,\n.was-validated :valid+.ts-wrapper.focus .ts-control {\n    border-color: var(--bs-form-valid-color);\n    box-shadow: 0 0 0 .25rem rgba(var(--bs-form-valid-color), .25)\n}\n\n.ts-wrapper {\n    display: flex;\n    min-height: calc(1.5em + .75rem + var(--bs-border-width)*2)\n}\n\n.input-group-sm>.ts-wrapper,\n.ts-wrapper.form-control-sm,\n.ts-wrapper.form-select-sm {\n    min-height: calc(1.5em + .5rem + var(--bs-border-width)*2)\n}\n\n.input-group-sm>.ts-wrapper .ts-control,\n.ts-wrapper.form-control-sm .ts-control,\n.ts-wrapper.form-select-sm .ts-control {\n    border-radius: var(--bs-border-radius-sm);\n    font-size: .875rem\n}\n\n.input-group-sm>.ts-wrapper.has-items .ts-control,\n.ts-wrapper.form-control-sm.has-items .ts-control,\n.ts-wrapper.form-select-sm.has-items .ts-control {\n    font-size: .875rem;\n    padding-bottom: 0\n}\n\n.input-group-sm>.ts-wrapper.multi.has-items .ts-control,\n.ts-wrapper.form-control-sm.multi.has-items .ts-control,\n.ts-wrapper.form-select-sm.multi.has-items .ts-control {\n    padding-top: calc(.75em - .40625rem + var(--bs-border-width)*2/2 - (var(--bs-border-width) + 1px)*2/2) !important\n}\n\n.ts-wrapper.multi.has-items .ts-control {\n    padding-left: calc(.75rem - 5px);\n    --ts-pr-min: calc(0.75rem - 5px)\n}\n\n.ts-wrapper.multi .ts-control>div {\n    border-radius: calc(var(--bs-border-radius) - 1px)\n}\n\n.input-group-lg>.ts-wrapper,\n.ts-wrapper.form-control-lg,\n.ts-wrapper.form-select-lg {\n    min-height: calc(1.5em + 1rem + var(--bs-border-width)*2)\n}\n\n.input-group-lg>.ts-wrapper .ts-control,\n.ts-wrapper.form-control-lg .ts-control,\n.ts-wrapper.form-select-lg .ts-control {\n    border-radius: var(--bs-border-radius-lg);\n    font-size: 1.25rem\n}\n\n.ts-wrapper:not(.form-control, .form-select) {\n    background: none;\n    border: none;\n    box-shadow: none;\n    height: auto;\n    padding: 0\n}\n\n.ts-wrapper:not(.form-control, .form-select).single .ts-control {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\");\n    background-position: right .75rem center;\n    background-repeat: no-repeat;\n    background-size: 16px 12px\n}\n\n.ts-wrapper.form-select,\n.ts-wrapper.single {\n    --ts-pr-caret: 2.25rem\n}\n\n.ts-wrapper.form-control,\n.ts-wrapper.form-select {\n    box-shadow: none;\n    display: flex;\n    height: auto;\n    padding: 0 !important\n}\n\n.ts-wrapper.form-control .ts-control,\n.ts-wrapper.form-control.single.input-active .ts-control,\n.ts-wrapper.form-select .ts-control,\n.ts-wrapper.form-select.single.input-active .ts-control {\n    border: none !important\n}\n\n.ts-wrapper.form-control:not(.disabled) .ts-control,\n.ts-wrapper.form-control:not(.disabled).single.input-active .ts-control,\n.ts-wrapper.form-select:not(.disabled) .ts-control,\n.ts-wrapper.form-select:not(.disabled).single.input-active .ts-control {\n    background: transparent !important\n}\n\n.input-group>.ts-wrapper {\n    flex-grow: 1;\n    width: 1%\n}\n\n.input-group>.ts-wrapper:not(:nth-child(2))>.ts-control {\n    border-bottom-left-radius: 0;\n    border-top-left-radius: 0\n}\n\n.input-group>.ts-wrapper:not(:last-child)>.ts-control {\n    border-bottom-right-radius: 0;\n    border-top-right-radius: 0\n}\n\n.ts-wrapper.single {\n    cursor: pointer !important;\n}\n\n.ts-wrapper.single.input-active .ts-control {\n    cursor: pointer !important;\n}\n\n.ts-control {\n    min-width: 150px;\n}\n\n.ts-dropdown.single {\n    width: auto !important;\n    min-width: 150px !important;\n}\n\n.ts-control>input {\n    min-width: 5rem;\n}\n\n.inspect-viz-table {\n    width: 100%;\n}\n\n.header-center .ag-header-cell-label {\n    justify-content: center;\n}\n\n.header-left .ag-header-cell-label {\n    justify-content: left;\n}\n\n.header-right .ag-header-cell-label {\n    justify-content: right;\n}\n\n.header-justify .ag-header-cell-label {\n    justify-content: space-between;\n}\n\n/* This disables a hard coded min height fo ag-grid.\nThis is their recommended approach (!). See \nhttps://github.com/ag-grid/ag-grid/issues/4095 */\n.ag-layout-auto-height .ag-center-cols-container,\n.ag-layout-auto-height .ag-center-cols-viewport{\n    min-height:0px !important;\n}\n\n.card-body .ag-column-last:after {\n    border: none !important;\n}\n\n\n\n.inspect-tip-container {\n  display: grid;\n  grid-template-columns: max-content auto;\n}\n\n/* Let each row be part of the parent grid */\n.inspect-tip-row {\n  display: contents;\n}\n\n/* Styling for striping */\n.inspect-tip-container > .inspect-tip-row:nth-child(even) > * {\n  background-color: var(--quarto-scss-export-table-striped-bg);\n}\n\n/* Optional padding & border */\n.inspect-tip-container > .inspect-tip-row > div:nth-child(1) {\n    padding-left: 0.5em;\n    padding-right: 0.5em;\n}\n\n.inspect-tip-container > .inspect-tip-row > div:nth-child(2) {\n    padding-right: 0.5em;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-color {\n    display: inline-block;\n    margin-left: 4px;\n    margin-right: 4px;\n    width: .5em;\n    height: .5em;\n    border-radius: 50%;;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-key {\n    font-size: 0.8em;\n    font-weight: 600;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-value {\n    font-size: 0.8em;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.tippy-box[data-theme~='inspect'] {\n  background-color: var(--bs-body-bg, #ffffff);\n  color: var(--bs-body-color, #000000);\n  filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.9));\n}\n\n.tippy-box[data-theme~='inspect'] .tippy-content {\n  padding: 0 !important;\n}\n\n.tippy-box[data-theme~='inspect'] .tippy-arrow:before {\n  color: var(--bs-body-bg, #ffffff); \n  filter: drop-shadow(3 1px 1px rgba(0, 0, 0, 0.9));\n  transform: translateY(1.5px); /* Move arrow down to reduce overlap */\n}\n\n","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsU0FBUyxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFBQSxJQUM5QyxLQUFLO0FBQ0QsYUFBTyxFQUFFLEtBQUssU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDMUMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzlDLEtBQUs7QUFDRCxhQUFPLEVBQUUsY0FBYyxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFBQSxJQUNuRCxLQUFLO0FBQ0QsYUFBTyxFQUFFLFVBQVUsU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDL0MsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQy9DLEtBQUs7QUFDRCxhQUFPLEVBQUUsT0FBTyxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFBQSxJQUM1QyxLQUFLO0FBQ0QsYUFBTyxFQUFFLFFBQVEsU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDN0MsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzdDLEtBQUs7QUFDRCxhQUFPLEVBQUUsUUFBUSxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFBQSxJQUM3QyxLQUFLO0FBQ0QsYUFBTyxFQUFFLFNBQVMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDOUMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzlDO0FBQ0ksWUFBTSxJQUFJLE1BQU0scUNBQXFDLE9BQU8sR0FBRztBQUFBLEVBQ3ZFO0FBQ0o7QUFFQSxJQUFNLHdCQUF3QixDQUMxQixXQUNzRTtBQUN0RSxTQUNJLE9BQU8sV0FBVyxZQUNsQixXQUFXLFFBQ1gsY0FBYyxVQUNkLGdCQUFnQixXQUNmLE9BQU8sYUFBYSxTQUFTLE9BQU8sYUFBYSxTQUNsRCxPQUFPLE9BQU8sZUFBZTtBQUVyQztBQUVBLElBQU0sZUFBZSxDQUFDLFdBQTJDO0FBQzdELFNBQU8sUUFBUSxlQUFlO0FBQ2xDO0FBRUEsSUFBTSxpQkFBaUIsQ0FBQyxXQUE2QztBQUNqRSxTQUFPLFFBQVEsZUFBZTtBQUNsQztBQUVBLElBQU0sZUFBZSxDQUFDLFdBQTJDO0FBQzdELFNBQU8sUUFBUSxlQUFlLFVBQVUsUUFBUSxlQUFlO0FBQ25FO0FBRUEsSUFBTSxnQkFBZ0IsQ0FBQyxXQUE2QztBQUNoRSxTQUFPLFFBQVEsZUFBZSxXQUFXLGtCQUFrQjtBQUMvRDtBQUVBLElBQU0sY0FBYyxDQUFDLFdBQTBDO0FBQzNELFNBQU8sUUFBUSxlQUFlO0FBQ2xDOzs7QUMza0NBO0FBQUEsRUFDSTtBQUFBLEVBQ0EsV0FBQUM7QUFBQSxFQUNBLGVBQUFDO0FBQUEsT0FFRztBQUNQLFNBQXFCLFNBQUFDLGNBQWE7QUFnQjNCLElBQU0sU0FBTixjQUFxQixNQUFNO0FBQUEsRUFNOUIsWUFBK0IsVUFBeUI7QUFDcEQsVUFBTSxTQUFTLFFBQVE7QUFESTtBQUczQixTQUFLLFFBQVEsVUFBVSxJQUFJLGlCQUFpQjtBQUU1QyxRQUFJLFNBQVMsT0FBTztBQUNoQixZQUFNLGFBQWEsT0FBTyxTQUFTLGNBQWMsT0FBTztBQUN4RCxpQkFBVyxhQUFhLE9BQU8sS0FBSyxHQUFHO0FBQ3ZDLGlCQUFXLFlBQVksU0FBUztBQUNoQyxXQUFLLFFBQVEsWUFBWSxVQUFVO0FBQUEsSUFDdkM7QUFHQSxTQUFLLFNBQVMsT0FBTyxTQUFTLGNBQWMsT0FBTztBQUNuRCxTQUFLLE9BQU8sZUFBZTtBQUMzQixTQUFLLE9BQU8sVUFBVSxJQUFJLFlBQVk7QUFDdEMsU0FBSyxPQUFPLEtBQUssS0FBSztBQUN0QixTQUFLLE9BQU8sT0FBTztBQUNuQixRQUFJLEtBQUssU0FBUyxhQUFhO0FBQzNCLFdBQUssT0FBTyxhQUFhLGVBQWUsS0FBSyxTQUFTLFdBQVc7QUFBQSxJQUNyRTtBQUNBLFFBQUksS0FBSyxTQUFTLE9BQU87QUFDckIsV0FBSyxPQUFPLE1BQU0sUUFBUSxHQUFHLFNBQVMsS0FBSztBQUFBLElBQy9DO0FBQ0EsU0FBSyxRQUFRLFlBQVksS0FBSyxNQUFNO0FBR3BDLFNBQUssT0FBTyxpQkFBaUIsU0FBUyxNQUFNO0FBQ3hDLFdBQUssUUFBUSxLQUFLLE9BQU8sS0FBSztBQUFBLElBQ2xDLENBQUM7QUFHRCxRQUFJLENBQUNDLGFBQVksS0FBSyxTQUFTLEVBQUUsR0FBRztBQUNoQyxXQUFLLFNBQVMsR0FBRyxpQkFBaUIsU0FBUyxXQUFTO0FBQ2hELFlBQUksVUFBVSxLQUFLLE9BQU8sT0FBTztBQUM3QixlQUFLLE9BQU8sUUFBUTtBQUFBLFFBQ3hCO0FBQUEsTUFDSixDQUFDO0FBQUEsSUFDTCxPQUFPO0FBQ0gsK0JBQXlCLE1BQU0sS0FBSyxNQUFNO0FBQUEsSUFDOUM7QUFBQSxFQUNKO0FBQUEsRUE5Q2lCO0FBQUEsRUFDQSxNQUFjLFdBQVc7QUFBQSxFQUNsQyxRQUFpQyxDQUFDO0FBQUEsRUFDbEM7QUFBQSxFQTZDUixRQUFRO0FBQ0osU0FBSyxPQUFPLFFBQVE7QUFBQSxFQUN4QjtBQUFBLEVBRUEsT0FBTyxPQUFpQztBQUNwQyxVQUFNLFFBQVEsS0FBSyxTQUFTLFNBQVMsS0FBSyxTQUFTO0FBQ25ELFdBQU8sWUFBWSxPQUFPLE9BQU8sRUFBRSxRQUFRLE1BQU0sUUFBUSxLQUFLLFNBQVMsS0FBSyxDQUFDO0FBQUEsRUFDakY7QUFBQSxFQUVBLFdBQVc7QUFDUCxRQUFJQSxhQUFZLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDL0IsV0FBSyxTQUFTLEdBQUcsU0FBUyxLQUFLLE9BQU8sRUFBRSxDQUFDO0FBQUEsSUFDN0M7QUFBQSxFQUNKO0FBQUEsRUFFQSxRQUFRLE9BQWdCO0FBQ3BCLFFBQUlBLGFBQVksS0FBSyxTQUFTLEVBQUUsR0FBRztBQUMvQixXQUFLLFNBQVMsR0FBRyxPQUFPLEtBQUssT0FBTyxLQUFLLENBQUM7QUFBQSxJQUM5QyxXQUFXQyxTQUFRLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDbEMsV0FBSyxTQUFTLEdBQUcsT0FBTyxLQUFLO0FBQUEsSUFDakM7QUFBQSxFQUNKO0FBQUEsRUFFQSxNQUFNLFNBQXVCLENBQUMsR0FBRztBQUM3QixXQUFPQyxPQUFNLEtBQUssS0FBSyxTQUFTLElBQUksRUFDL0IsT0FBTyxFQUFFLE1BQU0sS0FBSyxTQUFTLE9BQU8sQ0FBQyxFQUNyQyxTQUFTLEVBQ1QsTUFBTSxHQUFHLE1BQU07QUFBQSxFQUN4QjtBQUFBLEVBRUEsWUFBWSxNQUFpQjtBQUN6QixTQUFLLFFBQVE7QUFDYixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsU0FBZTtBQUNYLFVBQU0sT0FBTyxTQUFTLGNBQWMsVUFBVTtBQUM5QyxVQUFNLEtBQUssR0FBRyxLQUFLLEdBQUc7QUFDdEIsU0FBSyxhQUFhLE1BQU0sRUFBRTtBQUMxQixlQUFXLEtBQUssS0FBSyxPQUFPO0FBQ3hCLFlBQU0sTUFBTSxTQUFTLGNBQWMsUUFBUTtBQUMzQyxVQUFJLGFBQWEsU0FBUyxFQUFFLElBQUk7QUFDaEMsV0FBSyxPQUFPLEdBQUc7QUFBQSxJQUNuQjtBQUNBLFFBQUksS0FBSyxXQUFXO0FBQ2hCLFdBQUssVUFBVSxPQUFPO0FBQUEsSUFDMUI7QUFDQSxTQUFLLFFBQVEsWUFBYSxLQUFLLFlBQVksSUFBSztBQUNoRCxTQUFLLE9BQU8sYUFBYSxRQUFRLEVBQUU7QUFDbkMsV0FBTztBQUFBLEVBQ1g7QUFDSjs7O0FDakhPLElBQU0sU0FBd0M7QUFBQSxFQUNqRCxRQUFRLGFBQVcsTUFBTSxRQUFRLE9BQU87QUFBQSxFQUN4QyxRQUFRLGFBQVcsTUFBTSxRQUFRLE9BQU87QUFBQSxFQUN4QyxRQUFRLGFBQVcsTUFBTSxRQUFRLE9BQU87QUFBQSxFQUN4QyxVQUFVLGFBQVcsTUFBTSxVQUFVLE9BQU87QUFBQSxFQUM1QyxhQUFhLGFBQVcsTUFBTSxZQUFZLE9BQU87QUFBQSxFQUNqRCxnQkFBZ0IsYUFBVyxNQUFNLGVBQWUsT0FBTztBQUFBLEVBQ3ZELE9BQU8sYUFBVyxNQUFNLE9BQU8sT0FBTztBQUMxQzs7O0FDakJBO0FBQUEsRUFDSTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBRUE7QUFBQSxPQUNHOzs7QUNQQSxTQUFTLE1BQU0sSUFBMkI7QUFDN0MsU0FBTyxJQUFJLFFBQVEsYUFBVyxXQUFXLFNBQVMsRUFBRSxDQUFDO0FBQ3pEOzs7QURRQSxlQUFzQixhQUFhO0FBQy9CLFFBQU0sbUJBQW1CLG1CQUFtQjtBQUc1QyxRQUFNLFNBQVMsTUFBTSxhQUFhLGdCQUFnQjtBQUVsRCxRQUFNLGFBQWEsSUFBSTtBQUFBLElBQ25CLElBQUksS0FBSyxDQUFDLGtCQUFrQixPQUFPLFVBQVcsS0FBSyxHQUFHO0FBQUEsTUFDbEQsTUFBTTtBQUFBLElBQ1YsQ0FBQztBQUFBLEVBQ0w7QUFHQSxRQUFNLFNBQVMsSUFBSSxPQUFPLFVBQVU7QUFDcEMsUUFBTSxTQUFTLElBQUksY0FBYyxTQUFTLE9BQU87QUFDakQsUUFBTSxLQUFLLElBQUksWUFBWSxRQUFRLE1BQU07QUFDekMsUUFBTSxHQUFHLFlBQVksT0FBTyxZQUFZLE9BQU8sYUFBYTtBQUM1RCxNQUFJLGdCQUFnQixVQUFVO0FBRTlCLFNBQU8sRUFBRSxJQUFJLE9BQU87QUFDeEI7QUFFQSxlQUFzQixhQUNsQixNQUNBLE9BQ0EsRUFBRSxXQUFXLElBQUksSUFBSSxDQUFDLEdBQ3hCO0FBQ0UsU0FBTyxNQUFNO0FBQ1QsUUFBSTtBQUNBLFlBQU0sTUFBTSxNQUFNLEtBQUs7QUFBQSxRQUNuQjtBQUFBO0FBQUE7QUFBQSxpQ0FHaUIsS0FBSztBQUFBO0FBQUEsTUFFMUI7QUFFQSxVQUFJLElBQUksUUFBUztBQUFBLElBQ3JCLFNBQVMsS0FBSztBQUNWLGNBQVE7QUFBQSxRQUNKLFNBQVMsS0FBSyx1Q0FBdUMsUUFBUSxjQUFjLEdBQUc7QUFBQSxNQUNsRjtBQUFBLElBQ0o7QUFFQSxVQUFNLE1BQU0sUUFBUTtBQUFBLEVBQ3hCO0FBQ0o7OztBRXRETyxTQUFTLHdCQUF3QixLQUFpQixRQUFzQjtBQUUzRSxTQUFPLGlCQUFpQixTQUFTLFdBQVM7QUFDdEMsUUFBSSxxQkFBcUIsVUFBVSxNQUFNLEtBQUssQ0FBQztBQUFBLEVBQ25ELENBQUM7QUFHRCxTQUFPLGlCQUFpQixzQkFBc0IsV0FBUztBQUNuRCxRQUFJLHFCQUFxQixVQUFVLE1BQU0sTUFBTSxDQUFDO0FBQUEsRUFDcEQsQ0FBQztBQUdELFNBQU8saUJBQWlCLFdBQVcsV0FBUztBQUN4QyxRQUFJLE1BQU0sS0FBSyxTQUFTLFNBQVM7QUFDN0IsVUFBSSxxQkFBcUIsVUFBVSxNQUFNLEtBQUssS0FBSyxPQUFPLENBQUM7QUFBQSxJQUMvRDtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBV08sU0FBUyxVQUFVLE9BQTJCO0FBQ2pELE1BQUksUUFBUSxLQUFLLEdBQUc7QUFDaEIsV0FBTztBQUFBLE1BQ0gsTUFBTSxNQUFNLFFBQVE7QUFBQSxNQUNwQixTQUFTLE1BQU0sV0FBVztBQUFBLE1BQzFCLE9BQU8sTUFBTSxTQUFTO0FBQUEsTUFDdEIsTUFBTyxNQUFjLFFBQVE7QUFBQSxNQUM3QixHQUFJO0FBQUE7QUFBQSxJQUNSO0FBQUEsRUFDSixXQUFXLE9BQU8sVUFBVSxVQUFVO0FBQ2xDLFdBQU87QUFBQSxNQUNILE1BQU07QUFBQSxNQUNOLFNBQVM7QUFBQSxNQUNULE9BQU8sSUFBSSxNQUFNLEVBQUUsU0FBUztBQUFBLE1BQzVCLE1BQU07QUFBQSxJQUNWO0FBQUEsRUFDSixPQUFPO0FBRUgsV0FBTztBQUFBLE1BQ0gsTUFBTTtBQUFBLE1BQ04sU0FBUyxLQUFLLFVBQVUsT0FBTyxNQUFNLENBQUM7QUFBQSxNQUN0QyxPQUFPLElBQUksTUFBTSxFQUFFLFNBQVM7QUFBQSxNQUM1QixNQUFNO0FBQUEsTUFDTixlQUFlO0FBQUEsSUFDbkI7QUFBQSxFQUNKO0FBQ0o7QUFFTyxTQUFTLFlBQVksT0FBMEI7QUFDbEQsUUFBTSxTQUFTO0FBQUEsSUFDWCxJQUFJO0FBQUEsSUFDSixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVCxRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsRUFDVjtBQUdBLFFBQU0sYUFBYSxnQkFBZ0IsTUFBTSxLQUFLO0FBRzlDLE1BQUksT0FBTztBQUFBO0FBQUEsb0JBRUssT0FBTyxFQUFFO0FBQUEsMEJBQ0gsT0FBTyxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFJeEIsT0FBTyxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbURBT3lCLE9BQU8sS0FBSztBQUFBLDhDQUNqQixPQUFPLEtBQUs7QUFBQTtBQUFBLHVDQUVuQixPQUFPLEtBQUs7QUFBQSxZQUN2QyxXQUFXLE1BQU0sSUFBSSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFLWixPQUFPLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FJRixPQUFPLE1BQU07QUFBQTtBQUFBLGtIQUVvRSxXQUFXLE1BQU0sT0FBTyxDQUFDO0FBQUE7QUFHdkksTUFBSSxNQUFNLFNBQVMsTUFBTTtBQUNyQixZQUFRO0FBQUE7QUFBQSw4QkFFYyxPQUFPLE9BQU87QUFBQSw4QkFDZCxPQUFPLElBQUk7QUFBQSxZQUM3QixXQUFXLE9BQU8sTUFBTSxJQUFJLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQSxFQUd0QztBQUVBLE1BQUksV0FBVyxTQUFTLEdBQUc7QUFDdkIsWUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUlHLE9BQU8sT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFNUixXQUFXLE1BQU07QUFBQTtBQUFBO0FBSWxDLGVBQVcsUUFBUSxDQUFDLE1BQU0sTUFBTTtBQUM1QixjQUFRO0FBQUE7QUFBQSx3QkFFSSxJQUFJLE1BQU0sSUFBSSxPQUFPLFNBQVMsYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQ0FNbkMsT0FBTyxPQUFPLHVCQUF1QixJQUFJLENBQUM7QUFBQSxnQ0FDMUMsT0FBTyxJQUFJO0FBQUEsY0FDN0IsV0FBVyxJQUFJLENBQUM7QUFBQTtBQUFBO0FBQUEsSUFHdEIsQ0FBQztBQUVELFlBQVE7QUFBQTtBQUFBO0FBQUEsRUFHWjtBQUVBLFVBQVE7QUFFUixTQUFPO0FBQ1g7QUFFTyxTQUFTLG1CQUFtQixPQUFrQixVQUF1QjtBQUN4RSxXQUFTLGFBQWEsU0FBUyxFQUFFO0FBQ2pDLFdBQVMsWUFBWSxZQUFZLEtBQUs7QUFDMUM7QUFFQSxTQUFTLGdCQUFnQixPQUF5QjtBQUM5QyxNQUFJLENBQUMsTUFBTyxRQUFPLENBQUM7QUFFcEIsUUFBTSxRQUFRLE1BQU0sTUFBTSxJQUFJO0FBQzlCLFFBQU0sWUFBc0IsQ0FBQztBQUc3QixRQUFNLFdBQXFCO0FBQUE7QUFBQSxJQUV2QjtBQUFBO0FBQUEsSUFFQTtBQUFBO0FBQUEsSUFFQTtBQUFBLEVBQ0o7QUFFQSxhQUFXLFFBQVEsT0FBTztBQUN0QixVQUFNLFVBQVUsS0FBSyxLQUFLO0FBQzFCLFFBQUksQ0FBQyxXQUFXLFlBQVksUUFBUztBQUVyQyxRQUFJLGVBQWU7QUFFbkIsZUFBVyxXQUFXLFVBQVU7QUFDNUIsWUFBTSxRQUFRLFFBQVEsTUFBTSxPQUFPO0FBQ25DLFVBQUksT0FBTztBQUNQLFlBQUksTUFBTSxDQUFDLEdBQUc7QUFDVix5QkFBZSxNQUFNLENBQUMsRUFBRSxLQUFLO0FBQUEsUUFDakM7QUFDQTtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBR0EsUUFBSSxpQkFBaUIsZUFBZSxDQUFDLFNBQVMsS0FBSyxPQUFLLEVBQUUsS0FBSyxPQUFPLENBQUMsR0FBRztBQUN0RSxxQkFBZTtBQUFBLElBQ25CO0FBRUEsY0FBVSxLQUFLLFlBQVk7QUFBQSxFQUMvQjtBQUVBLFNBQU87QUFDWDtBQUVBLFNBQVMsV0FBVyxNQUFzQjtBQUN0QyxRQUFNLE1BQU0sU0FBUyxjQUFjLEtBQUs7QUFDeEMsTUFBSSxjQUFjO0FBQ2xCLFNBQU8sSUFBSTtBQUNmO0FBRUEsU0FBUyxRQUFRLE9BQWdDO0FBQzdDLFNBQU8saUJBQWlCO0FBQzVCOzs7QWpCek1BLElBQU0sYUFBTixjQUF5QixtQkFBbUI7QUFBQSxFQUl4QyxZQUNxQixPQUNqQixjQUNGO0FBQ0UsVUFBTSxFQUFFLGFBQWEsQ0FBQztBQUhMO0FBSWpCLFNBQUssTUFBTSxFQUFFLEdBQUcsS0FBSyxLQUFLLEdBQUcsT0FBTztBQUNwQyxTQUFLLFlBQVksa0JBQWtCLGNBQWMsRUFBRSxZQUFZLEtBQUssTUFBTSxDQUFDLENBQUM7QUFBQSxFQUNoRjtBQUFBLEVBVmlCLFVBQVUsb0JBQUksSUFBWTtBQUFBLEVBQ25DLG1CQUFnQyxDQUFDO0FBQUEsRUFXekMsTUFBTSxZQUFZLE9BQWUsTUFBa0I7QUFFL0MsUUFBSSxLQUFLLFFBQVEsSUFBSSxLQUFLLEdBQUc7QUFDekIsWUFBTSxLQUFLLGFBQWEsS0FBSztBQUM3QjtBQUFBLElBQ0o7QUFHQSxTQUFLLFFBQVEsSUFBSSxLQUFLO0FBR3RCLFVBQU0sS0FBSyxPQUFPLHlCQUF5QixNQUFNO0FBQUEsTUFDN0MsTUFBTTtBQUFBLE1BQ04sUUFBUTtBQUFBLElBQ1osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUVBLE1BQU0sYUFBYSxPQUFlO0FBQzlCLFVBQU0sYUFBYSxLQUFLLE9BQU8sS0FBSztBQUFBLEVBQ3hDO0FBQUEsRUFFQSxxQkFBcUIsT0FBa0I7QUFDbkMsU0FBSyxpQkFBaUIsS0FBSyxLQUFLO0FBQUEsRUFDcEM7QUFBQSxFQUVBLE1BQU0sc0JBQXNCLE9BQWUsS0FBc0M7QUFDN0UsVUFBTSxZQUFZLEtBQUssSUFBSTtBQUMzQixXQUFPLEtBQUssSUFBSSxJQUFJLFlBQVksTUFBTTtBQUNsQyxVQUFJLEtBQUssaUJBQWlCLFNBQVMsR0FBRztBQUNsQyxlQUFPLEtBQUssaUJBQWlCLE1BQU07QUFBQSxNQUN2QztBQUNBLFlBQU0sTUFBTSxHQUFHO0FBQUEsSUFDbkI7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsdUJBQXVCO0FBQ25CLFNBQUssbUJBQW1CLENBQUM7QUFBQSxFQUM3QjtBQUNKO0FBSUEsSUFBTSxrQkFBa0IsT0FBTyxJQUFJLHVCQUF1QjtBQUMxRCxlQUFlLFdBQVcsY0FBMEM7QUFDaEUsUUFBTSxjQUFtQixPQUFPLFdBQVcsY0FBYyxTQUFTO0FBQ2xFLE1BQUksQ0FBQyxZQUFZLGVBQWUsR0FBRztBQUMvQixnQkFBWSxlQUFlLEtBQUssWUFBWTtBQUN4QyxZQUFNLEVBQUUsSUFBSSxPQUFPLElBQUksTUFBTSxXQUFXO0FBQ3hDLFlBQU0sT0FBTyxNQUFNLEdBQUcsUUFBUTtBQUM5QixZQUFNLE1BQU0sSUFBSSxXQUFXLE1BQU0sWUFBWTtBQUM3Qyw4QkFBd0IsS0FBSyxNQUFNO0FBQ25DLGFBQU87QUFBQSxJQUNYLEdBQUc7QUFBQSxFQUNQO0FBQ0EsU0FBTyxZQUFZLGVBQWU7QUFDdEM7OztBa0JoRk8sU0FBUyxhQUFzQjtBQUNsQyxRQUFNLE1BQU07QUFTWixRQUFNLG9CQUNGLE9BQU8sSUFBSSxZQUFZLGVBQ3ZCLE9BQU8sSUFBSSxnQkFBZ0IsZUFDMUIsT0FBTyxJQUFJLFdBQVcsZUFBZSxJQUFJLE9BQU8sU0FDakQsT0FBTyxJQUFJLFlBQVksZUFDdkIsT0FBTyxJQUFJLE9BQU8sZUFDbEIsT0FBTyxJQUFJLHFCQUFxQjtBQUVwQyxTQUFPLHFCQUFxQixpQkFBaUI7QUFDakQ7QUFFTyxTQUFTLG1CQUFtQjtBQUMvQixTQUNJLE9BQU8sU0FBUyxhQUFhLHFCQUM3QixPQUFPLFNBQVMsT0FBTyxTQUFTLDBCQUEwQjtBQUVsRTs7O0FDMUJBLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sV0FBMEI7QUFFMUIsSUFBTSxxQkFBcUIsQ0FBQyxXQUF3QjtBQUV2RCwyQkFBeUIsTUFBTTtBQUsvQixRQUFNLFdBQVcsSUFBSSxpQkFBaUIsTUFBTTtBQUN4Qyw2QkFBeUIsTUFBTTtBQUFBLEVBQ25DLENBQUM7QUFDRCxXQUFTLFFBQVEsUUFBUSxFQUFFLFdBQVcsTUFBTSxTQUFTLEtBQUssQ0FBQztBQUMvRDtBQUlBLElBQU0saUJBQWlCLG9CQUFJLFFBQXVCO0FBRWxELElBQU0sMkJBQTJCLENBQUMsV0FBd0I7QUFDdEQsUUFBTSxjQUFjLE9BQU8saUJBQWlCLEtBQUs7QUFDakQsY0FBWSxRQUFRLFdBQVM7QUFDekIsUUFBSSxTQUFTLENBQUMsZUFBZSxJQUFJLEtBQUssR0FBRztBQUNyQywyQkFBcUIsT0FBTyxNQUFNO0FBQ2xDLHFCQUFlLElBQUksS0FBSztBQUN4QjtBQUFBLElBQ0o7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUVBLElBQUksa0JBQW1DO0FBRXZDLFNBQVMsY0FBYztBQUNuQixrQkFBZ0IsS0FBSztBQUNyQixTQUFPLG9CQUFvQixVQUFVLFdBQVc7QUFDcEQ7QUFFQSxTQUFTLGNBQWM7QUFDbkIsa0JBQWdCLEtBQUs7QUFDckIsU0FBTyxpQkFBaUIsVUFBVSxhQUFhLEVBQUUsTUFBTSxLQUFLLENBQUM7QUFDakU7QUFFQSxJQUFNLHVCQUF1QixDQUFDLE9BQXNCLFdBQXdCO0FBRXhFLE1BQUksQ0FBQyxpQkFBaUI7QUFDbEIsc0JBQWtCLE1BQU0sUUFBUTtBQUFBLE1BQzVCLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxJQUNYLENBQUM7QUFBQSxFQUNMO0FBSUEsUUFBTSxXQUFXLElBQUksaUJBQWlCLGVBQWE7QUFDL0MsY0FBVSxRQUFRLGNBQVk7QUFDMUIsVUFBSSxTQUFTLFNBQVMsYUFBYTtBQUMvQixjQUFNLGNBQWMsTUFBTSxpQkFBaUIscUJBQXFCO0FBQ2hFLFlBQUksWUFBWSxXQUFXLEdBQUc7QUFDMUIsZ0JBQU0saUJBQWlCLFlBQVksQ0FBQztBQUNwQyx5QkFBZSxNQUFNLFVBQVU7QUFJL0IsZ0JBQU0sUUFBUSxlQUFlO0FBQzdCLGNBQUksQ0FBQyxPQUFPO0FBQ1Isd0JBQVk7QUFBQSxVQUNoQixPQUFPO0FBR0gsa0JBQU0sU0FBUyxnQkFBZ0IsS0FBSztBQUdwQyxrQkFBTSxXQUFXLE1BQU0sZUFBZTtBQUN0QyxxQkFBUyxJQUFJLE9BQU8sV0FBVyxLQUFLO0FBQ3BDLHFCQUFTLElBQUksT0FBTyxXQUFXLEtBQUs7QUFDcEMsa0JBQU0sY0FBYyxTQUFTLGdCQUFnQixNQUFNLGFBQWEsQ0FBRTtBQUdsRSxrQkFBTSxVQUFVLFlBQVk7QUFDNUIsa0JBQU0sVUFBVSxZQUFZO0FBRzVCLDRCQUFnQixTQUFTO0FBQUEsY0FDckIsV0FDSSxPQUFPLGNBQWMsV0FBVyxPQUFPLGFBQWEsUUFBUTtBQUFBLGNBQ2hFLHdCQUF3QixNQUFNO0FBQzFCLHVCQUFPO0FBQUEsa0JBQ0gsT0FBTztBQUFBLGtCQUNQLFFBQVE7QUFBQSxrQkFDUixLQUFLO0FBQUEsa0JBQ0wsUUFBUTtBQUFBLGtCQUNSLE1BQU07QUFBQSxrQkFDTixPQUFPO0FBQUEsa0JBQ1AsR0FBRztBQUFBLGtCQUNILEdBQUc7QUFBQSxrQkFDSCxRQUFRLE1BQU07QUFBQSxrQkFBQztBQUFBLGdCQUNuQjtBQUFBLGNBQ0o7QUFBQSxjQUNBLE9BQU8sT0FBTyxjQUFjO0FBQUEsY0FDNUIsUUFBUSxPQUFPLGNBQWMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJO0FBQUEsY0FDakQ7QUFBQTtBQUFBO0FBQUEsZ0JBR0ksT0FBTyxjQUFjLFdBQ2Y7QUFBQSxrQkFDSSxXQUFXO0FBQUEsb0JBQ1A7QUFBQSxzQkFDSSxNQUFNO0FBQUEsc0JBQ04sU0FBUztBQUFBLG9CQUNiO0FBQUEsb0JBQ0E7QUFBQSxzQkFDSSxNQUFNO0FBQUEsc0JBQ04sU0FBUztBQUFBLG9CQUNiO0FBQUEsb0JBQ0E7QUFBQSxzQkFDSSxNQUFNO0FBQUEsc0JBQ04sU0FBUztBQUFBLHNCQUNULE9BQU87QUFBQSxzQkFDUCxJQUFJLENBQUMsRUFBRSxNQUFNLE1BQVc7QUFFcEIsOEJBQU0sY0FBYyxjQUFjLElBQzlCLFVBQVUsTUFBTSxNQUFNLE9BQU8sUUFBUTtBQUN6Qyw4QkFBTSxjQUFjLGNBQWMsSUFDOUIsVUFBVSxNQUFNLE1BQU0sT0FBTyxTQUFTO0FBQUEsc0JBQzlDO0FBQUEsb0JBQ0o7QUFBQSxrQkFDSjtBQUFBLGdCQUNKLElBQ0E7QUFBQTtBQUFBLFlBQ2QsQ0FBQztBQUdELGtCQUFNLFlBQVksU0FBUyxjQUFjLEtBQUs7QUFDOUMsc0JBQVUsVUFBVSxJQUFJLHVCQUF1QjtBQUMvQyxnQkFBSUMsU0FBUTtBQUNaLHVCQUFXLE9BQU8sT0FBTyxRQUFRO0FBRTdCLG9CQUFNLFFBQVEsU0FBUyxjQUFjLEtBQUs7QUFDMUMsb0JBQU0sWUFBWTtBQUNsQix3QkFBVSxZQUFZLEtBQUs7QUFHM0Isb0JBQU0sUUFBUSxTQUFTLGNBQWMsS0FBSztBQUMxQyxvQkFBTSxZQUFZO0FBQ2xCLG9CQUFNLE9BQU8sU0FBUyxlQUFlLElBQUksR0FBRyxDQUFDO0FBRzdDLG9CQUFNLFVBQVUsU0FBUyxjQUFjLEtBQUs7QUFDNUMsc0JBQVEsWUFBWTtBQUVwQixzQkFBUSxPQUFPLFNBQVMsZUFBZSxJQUFJLEtBQUssQ0FBQztBQUNqRCxrQkFBSSxJQUFJLE9BQU87QUFDWCxzQkFBTSxVQUFVLFNBQVMsY0FBYyxNQUFNO0FBQzdDLHdCQUFRLFlBQVk7QUFDcEIsd0JBQVEsTUFBTSxrQkFBa0IsSUFBSTtBQUNwQyx3QkFBUSxPQUFPLE9BQU87QUFBQSxjQUMxQjtBQUVBLG9CQUFNLFlBQVksS0FBSztBQUN2QixvQkFBTSxZQUFZLE9BQU87QUFDekIsY0FBQUE7QUFBQSxZQUNKO0FBR0EsNEJBQWdCLFdBQVcsU0FBUztBQUNwQyx3QkFBWTtBQUFBLFVBQ2hCO0FBQUEsUUFDSixPQUFPO0FBQ0gsZ0JBQU0sSUFBSTtBQUFBLFlBQ04sMkNBQTJDLFlBQVksTUFBTTtBQUFBLFVBQ2pFO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMLENBQUM7QUFFRCxXQUFTLFFBQVEsT0FBTztBQUFBLElBQ3BCLFdBQVc7QUFBQSxJQUNYLFNBQVM7QUFBQSxFQUNiLENBQUM7QUFDTDtBQWlCQSxJQUFNLGtCQUFrQixDQUFDLFVBQXNDO0FBQzNELFFBQU0sU0FBd0IsRUFBRSxRQUFRLENBQUMsRUFBRTtBQUkzQyxRQUFNLGVBQWUsTUFBTSxhQUFhLFdBQVc7QUFDbkQsTUFBSSxjQUFjO0FBQ2QsVUFBTSxRQUFRLGFBQWEsTUFBTSxzQkFBc0I7QUFDdkQsUUFBSSxPQUFPO0FBQ1AsWUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLE1BQU0sR0FBRyxFQUFFLElBQUksTUFBTTtBQUM3QyxhQUFPLFlBQVksRUFBRSxHQUFHLEVBQUU7QUFBQSxJQUM5QjtBQUFBLEVBQ0o7QUFHQSxRQUFNLFdBQVcsTUFBTSxpQkFBaUIsT0FBTztBQUMvQyxXQUFTLFFBQVEsV0FBUztBQUN0QixRQUFJLE1BQU07QUFDVixRQUFJLFFBQVE7QUFDWixRQUFJLFFBQVE7QUFDWixVQUFNLFdBQVcsUUFBUSxVQUFRO0FBQzdCLFVBQUksS0FBSyxhQUFhLFNBQVM7QUFFM0IsY0FBTSxZQUFhLEtBQWlCLGFBQWEsTUFBTTtBQUN2RCxZQUFJLFdBQVc7QUFDWCxrQkFBUTtBQUFBLFFBQ1osT0FBTztBQUNILGdCQUFNLEtBQUssYUFBYSxLQUFLO0FBQUEsUUFDakM7QUFBQSxNQUNKLFdBQVcsS0FBSyxhQUFhLFNBQVM7QUFFbEMsZ0JBQVEsS0FBSyxhQUFhLEtBQUs7QUFBQSxNQUNuQztBQUFBLElBQ0osQ0FBQztBQUNELFFBQUksUUFBUSxVQUFhLFVBQVUsUUFBVztBQUMxQyxhQUFPLE9BQU8sS0FBSyxFQUFFLEtBQUssT0FBTyxNQUFNLENBQUM7QUFBQSxJQUM1QztBQUFBLEVBQ0osQ0FBQztBQUdELFFBQU0sU0FBUyxNQUFNLGNBQWMsTUFBTTtBQUN6QyxNQUFJLFFBQVE7QUFDUixVQUFNLFdBQVcsT0FBTyxhQUFhLEdBQUc7QUFDeEMsUUFBSSxVQUFVO0FBQ1YsYUFBTyxZQUFZLG9CQUFvQixRQUFRO0FBQUEsSUFDbkQ7QUFBQSxFQUNKO0FBRUEsU0FBTztBQUNYO0FBRUEsSUFBTSxxQkFBcUIsQ0FBQyxHQUFXLE1BQTBDO0FBQzdFLE1BQUksSUFBSSxHQUFHO0FBQ1AsV0FBTztBQUFBLEVBQ1gsV0FBVyxJQUFJLEdBQUc7QUFDZCxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLElBQU0sc0JBQXNCLENBQUMsYUFBMkM7QUFDcEUsUUFBTSxTQUFTLGNBQWMsU0FBUyxRQUFRO0FBQzlDLE1BQUksT0FBTyxTQUFTLEdBQUc7QUFDbkIsV0FBTztBQUFBLEVBQ1g7QUFFQSxRQUFNLFNBQVMsT0FBTyxDQUFDO0FBQ3ZCLE1BQUksT0FBTyxTQUFTLEtBQUs7QUFDckIsWUFBUSxLQUFLLG9EQUFvRCxNQUFNO0FBQ3ZFLFdBQU87QUFBQSxFQUNYO0FBRUEsTUFBSSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sR0FBRztBQUNsQyxXQUFPO0FBQUEsRUFDWDtBQUVBLFFBQU0sU0FBUyxPQUFPLENBQUM7QUFDdkIsTUFBSSxPQUFPLFNBQVMsS0FBSztBQUNyQixZQUFRLEtBQUssb0RBQW9ELE1BQU07QUFDdkUsV0FBTztBQUFBLEVBQ1g7QUFFQSxRQUFNLGtCQUFrQixPQUFPLENBQUM7QUFDaEMsTUFBSSxnQkFBZ0IsU0FBUyxPQUFPLGdCQUFnQixTQUFTLEtBQUs7QUFDOUQsWUFBUTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsSUFDSjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBRUEsUUFBTSxpQkFBaUIsT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUMvQyxNQUFJLGVBQWUsU0FBUyxPQUFPLGVBQWUsU0FBUyxLQUFLO0FBQzVELFlBQVE7QUFBQSxNQUNKO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUdBLFFBQU0sSUFBSSxPQUFPO0FBQ2pCLFFBQU0sSUFBSSxPQUFPO0FBRWpCLE1BQUksaUJBQXNEO0FBQzFELE1BQUksSUFBSSxLQUFLLElBQUksR0FBRztBQUNoQixxQkFBaUI7QUFBQSxFQUNyQixXQUFXLElBQUksS0FBSyxJQUFJLEdBQUc7QUFDdkIsUUFBSSxnQkFBZ0IsU0FBUyxLQUFLO0FBQzlCLHVCQUFpQjtBQUFBLElBQ3JCLE9BQU87QUFDSCx1QkFBaUI7QUFBQSxJQUNyQjtBQUFBLEVBQ0osV0FBVyxJQUFJLEtBQUssSUFBSSxHQUFHO0FBQ3ZCLFFBQUksZ0JBQWdCLFNBQVMsS0FBSztBQUM5Qix1QkFBaUI7QUFBQSxJQUNyQixPQUFPO0FBQ0gsdUJBQWlCO0FBQUEsSUFDckI7QUFBQSxFQUNKLFdBQVcsSUFBSSxLQUFLLElBQUksR0FBRztBQUN2QixxQkFBaUI7QUFBQSxFQUNyQixPQUFPO0FBQ0gsWUFBUTtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUdBLE1BQUksZ0JBQTRDO0FBQ2hELE1BQUksZ0JBQWdCLFNBQVMsS0FBSztBQUM5QixvQkFBZ0IsbUJBQW1CLGdCQUFnQixHQUFHLGVBQWUsQ0FBQztBQUFBLEVBQzFFLE9BQU87QUFDSCxvQkFBZ0IsbUJBQW1CLGdCQUFnQixHQUFHLGVBQWUsQ0FBQztBQUFBLEVBQzFFO0FBR0EsTUFBSSxrQkFBa0IsVUFBVTtBQUM1QixXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTyxHQUFHLGNBQWMsSUFBSSxhQUFhO0FBQUEsRUFDN0M7QUFDSjs7O0FwQjVUQSxlQUFlLE9BQU8sRUFBRSxPQUFPLEdBQUcsR0FBNkI7QUFFM0QsUUFBTSxPQUFhLEtBQUssTUFBTSxNQUFNLElBQUksTUFBTSxDQUFDO0FBQy9DLFFBQU0sbUJBQW1CLEVBQUUsY0FBYyxLQUFLLGNBQWMsUUFBUSxFQUFFO0FBQ3RFLFFBQU0sa0JBQWtCLFVBQVUsZ0JBQWdCO0FBR2xELFFBQU0sTUFBTSxNQUFNLFdBQVcsZ0JBQWdCLFlBQVk7QUFHekQsUUFBTSxTQUFpQyxNQUFNLElBQUksUUFBUSxLQUFLLENBQUM7QUFDL0QsUUFBTSxXQUFXLEtBQUssTUFBTTtBQUc1QixLQUFHLFVBQVUsSUFBSSxlQUFlO0FBQ2hDLFFBQU0sZ0JBQWdCLFlBQVksRUFBRTtBQUNwQyxRQUFNLFNBQVMsSUFBSSxJQUFJLE9BQU8sS0FBSyxNQUFNLENBQUM7QUFDMUMsTUFBSSxjQUFjLHFCQUFxQixXQUFXLElBQUksR0FBRztBQUNyRCxPQUFHLE1BQU0sUUFBUTtBQUNqQixPQUFHLE1BQU0sU0FBUztBQUFBLEVBQ3RCO0FBQ0EsTUFBSSxjQUFjLFlBQVksWUFBWSxJQUFJLEdBQUc7QUFHN0MsVUFBTSxPQUFPLEdBQUcsUUFBUSxZQUFZO0FBQ3BDLFFBQUksTUFBTTtBQUNOLFdBQUssTUFBTSxVQUFVO0FBQUEsSUFDekI7QUFBQSxFQUNKO0FBQ0EsUUFBTSxhQUFhLFlBQVk7QUFDM0IsUUFBSTtBQUNBLFVBQUkscUJBQXFCO0FBQ3pCLFlBQU0sYUFBYSxjQUFjLFdBQVcsZUFBZSxNQUFNLEVBQUUsSUFBSTtBQUN2RSxZQUFNLE1BQU0sVUFBVSxZQUFZLEVBQUUsT0FBTyxDQUFDO0FBQzVDLFlBQU0sU0FBVSxNQUFNLFNBQVMsS0FBSyxHQUFHO0FBQ3ZDLFNBQUcsWUFBWTtBQUNmLFNBQUcsWUFBWSxNQUFNO0FBSXJCLHlCQUFvQixNQUFNO0FBRTFCLFlBQU0sdUJBQXVCLEtBQUssRUFBRTtBQUFBLElBQ3hDLFNBQVMsR0FBWTtBQUNqQixjQUFRLE1BQU0sQ0FBQztBQUNmLFlBQU0sUUFBUSxVQUFVLENBQUM7QUFDekIsU0FBRyxZQUFZLFlBQVksS0FBSztBQUFBLElBQ3BDO0FBQUEsRUFDSjtBQUNBLFFBQU0sV0FBVztBQUdqQixNQUFJLGNBQWMsWUFBWSxDQUFDLFlBQVksSUFBSSxHQUFHO0FBQzlDLFFBQUkscUJBQXFCLEdBQUc7QUFDNUIsUUFBSSxzQkFBc0IsR0FBRztBQUc3QixVQUFNLGlCQUFpQixJQUFJO0FBQUEsTUFDdkJDLFVBQVMsWUFBWTtBQUNqQixZQUNJLHVCQUF1QixHQUFHLGVBQzFCLHdCQUF3QixHQUFHLGNBQzdCO0FBQ0UsK0JBQXFCLEdBQUc7QUFDeEIsZ0NBQXNCLEdBQUc7QUFDekIscUJBQVc7QUFBQSxRQUNmO0FBQUEsTUFDSixDQUFDO0FBQUEsSUFDTDtBQUNBLG1CQUFlLFFBQVEsRUFBRTtBQUd6QixXQUFPLE1BQU07QUFDVCxxQkFBZSxXQUFXO0FBQUEsSUFDOUI7QUFBQSxFQUNKO0FBQ0o7QUFHQSxlQUFlLFdBQVcsS0FBaUIsUUFBZ0M7QUFDdkUsYUFBVyxDQUFDLFdBQVcsVUFBVSxLQUFLLE9BQU8sUUFBUSxNQUFNLEdBQUc7QUFDMUQsUUFBSSxZQUFZO0FBRVosWUFBTSxlQUFlLEtBQUssVUFBVTtBQUNwQyxZQUFNLFFBQVEsSUFBSSxXQUFXLGFBQWEsTUFBTTtBQUNoRCxlQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsUUFBUSxLQUFLO0FBQzFDLGNBQU0sQ0FBQyxJQUFJLGFBQWEsV0FBVyxDQUFDO0FBQUEsTUFDeEM7QUFHQSxZQUFNLElBQUksWUFBWSxXQUFXLEtBQUs7QUFBQSxJQUMxQyxPQUFPO0FBRUgsWUFBTSxJQUFJLGFBQWEsU0FBUztBQUFBLElBQ3BDO0FBQUEsRUFDSjtBQUNKO0FBT0EsU0FBUyxZQUFZLGFBQXlDO0FBRzFELFFBQU0sV0FBVyxZQUFZLFFBQVEsaUJBQWlCO0FBQ3RELE1BQUksVUFBVTtBQUNWLGFBQVMsTUFBTSxlQUFlO0FBQUEsRUFDbEM7QUFHQSxRQUFNLFdBQVcsT0FBTyxTQUFTLEtBQUssVUFBVSxTQUFTLGtCQUFrQjtBQUczRSxRQUFNLG9CQUNGLFlBQVksQ0FBQyxPQUFPLFNBQVMsS0FBSyxVQUFVLFNBQVMsZ0JBQWdCO0FBRXpFLFNBQU8sRUFBRSxVQUFVLGtCQUFrQjtBQUN6QztBQUlBLFNBQVMsZUFBZSxNQUFZLGFBQWdDO0FBQ2hFLFFBQU0sZUFBZTtBQUNyQixRQUFNLGdCQUFnQjtBQUV0QixTQUFPLGdCQUFnQixJQUFJO0FBQzNCLE1BQUksV0FBVyxRQUFRLEtBQUssVUFBVSxTQUFTO0FBQzNDLFVBQU0sUUFBUTtBQUVkLElBQUMsTUFBa0MsZUFBZTtBQUFBLEVBQ3RELFdBQVcsYUFBYSxRQUFRLEtBQUssUUFBUSxVQUFVLEdBQUc7QUFFdEQsVUFBTSxVQUFVLEtBQUs7QUFDckIsVUFBTSxPQUFPLFVBQVUsUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDLElBQUk7QUFDakQsUUFBSSxNQUFNO0FBQ04sV0FBSyxRQUFRLFlBQVksZUFBZSxRQUFRLFNBQVMsSUFBSSxlQUFlO0FBQzVFLFdBQUssU0FBUyxZQUFZO0FBQUEsSUFDOUI7QUFBQSxFQUNKLFdBQVcsYUFBYSxRQUFRLEtBQUssUUFBUSxVQUFVLEdBQUc7QUFFdEQsVUFBTSxVQUFVLEtBQUs7QUFDckIsVUFBTSxPQUNGLFVBQVUsUUFBUSxDQUFDLEtBQUssWUFBWSxRQUFRLENBQUMsSUFDdkMsUUFBUSxDQUFDLElBQ1QsVUFBVSxRQUFRLENBQUMsS0FBSyxZQUFZLFFBQVEsQ0FBQyxJQUMzQyxRQUFRLENBQUMsSUFDVDtBQUNaLFFBQUksTUFBTTtBQUNOLFdBQUssUUFBUSxZQUFZLGVBQWUsS0FBSyxRQUFRLFNBQVMsSUFBSSxlQUFlO0FBQ2pGLFdBQUssU0FBUyxZQUFZO0FBQUEsSUFDOUI7QUFBQSxFQUNKLFdBQVcsYUFBYSxRQUFRLEtBQUssUUFBUSxVQUFVLEdBQUc7QUFFdEQsVUFBTSxVQUFVLEtBQUs7QUFDckIsVUFBTSxPQUNGLFVBQVUsUUFBUSxDQUFDLEtBQUssWUFBWSxRQUFRLENBQUMsSUFDdkMsUUFBUSxDQUFDLElBQ1QsVUFBVSxRQUFRLENBQUMsS0FBSyxZQUFZLFFBQVEsQ0FBQyxJQUMzQyxRQUFRLENBQUMsSUFDVDtBQUNaLFFBQUksTUFBTTtBQUNOLFdBQUssUUFBUSxZQUFZO0FBQ3pCLFdBQUssU0FBUyxZQUFZLGdCQUFnQixLQUFLLFFBQVEsU0FBUyxJQUFJLGdCQUFnQjtBQUFBLElBQ3hGO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDtBQUVBLFNBQVMsV0FBVyxNQUFZO0FBQzVCLE1BQUksVUFBVSxNQUFNO0FBQ2hCLFdBQU87QUFBQSxFQUNYLFdBQVcsV0FBVyxRQUFRLEtBQUssVUFBVSxTQUFTO0FBQ2xELFdBQU87QUFBQSxFQUNYLFdBQ0ksYUFBYSxRQUNiLEtBQUssUUFBUSxXQUFXLE1BQ3ZCLFVBQVUsS0FBSyxRQUFRLENBQUMsS0FBSyxVQUFVLEtBQUssUUFBUSxDQUFDLElBQ3hEO0FBQ0UsV0FBTztBQUFBLEVBQ1gsV0FDSSxhQUFhLFFBQ2IsS0FBSyxRQUFRLFdBQVcsTUFDdkIsVUFBVSxLQUFLLFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_d0ee8cc6fe3d4094802637b7a0e8df1e","spec":"","tabbable":null,"tables":{},"tooltip":null}},"95802f42392c4111a5e92b4a2a24150f":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FB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LFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_686f5c3bfb824a0db725b128337b8580","spec":"{\"vconcat\":[{\"hconcat\":[{\"input\":\"select\",\"multiple\":false,\"value\":\"all\",\"label\":\"Species: \",\"from\":\"YUHPZ6NkhaN2GxhGFXxuAM\",\"as\":\"$selection_YUHPZ6NkhaN2GxhGFXxuAM\",\"column\":\"species\"},{\"input\":\"select\",\"multiple\":false,\"value\":\"all\",\"label\":\"X: \",\"options\":[\"body_mass\",\"flipper_length\",\"bill_depth\",\"bill_length\"],\"as\":\"$param_5zBGn8icQ9VUzBAgDMHRP6\"},{\"input\":\"select\",\"multiple\":false,\"value\":\"all\",\"label\":\"Y: \",\"options\":[\"body_mass\",\"flipper_length\",\"bill_depth\",\"bill_length\"],\"as\":\"$param_ekNWHDDAzg6DGPV5bxfRpp\"}]},{\"hconcat\":[{\"plot\":[{\"mark\":\"dot\",\"data\":{\"from\":\"YUHPZ6NkhaN2GxhGFXxuAM\",\"filterBy\":\"$selection_YUHPZ6NkhaN2GxhGFXxuAM\"},\"x\":{\"column\":\"$param_5zBGn8icQ9VUzBAgDMHRP6\"},\"y\":{\"column\":\"$param_ekNWHDDAzg6DGPV5bxfRpp\"},\"symbol\":\"species\",\"tip\":true,\"stroke\":\"species\"}],\"xLabel\":\"Body mass (g) â†’\",\"yLabel\":\"â†‘ Flipper length (mm)\",\"grid\":true,\"width\":700,\"height\":432.6328800988875,\"name\":\"plot_3W7L4c7ZndCzqxdX8wm5Wt\"},{\"legend\":\"symbol\",\"columns\":1,\"for\":\"plot_3W7L4c7ZndCzqxdX8wm5Wt\",\"width\":80}]},{\"input\":\"table\",\"from\":\"YUHPZ6NkhaN2GxhGFXxuAM\",\"filter_by\":\"$selection_YUHPZ6NkhaN2GxhGFXxuAM\"}],\"plotDefaults\":{\"width\":700,\"height\":450},\"params\":{\"param_5zBGn8icQ9VUzBAgDMHRP6\":{\"select\":\"value\",\"value\":\"body_mass\"},\"param_ekNWHDDAzg6DGPV5bxfRpp\":{\"select\":\"value\",\"value\":\"flipper_length\"},\"selection_YUHPZ6NkhaN2GxhGFXxuAM\":{\"select\":\"intersect\"}}}","tabbable":null,"tables":{"YUHPZ6NkhaN2GxhGFXxuAM":"/////2AGAAAQAAAAAAAKAA4ABgAFAAgACgAAAAABBAAQAAAAAAAKAAwAAAAEAAgACgAAAKwEAAAEAAAAAQAAAAwAAAAIAAwABAAIAAgAAACEBAAABAAAAHUEAAB7ImluZGV4X2NvbHVtbnMiOiBbeyJraW5kIjogInJhbmdlIiwgIm5hbWUiOiBudWxsLCAic3RhcnQiOiAwLCAic3RvcCI6IDM0MiwgInN0ZXAiOiAxfV0sICJjb2x1bW5faW5kZXhlcyI6IFt7Im5hbWUiOiBudWxsLCAiZmllbGRfbmFtZSI6IG51bGwsICJwYW5kYXNfdHlwZSI6ICJ1bmljb2RlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogeyJlbmNvZGluZyI6ICJVVEYtOCJ9fV0sICJjb2x1bW5zIjogW3sibmFtZSI6ICJzcGVjaWVzIiwgImZpZWxkX25hbWUiOiAic3BlY2llcyIsICJwYW5kYXNfdHlwZSI6ICJ1bmljb2RlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJpc2xhbmQiLCAiZmllbGRfbmFtZSI6ICJpc2xhbmQiLCAicGFuZGFzX3R5cGUiOiAidW5pY29kZSIsICJudW1weV90eXBlIjogIm9iamVjdCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAiYmlsbF9sZW5ndGgiLCAiZmllbGRfbmFtZSI6ICJiaWxsX2xlbmd0aCIsICJwYW5kYXNfdHlwZSI6ICJmbG9hdDY0IiwgIm51bXB5X3R5cGUiOiAiZmxvYXQ2NCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAiYmlsbF9kZXB0aCIsICJmaWVsZF9uYW1lIjogImJpbGxfZGVwdGgiLCAicGFuZGFzX3R5cGUiOiAiZmxvYXQ2NCIsICJudW1weV90eXBlIjogImZsb2F0NjQiLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogImZsaXBwZXJfbGVuZ3RoIiwgImZpZWxkX25hbWUiOiAiZmxpcHBlcl9sZW5ndGgiLCAicGFuZGFzX3R5cGUiOiAiaW50NjQiLCAibnVtcHlfdHlwZSI6ICJpbnQ2NCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAiYm9keV9tYXNzIiwgImZpZWxkX25hbWUiOiAiYm9keV9tYXNzIiwgInBhbmRhc190eXBlIjogImludDY0IiwgIm51bXB5X3R5cGUiOiAiaW50NjQiLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogInNleCIsICJmaWVsZF9uYW1lIjogInNleCIsICJwYW5kYXNfdHlwZSI6ICJ1bmljb2RlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogbnVsbH1dLCAiY3JlYXRvciI6IHsibGlicmFyeSI6ICJweWFycm93IiwgInZlcnNpb24iOiAiMjAuMC4wIn0sICJwYW5kYXNfdmVyc2lvbiI6ICIyLjMuMCJ9AAAABgAAAHBhbmRhcwAABwAAAFQBAAAYAQAA3AAAAKgAAABkAAAALAAAAAQAAADY/v//AAABBRAAAAAUAAAABAAAAAAAAAADAAAAc2V4AMT+///8/v//AAABAhAAAAAcAAAABAAAAAAAAAAJAAAAYm9keV9tYXNzAAAAyP///wAAAAFAAAAAMP///wAAAQIQAAAAKAAAAAQAAAAAAAAADgAAAGZsaXBwZXJfbGVuZ3RoAAAIAAwACAAHAAgAAAAAAAABQAAAAHD///8AAAEDEAAAABwAAAAEAAAAAAAAAAoAAABiaWxsX2RlcHRoAADO////AAACAKD///8AAAEDEAAAACQAAAAEAAAAAAAAAAsAAABiaWxsX2xlbmd0aAAAAAYACAAGAAYAAAAAAAIA2P///wAAAQUQAAAAGAAAAAQAAAAAAAAABgAAAGlzbGFuZAAAyP///xAAFAAIAAYABwAMAAAAEAAQAAAAAAABBRAAAAAcAAAABAAAAAAAAAAHAAAAc3BlY2llcwAEAAQABAAAAAAAAAD/////2AEAABQAAAAAAAAADAAWAAYABQAIAAwADAAAAAADBAAYAAAAiFIAAAAAAAAAAAoAGAAMAAQACAAKAAAALAEAABAAAABWAQAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXAUAAAAAAABgBQAAAAAAANAIAAAAAAAAMA4AAAAAAAAAAAAAAAAAADAOAAAAAAAAXAUAAAAAAACQEwAAAAAAACEIAAAAAAAAuBsAAAAAAAAAAAAAAAAAALgbAAAAAAAAsAoAAAAAAABoJgAAAAAAAAAAAAAAAAAAaCYAAAAAAACwCgAAAAAAABgxAAAAAAAAAAAAAAAAAAAYMQAAAAAAALAKAAAAAAAAyDsAAAAAAAAAAAAAAAAAAMg7AAAAAAAAsAoAAAAAAAB4RgAAAAAAACsAAAAAAAAAqEYAAAAAAABcBQAAAAAAAAhMAAAAAAAAfgYAAAAAAAAAAAAABwAAAFYBAAAAAAAAAAAAAAAAAABWAQAAAAAAAAAAAAAAAAAAVgEAAAAAAAAAAAAAAAAAAFYBAAAAAAAAAAAAAAAAAABWAQAAAAAAAAAAAAAAAAAAVgEAAAAAAAAAAAAAAAAAAFYBAAAAAAAACQAAAAAAAAAAAAAABgAAAAwAAAASAAAAGAAAAB4AAAAkAAAAKgAAADAAAAA2AAAAPAAAAEIAAABIAAAATgAAAFQAAABaAAAAYAAAAGYAAABsAAAAcgAAAHgAAAB+AAAAhAAAAIoAAACQAAAAlgAAAJwAAACiAAAAqAAAAK4AAAC0AAAAugAAAMAAAADGAAAAzAAAANIAAADYAAAA3gAAAOQAAADqAAAA8AAAAPYAAAD8AAAAAgEAAAgBAAAOAQAAFAEAABoBAAAgAQAAJgEAACwBAAAyAQAAOAEAAD4BAABEAQAASgEAAFABAABWAQAAXAEAAGIBAABoAQAAbgEAAHQBAAB6AQAAgAEAAIYBAACMAQAAkgEAAJgBAACeAQAApAEAAKoBAACwAQAAtgEAALwBAADCAQAAyAEAAM4BAADUAQAA2gEAAOABAADmAQAA7AEAAPIBAAD4AQAA/gEAAAQCAAAKAgAAEAIAABYCAAAcAgAAIgIAACgCAAAuAgAANAIAADoCAABAAgAARgIAAEwCAABSAgAAWAIAAF4CAABkAgAAagIAAHACAAB2AgAAfAIAAIICAACIAgAAjgIAAJQCAACaAgAAoAIAAKYCAACsAgAAsgIAALgCAAC+AgAAxAIAAMoCAADQAgAA1gIAANwCAADiAgAA6AIAAO4CAAD0AgAA+gIAAAADAAAGAwAADAMAABIDAAAYAwAAHgMAACQDAAAqAwAAMAMAADYDAAA8AwAAQgMAAEgDAABOAwAAVAMAAFoDAABgAwAAZgMAAGwDAAByAwAAeAMAAH4DAACEAwAAigMAAJMDAACcAwAApQMAAK4DAAC3AwAAwAMAAMkDAADSAwAA2wMAAOQDAADtAwAA9gMAAP8DAAAIBAAAEQQAABoEAAAjBAAALAQAADUEAAA+BAAARwQAAFAEAABZBAAAYgQAAGsEAAB0BAAAfQQAAIYEAACPBAAAmAQAAKEEAACqBAAAswQAALwEAADFBAAAzgQAANcEAADgBAAA6QQAAPIEAAD7BAAABAUAAA0FAAAWBQAAHwUAACgFAAAxBQAAOgUAAEMFAABMBQAAVQUAAF4FAABnBQAAcAUAAHkFAACCBQAAiwUAAJQFAACdBQAApgUAAK8FAAC4BQAAwQUAAMoFAADTBQAA3AUAAOUFAADuBQAA9AUAAPoFAAAABgAABgYAAAwGAAASBgAAGAYAAB4GAAAkBgAAKgYAADAGAAA2BgAAPAYAAEIGAABIBgAATgYAAFQGAABaBgAAYAYAAGYGAABsBgAAcgYAAHgGAAB+BgAAhAYAAIoGAACQBgAAlgYAAJwGAACiBgAAqAYAAK4GAAC0BgAAugYAAMAGAADGBgAAzAYAANIGAADYBgAA3gYAAOQGAADqBgAA8AYAAPYGAAD8BgAAAgcAAAgHAAAOBwAAFAcAABoHAAAgBwAAJgcAACwHAAAyBwAAOAcAAD4HAABEBwAASgcAAFAHAABWBwAAXAcAAGIHAABoBwAAbgcAAHQHAAB6BwAAgAcAAIYHAACMBwAAkgcAAJgHAACeBwAApAcAAKoHAACwBwAAtgcAALwHAADCBwAAyAcAAM4HAADUBwAA2gcAAOAHAADmBwAA7AcAAPIHAAD4BwAA/gcAAAQIAAAKCAAAEAgAABYIAAAcCAAAIggAACgIAAAuCAAANAgAADoIAABACAAARggAAEwIAABSCAAAWAgAAF4IAABkCAAAaggAAHAIAAB2CAAAfAgAAIIIAACICAAAjggAAJQIAACaCAAAoAgAAKYIAACsCAAAsggAALgIAAC+CAAAxAgAAMoIAADQCAAAAAAAAEFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUFkZWxpZUNoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcENoaW5zdHJhcEdlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvb0dlbnRvbwAAAAAJAAAAEgAAABsAAAAkAAAALQAAADYAAAA/AAAASAAAAFEAAABaAAAAYwAAAGwAAAB1AAAAfgAAAIcAAACQAAAAmQAAAKIAAACrAAAAsQAAALcAAAC9AAAAwwAAAMkAAADPAAAA1QAAANsAAADhAAAA5wAAAOwAAADxAAAA9gAAAPsAAAAAAQAABQEAAAoBAAAPAQAAFAEAABkBAAAeAQAAIwEAACgBAAAtAQAAMgEAADcBAAA8AQAAQQEAAEYBAABLAQAAUQEAAFcBAABdAQAAYwEAAGkBAABvAQAAdQEAAHsBAACBAQAAhwEAAI0BAACTAQAAmQEAAJ8BAAClAQAAqwEAALEBAAC3AQAAwAEAAMkBAADSAQAA2wEAAOQBAADtAQAA9gEAAP8BAAAIAgAAEQIAABoCAAAjAgAALAIAADUCAAA+AgAARwIAAEwCAABRAgAAVgIAAFsCAABgAgAAZQIAAGoCAABvAgAAdAIAAHkCAAB+AgAAgwIAAIgCAACNAgAAkgIAAJcCAACdAgAAowIAAKkCAACvAgAAtQIAALsCAADBAgAAxwIAAM0CAADTAgAA2QIAAN8CAADlAgAA6wIAAPECAAD3AgAAAAMAAAkDAAASAwAAGwMAACQDAAAtAwAANgMAAD8DAABIAwAAUQMAAFoDAABjAwAAbAMAAHUDAAB+AwAAhwMAAIwDAACRAwAAlgMAAJsDAACgAwAApQMAAKoDAACvAwAAtAMAALkDAAC+AwAAwwMAAMgDAADNAwAA0gMAANcDAADcAwAA4QMAAOYDAADrAwAA8AMAAPUDAAD6AwAA/wMAAAQEAAAJBAAADgQAABMEAAAYBAAAHQQAACIEAAAnBAAALAQAADEEAAA2BAAAOwQAAEAEAABFBAAASgQAAE8EAABUBAAAWQQAAF4EAABjBAAAaAQAAG0EAAByBAAAdwQAAHwEAACBBAAAhgQAAIsEAACQBAAAlQQAAJoEAACfBAAApAQAAKkEAACuBAAAswQAALgEAAC9BAAAwgQAAMcEAADMBAAA0QQAANYEAADbBAAA4AQAAOUEAADqBAAA7wQAAPQEAAD5BAAA/gQAAAMFAAAIBQAADQUAABIFAAAXBQAAHAUAACEFAAAmBQAAKwUAADAFAAA1BQAAOgUAAD8FAABFBQAASwUAAFEFAABXBQAAXQUAAGMFAABpBQAAbwUAAHUFAAB7BQAAgQUAAIcFAACNBQAAkwUAAJkFAACfBQAApQUAAKsFAACxBQAAtwUAAL0FAADDBQAAyQUAAM8FAADVBQAA2wUAAOEFAADnBQAA7QUAAPMFAAD5BQAA/wUAAAUGAAALBgAAEQYAABcGAAAdBgAAIwYAACkGAAAvBgAANQYAADsGAABBBgAARwYAAE0GAABTBgAAWQYAAF8GAABlBgAAawYAAHEGAAB3BgAAfQYAAIMGAACJBgAAjwYAAJUGAACbBgAAoQYAAKcGAACtBgAAswYAALkGAAC/BgAAxQYAAMsGAADRBgAA1wYAAN0GAADjBgAA6QYAAO8GAAD1BgAA+wYAAAEHAAAHBwAADQcAABMHAAAZBwAAHwcAACUHAAArBwAAMQcAADcHAAA9BwAAQwcAAEkHAABPBwAAVQcAAFsHAABhBwAAZwcAAG0HAABzBwAAeQcAAH8HAACFBwAAiwcAAJEHAACXBwAAnQcAAKMHAACpBwAArwcAALUHAAC7BwAAwQcAAMcHAADNBwAA0wcAANkHAADfBwAA5QcAAOsHAADxBwAA9wcAAP0HAAADCAAACQgAAA8IAAAVCAAAGwgAACEIAAAAAAAAVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZUJpc2NvZVRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlblRvcmdlcnNlbkRyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lQmlzY29lVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuVG9yZ2Vyc2VuRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1EcmVhbURyZWFtRHJlYW1CaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VCaXNjb2VC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zczMzMzMMkBmZmZmZmYzQM3MzMzMzDFAzczMzMxMNEAAAAAAAIAzQJqZmZmZmTJAMzMzMzMzM0DNzMzMzMwyQAAAAAAAADJAmpmZmZkZMkCamZmZmRkxQJqZmZmZGTJAzczMzMxMMUBmZmZmZuYyQJqZmZmZmTJAAAAAAACAMkCamZmZmRkwQAAAAAAAgDJAZmZmZmbmMUAAAAAAAAA0QAAAAAAAADBAAAAAAAAANECamZmZmZkyQGZmZmZm5jJAMzMzMzMzMUAAAAAAAAA0QAAAAAAAADFAAAAAAAAAM0AAAAAAAIAwQM3MzMzMTDRAMzMzMzOzMUAAAAAAAIAzQDMzMzMzszRAzczMzMxMMkAAAAAAAAAxQAAAAAAAgDRAAAAAAAAAMUCamZmZmZkyQDMzMzMzMzFAzczMzMzMM0AAAAAAAAAxQAAAAAAAgDJAzczMzMzML0AAAAAAAAAzQJqZmZmZmTFAzczMzMxMMkCamZmZmRkxQAAAAAAAADJAZmZmZmbmMUAzMzMzMzMzQAAAAAAAgDJAAAAAAACAMkCamZmZmZkxQAAAAAAAgDFAAAAAAACAMUCamZmZmRk0QAAAAAAAgDBAZmZmZmbmMUCamZmZmRkxQDMzMzMzMzFAAAAAAAAAL0AAAAAAAAAxQM3MzMzMzDBAMzMzMzOzMkCamZmZmZkyQGZmZmZmZjJAzczMzMzMMUCamZmZmRkyQJqZmZmZGTFAAAAAAACAMkBmZmZmZuYxQAAAAAAAgDNAMzMzMzMzM0AzMzMzM7MyQM3MzMzMzDNAzczMzMzMMUAzMzMzMzMyQDMzMzMzMzJAZmZmZmbmMkBmZmZmZuYzQM3MzMzMzDFAzczMzMxMNEDNzMzMzEwxQJqZmZmZGTJAmpmZmZkZMUCamZmZmZkzQAAAAAAAADRAzczMzMzMMUCamZmZmZkyQDMzMzMzMzJAzczMzMxMMUAAAAAAAIAxQJqZmZmZmTBAZmZmZmZmM0BmZmZmZuYxQAAAAAAAADNAZmZmZmZmMkAAAAAAAAAzQM3MzMzMzDFAAAAAAAAANECamZmZmZkwQM3MzMzMzDRAMzMzMzOzMEDNzMzMzMwyQJqZmZmZmTJAzczMzMzMMEDNzMzMzEwyQDMzMzMzszRAmpmZmZmZMEBmZmZmZuYzQAAAAAAAgDNAAAAAAACAMUCamZmZ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AAAAALsAAAAAAAAAwwAAAAAAAAC9AAAAAAAAAMQAAAAAAAAAuwAAAAAAAADBAAAAAAAAAL8AAAAAAAAAwgAAAAAAAAC+AAAAAAAAAL0AAAAAAAAAvQAAAAAAAAC+AAAAAAAAAMoAAAAAAAAAzQAAAAAAAAC5AAAAAAAAALoAAAAAAAAAuwAAAAAAAADQAAAAAAAAAL4AAAAAAAAAxAAAAAAAAACyAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADLAAAAAAAAALcAAAAAAAAAvgAAAAAAAADBAAAAAAAAALgAAAAAAAAAxwAAAAAAAAC+AAAAAAAAALUAAAAAAAAAxQAAAAAAAADGAAAAAAAAAL8AAAAAAAAAwQAAAAAAAADFAAAAAAAAAL8AAAAAAAAAxAAAAAAAAAC8AAAAAAAAAMcAAAAAAAAAvQAAAAAAAAC9AAAAAAAAALsAAAAAAAAAxgAAAAAAAACwAAAAAAAAAMoAAAAAAAAAugAAAAAAAADHAAAAAAAAAL8AAAAAAAAAwwAAAAAAAAC/AAAAAAAAANIAAAAAAAAAvgAAAAAAAADFAAAAAAAAAMEAAAAAAAAAxwAAAAAAAAC7AAAAAAAAAL4AAAAAAAAAvwAAAAAAAADIAAAAAAAAALkAAAAAAAAAwQAAAAAAAADBAAAAAAAAALsAAAAAAAAAvAAAAAAAAAC+AAAAAAAAAMAAAAAAAAAAuQAAAAAAAAC+AAAAAAAAALgAAAAAAAAAwwAAAAAAAADBAAAAAAAAALsAAAAAAAAAyQAAAAAAAADAAAAAAAAAAMQAAAAAAAAAwQAAAAAAAAC8AAAAAAAAAMUAAAAAAAAAxgAAAAAAAACyAAAAAAAAAMUAAAAAAAAAwwAAAAAAAADGAAAAAAAAAMEAAAAAAAAAwgAAAAAAAAC5AAAAAAAAAMkAAAAAAAAAvgAAAAAAAADJAAAAAAAAAMUAAAAAAAAAtQAAAAAAAAC+AAAAAAAAAMMAAAAAAAAAtQAAAAAAAAC/AAAAAAAAALsAAAAAAAAAwQAAAAAAAADDAAAAAAAAAMUAAAAAAAAAyAAAAAAAAADIAAAAAAAAAL8AAAAAAAAAzQAAAAAAAAC7AAAAAAAAAMkAAAAAAAAAuwAAAAAAAADLAAAAAAAAAMMAAAAAAAAAxwAAAAAAAADDAAAAAAAAANIAAAAAAAAA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RkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFTUFMRUZFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRU1BTEVGRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVGRU1BTEVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEVNQUxFRkVNQUxFRkVNQUxFTUFMRUZFTUFMRU1BTEUAAP////8AAAAA"},"tooltip":null}},"9b3c5bc60ac8417d869a2067bd630015":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"9f8c6d1fbff743e1bc73954a3f3764ce":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"a5874bd748da4c60a8383c52b0ec4dbc":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"bcc2d3ee18bb40558b944fec0a036bb1":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.mark._mark.Mark","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FB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LFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_e407c250827b4a9abf7eca85d9c2002a","spec":"","tabbable":null,"tables":{},"tooltip":null}},"cc40e61824a24fc58d477b5853b15ada":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FB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LFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_e521bacc6e68409b95dbd05bbb920d7c","spec":"","tabbable":null,"tables":{},"tooltip":null}},"d0ee8cc6fe3d4094802637b7a0e8df1e":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"d0f5aefff725448a9d893b225ee8aac9":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.plot._legend.Legend","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FB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LFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_0e200d7ac2834af8abe97f71b11451ea","spec":"","tabbable":null,"tables":{},"tooltip":null}},"d139bed5564c46d0bc67250be72a3e43":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQb3NpdGlvbn1gIGFzIFBsYWNlbWVudDtcbiAgICB9XG59O1xuIl0sCiAgIm1hcHBpbmdzIjogIjtBQUVBO0FBQUEsRUFHSTtBQUFBLE9BR0c7QUFFUCxTQUFTLFlBQUFBLGlCQUFnQjs7O0FDUnpCLFNBQVMscUJBQXFCO0FBRTlCLFNBQVMsMEJBQTBCOzs7QUNKbkM7QUFBQSxFQUNJO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLE9BQ0c7QUFFUDtBQUFBLEVBRUk7QUFBQSxPQUVHOzs7QUNaQSxJQUFNLFdBQVcsQ0FBQyxNQUE2QztBQUNsRSxTQUFPLE1BQU0sUUFBUSxPQUFPLE1BQU0sWUFBWSxDQUFDLE1BQU0sUUFBUSxDQUFDO0FBQ2xFOzs7QUNGQTtBQUFBLEVBQ0k7QUFBQSxFQUNBO0FBQUEsT0FHRztBQVNBLFNBQVMsTUFDWixlQUNHLFFBQ1E7QUFDWCxRQUFNQyxTQUFRLElBQUksV0FBVyxHQUFHLE1BQU07QUFDdEMsY0FBWSxFQUFFLFFBQVFBLE1BQUs7QUFDM0IsU0FBT0EsT0FBTTtBQUNqQjtBQUVPLElBQU0sUUFBTixjQUFvQixhQUFhO0FBQUEsRUFDcEI7QUFBQSxFQUNoQixZQUFZLFVBQXNCO0FBQzlCLFVBQU0sUUFBUTtBQUNkLFNBQUssVUFBVSxTQUFTLGNBQWMsS0FBSztBQUMzQyxXQUFPLGVBQWUsS0FBSyxTQUFTLFNBQVMsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUFBLEVBQ2hFO0FBQUEsRUFFQSxXQUFXO0FBQUEsRUFFWDtBQUNKOzs7QUNsQ08sU0FBUyxhQUFhO0FBQ3pCLFNBQU8sUUFBUSxLQUFLLE9BQU8sRUFBRSxTQUFTLEVBQUUsRUFBRSxVQUFVLENBQUMsSUFBSSxLQUFLLElBQUksRUFBRSxTQUFTLEVBQUU7QUFDbkY7OztBQ0VPLFNBQVMsZUFBZSxRQUFzQztBQUNqRSxRQUFNLFdBQVcsT0FBTyxTQUFTLGNBQWMsVUFBVTtBQUV6RCxNQUFJLFFBQVE7QUFDUixVQUFNLFdBQVcsT0FBTyxTQUFTLGNBQWMsUUFBUTtBQUN2RCxhQUFTLFlBQVk7QUFDckIsYUFBUyxPQUFPLE1BQU07QUFBQSxFQUMxQjtBQUVBLFNBQU87QUFDWDtBQUVPLFNBQVMsbUJBQ1osVUFDQSxTQUNBLE1BQ0Y7QUFFRSxXQUFTLGlCQUFpQixjQUFjLEVBQUUsUUFBUSxRQUFNO0FBQ3BELE9BQUcsT0FBTztBQUFBLEVBQ2QsQ0FBQztBQUdELFFBQU0sT0FBTyxXQUFXO0FBQ3hCLGFBQVcsRUFBRSxPQUFPLE1BQU0sS0FBSyxXQUFXLENBQUMsR0FBRztBQUMxQyxVQUFNLEVBQUUsV0FBVyxJQUFJLG1CQUFtQixNQUFNLE9BQU8sTUFBTSxLQUFLO0FBQ2xFLGFBQVMsWUFBWSxVQUFVO0FBQUEsRUFDbkM7QUFDSjtBQUVPLFNBQVMsbUJBQ1osTUFDQSxPQUNBLE1BQ0EsT0FDRjtBQUNFLFFBQU0sYUFBYSxPQUFPLFNBQVMsY0FBYyxPQUFPO0FBQ3hELFFBQU1DLFNBQVEsT0FBTyxTQUFTLGNBQWMsT0FBTztBQUNuRCxFQUFBQSxPQUFNLE9BQU87QUFDYixNQUFJLE1BQU07QUFDTixJQUFBQSxPQUFNLE9BQU87QUFBQSxFQUNqQjtBQUNBLE1BQUksT0FBTztBQUNQLElBQUFBLE9BQU0sUUFBUTtBQUFBLEVBQ2xCO0FBQ0EsYUFBVyxZQUFZQSxNQUFLO0FBQzVCLGFBQVcsWUFBWSxPQUFPLFNBQVMsZUFBZSxJQUFJLFNBQVMsS0FBSyxFQUFFLENBQUM7QUFDM0UsU0FBTyxFQUFFLFlBQVksT0FBQUEsT0FBTTtBQUMvQjtBQUVPLFNBQVMseUJBQXlCQSxRQUFjLFNBQXNCO0FBRXpFLFVBQVEsaUJBQWlCLGdCQUFnQixTQUFPO0FBQzVDLFFBQUksQ0FBQyxJQUFJLFFBQVMsQ0FBQUEsT0FBTSxTQUFTO0FBQUEsRUFDckMsQ0FBQztBQUNELFVBQVEsaUJBQWlCLFNBQVMsTUFBTUEsT0FBTSxTQUFTLENBQUM7QUFDNUQ7OztBSmhDTyxJQUFlLGNBQWYsY0FBbUMsTUFBTTtBQUFBLEVBRTVDLFlBQStCLFVBQThCO0FBQ3pELFVBQU0sU0FBUyxRQUFRO0FBREk7QUFBQSxFQUUvQjtBQUFBLEVBSFUsUUFBa0IsQ0FBQztBQUFBLEVBVzdCLFdBQVc7QUFDUCxRQUFJLFlBQVksS0FBSyxTQUFTLEVBQUUsS0FBSyxLQUFLLFNBQVMsUUFBUTtBQUN2RCxZQUFNLFFBQVEsS0FBSyxTQUFTLFNBQVMsS0FBSyxTQUFTO0FBQ25ELFdBQUssU0FBUyxHQUFHLFNBQVMsWUFBWSxPQUFPLFFBQVcsRUFBRSxRQUFRLEtBQUssQ0FBQyxDQUFDO0FBQUEsSUFDN0U7QUFBQSxFQUNKO0FBQUEsRUFFQSxRQUFRLE9BQTJCO0FBQy9CLFVBQU0sRUFBRSxJQUFJLE9BQU8sUUFBQUMsUUFBTyxJQUFJLEtBQUs7QUFDbkMsUUFBSSxZQUFZLEVBQUUsS0FBS0EsU0FBUTtBQUMzQixVQUFJLFNBQVMsWUFBWSxTQUFTQSxTQUFRLFFBQVcsRUFBRSxRQUFRLEtBQUssQ0FBQztBQUNyRSxVQUFJLE1BQU0sUUFBUSxLQUFLLEtBQUssTUFBTSxTQUFTLEdBQUc7QUFDMUMsaUJBQVM7QUFBQSxVQUNMLENBQUMsU0FBU0EsT0FBTTtBQUFBLFVBQ2hCLE1BQU0sSUFBSSxPQUFLLENBQUMsQ0FBQyxDQUFDO0FBQUEsVUFDbEIsRUFBRSxRQUFRLEtBQUs7QUFBQSxRQUNuQjtBQUFBLE1BQ0osV0FBVyxPQUFPLFFBQVE7QUFDdEIsaUJBQVMsWUFBWSxTQUFTQSxTQUFRLE9BQU8sRUFBRSxRQUFRLEtBQUssQ0FBQztBQUFBLE1BQ2pFO0FBQ0EsU0FBRyxPQUFPLE1BQU07QUFBQSxJQUNwQixXQUFXLFFBQVEsRUFBRSxHQUFHO0FBQ3BCLFNBQUcsT0FBTyxLQUFLO0FBQUEsSUFDbkI7QUFBQSxFQUNKO0FBQUEsRUFFQSxNQUFNLFNBQXVCLENBQUMsR0FBdUI7QUFDakQsVUFBTSxFQUFFLE1BQU0sUUFBQUEsUUFBTyxJQUFJLEtBQUs7QUFFOUIsUUFBSSxDQUFDLE1BQU07QUFDUCxhQUFPO0FBQUEsSUFDWDtBQUVBLFFBQUksQ0FBQ0EsU0FBUTtBQUNULFlBQU0sSUFBSSxNQUFNLG9EQUFvRDtBQUFBLElBQ3hFO0FBRUEsV0FBTyxNQUFNLEtBQUssSUFBSSxFQUNqQixPQUFPLEVBQUUsT0FBT0EsUUFBTyxDQUFDLEVBQ3hCLFNBQVMsRUFDVCxNQUFNLEdBQUcsTUFBTSxFQUNmLFFBQVFBLE9BQU07QUFBQSxFQUN2QjtBQUFBLEVBRUEsWUFBWSxNQUFpQjtBQUN6QixTQUFLLFFBQVEsQ0FBQyxFQUFFLE9BQU8sSUFBSSxPQUFPLE1BQU0sR0FBRyxHQUFHLEtBQUssbUJBQW1CLElBQUksQ0FBQyxDQUFDO0FBQzVFLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxtQkFBbUIsTUFBcUI7QUFDcEMsVUFBTSxVQUFVLGNBQWMsSUFBSTtBQUNsQyxVQUFNLFNBQVMsUUFBUSxRQUFRO0FBQy9CLFdBQU8sT0FBTyxJQUFJLFFBQU0sRUFBRSxPQUFPLEVBQUUsRUFBRTtBQUFBLEVBQ3pDO0FBQUEsRUFFVSxXQUFXLFNBQW1CO0FBQ3BDLFNBQUssUUFBUSxRQUFRLElBQUksU0FBUSxTQUFTLEdBQUcsSUFBSSxNQUFNLEVBQUUsT0FBTyxJQUFJLENBQUUsQ0FBQztBQUN2RSxTQUFLLE9BQU87QUFBQSxFQUNoQjtBQUFBLEVBRVUscUJBQXFCO0FBQzNCLFFBQUksQ0FBQyxZQUFZLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDaEMsV0FBSyxTQUFTLEdBQUcsaUJBQWlCLFNBQVMsV0FBUztBQUNoRCxhQUFLLGdCQUFnQjtBQUFBLE1BQ3pCLENBQUM7QUFBQSxJQUNMO0FBQUEsRUFDSjtBQUFBLEVBRVUseUJBQXlCLFNBQXNCO0FBQ3JELFFBQUksWUFBWSxLQUFLLFNBQVMsRUFBRSxHQUFHO0FBQy9CLCtCQUF5QixNQUFNLE9BQU87QUFBQSxJQUMxQztBQUFBLEVBQ0o7QUFBQSxFQUVVLHNCQUFzQjtBQUU1QixVQUFNLFFBQVEsWUFBWSxLQUFLLFNBQVMsRUFBRSxJQUNwQyxLQUFLLFNBQVMsR0FBRyxTQUFTLElBQUksSUFDOUIsS0FBSyxTQUFTLEdBQUc7QUFDdkIsU0FBSyxnQkFBZ0IsVUFBVSxTQUFZLEtBQUs7QUFBQSxFQUNwRDtBQUFBLEVBRUEsUUFBUSxTQUFtQjtBQUN2QixRQUFJLENBQUMsWUFBWSxLQUFLLFNBQVMsRUFBRSxHQUFHO0FBQ2hDLFlBQU0sYUFBYSxLQUFLLFNBQVMsR0FBRztBQUNwQyxVQUNJLGNBQ0EsQ0FBQyxNQUFNLFFBQVEsVUFBVSxLQUN6QixDQUFDLFFBQVEsS0FBSyxZQUFVLE9BQU8sVUFBVSxVQUFVLEdBQ3JEO0FBQ0Usa0JBQVUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxPQUFPLFdBQVcsQ0FBQztBQUFBLE1BQ2hEO0FBQUEsSUFDSjtBQUNBLFNBQUssUUFBUTtBQUFBLEVBQ2pCO0FBQ0o7OztBS2xJTyxJQUFNLGFBQU4sY0FBeUIsWUFBWTtBQUFBLEVBQ3ZCO0FBQUEsRUFDakIsWUFBWSxTQUE0QjtBQUVwQyxVQUFNLE9BQU87QUFHYixTQUFLLFlBQVksZUFBZSxRQUFRLFNBQVMsUUFBUSxNQUFNO0FBQy9ELFNBQUssUUFBUSxPQUFPLEtBQUssU0FBUztBQUdsQyxRQUFJLFFBQVEsU0FBUztBQUNqQixXQUFLLFdBQVcsUUFBUSxPQUFPO0FBQUEsSUFDbkM7QUFHQSxTQUFLLGdCQUFnQjtBQUdyQixTQUFLLFVBQVUsaUJBQWlCLFVBQVUsT0FBSztBQUMzQyxVQUFJLEVBQUUsa0JBQWtCLGtCQUFrQjtBQUN0QyxZQUFJLEVBQUUsT0FBTyxTQUFTLFNBQVM7QUFDM0IsZUFBSyxRQUFRLEtBQUssaUJBQWlCLElBQUk7QUFBQSxRQUMzQztBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFHRCxTQUFLLG1CQUFtQjtBQUN4QixTQUFLLHlCQUF5QixLQUFLLFNBQVM7QUFBQSxFQUNoRDtBQUFBLEVBRUEsSUFBSSxnQkFBd0I7QUFDeEIsVUFBTSxVQUFVLEtBQUssVUFBVTtBQUFBLE1BQzNCO0FBQUEsSUFDSjtBQUNBLFdBQU8sU0FBUyxRQUFTLFFBQVEsVUFBVSxPQUFPLEtBQUssUUFBUSxRQUFTO0FBQUEsRUFDNUU7QUFBQSxFQUVBLElBQUksY0FBYyxPQUFlO0FBQzdCLFlBQVEsVUFBVSxLQUFLLE9BQU87QUFDOUIsVUFBTSxTQUFTLEtBQUssVUFBVSxpQkFBaUIscUJBQXFCO0FBQ3BFLGVBQVcsU0FBUyxRQUFRO0FBQ3hCLFVBQUssTUFBMkIsVUFBVSxPQUFPO0FBQzdDLFFBQUMsTUFBMkIsVUFBVTtBQUN0QyxjQUFNLGNBQWMsSUFBSSxNQUFNLFVBQVUsRUFBRSxTQUFTLEtBQUssQ0FBQyxDQUFDO0FBQzFEO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFFQSxTQUFlO0FBQ1gsdUJBQW1CLEtBQUssV0FBVyxLQUFLLE9BQU8sT0FBTztBQUN0RCxTQUFLLG9CQUFvQjtBQUN6QixXQUFPO0FBQUEsRUFDWDtBQUNKOzs7QUM3RE8sSUFBTSxvQkFBb0I7QUFDMUIsSUFBTSxlQUFlOzs7QUNJNUIsT0FBTyxlQUFlO0FBQ3RCLFNBQVMsZUFBQUMsb0JBQW1CO0FBUXJCLElBQU0sU0FBTixjQUFxQixZQUFZO0FBQUEsRUFDbkI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNULGFBQXlCO0FBQUEsRUFDakMsWUFBWSxTQUF3QjtBQUVoQyxVQUFNLE9BQU87QUFHYixTQUFLLFlBQVksUUFBUSxZQUFZO0FBQ3JDLFNBQUssY0FBYyxRQUFRLFVBQVU7QUFDckMsU0FBSyxnQkFDRCxRQUFRLFVBQVUsU0FBUyxRQUFRLFVBQVUsU0FBUyxTQUFZLFFBQVE7QUFHOUUsU0FBSyxRQUFRLFVBQVUsSUFBSSxpQkFBaUI7QUFHNUMsVUFBTSxRQUFRLFFBQVEsU0FBUyxRQUFRO0FBQ3ZDLFFBQUksVUFBbUM7QUFDdkMsUUFBSSxVQUFVLFFBQVc7QUFDckIsZ0JBQVUsT0FBTyxTQUFTLGNBQWMsT0FBTztBQUMvQyxjQUFRLFlBQVk7QUFDcEIsV0FBSyxRQUFRLFlBQVksT0FBTztBQUFBLElBQ3BDO0FBR0EsU0FBSyxVQUFVLFNBQVMsY0FBYyxRQUFRO0FBQzlDLFFBQUksUUFBUSxPQUFPO0FBQ2YsV0FBSyxRQUFRLE1BQU0sUUFBUSxHQUFHLFFBQVEsS0FBSztBQUFBLElBQy9DO0FBQ0EsU0FBSyxRQUFRLEtBQUssV0FBVztBQUM3QixRQUFJLFNBQVM7QUFDVCxjQUFRLFlBQVksS0FBSyxPQUFPO0FBQUEsSUFDcEMsT0FBTztBQUNILFdBQUssUUFBUSxZQUFZLEtBQUssT0FBTztBQUFBLElBQ3pDO0FBR0EsUUFBSSxRQUFRLFNBQVM7QUFDakIsV0FBSyxXQUFXLFFBQVEsT0FBTztBQUFBLElBQ25DO0FBR0EsUUFBSSxLQUFLLGtCQUFrQixVQUFhQSxhQUFZLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDbkUsV0FBSyxRQUFRLFFBQVEsS0FBSztBQUFBLElBQzlCO0FBR0EsU0FBSyxRQUFRLGlCQUFpQixTQUFTLE1BQU07QUFDekMsV0FBSyxRQUFRLEtBQUssaUJBQWlCLElBQUk7QUFBQSxJQUMzQyxDQUFDO0FBR0QsU0FBSyxtQkFBbUI7QUFDeEIsU0FBSyx5QkFBeUIsS0FBSyxPQUFPO0FBQUEsRUFDOUM7QUFBQSxFQUVBLFlBQVksTUFBaUI7QUFDekIsUUFBSSxLQUFLLGFBQWEsQ0FBQyxLQUFLLGFBQWE7QUFDckMsV0FBSyxRQUFRLEtBQUssbUJBQW1CLElBQUksQ0FBQztBQUMxQyxhQUFPO0FBQUEsSUFDWCxPQUFPO0FBQ0gsYUFBTyxNQUFNLFlBQVksSUFBSTtBQUFBLElBQ2pDO0FBQUEsRUFDSjtBQUFBLEVBRUEsSUFBSSxnQkFBbUM7QUFDbkMsV0FBTyxLQUFLLFlBQVksU0FBUyxLQUFLO0FBQUEsRUFDMUM7QUFBQSxFQUVBLElBQUksY0FBYyxPQUEwQjtBQUN4QyxTQUFLLFlBQVksU0FBUyxLQUFLO0FBQUEsRUFDbkM7QUFBQSxFQUVBLFNBQWU7QUFFWCxRQUFJLENBQUMsS0FBSyxZQUFZO0FBQ2xCLFVBQUksS0FBSyxXQUFXO0FBQ2hCLGFBQUssUUFBUSxXQUFXO0FBQUEsTUFDNUI7QUFDQSxZQUFNLFNBQStCO0FBQUEsUUFDakMsUUFBUTtBQUFBLFFBQ1IsZ0JBQWdCO0FBQUEsTUFDcEI7QUFDQSxVQUFJLENBQUMsS0FBSyxRQUFRLFVBQVU7QUFDeEIsZUFBTyxtQkFBbUIsS0FBSztBQUUvQixlQUFPLGVBQWU7QUFBQSxNQUMxQixPQUFPO0FBQ0gsZUFBTyxVQUFVO0FBQUEsVUFDYixlQUFlO0FBQUEsWUFDWCxPQUFPO0FBQUEsVUFDWDtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBRUEsV0FBSyxhQUFhLElBQUksVUFBVSxLQUFLLFNBQVMsTUFBTTtBQUVwRCxVQUFJLEtBQUssV0FBVztBQUNoQixhQUFLLFdBQVcsR0FBRyxZQUFZLE1BQU07QUFDakMsZUFBSyxXQUFZLGNBQWMsUUFBUTtBQUN2QyxlQUFLLFlBQVksZUFBZSxLQUFLO0FBQUEsUUFDekMsQ0FBQztBQUFBLE1BQ0w7QUFFQSxZQUFNLGVBQ0YsS0FBSyxrQkFBa0IsS0FBSyxjQUFjLEtBQUssS0FBSyxRQUFRLENBQUMsRUFBRTtBQUNuRSxZQUFNLFFBQVFBLGFBQVksS0FBSyxTQUFTLEVBQUUsSUFDcEMsZUFDQSxLQUFLLFNBQVMsR0FBRyxTQUFTO0FBRWhDLFdBQUssZ0JBQWdCO0FBQ3JCLFdBQUssUUFBUSxLQUFLO0FBQUEsSUFDdEI7QUFHQSxTQUFLLFdBQVcsYUFBYTtBQUM3QixTQUFLLFdBQVc7QUFBQSxNQUNaLEtBQUssTUFBTSxJQUFJLFFBQU0sRUFBRSxPQUFPLEVBQUUsT0FBTyxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRTtBQUFBLElBQ3RFO0FBQ0EsU0FBSyxXQUFXLGVBQWUsS0FBSztBQUdwQyxTQUFLLG9CQUFvQjtBQUV6QixXQUFPO0FBQUEsRUFDWDtBQUNKOzs7QUMzSU8sSUFBTSxnQkFBTixjQUE0QixZQUFZO0FBQUEsRUFDMUI7QUFBQSxFQUNqQixZQUFZLFNBQStCO0FBRXZDLFVBQU0sT0FBTztBQUdiLFNBQUssWUFBWSxlQUFlLFFBQVEsU0FBUyxRQUFRLE1BQU07QUFDL0QsU0FBSyxRQUFRLE9BQU8sS0FBSyxTQUFTO0FBR2xDLFFBQUksUUFBUSxTQUFTO0FBQ2pCLFdBQUssV0FBVyxRQUFRLE9BQU87QUFBQSxJQUNuQztBQUdBLFNBQUssVUFBVSxpQkFBaUIsVUFBVSxPQUFLO0FBQzNDLFVBQUksRUFBRSxrQkFBa0Isa0JBQWtCO0FBQ3RDLFlBQUksRUFBRSxPQUFPLFNBQVMsWUFBWTtBQUM5QixlQUFLLFFBQVEsS0FBSyxpQkFBaUIsQ0FBQyxDQUFDO0FBQUEsUUFDekM7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBR0QsU0FBSyxtQkFBbUI7QUFDeEIsU0FBSyx5QkFBeUIsS0FBSyxTQUFTO0FBQUEsRUFDaEQ7QUFBQSxFQUVBLElBQUksZ0JBQTBCO0FBQzFCLFVBQU0sVUFBVSxLQUFLLFVBQVU7QUFBQSxNQUMzQjtBQUFBLElBQ0o7QUFDQSxXQUFPLE1BQU0sS0FBSyxPQUFPLEVBQUUsSUFBSSxjQUFZLFNBQVMsS0FBSztBQUFBLEVBQzdEO0FBQUEsRUFFQSxJQUFJLGNBQWMsUUFBa0I7QUFDaEMsVUFBTSxhQUFhLEtBQUssVUFBVSxpQkFBaUIsd0JBQXdCO0FBQzNFLGVBQVcsWUFBWSxZQUFZO0FBQy9CLFlBQU1DLFNBQVE7QUFDZCxZQUFNLGtCQUFrQixPQUFPLFNBQVNBLE9BQU0sS0FBSztBQUVuRCxVQUFJQSxPQUFNLFlBQVksaUJBQWlCO0FBQ25DLFFBQUFBLE9BQU0sVUFBVTtBQUNoQixRQUFBQSxPQUFNLGNBQWMsSUFBSSxNQUFNLFVBQVUsRUFBRSxTQUFTLEtBQUssQ0FBQyxDQUFDO0FBQUEsTUFDOUQ7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUFBLEVBRUEsWUFBWSxNQUFpQjtBQUN6QixTQUFLLFFBQVEsS0FBSyxtQkFBbUIsSUFBSSxDQUFDO0FBQzFDLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFQSxTQUFlO0FBQ1gsdUJBQW1CLEtBQUssV0FBVyxLQUFLLE9BQU8sVUFBVTtBQUN6RCxTQUFLLG9CQUFvQjtBQUN6QixXQUFPO0FBQUEsRUFDWDtBQUNKOzs7QUNoRUE7QUFBQSxFQUNJLGVBQUFDO0FBQUEsRUFDQSxXQUFBQztBQUFBLEVBQ0EsZUFBQUM7QUFBQSxPQUVHO0FBWUEsSUFBTSxXQUFOLGNBQXVCLE1BQU07QUFBQSxFQUNoQyxZQUErQixVQUEyQjtBQUN0RCxVQUFNLFNBQVMsUUFBUTtBQURJO0FBSTNCLFVBQU0sRUFBRSxZQUFZLE9BQUFDLE9BQU0sSUFBSSxtQkFBbUIsWUFBWSxTQUFTLEtBQUs7QUFDM0UsSUFBQUEsT0FBTSxLQUFLLFdBQVc7QUFDdEIsU0FBSyxRQUFRLFlBQVksVUFBVTtBQUduQyxJQUFBQSxPQUFNLFVBQVUsQ0FBQ0MsYUFBWSxLQUFLLFNBQVMsRUFBRSxJQUN0QyxLQUFLLFNBQVMsSUFBSSxTQUFTLFNBQVMsVUFDckMsU0FBUztBQUdmLFVBQU0sVUFBVSxNQUNaLEtBQUs7QUFBQSxNQUNERCxPQUFNLFVBQVUsU0FBUyxPQUFPLENBQUMsS0FBSyxTQUFZLFNBQVMsT0FBTyxDQUFDLEtBQUs7QUFBQSxJQUM1RTtBQUNKLElBQUFBLE9BQU0saUJBQWlCLFVBQVUsT0FBTztBQUN4QyxZQUFRO0FBR1IsUUFBSSxDQUFDQyxhQUFZLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDaEMsV0FBSyxTQUFTLEdBQUcsaUJBQWlCLFNBQVMsV0FBUztBQUNoRCxRQUFBRCxPQUFNLFVBQVUsVUFBVSxLQUFLLFNBQVMsT0FBTyxDQUFDO0FBQUEsTUFDcEQsQ0FBQztBQUFBLElBQ0wsT0FHSztBQUNELCtCQUF5QixNQUFNQSxNQUFLO0FBQUEsSUFDeEM7QUFBQSxFQUNKO0FBQUEsRUFFQSxXQUFpQjtBQUNiLFFBQUlDLGFBQVksS0FBSyxTQUFTLEVBQUUsR0FBRztBQUMvQixXQUFLLFNBQVMsR0FBRyxTQUFTLEtBQUssT0FBTyxDQUFDO0FBQUEsSUFDM0M7QUFBQSxFQUNKO0FBQUEsRUFFQSxPQUFPLE9BQW9EO0FBQ3ZELFFBQUksQ0FBQyxLQUFLLFNBQVMsT0FBTztBQUN0QixZQUFNLElBQUksTUFBTSwwREFBMEQ7QUFBQSxJQUM5RTtBQUVBLFdBQU9DLGFBQVksS0FBSyxTQUFTLE9BQU8sT0FBTyxFQUFFLFFBQVEsS0FBSyxDQUFDO0FBQUEsRUFDbkU7QUFBQSxFQUVBLFFBQVEsT0FBbUM7QUFDdkMsUUFBSUQsYUFBWSxLQUFLLFNBQVMsRUFBRSxHQUFHO0FBQy9CLFdBQUssU0FBUyxHQUFHLE9BQU8sS0FBSyxPQUFPLEtBQUssQ0FBQztBQUFBLElBQzlDLFdBQVdFLFNBQVEsS0FBSyxTQUFTLEVBQUUsR0FBRztBQUNsQyxXQUFLLFNBQVMsR0FBRyxPQUFPLEtBQUs7QUFBQSxJQUNqQztBQUFBLEVBQ0o7QUFDSjs7O0FDekVBO0FBQUEsRUFDSTtBQUFBLEVBQ0EsZUFBQUM7QUFBQSxFQUNBLFdBQUFDO0FBQUEsRUFDQSxlQUFBQztBQUFBLE9BRUc7QUFHUDtBQUFBLEVBRUk7QUFBQSxFQUNBO0FBQUEsRUFDQSxTQUFBQztBQUFBLE9BQ0c7QUFJUDtBQUFBLEVBQ0ksVUFBVTtBQUFBLE9BRVA7QUFlUCxJQUFNLGVBQWU7QUFFZCxJQUFNLFNBQU4sY0FBcUIsTUFBTTtBQUFBLEVBSzlCLFlBQStCLFVBQXlCO0FBQ3BELFVBQU0sU0FBUyxRQUFRO0FBREk7QUFJM0IsU0FBSyxRQUFRLFVBQVUsSUFBSSxjQUFjLGlCQUFpQjtBQUcxRCxVQUFNLEtBQUssV0FBVztBQUN0QixVQUFNLFFBQVEsU0FBUyxTQUFTLFNBQVM7QUFDekMsUUFBSSxZQUF5QixLQUFLO0FBQ2xDLFFBQUksT0FBTztBQUNQLGtCQUFZLE9BQU8sU0FBUyxjQUFjLE9BQU87QUFDakQsZ0JBQVUsWUFBWTtBQUN0QixXQUFLLFFBQVEsWUFBWSxTQUFTO0FBQUEsSUFDdEM7QUFHQSxRQUFJLEVBQUUsT0FBTyxPQUFPLEtBQUFDLE1BQUssS0FBQUMsS0FBSSxJQUFJO0FBR2pDLFNBQUssVUFBVSxTQUFTLGNBQWMsS0FBSztBQUMzQyxTQUFLLFFBQVEsVUFBVSxJQUFJLFlBQVk7QUFDdkMsU0FBSyxRQUFRLGFBQWEsTUFBTSxFQUFFO0FBQ2xDLFFBQUksU0FBUyxRQUFXO0FBQ3BCLFdBQUssUUFBUSxNQUFNLFFBQVEsR0FBRyxDQUFDLEtBQUs7QUFBQSxJQUN4QztBQUNBLFFBQUksV0FBVztBQUNYLGdCQUFVLFlBQVksS0FBSyxPQUFPO0FBQUEsSUFDdEMsT0FBTztBQUNILFdBQUssUUFBUSxZQUFZLEtBQUssT0FBTztBQUFBLElBQ3pDO0FBQ0EsU0FBSyxhQUFhLGFBQWEsS0FBSyxTQUFTO0FBQUEsTUFDekMsT0FBTyxFQUFFLEtBQUssR0FBRyxLQUFLLEVBQUU7QUFBQSxNQUN4QixTQUFTLFNBQVMsV0FBVztBQUFBLE1BQzdCLE9BQU8sU0FBUyxXQUFXLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSTtBQUFBLElBQ3JELENBQUM7QUFHRCxTQUFLLFVBQVUsU0FBUyxjQUFjLE9BQU87QUFDN0MsU0FBSyxRQUFRLGFBQWEsU0FBUyxjQUFjO0FBQ2pELFNBQUssUUFBUSxZQUFZLEtBQUssT0FBTztBQUdyQyxRQUFJLEtBQUssU0FBUyxJQUFJLFVBQVUsUUFBVztBQUN2QyxXQUFLLFFBQVEsS0FBSztBQUFBLElBQ3RCLFdBQVcsVUFBVSxRQUFXO0FBQzVCLGNBQVEsS0FBSyxTQUFTLElBQUk7QUFBQSxJQUM5QjtBQUdBLFNBQUssbUJBQW1CO0FBR3hCLFFBQUksQ0FBQ0MsYUFBWSxLQUFLLFNBQVMsRUFBRSxHQUFHO0FBQ2hDLFdBQUssU0FBUyxHQUFHLGlCQUFpQixTQUFTLENBQUFDLFdBQVM7QUFDaEQsWUFBSSxDQUFDLFNBQVNBLFFBQU8sS0FBSyxXQUFXLEdBQUc7QUFDcEMsZUFBSyxXQUFXLElBQUlBLE1BQUs7QUFDekIsZUFBSyxtQkFBbUI7QUFBQSxRQUM1QjtBQUFBLE1BQ0osQ0FBQztBQUFBLElBQ0wsT0FHSztBQUNELCtCQUF5QixNQUFNLEtBQUssT0FBTztBQUFBLElBQy9DO0FBR0EsUUFBSSxDQUFDLFNBQVMsTUFBTTtBQUNoQixNQUFBSCxPQUFNQSxTQUFRLE1BQU0sUUFBUSxLQUFLLElBQUksTUFBTSxDQUFDLElBQUssU0FBUztBQUMxRCxNQUFBQyxPQUFNQSxTQUFRLE1BQU0sUUFBUSxLQUFLLElBQUksTUFBTSxDQUFDLElBQUssU0FBUztBQUMxRCxZQUFNLFFBQVEsVUFBVSxTQUFTLFdBQVcsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJO0FBQ2xFLFdBQUssYUFBYUQsTUFBS0MsTUFBSyxLQUFLO0FBQ2pDLFdBQUssV0FBVyxHQUFHLFVBQVUsTUFBTTtBQUMvQixhQUFLLG1CQUFtQjtBQUN4QixhQUFLLFFBQVEsS0FBSyxXQUFXO0FBQUEsTUFDakMsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQUEsRUFsRmlCO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNULGNBQXVCO0FBQUEsRUFpRi9CLHFCQUFxQjtBQUNqQixVQUFNLFFBQVEsS0FBSztBQUNuQixRQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDdEIsV0FBSyxRQUFRLFlBQVksR0FBRyxNQUFNLENBQUMsRUFBRSxlQUFlLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxlQUFlLENBQUM7QUFBQSxJQUN0RixPQUFPO0FBQ0gsV0FBSyxRQUFRLFlBQVksTUFBTSxlQUFlO0FBQUEsSUFDbEQ7QUFBQSxFQUNKO0FBQUEsRUFFQSxJQUFJLGNBQXlDO0FBQ3pDLFVBQU0sUUFBUSxLQUFLLFdBQVcsSUFBSTtBQUNsQyxRQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDdEIsYUFBTyxNQUFNLElBQUksV0FBVyxFQUFFLE1BQU0sR0FBRyxDQUFDO0FBQUEsSUFDNUMsT0FBTztBQUNILGFBQU8sWUFBWSxLQUFLO0FBQUEsSUFDNUI7QUFBQSxFQUNKO0FBQUEsRUFFQSxJQUFJLFlBQVksT0FBa0M7QUFDOUMsU0FBSyxXQUFXLElBQUksT0FBTyxJQUFJO0FBQUEsRUFDbkM7QUFBQSxFQUVBLFdBQWlCO0FBQ2IsVUFBTSxTQUFTLEtBQUssU0FBUztBQUM3QixRQUFJQyxhQUFZLE1BQU0sR0FBRztBQUNyQixhQUFPLFNBQVMsS0FBSyxPQUFPLENBQUM7QUFBQSxJQUNqQztBQUFBLEVBQ0o7QUFBQSxFQUVBLE1BQU0sU0FBdUIsQ0FBQyxHQUFHO0FBQzdCLFVBQU0sRUFBRSxNQUFNLFFBQUFFLFFBQU8sSUFBSSxLQUFLO0FBQzlCLFFBQUksQ0FBQyxRQUFRLENBQUNBLFNBQVE7QUFDbEIsYUFBTztBQUFBLElBQ1g7QUFDQSxXQUFPQyxPQUFNLE9BQU8sRUFBRSxLQUFLLElBQUlELE9BQU0sR0FBRyxLQUFLLElBQUlBLE9BQU0sRUFBRSxDQUFDLEVBQ3JELEtBQUssSUFBSSxFQUNULE1BQU0sR0FBRyxNQUFNO0FBQUEsRUFDeEI7QUFBQSxFQUVBLFlBQVksTUFBVztBQUVuQixVQUFNLEVBQUUsS0FBSyxTQUFTLEtBQUssUUFBUSxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUUsQ0FBQztBQUN6RCxVQUFNSixPQUFNLEtBQUssU0FBUyxPQUFPO0FBQ2pDLFVBQU1DLE9BQU0sS0FBSyxTQUFTLE9BQU87QUFHakMsUUFBSSxRQUFRLEtBQUs7QUFDakIsUUFBSSxDQUFDLEtBQUssYUFBYTtBQUNuQixXQUFLLGNBQWM7QUFDbkIsVUFBSSxLQUFLLFNBQVMsVUFBVSxRQUFXO0FBQ25DLGdCQUFRLEtBQUssU0FBUyxXQUFXLGFBQWEsQ0FBQ0QsTUFBS0MsSUFBRyxJQUFJQTtBQUFBLE1BQy9ELE9BQU87QUFDSCxnQkFBUSxLQUFLLFNBQVM7QUFBQSxNQUMxQjtBQUVBLFdBQUssYUFBYUQsTUFBS0MsTUFBSyxLQUFLO0FBRWpDLFdBQUssV0FBVyxHQUFHLFVBQVUsTUFBTTtBQUMvQixhQUFLLG1CQUFtQjtBQUN4QixhQUFLLFFBQVEsS0FBSyxXQUFXO0FBQUEsTUFDakMsQ0FBQztBQUFBLElBQ0wsT0FBTztBQUNILFdBQUssYUFBYUQsTUFBS0MsTUFBSyxLQUFLO0FBQUEsSUFDckM7QUFFQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsYUFBYUQsTUFBYUMsTUFBYSxPQUFrQztBQUNyRSxVQUFNLE9BQU8sS0FBSyxTQUFTLFNBQVNELFFBQU8sS0FBS0MsUUFBTyxJQUFJLElBQUk7QUFDL0QsU0FBSyxXQUFXO0FBQUEsTUFDWjtBQUFBLFFBQ0ksT0FBTztBQUFBLFVBQ0gsS0FBQUQ7QUFBQSxVQUNBLEtBQUFDO0FBQUEsUUFDSjtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFBQSxJQUNKO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUVBLE9BQU8sT0FBb0Q7QUFDdkQsUUFBSSxFQUFFLE9BQU8sUUFBQUcsU0FBUSxLQUFBSixNQUFLLFNBQVMsUUFBUSxJQUFJLEtBQUs7QUFDcEQsWUFBUSxTQUFTSTtBQUNqQixRQUFJLENBQUMsT0FBTztBQUNSLFlBQU0sSUFBSTtBQUFBLFFBQ047QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNBLFFBQUksV0FBVyxjQUFjLFVBQVUsUUFBVztBQUM5QyxZQUFNLFNBQTJCLE1BQU0sUUFBUSxLQUFLLElBQUksUUFBUSxDQUFDSixRQUFPLEdBQUcsS0FBSztBQUNoRixhQUFPLGVBQWUsT0FBTyxRQUFRO0FBQUEsUUFDakMsUUFBUTtBQUFBLFFBQ1IsS0FBSztBQUFBLFFBQ0wsT0FBTyxFQUFFLE1BQU0sWUFBWSxPQUFPO0FBQUEsUUFDbEMsV0FBVyxLQUFLLFNBQVMsUUFBUTtBQUFBLE1BQ3JDLENBQUM7QUFBQSxJQUNMLE9BQU87QUFDSCxhQUFPTSxhQUFZLE9BQU8sTUFBTSxRQUFRLEtBQUssSUFBSSxNQUFNLENBQUMsSUFBSSxPQUFPO0FBQUEsUUFDL0QsUUFBUTtBQUFBLE1BQ1osQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQUEsRUFFQSxRQUFRLE9BQW1DO0FBQ3ZDLFVBQU0sU0FBUyxLQUFLLFNBQVM7QUFDN0IsUUFBSUosYUFBWSxNQUFNLEdBQUc7QUFDckIsYUFBTyxPQUFPLEtBQUssT0FBTyxLQUFLLENBQUM7QUFBQSxJQUNwQyxXQUFXSyxTQUFRLE1BQU0sR0FBRztBQUN4QixhQUFPLE9BQU8sS0FBSztBQUFBLElBQ3ZCO0FBQUEsRUFDSjtBQUNKO0FBRUEsU0FBUyxTQUFTLEdBQThCLEdBQThCO0FBQzFFLE1BQUksTUFBTSxRQUFRLENBQUMsS0FBSyxNQUFNLFFBQVEsQ0FBQyxHQUFHO0FBQ3RDLFdBQU8sRUFBRSxJQUFJLFdBQVcsTUFBTSxFQUFFLElBQUksV0FBVztBQUFBLEVBQ25ELFdBQVcsQ0FBQyxNQUFNLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxRQUFRLENBQUMsR0FBRztBQUMvQyxXQUFPLFlBQVksQ0FBQyxNQUFNLFlBQVksQ0FBQztBQUFBLEVBQzNDLE9BQU87QUFDSCxXQUFPO0FBQUEsRUFDWDtBQUNKO0FBRUEsU0FBUyxZQUFZLEtBQXNCO0FBQ3ZDLE1BQUksT0FBTyxRQUFRLFVBQVU7QUFDekIsVUFBTSxXQUFXLEdBQUc7QUFBQSxFQUN4QjtBQUdBLE1BQUksQ0FBQyxTQUFTLEdBQUcsRUFBRyxRQUFPO0FBQzNCLE1BQUksUUFBUSxFQUFHLFFBQU87QUFHdEIsUUFBTSxZQUFZLEtBQUssSUFBSSxHQUFHO0FBQzlCLFFBQU0sVUFBVSxZQUFZLE9BQU8sVUFBVTtBQUc3QyxRQUFNLFVBQVUsS0FBSyxNQUFNLEdBQUc7QUFHOUIsTUFBSSxLQUFLLElBQUksTUFBTSxPQUFPLElBQUksU0FBUztBQUNuQyxXQUFPO0FBQUEsRUFDWDtBQUdBLFNBQU8sV0FBVyxJQUFJLFlBQVksRUFBRSxDQUFDO0FBQ3pDOzs7QUNqUkE7QUFBQSxFQUNJLGdCQUFBQztBQUFBLEVBQ0EsZUFBQUM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsaUJBQUFDO0FBQUEsT0FDRztBQUVQO0FBQUEsRUFDSTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUdBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsU0FBQUM7QUFBQSxFQUVBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQSxPQUFBQztBQUFBLEVBQ0EsT0FBQUM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsT0FDRztBQUVQO0FBQUEsRUFDSTtBQUFBLEVBR0E7QUFBQSxFQUNBO0FBQUEsRUFFQTtBQUFBLE9BU0c7QUFFUCxZQUFZLGNBQWM7QUFDMUIsWUFBWSxrQkFBa0I7QUFROUIsSUFBTSxnQkFBZ0I7QUFDdEIsSUFBTSxvQkFBb0I7QUFnSG5CLElBQU0sUUFBTixjQUFvQixNQUFNO0FBQUEsRUFtQjdCLFlBQStCLFVBQXdCO0FBQ25ELFVBQU0sU0FBUyxTQUFTO0FBREc7QUFJM0IsbUJBQWUsZ0JBQWdCLENBQUMsa0JBQWtCLENBQUM7QUFHbkQsU0FBSyxNQUFNLFdBQVc7QUFHdEIsU0FBSyxjQUFjO0FBR25CLFNBQUssUUFBUSxVQUFVLElBQUksbUJBQW1CO0FBRzlDLFFBQUksT0FBTyxLQUFLLFNBQVMsVUFBVSxVQUFVO0FBQ3pDLFdBQUssUUFBUSxNQUFNLFFBQVEsR0FBRyxLQUFLLFNBQVMsS0FBSztBQUFBLElBQ3JEO0FBRUEsUUFBSSxLQUFLLFNBQVMsV0FBVztBQUN6QixXQUFLLFFBQVEsTUFBTSxXQUFXLEdBQUcsS0FBSyxTQUFTLFNBQVM7QUFBQSxJQUM1RDtBQUVBLFFBQUksS0FBSyxTQUFTLGNBQWM7QUFDNUIsV0FBSyxRQUFRLE1BQU0sU0FBUztBQUFBLElBQ2hDLFdBQVcsS0FBSyxTQUFTLFVBQVUsS0FBSyxTQUFTLFdBQVcsUUFBUTtBQUNoRSxXQUFLLFFBQVEsTUFBTSxTQUFTLEdBQUcsS0FBSyxTQUFTLE1BQU07QUFBQSxJQUN2RDtBQUVBLFFBQUksS0FBSyxTQUFTLE9BQU87QUFJckIsVUFBSSxLQUFLLFNBQVMsT0FBTyxrQkFBa0I7QUFDdkMsYUFBSyxRQUFRLE1BQU07QUFBQSxVQUNmO0FBQUEsVUFDQSxLQUFLLFNBQVMsTUFBTTtBQUFBLFFBQ3hCO0FBQUEsTUFDSjtBQUVBLFVBQUksS0FBSyxTQUFTLE9BQU8sa0JBQWtCO0FBQ3ZDLGFBQUssUUFBUSxNQUFNO0FBQUEsVUFDZjtBQUFBLFVBQ0EsS0FBSyxTQUFTLE1BQU07QUFBQSxRQUN4QjtBQUFBLE1BQ0o7QUFFQSxVQUFJLEtBQUssU0FBUyxPQUFPLGNBQWM7QUFDbkMsYUFBSyxRQUFRLE1BQU07QUFBQSxVQUNmO0FBQUEsVUFDQSxLQUFLLFNBQVMsTUFBTTtBQUFBLFFBQ3hCO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFHQSxTQUFLLGlCQUFpQixTQUFTLGNBQWMsS0FBSztBQUNsRCxTQUFLLGVBQWUsS0FBSyxLQUFLO0FBQzlCLFNBQUssZUFBZSxNQUFNLFFBQVE7QUFDbEMsU0FBSyxlQUFlLE1BQU0sU0FBUztBQUNuQyxTQUFLLFFBQVEsWUFBWSxLQUFLLGNBQWM7QUFHNUMsU0FBSyxlQUFlLEtBQUssa0JBQWtCLEtBQUssUUFBUTtBQUFBLEVBQzVEO0FBQUEsRUFuRmlCO0FBQUEsRUFDVCxXQUE2QixDQUFDO0FBQUEsRUFDOUIsaUJBQWlELENBQUM7QUFBQSxFQUNsRCxlQUF1QyxDQUFDO0FBQUEsRUFFL0I7QUFBQSxFQUNULFFBQXdCO0FBQUEsRUFDeEI7QUFBQSxFQUVBO0FBQUEsRUFDQSxhQUE2QixDQUFDO0FBQUEsRUFDOUIsZUFBNEIsQ0FBQztBQUFBLEVBRTdCLFFBQXNFO0FBQUEsSUFDMUUsU0FBUztBQUFBLElBQ1QsU0FBUyxDQUFDO0FBQUEsRUFDZDtBQUFBO0FBQUEsRUFzRUEsT0FBTyxPQUFpQixDQUFDLEdBQUc7QUFDeEIsVUFBTSxTQUFTLEtBQUssbUJBQW1CLEVBQUUsSUFBSSxDQUFBQyxZQUFVQSxRQUFPLFNBQVM7QUFFdkUsVUFBTSxTQUFTLEtBQUssSUFBSSxTQUFPO0FBQzNCLGFBQU8sT0FBTyxJQUFJLE9BQUssS0FBSyxNQUFNLFFBQVEsQ0FBQyxFQUFFLEdBQUcsQ0FBQztBQUFBLElBQ3JELENBQUM7QUFDRCxXQUFPQyxjQUFhLFFBQVEsUUFBUSxFQUFFLFFBQVEsS0FBSyxDQUFDO0FBQUEsRUFDeEQ7QUFBQTtBQUFBO0FBQUEsRUFJQSxNQUFNLFVBQVU7QUFFWixVQUFNLFFBQVEsS0FBSyxTQUFTO0FBQzVCLFVBQU0sU0FBUyxNQUFNLGVBQWUsS0FBSyxhQUFjLENBQUMsRUFBRSxRQUFRLEtBQUssTUFBTSxDQUFDLENBQUM7QUFJL0UsVUFBTSxjQUFjLEtBQUssU0FBUyxVQUM1QixLQUFLLFNBQVMsVUFDZCxPQUFPLElBQUksT0FBSyxFQUFFLE1BQU07QUFDOUIsU0FBSyxXQUFXLGVBQWUsV0FBVztBQUMxQyxTQUFLLGlCQUFpQixLQUFLLFNBQVM7QUFBQSxNQUNoQyxDQUFDLEtBQUssUUFBUTtBQUNWLFlBQUksSUFBSSxXQUFXLElBQUk7QUFDdkIsZUFBTztBQUFBLE1BQ1g7QUFBQSxNQUNBLENBQUM7QUFBQSxJQUNMO0FBS0EsU0FBSyxTQUNBLE9BQU8sT0FBSyxFQUFFLFNBQVMsU0FBUyxFQUNoQyxRQUFRLENBQUFELFlBQVU7QUFDZixZQUFNLE9BQU8sT0FBTyxLQUFLLE9BQUssRUFBRSxXQUFXQSxRQUFPLFNBQVM7QUFDM0QsVUFBSSxNQUFNO0FBQ04sYUFBSyxhQUFhQSxRQUFPLFdBQVcsSUFBSSxLQUFLO0FBQUEsTUFDakQ7QUFBQSxJQUNKLENBQUM7QUFHTCxTQUFLLGtCQUFrQixFQUFFLFFBQVEsT0FBSztBQUNsQyxZQUFNLFNBQVMsRUFBRTtBQUNqQixVQUFJLE1BQU0sUUFBUSxNQUFNLEdBQUc7QUFFdkIsY0FBTSxXQUFXLE9BQU8sQ0FBQztBQUN6QixjQUFNLFVBQ0YsT0FBTyxhQUFhLFlBQ2QsWUFDQSxPQUFPLGFBQWEsV0FDbEIsV0FDQTtBQUNaLFlBQUksU0FBUztBQUNULGVBQUssYUFBYSxFQUFFLFdBQVcsSUFBSTtBQUFBLFFBQ3ZDO0FBQUEsTUFDSixXQUFXLE9BQU8sV0FBVyxXQUFXO0FBQ3BDLGFBQUssYUFBYSxFQUFFLFdBQVcsSUFBSTtBQUFBLE1BQ3ZDLFdBQVcsT0FBTyxXQUFXLFVBQVU7QUFDbkMsYUFBSyxhQUFhLEVBQUUsV0FBVyxJQUFJO0FBQUEsTUFDdkM7QUFBQSxJQUNKLENBQUM7QUFHRCxVQUFNLGFBQXVCLEtBQUssU0FBUyxJQUFJLENBQUFBLFlBQVU7QUFDckQsWUFBTSxJQUFJLEtBQUssYUFBYUEsUUFBTyxXQUFXO0FBQzlDLGFBQU8sS0FBSyxnQkFBZ0JBLFFBQU8sYUFBYSxDQUFDO0FBQUEsSUFDckQsQ0FBQztBQUNELFNBQUssYUFBYSxhQUFhO0FBRy9CLFNBQUssUUFBUSxXQUFXLEtBQUssZ0JBQWdCLEtBQUssWUFBWTtBQUFBLEVBQ2xFO0FBQUE7QUFBQTtBQUFBLEVBSUEsTUFBTSxTQUF1QixDQUFDLEdBQUc7QUFDN0IsVUFBTSxjQUFpRCxDQUFDO0FBQ3hELFVBQU0sVUFBb0IsQ0FBQztBQUMzQixRQUFJLGdCQUFnQjtBQUtwQixlQUFXQSxXQUFVLEtBQUssbUJBQW1CLEdBQUc7QUFDNUMsVUFBSUEsUUFBTyxTQUFTLGFBQWE7QUFDN0IsY0FBTSxPQUFPLG9CQUFvQkEsT0FBTTtBQUN2QyxvQkFBWSxLQUFLLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQztBQUM3Qix3QkFBZ0I7QUFBQSxNQUNwQixXQUFXQSxRQUFPLFNBQVMsVUFBVTtBQUNqQyxvQkFBWUEsUUFBTyxTQUFTLElBQUlBLFFBQU87QUFDdkMsZ0JBQVEsS0FBS0EsUUFBTyxTQUFTO0FBQUEsTUFDakM7QUFBQSxJQUNKO0FBR0EsUUFBSSxRQUFRRSxPQUFNLEtBQUssS0FBSyxTQUFTLElBQUksRUFBRTtBQUFBLE1BQ3ZDLE9BQU8sS0FBSyxXQUFXLEVBQUUsU0FBUyxjQUFjO0FBQUEsSUFDcEQ7QUFHQSxRQUFJLGlCQUFpQixRQUFRLFNBQVMsR0FBRztBQUNyQyxZQUFNLFFBQVEsT0FBTztBQUFBLElBQ3pCO0FBR0EsWUFBUSxNQUFNLE1BQU0sR0FBRyxNQUFNO0FBRzdCLFdBQU8sS0FBSyxLQUFLLFlBQVksRUFBRSxRQUFRLGdCQUFjO0FBQ2pELFlBQU0sTUFBTSxLQUFLLGVBQWUsVUFBVSxLQUFLLENBQUM7QUFDaEQsVUFBSSxJQUFJLFNBQVMsV0FBVztBQUN4QixjQUFNLFlBQVksSUFBSSxTQUFTO0FBQy9CLGNBQU1DLFVBQVMsS0FBSyxhQUFhLFVBQVU7QUFDM0MsY0FBTSxhQUFhLGlCQUFpQixZQUFZQSxTQUFRLEtBQUs7QUFDN0QsWUFBSSxZQUFZO0FBQ1osY0FBSSxXQUFXO0FBQ1gsa0JBQU0sT0FBTyxVQUFVO0FBQUEsVUFDM0IsT0FBTztBQUNILG9CQUFRLE1BQU0sTUFBTSxVQUFVO0FBQUEsVUFDbEM7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0osQ0FBQztBQUdELFFBQUksS0FBSyxXQUFXLFNBQVMsR0FBRztBQUM1QixXQUFLLFdBQVcsUUFBUSxVQUFRO0FBQzVCLGNBQU0sTUFBTSxLQUFLLGVBQWUsS0FBSyxLQUFLLEtBQUssQ0FBQztBQUNoRCxZQUFJLElBQUksU0FBUyxXQUFXO0FBQ3hCLGtCQUFRLE1BQU0sUUFBUSxLQUFLLFNBQVMsUUFBUSxJQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxLQUFLLENBQUM7QUFBQSxRQUNsRjtBQUFBLE1BQ0osQ0FBQztBQUFBLElBQ0w7QUFFQSxXQUFPO0FBQUEsRUFDWDtBQUFBO0FBQUEsRUFHQSxZQUFZLE1BQVc7QUFDbkIsU0FBSyxRQUFRQyxlQUFjLElBQUk7QUFDL0IsV0FBTztBQUFBLEVBQ1g7QUFBQTtBQUFBLEVBR0EsU0FBUztBQUNMLFNBQUssV0FBVyxJQUFJO0FBQ3BCLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFFUSxhQUFhLFNBQVMsWUFBWTtBQUN0QyxRQUFJLENBQUMsS0FBSyxPQUFPO0FBQ2I7QUFBQSxJQUNKO0FBR0EsVUFBTSxVQUFpQixDQUFDO0FBQ3hCLGFBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxNQUFNLFNBQVMsS0FBSztBQUN6QyxZQUFNLE1BQVcsQ0FBQztBQUNsQixXQUFLLFNBQVMsUUFBUSxDQUFDLEVBQUUsYUFBYSxRQUFBSixRQUFPLE1BQU07QUFDL0MsWUFBSSxNQUFNLFFBQVFBLE9BQU0sR0FBRztBQUN2QixnQkFBTSxRQUFRLElBQUlBLFFBQU87QUFDekIsY0FBSSxXQUFXLElBQUlBLFFBQU8sS0FBSztBQUFBLFFBQ25DLFdBQVcsT0FBT0EsWUFBVyxhQUFhLE9BQU9BLFlBQVcsVUFBVTtBQUNsRSxjQUFJLFdBQVcsSUFBSUE7QUFBQSxRQUN2QixPQUFPO0FBQ0gsY0FBSSxXQUFXLElBQUksS0FBSyxNQUFNLFFBQVEsV0FBVyxFQUFFLENBQUM7QUFBQSxRQUN4RDtBQUFBLE1BQ0osQ0FBQztBQUVELGNBQVEsS0FBSyxHQUFHO0FBQUEsSUFDcEI7QUFFQSxTQUFLLE1BQU0sY0FBYyxXQUFXLE9BQU87QUFDM0MsUUFBSSxLQUFLLE1BQU0sVUFBVSxpQkFBaUIsS0FBSyxTQUFTLFdBQVcsUUFBVztBQUMxRSxXQUFLLE1BQU0sY0FBYyxhQUFhLFlBQVk7QUFBQSxJQUN0RCxXQUNJLENBQUMsS0FBSyxTQUFTLGlCQUNkLEtBQUssU0FBUyxXQUFXLFVBQVUsS0FBSyxTQUFTLFdBQVcsU0FDL0Q7QUFDRSxXQUFLLFFBQVEsTUFBTSxTQUFTLEdBQUcsaUJBQWlCO0FBQUEsSUFDcEQ7QUFBQSxFQUNKLENBQUM7QUFBQSxFQUVPLGtCQUFrQixTQUFvQztBQUMxRCxVQUFNLHFCQUNGLE9BQU8sUUFBUSxrQkFBa0IsV0FBVyxTQUFZLFFBQVE7QUFDcEUsVUFBTSxjQUFjLFFBQVEsV0FBVztBQUN2QyxVQUFNLG9CQUFvQixvQkFBb0IsT0FBTztBQUdyRCxVQUFNLFlBQVksWUFBWSxXQUFXO0FBQUEsTUFDckMsV0FBVyxLQUFLLFNBQVMsT0FBTztBQUFBLE1BQ2hDLGlCQUNJLEtBQUssU0FBUyxPQUFPLHFCQUFxQixLQUFLLFNBQVMsT0FBTztBQUFBLE1BQ25FLGVBQWUsS0FBSyxTQUFTLE9BQU87QUFBQSxNQUVwQyxZQUFZLEtBQUssU0FBUyxPQUFPO0FBQUEsTUFDakMsa0JBQ0ksS0FBSyxTQUFTLE9BQU8sc0JBQXNCLEtBQUssU0FBUyxPQUFPO0FBQUEsTUFDcEUsZ0JBQ0ksS0FBSyxTQUFTLE9BQU8sb0JBQW9CLEtBQUssU0FBUyxPQUFPO0FBQUEsTUFFbEUsU0FBUyxLQUFLLFNBQVMsT0FBTyxXQUFXO0FBQUEsTUFFekMsYUFBYSxLQUFLLFNBQVMsT0FBTztBQUFBLE1BQ2xDLGNBQWMsS0FBSyxTQUFTLE9BQU87QUFBQSxNQUVuQyw0QkFBNEIsS0FBSyxTQUFTLE9BQU87QUFBQSxJQUNyRCxDQUFDO0FBQ0QsVUFBTSxZQUFZLEtBQUssU0FBUyxXQUFXLFNBQVMsZUFBZTtBQUduRSxXQUFPO0FBQUE7QUFBQSxNQUVILFlBQVksQ0FBQyxDQUFDLFFBQVE7QUFBQSxNQUN0Qix3QkFDSSxRQUFRLFlBQVksY0FBYyxVQUNsQyxRQUFRLFlBQVksY0FBYztBQUFBLE1BQ3RDLDRCQUE0QixRQUFRLFlBQVk7QUFBQSxNQUNoRCxvQkFDSSxPQUFPLFFBQVEsWUFBWSxjQUFjLFdBQ25DLFFBQVEsV0FBVyxZQUNuQjtBQUFBLE1BQ1YsYUFBYTtBQUFBLE1BQ2IsY0FBYztBQUFBLE1BQ2QsV0FBVyxRQUFRO0FBQUEsTUFDbkI7QUFBQSxNQUNBLFlBQVksQ0FBQztBQUFBLE1BQ2IsU0FBUyxDQUFDO0FBQUEsTUFDVixjQUFjO0FBQUEsTUFDZCxtQkFBbUI7QUFBQSxNQUNuQix5QkFBeUI7QUFBQSxNQUN6QixPQUFPO0FBQUEsTUFDUCxpQkFBaUIsTUFBTTtBQUVuQixhQUFLLGVBQWUsS0FBSyxPQUFPLGVBQWUsS0FBSyxDQUFDO0FBR3JELGFBQUssYUFBYTtBQUFBLE1BQ3RCO0FBQUEsTUFDQSxlQUFlLE1BQU07QUFDakIsWUFBSSxLQUFLLE9BQU87QUFFWixnQkFBTSxZQUFZLEtBQUssTUFDbEIsZUFBZSxFQUNmLE9BQU8sU0FBTyxJQUFJLElBQUksRUFDdEIsSUFBSSxVQUFRLEVBQUUsT0FBTyxJQUFJLE9BQU8sTUFBTSxJQUFJLEtBQUssRUFBRTtBQUN0RCxlQUFLLGFBQWE7QUFHbEIsZUFBSyxhQUFhO0FBQUEsUUFDdEI7QUFBQSxNQUNKO0FBQUEsTUFDQSxvQkFBb0IsV0FBUztBQUN6QixZQUFJLHNCQUFzQixVQUFhSyxhQUFZLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDbEUsY0FBSSxNQUFNLGVBQWU7QUFFckIsa0JBQU0sYUFBYSxNQUFNLGNBQ3BCLElBQUksT0FBSyxFQUFFLFFBQVEsRUFDbkIsT0FBTyxPQUFLLE1BQU0sSUFBSTtBQUczQixpQkFBSyxTQUFTLEdBQUcsT0FBTyxLQUFLLE9BQU8sVUFBVSxDQUFDO0FBQUEsVUFDbkQ7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0EsaUJBQWlCLFdBQVM7QUFDdEIsWUFBSSxlQUFlQSxhQUFZLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDOUMsZ0JBQU0sV0FBVyxNQUFNO0FBQ3ZCLGNBQ0ksYUFBYSxVQUNiLGFBQWEsUUFDYixhQUFhLEtBQUssYUFDcEI7QUFDRSxpQkFBSyxjQUFjO0FBQ25CLGlCQUFLLFNBQVMsR0FBRyxPQUFPLEtBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQUEsVUFDbkQ7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLE1BQ0EsZ0JBQWdCLE1BQU07QUFDbEIsWUFBSSxlQUFlQSxhQUFZLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDOUMsZUFBSyxjQUFjO0FBQ25CLGVBQUssU0FBUyxHQUFHLE9BQU8sS0FBSyxPQUFPLENBQUM7QUFBQSxRQUN6QztBQUFBLE1BQ0o7QUFBQSxNQUNBLGFBQWEsTUFBTTtBQUVmLGFBQUssVUFBVTtBQUFBLE1BQ25CO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUVRLG9CQUE2QztBQUNqRCxXQUFPLEtBQUssU0FBUyxPQUFPLE9BQUssRUFBRSxTQUFTLFNBQVM7QUFBQSxFQUN6RDtBQUFBLEVBRVEscUJBQTRFO0FBQ2hGLFdBQU8sS0FBSyxTQUFTLE9BQU8sT0FBSyxFQUFFLFNBQVMsWUFBWSxFQUFFLFNBQVMsV0FBVztBQUFBLEVBQ2xGO0FBQUEsRUFFUSxnQkFBZ0IsYUFBcUIsTUFBc0I7QUFDL0QsVUFBTUwsVUFBUyxLQUFLLGVBQWUsV0FBVyxLQUFLLENBQUM7QUFHcEQsVUFBTSxRQUFRQSxRQUFPLFVBQVUsU0FBUyxXQUFXLFVBQVU7QUFDN0QsVUFBTSxrQkFBa0JBLFFBQU87QUFHL0IsVUFBTSxZQUFZLGlCQUFpQixNQUFNQSxRQUFPLE1BQU07QUFHdEQsVUFBTSxXQUFXLEtBQUssU0FBUyxZQUFZLFNBQVNBLFFBQU8sYUFBYTtBQUN4RSxVQUFNLGFBQWEsS0FBSyxTQUFTLGNBQWMsU0FBU0EsUUFBTyxlQUFlO0FBRzlFLFVBQU0sWUFBWUEsUUFBTyxjQUFjO0FBR3ZDLFVBQU0sV0FBV0EsUUFBTztBQUN4QixVQUFNLFdBQVdBLFFBQU87QUFHeEIsVUFBTSxhQUFhQSxRQUFPO0FBQzFCLFVBQU0sbUJBQ0YsS0FBSyxTQUFTLGtCQUFrQixVQUFVQSxRQUFPLHVCQUF1QjtBQUc1RSxVQUFNLFdBQVdBLFFBQU87QUFDeEIsVUFBTSxpQkFBaUJBLFFBQU87QUFHOUIsVUFBTSxPQUFPQSxRQUFPO0FBSXBCLFVBQU0sb0JBQW9CLENBQUMsU0FBa0IsWUFBcUI7QUFDOUQsYUFBTztBQUFBLElBQ1g7QUFHQSxVQUFNLFNBQWlCO0FBQUEsTUFDbkIsT0FBTztBQUFBLE1BQ1AsWUFBWUEsUUFBTyxTQUFTO0FBQUEsTUFDNUIsYUFBYSxjQUFjLGVBQWU7QUFBQSxNQUMxQyxXQUFXLEVBQUUsV0FBVyxNQUFNO0FBQUEsTUFDOUIsWUFBWUEsUUFBTyxTQUFTLFlBQVksb0JBQW9CO0FBQUEsTUFDNUQsUUFBUSxDQUFDLGFBQWEsUUFBUSxvQkFBb0IsSUFBSTtBQUFBLE1BQ3REO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLGdCQUFnQixLQUFLLFNBQVMsY0FBYztBQUFBO0FBQUEsTUFFNUMsaUJBQWlCO0FBQUEsTUFDakIsZ0JBQWdCLFlBQVU7QUFFdEIsY0FBTSxRQUFRLE9BQU87QUFDckIsWUFBSSxhQUFhLFVBQVUsUUFBUSxVQUFVLFFBQVc7QUFDcEQsaUJBQU8sVUFBVSxLQUFLO0FBQUEsUUFDMUI7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFJQSxVQUFNLFFBQVFBLFFBQU87QUFDckIsUUFBSSxPQUFPO0FBQ1AsYUFBTyxRQUFRO0FBQUEsSUFDbkIsV0FBVyxTQUFTLFVBQWEsU0FBUyxNQUFNO0FBQzVDLGFBQU8sT0FBTztBQUFBLElBQ2xCO0FBRUEsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUVRLFlBQVk7QUFDaEIsUUFBSSxDQUFDLEtBQUssT0FBTztBQUNiO0FBQUEsSUFDSjtBQUVBLFVBQU0sVUFBVSxLQUFLLE1BQU0sV0FBVztBQUN0QyxRQUFJLFNBQVM7QUFDVCxjQUFRLFFBQVEsT0FBTUEsWUFBVTtBQUM1QixjQUFNLFFBQVFBLFFBQU8sU0FBUztBQUM5QixjQUFNLGlCQUFpQixNQUFNLEtBQUssTUFBTyx3QkFBd0IsS0FBSztBQUN0RSxjQUFNLE1BQU0sS0FBSyxlQUFlLEtBQUssS0FBSyxDQUFDO0FBTzNDLFlBQ0ksa0JBQ0EsT0FBTyxlQUFlLG1CQUFtQixjQUN6QyxJQUFJLFNBQVMsV0FDZjtBQUNFLHlCQUFlLGlCQUFpQixNQUFNO0FBQUEsUUFDMUM7QUFBQSxNQUNKLENBQUM7QUFBQSxJQUNMO0FBQUEsRUFDSjtBQUFBO0FBQUEsRUFHQSxXQUFXO0FBQ1AsUUFBSUssYUFBWSxLQUFLLFNBQVMsRUFBRSxHQUFHO0FBQy9CLFdBQUssU0FBUyxHQUFHLFNBQVMsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQUEsSUFDN0M7QUFBQSxFQUNKO0FBQ0o7QUFFQSxJQUFNLGlCQUFpQixDQUFDLFlBQXNEO0FBQzFFLE1BQUksY0FBYztBQUNsQixRQUFNLHdCQUF3QixNQUFNO0FBQ2hDLFdBQU8sT0FBTyxhQUFhO0FBQUEsRUFDL0I7QUFFQSxTQUFPLFFBQVEsSUFBSSxTQUFPO0FBQ3RCLFFBQUksT0FBTyxRQUFRLFVBQVU7QUFFekIsYUFBTztBQUFBLFFBQ0gsYUFBYTtBQUFBLFFBQ2IsV0FBVztBQUFBLFFBQ1gsUUFBUTtBQUFBLFFBQ1IsTUFBTTtBQUFBLE1BQ1Y7QUFBQSxJQUNKLFdBQVcsT0FBTyxRQUFRLFlBQVksUUFBUSxNQUFNO0FBR2hELFVBQUksT0FBTyxJQUFJLFdBQVcsVUFBVTtBQUNoQyxlQUFPO0FBQUEsVUFDSCxHQUFHO0FBQUEsVUFDSCxhQUFhLElBQUk7QUFBQSxVQUNqQixXQUFXLElBQUk7QUFBQSxVQUNmLE1BQU07QUFBQSxRQUNWO0FBQUEsTUFDSixXQUFXLE9BQU8sSUFBSSxXQUFXLFVBQVU7QUFJdkMsZUFBTztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsYUFBYSxzQkFBc0I7QUFBQSxVQUNuQyxRQUFRLElBQUk7QUFBQSxVQUNaLE1BQU07QUFBQSxRQUNWO0FBQUEsTUFDSixXQUFXLE9BQU8sSUFBSSxXQUFXLFdBQVc7QUFJeEMsZUFBTztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsYUFBYSxzQkFBc0I7QUFBQSxVQUNuQyxRQUFRLElBQUk7QUFBQSxVQUNaLE1BQU07QUFBQSxRQUNWO0FBQUEsTUFDSixXQUFXLE1BQU0sUUFBUSxJQUFJLE1BQU0sR0FBRztBQUVsQyxZQUFJLElBQUksT0FBTyxXQUFXLEdBQUc7QUFDekIsZ0JBQU0sSUFBSSxNQUFNLHFDQUFxQztBQUFBLFFBQ3pEO0FBQ0EsZUFBTztBQUFBLFVBQ0gsR0FBRztBQUFBLFVBQ0gsYUFBYSxzQkFBc0I7QUFBQSxVQUNuQyxRQUFRLElBQUk7QUFBQSxVQUNaLE1BQU07QUFBQSxRQUNWO0FBQUEsTUFDSixXQUFXLE9BQU8sSUFBSSxXQUFXLFVBQVU7QUFDdkMsY0FBTSxNQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sRUFBRSxDQUFDO0FBQ3JDLGNBQU0sZUFBZSxJQUFJLE9BQU8sR0FBRztBQUNuQyxlQUFPO0FBQUEsVUFDSCxHQUFHO0FBQUEsVUFDSCxhQUFhLEdBQUcsR0FBRyxJQUFJLFlBQVk7QUFBQSxVQUNuQyxXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixlQUFlLENBQUMsWUFBWTtBQUFBLFVBQzVCLE1BQU07QUFBQSxRQUNWO0FBQUEsTUFDSixPQUFPO0FBQ0gsY0FBTSxJQUFJLE1BQU0sOEJBQThCLE9BQU8sSUFBSSxNQUFNO0FBQUEsTUFDbkU7QUFBQSxJQUNKLE9BQU87QUFDSCxZQUFNLElBQUksTUFBTSw4QkFBOEIsR0FBRyxFQUFFO0FBQUEsSUFDdkQ7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUVBLElBQU0sZ0JBQWdCLENBQUMsVUFBMEU7QUFDN0YsTUFBSSxDQUFDLE9BQU87QUFDUixXQUFPO0FBQUEsRUFDWDtBQUNBLFNBQU8sQ0FBQyxVQUFVLEtBQUssRUFBRTtBQUM3QjtBQUVBLElBQU0sc0JBQXNCLENBQUMsWUFBcUU7QUFDOUYsTUFBSSxRQUFRLFdBQVcsU0FBUztBQUM1QixXQUFPO0FBQUEsRUFDWDtBQUVBLFFBQU0sYUFBYSxRQUFRLFVBQVU7QUFDckMsTUFBSSxXQUFXLFdBQVcsU0FBUyxHQUFHO0FBQ2xDLFdBQU87QUFBQSxNQUNILE1BQU07QUFBQSxNQUNOLFlBQVksUUFBUSxXQUFXO0FBQUEsTUFDL0Isc0JBQXNCLFFBQVEsV0FBVztBQUFBLElBQzdDO0FBQUEsRUFDSixXQUFXLFdBQVcsV0FBVyxXQUFXLEdBQUc7QUFDM0MsV0FBTztBQUFBLE1BQ0gsTUFBTTtBQUFBLE1BQ04sV0FBVztBQUFBLE1BQ1gsWUFBWSxRQUFRLFdBQVc7QUFBQSxJQUNuQztBQUFBLEVBQ0osT0FBTztBQUNILFVBQU0sSUFBSSxNQUFNLDRCQUE0QixRQUFRLE1BQU07QUFBQSxFQUM5RDtBQUNKO0FBRUEsSUFBTSxzQkFBc0IsQ0FBQyxTQUF5QjtBQUVsRCxVQUFRLE1BQU07QUFBQSxJQUNWLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYO0FBQ0ksYUFBTztBQUFBLEVBQ2Y7QUFDSjtBQUVBLElBQU0sbUJBQW1CLENBQUMsTUFBYyxjQUF1QjtBQUMzRCxVQUFRLE1BQU07QUFBQSxJQUNWLEtBQUs7QUFDRCxhQUFnQixnQkFBTyxhQUFhLEdBQUc7QUFBQSxJQUMzQyxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQ0QsYUFBZ0IsZ0JBQU8sYUFBYSxPQUFPO0FBQUEsSUFDL0MsS0FBSztBQUNELGFBQWdCLGdCQUFPLGFBQWEsT0FBTztBQUFBLElBQy9DLEtBQUs7QUFFRCxhQUFvQix3QkFBVyxhQUFhLFVBQVU7QUFBQSxJQUMxRCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBRUQsYUFBb0Isd0JBQVcsYUFBYSxtQkFBbUI7QUFBQSxJQUNuRSxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTDtBQUNJLGFBQU87QUFBQSxFQUNmO0FBQ0o7QUFXQSxJQUFNLG1CQUFtQixDQUNyQixPQUNBLFFBQ0EsVUFDdUI7QUFDdkIsTUFBSSxzQkFBc0IsTUFBTSxHQUFHO0FBQy9CLFVBQU0sV0FBVyxPQUFPLGFBQWEsUUFBUSxNQUFNO0FBQ25ELFVBQU0sY0FBYyxPQUFPLFlBQ3JCLElBQUksQ0FBQyxNQUFXO0FBQ2QsYUFBTyxpQkFBaUIsT0FBTyxHQUFzQixLQUFLO0FBQUEsSUFDOUQsQ0FBQyxFQUNBLE9BQU8sT0FBSyxNQUFNLE1BQVM7QUFDaEMsUUFBSSxlQUFlLFlBQVksU0FBUyxHQUFHO0FBQ3ZDLGFBQU8sU0FBUyxHQUFHLFdBQVc7QUFBQSxJQUNsQztBQUFBLEVBQ0osV0FBVyxhQUFhLE1BQU0sR0FBRztBQUM3QixXQUFPLGlCQUFpQixPQUFPLE9BQU8sTUFBTSxPQUFPLFFBQVEsUUFBVyxJQUFJO0FBQUEsRUFDOUUsV0FBVyxlQUFlLE1BQU0sR0FBRztBQUMvQixXQUFPLGlCQUFpQixPQUFPLE9BQU8sTUFBTSxPQUFPLE1BQU07QUFBQSxFQUM3RCxXQUFXLGNBQWMsTUFBTSxHQUFHO0FBQzlCLFVBQU0sT0FBTyxPQUFPLGNBQ2QsSUFBSSxDQUFDLE1BQVc7QUFDZCxhQUFPLGlCQUFpQixPQUFPLEdBQUcsS0FBSztBQUFBLElBQzNDLENBQUMsRUFDQSxPQUFPLE9BQUssTUFBTSxNQUFTO0FBQ2hDLFFBQUksUUFBUSxLQUFLLFNBQVMsR0FBRztBQUN6QixhQUFPLElBQUksR0FBRyxJQUFJO0FBQUEsSUFDdEI7QUFBQSxFQUNKLFdBQVcsYUFBYSxNQUFNLEdBQUc7QUFDN0IsV0FBTyxpQkFBaUIsT0FBTyxPQUFPLE1BQU0sT0FBTyxVQUFVLE9BQU8sVUFBVSxNQUFTO0FBQUEsRUFDM0YsV0FBVyxZQUFZLE1BQU0sR0FBRztBQUM1QixZQUFRLEtBQUssNEJBQTRCO0FBQUEsRUFDN0M7QUFDSjtBQUVPLElBQU0sbUJBQW1CLENBQzVCLE9BQ0EsTUFpQkEsUUFDQSxXQUErQyxRQUMvQyxhQUFzQixVQUNDO0FBQ3ZCLFVBQVEsTUFBTTtBQUFBLElBQ1YsS0FBSztBQUNELGFBQU8sR0FBRyxPQUFPLFFBQVEsTUFBTSxDQUFDO0FBQUEsSUFDcEMsS0FBSztBQUNELGFBQU8sSUFBSSxPQUFPLFFBQVEsTUFBTSxDQUFDO0FBQUEsSUFDckMsS0FBSztBQUNELFVBQUksWUFBWTtBQUNaLGVBQU8sTUFBTSxPQUFPLEtBQUssQ0FBQyxVQUFVLFFBQVEsTUFBTSxTQUFTLEdBQUcsQ0FBQztBQUFBLE1BQ25FLE9BQU87QUFDSCxlQUFPLFNBQVMsT0FBTyxPQUFPLE1BQU0sQ0FBQztBQUFBLE1BQ3pDO0FBQUEsSUFDSixLQUFLO0FBQ0QsYUFBTyxJQUFJLFNBQVMsT0FBTyxPQUFPLE1BQU0sQ0FBQyxDQUFDO0FBQUEsSUFDOUMsS0FBSztBQUNELGFBQU8sT0FBTyxLQUFLO0FBQUEsSUFDdkIsS0FBSztBQUNELGFBQU8sSUFBSSxPQUFPLEtBQUssQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLE9BQU8sT0FBTyxPQUFPLE1BQU0sQ0FBQztBQUFBLElBQ3ZDLEtBQUs7QUFDRCxhQUFPLE9BQU8sT0FBTyxPQUFPLE1BQU0sQ0FBQztBQUFBLElBQ3ZDLEtBQUs7QUFDRCxhQUFPLEdBQUcsT0FBTyxRQUFRLE1BQU0sQ0FBQztBQUFBLElBQ3BDLEtBQUs7QUFDRCxhQUFPLEdBQUcsT0FBTyxRQUFRLE1BQU0sQ0FBQztBQUFBLElBQ3BDLEtBQUs7QUFDRCxhQUFPLElBQUksT0FBTyxRQUFRLE1BQU0sQ0FBQztBQUFBLElBQ3JDLEtBQUs7QUFDRCxhQUFPLElBQUksT0FBTyxRQUFRLE1BQU0sQ0FBQztBQUFBLElBQ3JDLEtBQUs7QUFDRCxVQUFJLGFBQWEsVUFBYSxhQUFhLE1BQU07QUFDN0MsZUFBUSxJQUFJLE9BQU8sUUFBUSxNQUFNLENBQUMsR0FBRyxJQUFJLE9BQU8sUUFBUSxRQUFRLENBQUM7QUFBQSxNQUNyRTtBQUNBO0FBQUEsSUFDSjtBQUNJLGNBQVEsS0FBSyw0QkFBNEIsSUFBSSxFQUFFO0FBQUEsRUFDdkQ7QUFDQSxTQUFPO0FBQ1g7QUFFQSxJQUFNLHNCQUFzQixDQUN4QixNQUM0QztBQUM1QyxRQUFNLFVBQVUsRUFBRTtBQUVsQixRQUFNLFdBQVcsTUFBTTtBQUNuQixRQUFJLEVBQUUsY0FBYyxTQUFTLEdBQUc7QUFDNUIsYUFBTyxFQUFFLGNBQWMsQ0FBQztBQUFBLElBQzVCO0FBQ0EsVUFBTSxJQUFJLE1BQU0sd0JBQXdCLE9BQU8saUNBQWlDO0FBQUEsRUFDcEY7QUFFQSxRQUFNLFlBQVksTUFBTTtBQUNwQixRQUFJLEVBQUUsY0FBYyxTQUFTLEdBQUc7QUFDNUIsYUFBTyxFQUFFLGNBQWMsQ0FBQztBQUFBLElBQzVCO0FBQ0EsVUFBTSxJQUFJLE1BQU0sd0JBQXdCLE9BQU8sa0NBQWtDO0FBQUEsRUFDckY7QUFFQSxRQUFNLElBQUksQ0FBQyxRQUFrRTtBQUN6RSxXQUFPLENBQUMsRUFBRSxhQUFhLEdBQUc7QUFBQSxFQUM5QjtBQUVBLFVBQVEsU0FBUztBQUFBLElBQ2IsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxJQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FB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LFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_7eeb2461dc6547fda8bd0de2447b823d","spec":"","tabbable":null,"tables":{},"tooltip":null}},"e407c250827b4a9abf7eca85d9c2002a":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"e521bacc6e68409b95dbd05bbb920d7c":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"f25468f5fbf14170be28516b9c6eaa53":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    const label = options.label || options.column;\n    let labelEl = null;\n    if (label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.multiple_ || !this.allowEmpty_) {\n      this.setData(this.queryResultOptions(data));\n      return this;\n    } else {\n      return super.queryResult(data);\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label || options.column);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    this.setData(this.queryResultOptions(data));\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label || options_.column;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: !filterable ? false : filterForColumnType(type),\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return \"agNumberColumnFilter\";\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return \"agDateColumnFilter\";\n    case \"boolean\":\n      return \"agTextColumnFilter\";\n    default:\n      return \"agTextColumnFilter\";\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nfunction hideTooltip() {\n  tooltipInstance.hide();\n  window.removeEventListener(\"scroll\", hideTooltip);\n}\nfunction showTooltip() {\n  tooltipInstance.show();\n  window.addEventListener(\"scroll\", hideTooltip, { once: true });\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  if (!tooltipInstance) {\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\"\n    });\n  }\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        if (tipElements.length === 1) {\n          const tipContainerEl = tipElements[0];\n          tipContainerEl.style.display = \"none\";\n          const tipEl = tipContainerEl.firstChild;\n          if (!tipEl) {\n            hideTooltip();\n          } else {\n            const parsed = parseSVGTooltip(tipEl);\n            const svgPoint = svgEl.createSVGPoint();\n            svgPoint.x = parsed.transform?.x || 0;\n            svgPoint.y = parsed.transform?.y || 0;\n            const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n            const centerX = screenPoint.x;\n            const centerY = screenPoint.y;\n            tooltipInstance.setProps({\n              placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n              getReferenceClientRect: () => {\n                return {\n                  width: 0,\n                  height: 0,\n                  top: centerY,\n                  bottom: centerY,\n                  left: centerX,\n                  right: centerX,\n                  x: centerX,\n                  y: centerY,\n                  toJSON: () => {\n                  }\n                };\n              },\n              arrow: parsed.placement !== \"middle\",\n              offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n              popperOptions: (\n                // Special handling for middle placement, which isn't a supported\n                // tippy placement\n                parsed.placement === \"middle\" ? {\n                  modifiers: [\n                    {\n                      name: \"preventOverflow\",\n                      enabled: false\n                    },\n                    {\n                      name: \"flip\",\n                      enabled: false\n                    },\n                    {\n                      name: \"customMiddle\",\n                      enabled: true,\n                      phase: \"main\",\n                      fn: ({ state }) => {\n                        state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                        state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                      }\n                    }\n                  ]\n                } : void 0\n              )\n            });\n            const contentEl = document.createElement(\"div\");\n            contentEl.classList.add(\"inspect-tip-container\");\n            let count2 = 0;\n            for (const row of parsed.values) {\n              const rowEl = document.createElement(\"div\");\n              rowEl.className = \"inspect-tip-row\";\n              contentEl.appendChild(rowEl);\n              const keyEl = document.createElement(\"div\");\n              keyEl.className = \"inspect-tip-key\";\n              keyEl.append(document.createTextNode(row.key));\n              const valueEl = document.createElement(\"div\");\n              valueEl.className = \"inspect-tip-value\";\n              valueEl.append(document.createTextNode(row.value));\n              if (row.color) {\n                const colorEl = document.createElement(\"span\");\n                colorEl.className = \"inspect-tip-color\";\n                colorEl.style.backgroundColor = row.color;\n                valueEl.append(colorEl);\n              }\n              rowEl.appendChild(keyEl);\n              rowEl.appendChild(valueEl);\n              count2++;\n            }\n            tooltipInstance.setContent(contentEl);\n            showTooltip();\n          }\n        } else {\n          throw new Error(\n            `Expected exactly one tip element, found ${tipElements.length}`\n          );\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseSVGTooltip = (tipEl) => {\n  const result = { values: [] };\n  const transformVal = tipEl.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      result.transform = { x, y };\n    }\n  }\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      result.values.push({ key, value, color });\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n  }\n  return result;\n};\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle2(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? kLegendWidth : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? kLegendHeight : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vanMvd2lkZ2V0cy9tb3NhaWMudHMiLCAiLi4vLi4vLi4vanMvY29udGV4dC9pbmRleC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hvaWNlLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvb2JqZWN0LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9pbnB1dC50cyIsICIuLi8uLi8uLi9qcy91dGlsL2lkLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy91dGlsLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9yYWRpb19ncm91cC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvdHlwZXMudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3NlbGVjdC50cyIsICIuLi8uLi8uLi9qcy9pbnB1dHMvY2hlY2tib3hfZ3JvdXAudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2NoZWNrYm94LnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zbGlkZXIudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL3RhYmxlLnRzIiwgIi4uLy4uLy4uL2pzL2lucHV0cy9zZWFyY2gudHMiLCAiLi4vLi4vLi4vanMvaW5wdXRzL2luZGV4LnRzIiwgIi4uLy4uLy4uL2pzL2NvbnRleHQvZHVja2RiLnRzIiwgIi4uLy4uLy4uL2pzL3V0aWwvYXN5bmMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9lcnJvcnMudHMiLCAiLi4vLi4vLi4vanMvdXRpbC9wbGF0Zm9ybS50cyIsICIuLi8uLi8uLi9qcy9wbG90L3Rvb2x0aXBzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgdHlwZSB7IFJlbmRlclByb3BzIH0gZnJvbSAnQGFueXdpZGdldC90eXBlcyc7XG5cbmltcG9ydCB7XG4gICAgU3BlYyxcbiAgICBTcGVjTm9kZSxcbiAgICBwYXJzZVNwZWMsXG4gICAgSW5zdGFudGlhdGVDb250ZXh0LFxuICAgIEFTVE5vZGUsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3BlY0AwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGVycm9ySW5mbywgZXJyb3JBc0hUTUwsIGRpc3BsYXlSZW5kZXJFcnJvciB9IGZyb20gJy4uL3V0aWwvZXJyb3JzJztcbmltcG9ydCB7IGlzTm90ZWJvb2sgfSBmcm9tICcuLi91dGlsL3BsYXRmb3JtJztcbmltcG9ydCB7IFRhYmxlT3B0aW9ucyB9IGZyb20gJy4uL2lucHV0cy90YWJsZSc7XG5pbXBvcnQgeyByZXBsYWNlVG9vbHRpcEltcGwgYXMgaW5zdGFsbFBsb3RUb29sdGlwcyB9IGZyb20gJy4uL3Bsb3QvdG9vbHRpcHMnO1xuXG5pbnRlcmZhY2UgTW9zYWljUHJvcHMge1xuICAgIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICBzcGVjOiBzdHJpbmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7IG1vZGVsLCBlbCB9OiBSZW5kZXJQcm9wczxNb3NhaWNQcm9wcz4pIHtcbiAgICAvLyBnZXQgdGhlIHNwZWMgYW5kIHBhcnNlIGl0IGZvciBwbG90IGRlZmF1bHRzXG4gICAgY29uc3Qgc3BlYzogU3BlYyA9IEpTT04ucGFyc2UobW9kZWwuZ2V0KCdzcGVjJykpO1xuICAgIGNvbnN0IHBsb3REZWZhdWx0c1NwZWMgPSB7IHBsb3REZWZhdWx0czogc3BlYy5wbG90RGVmYXVsdHMsIHZzcGFjZTogMCB9IGFzIFNwZWM7XG4gICAgY29uc3QgcGxvdERlZmF1bHRzQXN0ID0gcGFyc2VTcGVjKHBsb3REZWZhdWx0c1NwZWMpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjb250ZXh0XG4gICAgY29uc3QgY3R4ID0gYXdhaXQgdml6Q29udGV4dChwbG90RGVmYXVsdHNBc3QucGxvdERlZmF1bHRzKTtcblxuICAgIC8vIGluc2VydC93YWl0IGZvciB0YWJsZXMgdG8gYmUgcmVhZHlcbiAgICBjb25zdCB0YWJsZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBtb2RlbC5nZXQoJ3RhYmxlcycpIHx8IHt9O1xuICAgIGF3YWl0IHN5bmNUYWJsZXMoY3R4LCB0YWJsZXMpO1xuXG4gICAgLy8gcmVuZGVyIG1vc2FpYyBzcGVjXG4gICAgZWwuY2xhc3NMaXN0LmFkZCgnbW9zYWljLXdpZGdldCcpO1xuICAgIGNvbnN0IHJlbmRlck9wdGlvbnMgPSByZW5kZXJTZXR1cChlbCk7XG4gICAgY29uc3QgaW5wdXRzID0gbmV3IFNldChPYmplY3Qua2V5cyhJTlBVVFMpKTtcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbFNjcm9sbGluZyAmJiBpc1Bsb3RTcGVjKHNwZWMpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnNDAwcHgnO1xuICAgIH1cbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiBpc1RhYmxlU3BlYyhzcGVjKSkge1xuICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0by1maWxsaW5nIGEgdGFibGUgc3BlYywgdGhlbiByZW1vdmUgYW55IHBhZGRpbmcgZnJvbSB0aGUgY2FyZCBib2R5XG4gICAgICAgIC8vIGFzIHRoZSB0YWJsZSB3aWxsIGZpbGwgdGhlIGVudGlyZSBzcGFjZSAodGhpcyBpcyBiYXNpY2FsbHkgaW4gYSBxdWFydG8gZGFzaGJvYXJkIGNhcmQpXG4gICAgICAgIGNvbnN0IGNhcmQgPSBlbC5jbG9zZXN0KCcuY2FyZC1ib2R5JykgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBpZiAoY2FyZCkge1xuICAgICAgICAgICAgY2FyZC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlclNwZWMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjdHguY2xlYXJVbmhhbmRsZWRFcnJvcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNwZWMgPSByZW5kZXJPcHRpb25zLmF1dG9GaWxsID8gcmVzcG9uc2l2ZVNwZWMoc3BlYywgZWwpIDogc3BlYztcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHBhcnNlU3BlYyh0YXJnZXRTcGVjLCB7IGlucHV0cyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNFbCA9IChhd2FpdCBhc3RUb0RPTShhc3QsIGN0eCkpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChzcGVjRWwpO1xuXG4gICAgICAgICAgICAvLyBGb3IgcGxvdHMsIHJlcGxhY2UgdGhlIHRvb2x0aXAgaW1wbGVtZW50YXRpb24gd2l0aFxuICAgICAgICAgICAgLy8gb3VyIG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgaW5zdGFsbFBsb3RUb29sdGlwcyhzcGVjRWwpO1xuXG4gICAgICAgICAgICBhd2FpdCBkaXNwbGF5VW5oYW5kbGVkRXJyb3JzKGN0eCwgZWwpO1xuICAgICAgICB9IGNhdGNoIChlOiB1bmtub3duKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvckluZm8oZSk7XG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHJlbmRlclNwZWMoKTtcblxuICAgIC8vIGlmIHdlIGFyZSBkb2luZyBhdXRvLWZpbGwgdGhlbiByZS1yZW5kZXIgd2hlbiBzaXplIGNoYW5nZXNcbiAgICBpZiAocmVuZGVyT3B0aW9ucy5hdXRvRmlsbCAmJiAhaXNJbnB1dFNwZWMoc3BlYykpIHtcbiAgICAgICAgbGV0IGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgbGFzdENvbnRhaW5lckhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAvLyByZS1yZW5kZXIgb24gY29udGFpbmVyIHNpemUgY2hhbmdlZFxuICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihcbiAgICAgICAgICAgIHRocm90dGxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCAhPT0gZWwuY2xpZW50V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgbGFzdENvbnRhaW5lckhlaWdodCAhPT0gZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb250YWluZXJXaWR0aCA9IGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29udGFpbmVySGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTcGVjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgLy8gY2xlYW51cCByZXNpemUgb2JzZXJ2ZXIgb24gZGlzY29ubmVjdFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gaW5zZXJ0L3dhaXQgZm9yIHRhYmxlcyB0byBiZSByZWFkeVxuYXN5bmMgZnVuY3Rpb24gc3luY1RhYmxlcyhjdHg6IFZpekNvbnRleHQsIHRhYmxlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgW3RhYmxlTmFtZSwgYmFzZTY0RGF0YV0gb2YgT2JqZWN0LmVudHJpZXModGFibGVzKSkge1xuICAgICAgICBpZiAoYmFzZTY0RGF0YSkge1xuICAgICAgICAgICAgLy8gZGVjb2RlIGJhc2U2NCB0byBieXRlc1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGNvbnRleHRcbiAgICAgICAgICAgIGF3YWl0IGN0eC5pbnNlcnRUYWJsZSh0YWJsZU5hbWUsIGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRhYmxlIGlmIG5vIGRhdGEgcHJvdmlkZWRcbiAgICAgICAgICAgIGF3YWl0IGN0eC53YWl0Rm9yVGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIFJlbmRlck9wdGlvbnMge1xuICAgIGF1dG9GaWxsOiBib29sZWFuO1xuICAgIGF1dG9GaWxsU2Nyb2xsaW5nOiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiByZW5kZXJTZXR1cChjb250YWluZXJFbDogSFRNTEVsZW1lbnQpOiBSZW5kZXJPcHRpb25zIHtcbiAgICAvLyBtb3NhaWMgd2lkZ2V0cyBhbHJlYWR5IGhhdmUgc3VmZmljaWVudCBtYXJnaW4vcGFkZGluZyBzbyBvdmVycmlkZVxuICAgIC8vIGFueSBob3N0IHByZXNjcmliZWQgYm90dG9tIG1hcmdpbi5cbiAgICBjb25zdCB3aWRnZXRFbCA9IGNvbnRhaW5lckVsLmNsb3Nlc3QoJy53aWRnZXQtc3ViYXJlYScpIGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGlmICh3aWRnZXRFbCkge1xuICAgICAgICB3aWRnZXRFbC5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnMCc7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0IHdoZXRoZXIgd2Ugc2hvdWxkIGJlIGF1dG8tZmlsbGluZyBvdXIgY29udGFpbmVyXG4gICAgY29uc3QgYXV0b0ZpbGwgPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ3F1YXJ0by1kYXNoYm9hcmQnKTtcblxuICAgIC8vIGRldGVjdCB3aGV0aGVyIHdlIGFyZSBpbiBhIHNjcm9sbGluZyBsYXlvdXQgdy8gYXV0by1maWxsIChzbyB3ZSBuZWVkIHRvIHByb3ZpZGUgZWxlbWVudCBoZWlnaHRzKVxuICAgIGNvbnN0IGF1dG9GaWxsU2Nyb2xsaW5nID1cbiAgICAgICAgYXV0b0ZpbGwgJiYgIXdpbmRvdy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZGFzaGJvYXJkLWZpbGwnKTtcblxuICAgIHJldHVybiB7IGF1dG9GaWxsLCBhdXRvRmlsbFNjcm9sbGluZyB9O1xufVxuXG4vLyBpZiB0aGlzIGlzIGEgc2luZ2xlIHBsb3QgKHcvIG9wdGlvbmFsIGxlZ2VuZCkgaW4gYW4gaGNvbmNhdCBvciB2Y29uY2F0LFxuLy8gdGhlbiBnaXZlIGl0IGR5bmFtaWMgc2l6aW5nIChtb3JlIGNvbXBsZXggbGF5b3V0cyBkb24ndCBnZXQgYXV0by1zaXplZClcbmZ1bmN0aW9uIHJlc3BvbnNpdmVTcGVjKHNwZWM6IFNwZWMsIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCk6IFNwZWMge1xuICAgIGNvbnN0IGtMZWdlbmRXaWR0aCA9IDgwOyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG4gICAgY29uc3Qga0xlZ2VuZEhlaWdodCA9IDM1OyAvLyBiZXN0IGd1ZXNzIGVzdGltYXRlXG5cbiAgICBzcGVjID0gc3RydWN0dXJlZENsb25lKHNwZWMpO1xuICAgIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHNwZWM7XG4gICAgICAgIC8vIGRpc2FibGUgbWF4LXdpZHRoIGZvciB0YWJsZSBpbnB1dHNcbiAgICAgICAgKHRhYmxlIGFzIHVua25vd24gYXMgVGFibGVPcHRpb25zKS5hdXRvX2ZpbGxpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJ2hjb25jYXQnIGluIHNwZWMgJiYgc3BlYy5oY29uY2F0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgcGxvdFxuICAgICAgICBjb25zdCBoY29uY2F0ID0gc3BlYy5oY29uY2F0O1xuICAgICAgICBjb25zdCBwbG90ID0gJ3Bsb3QnIGluIGhjb25jYXRbMF0gPyBoY29uY2F0WzBdIDogbnVsbDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChoY29uY2F0Lmxlbmd0aCA+IDEgPyBrTGVnZW5kV2lkdGggOiAwKTtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICgnaGNvbmNhdCcgaW4gc3BlYyAmJiBzcGVjLmhjb25jYXQubGVuZ3RoID09IDIpIHtcbiAgICAgICAgLy8gcGxvdCB3aXRoIGhvcml6b250YWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IGhjb25jYXQgPSBzcGVjLmhjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIGhjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIGhjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gaGNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyBoY29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aCAtIChzcGVjLmhjb25jYXQubGVuZ3RoID4gMSA/IGtMZWdlbmRXaWR0aCA6IDApO1xuICAgICAgICAgICAgcGxvdC5oZWlnaHQgPSBjb250YWluZXJFbC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCd2Y29uY2F0JyBpbiBzcGVjICYmIHNwZWMudmNvbmNhdC5sZW5ndGggPT0gMikge1xuICAgICAgICAvLyBwbG90IHdpdGggdmVydGljYWwgbGVnZW5kXG4gICAgICAgIGNvbnN0IHZjb25jYXQgPSBzcGVjLnZjb25jYXQ7XG4gICAgICAgIGNvbnN0IHBsb3QgPVxuICAgICAgICAgICAgJ3Bsb3QnIGluIHZjb25jYXRbMF0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFsxXVxuICAgICAgICAgICAgICAgID8gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgIDogJ3Bsb3QnIGluIHZjb25jYXRbMV0gJiYgJ2xlZ2VuZCcgaW4gdmNvbmNhdFswXVxuICAgICAgICAgICAgICAgICAgPyB2Y29uY2F0WzFdXG4gICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHBsb3QpIHtcbiAgICAgICAgICAgIHBsb3Qud2lkdGggPSBjb250YWluZXJFbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHBsb3QuaGVpZ2h0ID0gY29udGFpbmVyRWwuY2xpZW50SGVpZ2h0IC0gKHNwZWMudmNvbmNhdC5sZW5ndGggPiAxID8ga0xlZ2VuZEhlaWdodCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBpc1Bsb3RTcGVjKHNwZWM6IFNwZWMpIHtcbiAgICBpZiAoJ3Bsb3QnIGluIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICAnaGNvbmNhdCcgaW4gc3BlYyAmJlxuICAgICAgICBzcGVjLmhjb25jYXQubGVuZ3RoID09PSAyICYmXG4gICAgICAgICgncGxvdCcgaW4gc3BlYy5oY29uY2F0WzBdIHx8ICdwbG90JyBpbiBzcGVjLmhjb25jYXRbMV0pXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICd2Y29uY2F0JyBpbiBzcGVjICYmXG4gICAgICAgIHNwZWMudmNvbmNhdC5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgKCdwbG90JyBpbiBzcGVjLnZjb25jYXRbMF0gfHwgJ3Bsb3QnIGluIHNwZWMudmNvbmNhdFsxXSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNJbnB1dFNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCAhPT0gJ3RhYmxlJztcbn1cblxuZnVuY3Rpb24gaXNUYWJsZVNwZWMoc3BlYzogU3BlYykge1xuICAgIHJldHVybiAnaW5wdXQnIGluIHNwZWMgJiYgc3BlYy5pbnB1dCA9PT0gJ3RhYmxlJztcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXN0VG9ET00oYXN0OiBTcGVjTm9kZSwgY3R4OiBJbnN0YW50aWF0ZUNvbnRleHQpIHtcbiAgICAvLyBwcm9jZXNzIHBhcmFtL3NlbGVjdGlvbiBkZWZpbml0aW9uc1xuICAgIGZvciAoY29uc3QgW25hbWUsIG5vZGVdIG9mIE9iamVjdC5lbnRyaWVzKGFzdC5wYXJhbXMpKSB7XG4gICAgICAgIC8vIGRlZmluZSB0aGUgcGFyYW1ldGVyIGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgd2UgYXJlIGluIGEgbm90ZWJvb2tcbiAgICAgICAgLy8gKGFzIGluIGEgbm90ZWJvb2sgd2UgYXJlIGxvc2luZyB0aGUgcHJpb3IgY2VsbCBzbyB3ZSB3YW50IHRvIHJlc2V0IHRoZSBzZWxlY3Rpb24pXG4gICAgICAgIGlmICghY3R4LmFjdGl2ZVBhcmFtcy5oYXMobmFtZSkgfHwgaXNOb3RlYm9vaygpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IChub2RlIGFzIEFTVE5vZGUpLmluc3RhbnRpYXRlKGN0eCk7XG4gICAgICAgICAgICBjdHguYWN0aXZlUGFyYW1zLnNldChuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGVsZW1lbnRcbiAgICByZXR1cm4gYXN0LnJvb3QuaW5zdGFudGlhdGUoY3R4KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZGlzcGxheVVuaGFuZGxlZEVycm9ycyhjdHg6IFZpekNvbnRleHQsIHdpZGdldEVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vIGVtcHR5IHBsb3QgZGl2cyBpbmRpY2F0ZSBhIHBvc3NpYmxlIHVuaGFuZGxlZCBlcnJvciwgbG9vayBmb3IgdGhlc2VcbiAgICAvLyBhbmQgdGhlbiBhdHRlbXB0IHRvIGNvbGxlY3QgYW5kIGRpc3BsYXkgdW5oYW5kbGVkIGVycm9yc1xuICAgIGNvbnN0IGVtcHR5UGxvdERpdnMgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yQWxsKCdkaXYucGxvdDplbXB0eScpO1xuICAgIGZvciAoY29uc3QgZW1wdHlEaXYgb2YgZW1wdHlQbG90RGl2cykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IGN0eC5jb2xsZWN0VW5oYW5kbGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3IsIGVtcHR5RGl2IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyByZW5kZXIgfTtcbiIsICJpbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuXG5pbXBvcnQgeyB3YXNtQ29ubmVjdG9yIH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSW5zdGFudGlhdGVDb250ZXh0IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1zcGVjQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHsgSU5QVVRTIH0gZnJvbSAnLi4vaW5wdXRzJztcbmltcG9ydCB7IGluaXREdWNrZGIsIHdhaXRGb3JUYWJsZSB9IGZyb20gJy4vZHVja2RiJztcbmltcG9ydCB7IEVycm9ySW5mbywgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcgfSBmcm9tICcuLi91dGlsL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzbGVlcCB9IGZyb20gJy4uL3V0aWwvYXN5bmMuanMnO1xuXG5jbGFzcyBWaXpDb250ZXh0IGV4dGVuZHMgSW5zdGFudGlhdGVDb250ZXh0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhYmxlc18gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBwcml2YXRlIHVuaGFuZGxlZEVycm9yc186IEVycm9ySW5mb1tdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBjb25uXzogQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgICAgICBwbG90RGVmYXVsdHM6IGFueVtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHsgcGxvdERlZmF1bHRzIH0pO1xuICAgICAgICB0aGlzLmFwaSA9IHsgLi4udGhpcy5hcGksIC4uLklOUFVUUyB9O1xuICAgICAgICB0aGlzLmNvb3JkaW5hdG9yLmRhdGFiYXNlQ29ubmVjdG9yKHdhc21Db25uZWN0b3IoeyBjb25uZWN0aW9uOiB0aGlzLmNvbm5fIH0pKTtcbiAgICB9XG5cbiAgICBhc3luYyBpbnNlcnRUYWJsZSh0YWJsZTogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIGp1c3Qgd2FpdCBmb3IgaXQgaWYgd2UgYWxyZWFkeSBoYXZlIGl0XG4gICAgICAgIGlmICh0aGlzLnRhYmxlc18uaGFzKHRhYmxlKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yVGFibGUodGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgdGFibGVzXG4gICAgICAgIHRoaXMudGFibGVzXy5hZGQodGFibGUpO1xuXG4gICAgICAgIC8vIGluc2VydCB0YWJsZSBpbnRvIGRhdGFiYXNlXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubl8/Lmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShkYXRhLCB7XG4gICAgICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgICAgIGNyZWF0ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgd2FpdEZvclRhYmxlKHRhYmxlOiBzdHJpbmcpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclRhYmxlKHRoaXMuY29ubl8sIHRhYmxlKTtcbiAgICB9XG5cbiAgICByZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvcjogRXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5wdXNoKGVycm9yKTtcbiAgICB9XG5cbiAgICBhc3luYyBjb2xsZWN0VW5oYW5kbGVkRXJyb3Iod2FpdDogbnVtYmVyID0gMTAwMCk6IFByb21pc2U8RXJyb3JJbmZvIHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRXJyb3JzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5oYW5kbGVkRXJyb3JzXy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNsZWFyVW5oYW5kbGVkRXJyb3JzKCkge1xuICAgICAgICB0aGlzLnVuaGFuZGxlZEVycm9yc18gPSBbXTtcbiAgICB9XG59XG5cbi8vIGdldCB0aGUgZ2xvYmFsIGNvbnRleHQgaW5zdGFuY2UsIGVuc3VyaW5nIHdlIGdldCB0aGUgc2FtZVxuLy8gaW5zdGFuY2UgZXZhbCBhY3Jvc3MgZGlmZmVyZW50IGpzIGJ1bmRsZXMgbG9hZGVkIGludG8gdGhlIHBhZ2VcbmNvbnN0IFZJWl9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoJ0BAaW5zcGVjdC12aXotY29udGV4dCcpO1xuYXN5bmMgZnVuY3Rpb24gdml6Q29udGV4dChwbG90RGVmYXVsdHM6IGFueVtdKTogUHJvbWlzZTxWaXpDb250ZXh0PiB7XG4gICAgY29uc3QgZ2xvYmFsU2NvcGU6IGFueSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsVGhpcztcbiAgICBpZiAoIWdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0pIHtcbiAgICAgICAgZ2xvYmFsU2NvcGVbVklaX0NPTlRFWFRfS0VZXSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRiLCB3b3JrZXIgfSA9IGF3YWl0IGluaXREdWNrZGIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBkYi5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBuZXcgVml6Q29udGV4dChjb25uLCBwbG90RGVmYXVsdHMpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZUVycm9ySGFuZGxpbmcoY3R4LCB3b3JrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbFNjb3BlW1ZJWl9DT05URVhUX0tFWV0gYXMgUHJvbWlzZTxWaXpDb250ZXh0Pjtcbn1cblxuZXhwb3J0IHsgVml6Q29udGV4dCwgdml6Q29udGV4dCB9O1xuIiwgImltcG9ydCB7XG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBjbGF1c2VQb2ludCxcbiAgICBjbGF1c2VQb2ludHMsXG4gICAgdG9EYXRhQ29sdW1ucyxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuaW1wb3J0IHtcbiAgICBGaWx0ZXJFeHByLFxuICAgIFF1ZXJ5LFxuICAgIFNlbGVjdFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnO1xuXG5pbXBvcnQgeyBJbnB1dCwgSW5wdXRPcHRpb25zIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hvaWNlSW5wdXRPcHRpb25zIGV4dGVuZHMgSW5wdXRPcHRpb25zIHtcbiAgICBmcm9tPzogc3RyaW5nO1xuICAgIGNvbHVtbj86IHN0cmluZztcbiAgICBvcHRpb25zPzogQXJyYXk8T3B0aW9uPjtcbiAgICBmaWVsZD86IHN0cmluZztcbiAgICBsYWJlbD86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob2ljZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICAgIHByb3RlY3RlZCBkYXRhXzogT3B0aW9uW10gPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgb3B0aW9uc186IENob2ljZUlucHV0T3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkVmFsdWUoKTogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgICBhYnN0cmFjdCBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pO1xuXG4gICAgYWJzdHJhY3QgdXBkYXRlKCk6IHRoaXM7XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpICYmIHRoaXMub3B0aW9uc18uY29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKGNsYXVzZVBvaW50KGZpZWxkLCB1bmRlZmluZWQsIHsgc291cmNlOiB0aGlzIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCB7IGFzLCBmaWVsZCwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24oYXMpICYmIGNvbHVtbikge1xuICAgICAgICAgICAgbGV0IGNsYXVzZSA9IGNsYXVzZVBvaW50KGZpZWxkIHx8IGNvbHVtbiwgdW5kZWZpbmVkLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2xhdXNlID0gY2xhdXNlUG9pbnRzKFxuICAgICAgICAgICAgICAgICAgICBbZmllbGQgfHwgY29sdW1uXSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubWFwKHYgPT4gW3ZdKSxcbiAgICAgICAgICAgICAgICAgICAgeyBzb3VyY2U6IHRoaXMgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbGF1c2UgPSBjbGF1c2VQb2ludChmaWVsZCB8fCBjb2x1bW4sIHZhbHVlLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzLnVwZGF0ZShjbGF1c2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGFyYW0oYXMpKSB7XG4gICAgICAgICAgICBhcy51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcXVlcnkoZmlsdGVyOiBGaWx0ZXJFeHByW10gPSBbXSk6IFNlbGVjdFF1ZXJ5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuXG4gICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgY29sdW1uIGFsb25nIHdpdGggYSBkYXRhIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LmZyb20oZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyB2YWx1ZTogY29sdW1uIH0pXG4gICAgICAgICAgICAuZGlzdGluY3QoKVxuICAgICAgICAgICAgLndoZXJlKC4uLmZpbHRlcilcbiAgICAgICAgICAgIC5vcmRlcmJ5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KTogdGhpcyB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbeyB2YWx1ZTogJycsIGxhYmVsOiAnQWxsJyB9LCAuLi50aGlzLnF1ZXJ5UmVzdWx0T3B0aW9ucyhkYXRhKV0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdE9wdGlvbnMoZGF0YTogYW55KTogT3B0aW9uW10ge1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gdG9EYXRhQ29sdW1ucyhkYXRhKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gY29sdW1ucy5jb2x1bW5zLnZhbHVlIGFzIHN0cmluZ1tdO1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcCh2ID0+ICh7IHZhbHVlOiB2IH0pKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0T3B0aW9ucyhvcHRpb25zOiBPcHRpb25bXSkge1xuICAgICAgICB0aGlzLnNldERhdGEob3B0aW9ucy5tYXAob3B0ID0+IChpc09iamVjdChvcHQpID8gb3B0IDogeyB2YWx1ZTogb3B0IH0pKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwUGFyYW1MaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgICAvLyB1cGRhdGUgdmFsdWUgYmFzZWQgb24gcGFyYW0vc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcylcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5hcy52YWx1ZUZvcih0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzZXREYXRhKG9wdGlvbnM6IE9wdGlvbltdKSB7XG4gICAgICAgIGlmICghaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtVmFsdWUgPSB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJhbVZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNvbWUob3B0aW9uID0+IG9wdGlvbi52YWx1ZSA9PT0gcGFyYW1WYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbLi4ub3B0aW9ucywgeyB2YWx1ZTogcGFyYW1WYWx1ZSB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFfID0gb3B0aW9ucztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gKHY6IHVua25vd24pOiB2IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0+IHtcbiAgICByZXR1cm4gdiAhPT0gbnVsbCAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodik7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY29vcmRpbmF0b3IsXG4gICAgTW9zYWljQ2xpZW50LFxuICAgIFBhcmFtLFxuICAgIFNlbGVjdGlvbixcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dE9wdGlvbnMge1xuICAgIGFzOiBQYXJhbTtcbiAgICBmaWx0ZXJCeT86IFNlbGVjdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRGdW5jdGlvbjxUIGV4dGVuZHMgSW5wdXRPcHRpb25zID0gYW55PiA9IChvcHRpb25zOiBUKSA9PiBIVE1MRWxlbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlucHV0PFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBJbnB1dD4oXG4gICAgSW5wdXRDbGFzczogVCxcbiAgICAuLi5wYXJhbXM6IENvbnN0cnVjdG9yUGFyYW1ldGVyczxUPlxuKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0ID0gbmV3IElucHV0Q2xhc3MoLi4ucGFyYW1zKTtcbiAgICBjb29yZGluYXRvcigpLmNvbm5lY3QoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dC5lbGVtZW50O1xufVxuXG5leHBvcnQgY2xhc3MgSW5wdXQgZXh0ZW5kcyBNb3NhaWNDbGllbnQge1xuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihmaWx0ZXJCeT86IFNlbGVjdGlvbikge1xuICAgICAgICBzdXBlcihmaWx0ZXJCeSk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB7IHZhbHVlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJZCgpIHtcbiAgICByZXR1cm4gJ2lkLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMikgKyBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbn1cbiIsICJpbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGaWVsZHNldChsZWdlbmQ/OiBzdHJpbmcpOiBIVE1MRmllbGRTZXRFbGVtZW50IHtcbiAgICBjb25zdCBmaWVsZHNldCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaWVsZHNldCcpO1xuXG4gICAgaWYgKGxlZ2VuZCkge1xuICAgICAgICBjb25zdCBsZWdlbmRFbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICAgICAgbGVnZW5kRWwuaW5uZXJUZXh0ID0gbGVnZW5kO1xuICAgICAgICBmaWVsZHNldC5hcHBlbmQobGVnZW5kKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWVsZHNldE9wdGlvbnMoXG4gICAgZmllbGRzZXQ6IEhUTUxGaWVsZFNldEVsZW1lbnQsXG4gICAgb3B0aW9uczogT3B0aW9uW10sXG4gICAgdHlwZTogJ3JhZGlvJyB8ICdjaGVja2JveCdcbikge1xuICAgIC8vIHJlbW92ZSBpbnB1dCBlbGVtZW50c1xuICAgIGZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCBsYWJlbCcpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5yZW1vdmUoKTtcbiAgICB9KTtcblxuICAgIC8vIHBvcHVsYXRlIHJhZGlvIGJ1dHRvbnNcbiAgICBjb25zdCBuYW1lID0gZ2VuZXJhdGVJZCgpO1xuICAgIGZvciAoY29uc3QgeyB2YWx1ZSwgbGFiZWwgfSBvZiBvcHRpb25zIHx8IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCB9ID0gY3JlYXRlTGFiZWxlZElucHV0KHR5cGUsIGxhYmVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGZpZWxkc2V0LmFwcGVuZENoaWxkKGlucHV0TGFiZWwpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxhYmVsZWRJbnB1dChcbiAgICB0eXBlOiAncmFkaW8nIHwgJ2NoZWNrYm94JyxcbiAgICBsYWJlbD86IHN0cmluZyxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIHZhbHVlPzogc3RyaW5nXG4pIHtcbiAgICBjb25zdCBpbnB1dExhYmVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgY29uc3QgaW5wdXQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIGlucHV0TGFiZWwuYXBwZW5kQ2hpbGQod2luZG93LmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAgJHtsYWJlbCB8fCB2YWx1ZX1gKSk7XG4gICAgcmV0dXJuIHsgaW5wdXRMYWJlbCwgaW5wdXQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyhpbnB1dDogSW5wdXQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgLy8gdHJpZ2dlciBzZWxlY3Rpb24gYWN0aXZhdGlvblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmVudGVyJywgZXZ0ID0+IHtcbiAgICAgICAgaWYgKCFldnQuYnV0dG9ucykgaW5wdXQuYWN0aXZhdGUoKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4gaW5wdXQuYWN0aXZhdGUoKSk7XG59XG4iLCAiaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGNyZWF0ZUZpZWxkc2V0LCBzZXRGaWVsZHNldE9wdGlvbnMgfSBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBPcHRpb25zIGV4dGVuZHMgQ2hvaWNlSW5wdXRPcHRpb25zIHt9XG5cbmV4cG9ydCBjbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ2hvaWNlSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZmllbGRzZXRfOiBIVE1MRmllbGRTZXRFbGVtZW50O1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFJhZGlvR3JvdXBPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJCeVxuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICAvLyBvdXRlciBmaWVsZHNldFxuICAgICAgICB0aGlzLmZpZWxkc2V0XyA9IGNyZWF0ZUZpZWxkc2V0KG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuZmllbGRzZXRfKTtcblxuICAgICAgICAvLyBiaW5kIGV4cGxpY2l0IG9wdGlvbnMgdG8gZGF0YSBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKG9wdGlvbnMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgdmFsdWUgdG8gXCJhbGxcIlxuICAgICAgICB0aGlzLnNlbGVjdGVkVmFsdWUgPSAnJztcblxuICAgICAgICAvLyBwdWJsaXNoIHNlbGVjdGVkIHZhbHVlIG9uIHJhZGlvIGNoYW5nZVxuICAgICAgICB0aGlzLmZpZWxkc2V0Xy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuc2V0dXBQYXJhbUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMuZmllbGRzZXRfKTtcbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBjaGVja2VkID0gdGhpcy5maWVsZHNldF8ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCdcbiAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICByZXR1cm4gY2hlY2tlZD8udmFsdWUgPyAoY2hlY2tlZC52YWx1ZSA9PT0gJ29uJyA/ICcnIDogY2hlY2tlZC52YWx1ZSkgOiAnJztcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09ICcnID8gJ29uJyA6IHZhbHVlO1xuICAgICAgICBjb25zdCByYWRpb3MgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiByYWRpb3MpIHtcbiAgICAgICAgICAgIGlmICgocmFkaW8gYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKHJhZGlvIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJhZGlvLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdjaGFuZ2UnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBzZXRGaWVsZHNldE9wdGlvbnModGhpcy5maWVsZHNldF8sIHRoaXMuZGF0YV8sICdyYWRpbycpO1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBrU2lkZWJhckZ1bGx3aWR0aCA9ICdzaWRlYmFyLWZ1bGx3aWR0aCc7XG5leHBvcnQgY29uc3Qga0lucHV0U2VhcmNoID0gJ2lucHV0LXNlYXJjaCc7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbiA9IHsgdmFsdWU6IHN0cmluZzsgbGFiZWw/OiBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBUb21TZXR0aW5ncyB9IGZyb20gJ3RvbS1zZWxlY3QvZGlzdC9lc20vdHlwZXMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCB9IGZyb20gJy4uL3V0aWwvaWQnO1xuaW1wb3J0IHsgQ2hvaWNlSW5wdXQsIENob2ljZUlucHV0T3B0aW9ucyB9IGZyb20gJy4vY2hvaWNlJztcbmltcG9ydCB7IGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmltcG9ydCBUb21TZWxlY3QgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90b20tc2VsZWN0QDIuNC4zLytlc20nO1xuaW1wb3J0IHsgaXNTZWxlY3Rpb24gfSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLWNvcmVAMC4xNi4yLytlc20nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvbnMgZXh0ZW5kcyBDaG9pY2VJbnB1dE9wdGlvbnMge1xuICAgIHZhbHVlPzogJ2FsbCcgfCAnYXV0bycgfCBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBtdWx0aXBsZT86IGJvb2xlYW47XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3QgZXh0ZW5kcyBDaG9pY2VJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzZWxlY3RfOiBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG11bHRpcGxlXzogYm9vbGVhbjtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFsbG93RW1wdHlfOiBib29sZWFuO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbFZhbHVlXz86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgdG9tU2VsZWN0Xz86IFRvbVNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTZWxlY3RPcHRpb25zKSB7XG4gICAgICAgIC8vIHByb3BhZ2F0ZSBmaWx0ZXJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gbm90ZSBtdWx0aXBsZSBhbmQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLm11bHRpcGxlXyA9IG9wdGlvbnMubXVsdGlwbGUgPz8gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dFbXB0eV8gPSBvcHRpb25zLnZhbHVlID09PSAnYWxsJztcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID1cbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWUgPT09ICdhbGwnIHx8IG9wdGlvbnMudmFsdWUgPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IG9wdGlvbnMudmFsdWU7XG5cbiAgICAgICAgLy8gYWRkIGZ1bGx3aWR0aCBjbGFzcyAoZm9yIHNpZGViYXJzKVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZChrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBsYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgb3B0aW9ucy5jb2x1bW47XG4gICAgICAgIGxldCBsYWJlbEVsOiBIVE1MTGFiZWxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYWJlbEVsID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBsYWJlbEVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsRWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlbGVjdFxuICAgICAgICB0aGlzLnNlbGVjdF8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5zdHlsZS53aWR0aCA9IGAke29wdGlvbnMud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0Xy5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgaWYgKGxhYmVsRWwpIHtcbiAgICAgICAgICAgIGxhYmVsRWwuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdF8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHZhbHVlIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWVfICE9PSB1bmRlZmluZWQgJiYgaXNTZWxlY3Rpb24odGhpcy5vcHRpb25zXy5hcykpIHtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaChvcHRpb25zLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1Ymxpc2ggc2VsZWN0ZWQgdmFsdWUgdXBvbiBtZW51IGNoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdF8uYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godGhpcy5zZWxlY3RlZFZhbHVlID8/IG51bGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5zZWxlY3RfKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpOiB0aGlzIHtcbiAgICAgICAgaWYgKHRoaXMubXVsdGlwbGVfIHx8ICF0aGlzLmFsbG93RW1wdHlfKSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucXVlcnlSZXN1bHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2VsZWN0ZWRWYWx1ZSgpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvbVNlbGVjdF8/LmdldFZhbHVlKCkgPz8gJyc7XG4gICAgfVxuXG4gICAgc2V0IHNlbGVjdGVkVmFsdWUodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xz8uc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpOiB0aGlzIHtcbiAgICAgICAgLy8gY3JlYXRlIHRvbVNlbGVjdCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCF0aGlzLnRvbVNlbGVjdF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0Xy5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8VG9tU2V0dGluZ3M+ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHJvcGRvd25QYXJlbnQ6ICdib2R5JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0Xy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5hbGxvd0VtcHR5T3B0aW9uID0gdGhpcy5hbGxvd0VtcHR5XztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29uZmlnLmNvbnRyb2xJbnB1dCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wbHVnaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVfYnV0dG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1JlbW92ZSB0aGlzIGl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudG9tU2VsZWN0XyA9IG5ldyBUb21TZWxlY3QodGhpcy5zZWxlY3RfLCBjb25maWcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8ub24oJ2l0ZW1fYWRkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvbVNlbGVjdF8hLmNvbnRyb2xfaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b21TZWxlY3RfPy5yZWZyZXNoT3B0aW9ucyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVfID8/ICh0aGlzLmFsbG93RW1wdHlfID8gJycgOiB0aGlzLmRhdGFfPy5bMF0udmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKVxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnNfLmFzLnZhbHVlIHx8IGRlZmF1bHRWYWx1ZTtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgb3B0aW9uc1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8uY2xlYXJPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudG9tU2VsZWN0Xy5hZGRPcHRpb25zKFxuICAgICAgICAgICAgdGhpcy5kYXRhXy5tYXAobyA9PiAoeyB2YWx1ZTogby52YWx1ZSwgdGV4dDogby5sYWJlbCB8fCBvLnZhbHVlIH0pKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRvbVNlbGVjdF8ucmVmcmVzaE9wdGlvbnMoZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZSBiYXNlZCBvbiBwYXJhbS9zZWxlY3Rpb25cbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IENob2ljZUlucHV0LCBDaG9pY2VJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2Nob2ljZSc7XG5pbXBvcnQgeyBjcmVhdGVGaWVsZHNldCwgc2V0RmllbGRzZXRPcHRpb25zIH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwT3B0aW9ucyBleHRlbmRzIENob2ljZUlucHV0T3B0aW9ucyB7fVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hHcm91cCBleHRlbmRzIENob2ljZUlucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZpZWxkc2V0XzogSFRNTEZpZWxkU2V0RWxlbWVudDtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBDaGVja2JveEdyb3VwT3B0aW9ucykge1xuICAgICAgICAvLyBwcm9wYWdhdGUgZmlsdGVyQnlcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gb3V0ZXIgZmllbGRzZXRcbiAgICAgICAgdGhpcy5maWVsZHNldF8gPSBjcmVhdGVGaWVsZHNldChvcHRpb25zLmxhYmVsIHx8IG9wdGlvbnMuY29sdW1uKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmZpZWxkc2V0Xyk7XG5cbiAgICAgICAgLy8gYmluZCBleHBsaWNpdCBvcHRpb25zIHRvIGRhdGEgaWYgc3BlY2lmaWVkXG4gICAgICAgIGlmIChvcHRpb25zLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVibGlzaCBzZWxlY3RlZCB2YWx1ZSBvbiBjaGVja2JveCBjaGFuZ2VcbiAgICAgICAgdGhpcy5maWVsZHNldF8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2VsZWN0ZWRWYWx1ZSA/PyBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5zZXR1cFBhcmFtTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnModGhpcy5maWVsZHNldF8pO1xuICAgIH1cblxuICAgIGdldCBzZWxlY3RlZFZhbHVlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY2hlY2tlZCA9IHRoaXMuZmllbGRzZXRfLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdOmNoZWNrZWQnXG4gICAgICAgICkgYXMgTm9kZUxpc3RPZjxIVE1MSW5wdXRFbGVtZW50PjtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hlY2tlZCkubWFwKGNoZWNrYm94ID0+IGNoZWNrYm94LnZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgc2VsZWN0ZWRWYWx1ZSh2YWx1ZXM6IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSB0aGlzLmZpZWxkc2V0Xy5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiBjaGVja2JveGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNoZWNrYm94IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZUNoZWNrZWQgPSB2YWx1ZXMuaW5jbHVkZXMoaW5wdXQudmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAhPT0gc2hvdWxkQmVDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHNob3VsZEJlQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLnNldERhdGEodGhpcy5xdWVyeVJlc3VsdE9wdGlvbnMoZGF0YSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1cGRhdGUoKTogdGhpcyB7XG4gICAgICAgIHNldEZpZWxkc2V0T3B0aW9ucyh0aGlzLmZpZWxkc2V0XywgdGhpcy5kYXRhXywgJ2NoZWNrYm94Jyk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGNyZWF0ZUxhYmVsZWRJbnB1dCwgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveE9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgY2hlY2tlZDogYm9vbGVhbjtcbiAgICB2YWx1ZXM6IFtzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxdO1xuICAgIGZpZWxkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBDaGVja2JveE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9uc18uZmlsdGVyQnkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgaW5wdXRMYWJlbCwgaW5wdXQgfSA9IGNyZWF0ZUxhYmVsZWRJbnB1dCgnY2hlY2tib3gnLCBvcHRpb25zXy5sYWJlbCk7XG4gICAgICAgIGlucHV0LmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGluaXRpYWwgY2hlY2tlZCBzdGF0ZVxuICAgICAgICBpbnB1dC5jaGVja2VkID0gIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpXG4gICAgICAgICAgICA/ICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA/PyBvcHRpb25zXy5jaGVja2VkKVxuICAgICAgICAgICAgOiBvcHRpb25zXy5jaGVja2VkO1xuXG4gICAgICAgIC8vIHB1Ymxpc2ggaW5wdXQgKGFuZCBzeW5jIHRvIGNoZWNrYm94IGNoYW5nZXMpXG4gICAgICAgIGNvbnN0IHB1Ymxpc2ggPSAoKSA9PlxuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKFxuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPyBvcHRpb25zXy52YWx1ZXNbMF0gfHwgdW5kZWZpbmVkIDogb3B0aW9uc18udmFsdWVzWzFdIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcHVibGlzaCk7XG4gICAgICAgIHB1Ymxpc2goKTtcblxuICAgICAgICAvLyBzZXR1cCBwYXJhbSBsaXN0ZW5lclxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zXy52YWx1ZXNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCBpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xhdXNlKHZhbHVlPzogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbik6IFNlbGVjdGlvbkNsYXVzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zXy5maWVsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tib3ggJ2ZpZWxkJyBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2l0aCBzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQodGhpcy5vcHRpb25zXy5maWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzIH0pO1xuICAgIH1cblxuICAgIHB1Ymxpc2godmFsdWU/OiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgICBjbGF1c2VJbnRlcnZhbCxcbiAgICBjbGF1c2VQb2ludCxcbiAgICBpc1BhcmFtLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIFNlbGVjdGlvbkNsYXVzZSxcbn0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AdXdkYXRhL21vc2FpYy1jb3JlQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7XG4gICAgRmlsdGVyRXhwcixcbiAgICBtYXgsXG4gICAgbWluLFxuICAgIFF1ZXJ5LFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBzZXR1cEFjdGl2YXRpb25MaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsga1NpZGViYXJGdWxsd2lkdGggfSBmcm9tICcuL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgICBjcmVhdGUgYXMgY3JlYXRlU2xpZGVyLFxuICAgIEFQSSBhcyBTbGlkZXJBUEksXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbm91aXNsaWRlckAxNS44LjEvK2VzbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgc2VsZWN0OiAncG9pbnQnIHwgJ2ludGVydmFsJztcbiAgICB2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG4gICAgZnJvbT86IHN0cmluZztcbiAgICBjb2x1bW4/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICBzdGVwPzogbnVtYmVyO1xuICAgIHdpZHRoPzogbnVtYmVyO1xufVxuXG5jb25zdCBrU2xpZGVySW5wdXQgPSAnc2xpZGVyLWlucHV0JztcblxuZXhwb3J0IGNsYXNzIFNsaWRlciBleHRlbmRzIElucHV0IHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNsaWRlcl86IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgcmVhZG9ubHkgc2xpZGVyQXBpXzogU2xpZGVyQVBJO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY3VydmFsXzogSFRNTExhYmVsRWxlbWVudDtcbiAgICBwcml2YXRlIGZpcnN0UXVlcnlfOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IG9wdGlvbnNfOiBTbGlkZXJPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlckJ5KTtcblxuICAgICAgICAvLyByZWdpc3RlciBhcyBmdWxsd2lkdGhcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NsaWRlcklucHV0LCBrU2lkZWJhckZ1bGx3aWR0aCk7XG5cbiAgICAgICAgLy8gYWRkIGxhYmVsIGlmIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb25zXy5sYWJlbCB8fCBvcHRpb25zXy5jb2x1bW47XG4gICAgICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgc2xpZGVyXG4gICAgICAgIGxldCB7IHZhbHVlLCB3aWR0aCwgbWluLCBtYXggfSA9IG9wdGlvbnNfO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgd2lkZ2V0XG4gICAgICAgIHRoaXMuc2xpZGVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uY2xhc3NMaXN0LmFkZCgnbm9VaS1yb3VuZCcpO1xuICAgICAgICB0aGlzLnNsaWRlcl8uc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgaWYgKHdpZHRoICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zbGlkZXJfLnN0eWxlLndpZHRoID0gYCR7K3dpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zbGlkZXJfKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNsaWRlcl8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXyA9IGNyZWF0ZVNsaWRlcih0aGlzLnNsaWRlcl8sIHtcbiAgICAgICAgICAgIHJhbmdlOiB7IG1pbjogMCwgbWF4OiAwIH0sXG4gICAgICAgICAgICBjb25uZWN0OiBvcHRpb25zXy5zZWxlY3QgPT09ICdpbnRlcnZhbCcsXG4gICAgICAgICAgICBzdGFydDogb3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gWzAsIDBdIDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGN1cnJlbnQgdmFsdWUgbGFiZWxcbiAgICAgICAgdGhpcy5jdXJ2YWxfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgdGhpcy5jdXJ2YWxfLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2xpZGVyLXZhbHVlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmN1cnZhbF8pO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbml0aWFsIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmFzPy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2godmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zXy5hcz8udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdmFsdWUgZGlzcGxheVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHRyYWNrIHBhcmFtIHVwZGF0ZXNcbiAgICAgICAgaWYgKCFpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy5hZGRFdmVudExpc3RlbmVyKCd2YWx1ZScsIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZUVxdWFsKHZhbHVlLCB0aGlzLnNsaWRlclZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8uc2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIGFjdGl2YXRpb24gbGlzdGVuZXJzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0dXBBY3RpdmF0aW9uTGlzdGVuZXJzKHRoaXMsIHRoaXMuc2xpZGVyXyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgc2xpZGVyIGlmIHdlIGFyZW4ndCB1c2luZyB0aGUgZGJcbiAgICAgICAgaWYgKCFvcHRpb25zXy5mcm9tKSB7XG4gICAgICAgICAgICBtaW4gPSBtaW4gPz8gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiAodmFsdWUgPz8gMCkpO1xuICAgICAgICAgICAgbWF4ID0gbWF4ID8/IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogKHZhbHVlID8/IDApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWUgPz8gKG9wdGlvbnNfLnNlbGVjdCA9PT0gJ2ludGVydmFsJyA/IFswLCAwXSA6IDApO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuc2xpZGVyQXBpXy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuc2xpZGVyVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDdXJyZW50VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJUZXh0ID0gYCR7dmFsdWVbMF0udG9Mb2NhbGVTdHJpbmcoKX0tJHt2YWx1ZVsxXS50b0xvY2FsZVN0cmluZygpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnZhbF8uaW5uZXJIVE1MID0gdmFsdWUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzbGlkZXJWYWx1ZSgpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnNsaWRlckFwaV8uZ2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChjbGVhbk51bWJlcikuc2xpY2UoMCwgMikgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbGVhbk51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2xpZGVyVmFsdWUodmFsdWU6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgdGhpcy5zbGlkZXJBcGlfLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMub3B0aW9uc18uYXM7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0aXZhdGUodGhpcy5jbGF1c2UoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgY29sdW1uIH0gPSB0aGlzLm9wdGlvbnNfO1xuICAgICAgICBpZiAoIWZyb20gfHwgIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFF1ZXJ5LnNlbGVjdCh7IG1pbjogbWluKGNvbHVtbiksIG1heDogbWF4KGNvbHVtbikgfSlcbiAgICAgICAgICAgIC5mcm9tKGZyb20pXG4gICAgICAgICAgICAud2hlcmUoLi4uZmlsdGVyKTtcbiAgICB9XG5cbiAgICBxdWVyeVJlc3VsdChkYXRhOiBhbnkpIHtcbiAgICAgICAgLy8gZ2V0IG1pbiBhbmQgbWF4XG4gICAgICAgIGNvbnN0IHsgbWluOiBkYXRhTWluLCBtYXg6IGRhdGFNYXggfSA9IEFycmF5LmZyb20oZGF0YSlbMF0gYXMgeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXIgfTtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5vcHRpb25zXy5taW4gPz8gZGF0YU1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5vcHRpb25zXy5tYXggPz8gZGF0YU1heDtcblxuICAgICAgICAvLyBzbmFwIHRvIG1pbiBhbmQgbWF4IGlmIGZpcnN0IHF1ZXJ5IGFuZCBubyB2YWx1ZSBzcGVjaWZpZWRcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0UXVlcnlfKSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UXVlcnlfID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMub3B0aW9uc18uc2VsZWN0ID09PSAnaW50ZXJ2YWwnID8gW21pbiwgbWF4XSA6IG1heDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLm9wdGlvbnNfLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNsaWRlcihtaW4sIG1heCwgc3RhcnQpO1xuXG4gICAgICAgICAgICB0aGlzLnNsaWRlckFwaV8ub24oJ3VwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLnNsaWRlclZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbGlkZXIobWluLCBtYXgsIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVwZGF0ZVNsaWRlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLm9wdGlvbnNfLnN0ZXAgPz8gKG1pbiA+PSA1IHx8IG1heCA+PSA1ID8gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2xpZGVyQXBpXy51cGRhdGVPcHRpb25zKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsYXVzZSh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBsZXQgeyBmaWVsZCwgY29sdW1uLCBtaW4sIHNlbGVjdCA9ICdwb2ludCcgfSA9IHRoaXMub3B0aW9uc187XG4gICAgICAgIGZpZWxkID0gZmllbGQgfHwgY29sdW1uO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBzcGVjaWZ5IGEgJ2NvbHVtbicgb3IgJ2ZpZWxkJyBmb3IgYSBzbGlkZXIgdGFyZ2V0aW5nIGEgc2VsZWN0aW9uLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3QgPT09ICdpbnRlcnZhbCcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluOiBbbnVtYmVyLCBudW1iZXJdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFttaW4gPz8gMCwgdmFsdWVdO1xuICAgICAgICAgICAgcmV0dXJuIGNsYXVzZUludGVydmFsKGZpZWxkLCBkb21haW4sIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYmluOiAnY2VpbCcsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHsgdHlwZTogJ2lkZW50aXR5JywgZG9tYWluIH0sXG4gICAgICAgICAgICAgICAgcGl4ZWxTaXplOiB0aGlzLm9wdGlvbnNfLnN0ZXAgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnQoZmllbGQsIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbMF0gOiB2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGlzaCh2YWx1ZT86IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5vcHRpb25zXy5hcztcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdldC51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdLCBiOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gYS5tYXAoY2xlYW5OdW1iZXIpID09PSBiLm1hcChjbGVhbk51bWJlcik7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhKSAmJiAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICByZXR1cm4gY2xlYW5OdW1iZXIoYSkgPT09IGNsZWFuTnVtYmVyKGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuTnVtYmVyKG51bTogbnVtYmVyIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG51bSA9IHBhcnNlRmxvYXQobnVtKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2VzXG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKSByZXR1cm4gbnVtO1xuICAgIGlmIChudW0gPT09IDApIHJldHVybiAwO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGEgcmVhc29uYWJsZSBlcHNpbG9uIGJhc2VkIG9uIHRoZSBtYWduaXR1ZGUgb2YgdGhlIG51bWJlclxuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGguYWJzKG51bSk7XG4gICAgY29uc3QgZXBzaWxvbiA9IG1hZ25pdHVkZSAqIE51bWJlci5FUFNJTE9OICogMTAwO1xuXG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgXCJjbGVhblwiIHZhbHVlXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQobnVtKTtcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gYW4gaW50ZWdlciwgcmV0dXJuIHRoZSBpbnRlZ2VyXG4gICAgaWYgKE1hdGguYWJzKG51bSAtIHJvdW5kZWQpIDwgZXBzaWxvbikge1xuICAgICAgICByZXR1cm4gcm91bmRlZDtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSB0b1ByZWNpc2lvbiB0byBjbGVhbiB1cFxuICAgIHJldHVybiBwYXJzZUZsb2F0KG51bS50b1ByZWNpc2lvbigxNSkpO1xufVxuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlUG9pbnRzLFxuICAgIGlzU2VsZWN0aW9uLFxuICAgIHF1ZXJ5RmllbGRJbmZvLFxuICAgIHRocm90dGxlLFxuICAgIHRvRGF0YUNvbHVtbnMsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgYW5kLFxuICAgIGFzYyxcbiAgICBjb250YWlucyxcbiAgICBkZXNjLFxuICAgIGVxLFxuICAgIEV4cHJOb2RlLFxuICAgIEZpbHRlckV4cHIsXG4gICAgZ3QsXG4gICAgZ3RlLFxuICAgIGlzTnVsbCxcbiAgICBsaXRlcmFsLFxuICAgIGx0LFxuICAgIGx0ZSxcbiAgICBuZXEsXG4gICAgbm90LFxuICAgIG9yLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgUXVlcnksXG4gICAgU2VsZWN0UXVlcnksXG4gICAgc3FsLFxuICAgIGNvbHVtbixcbiAgICBhdmcsXG4gICAgY291bnQsXG4gICAgc3VtLFxuICAgIGFyZ21heCxcbiAgICBtYWQsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBwcm9kdWN0LFxuICAgIGdlb21lYW4sXG4gICAgbWVkaWFuLFxuICAgIG1vZGUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RkZGV2LFxuICAgIHNrZXduZXNzLFxuICAgIGt1cnRvc2lzLFxuICAgIGVudHJvcHksXG4gICAgdmFyUG9wLFxuICAgIHN0ZGRldlBvcCxcbiAgICBmaXJzdCxcbiAgICBsYXN0LFxuICAgIHN0cmluZ0FnZyxcbiAgICBhcnJheUFnZyxcbiAgICBhcmdtaW4sXG4gICAgcXVhbnRpbGUsXG4gICAgY29ycixcbiAgICBjb3ZhclBvcCxcbiAgICByZWdySW50ZXJjZXB0LFxuICAgIHJlZ3JTbG9wZSxcbiAgICByZWdyQ291bnQsXG4gICAgcmVnclIyLFxuICAgIHJlZ3JTWFgsXG4gICAgcmVnclNZWSxcbiAgICByZWdyU1hZLFxuICAgIHJlZ3JBdmdYLFxuICAgIHJlZ3JBdmdZLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B1d2RhdGEvbW9zYWljLXNxbEAwLjE2LjIvK2VzbSc7XG5cbmltcG9ydCB7XG4gICAgY3JlYXRlR3JpZCxcbiAgICBHcmlkT3B0aW9ucyxcbiAgICBDb2xEZWYsXG4gICAgTW9kdWxlUmVnaXN0cnksXG4gICAgQWxsQ29tbXVuaXR5TW9kdWxlLFxuICAgIEdyaWRBcGksXG4gICAgdGhlbWVCYWxoYW0sXG4gICAgRmlsdGVyTW9kZWwsXG4gICAgVGV4dEZpbHRlck1vZGVsLFxuICAgIE51bWJlckZpbHRlck1vZGVsLFxuICAgIERhdGVGaWx0ZXJNb2RlbCxcbiAgICBJTXVsdGlGaWx0ZXJNb2RlbCxcbiAgICBTZXRGaWx0ZXJNb2RlbCxcbiAgICBJQ29tYmluZWRTaW1wbGVNb2RlbCxcbiAgICBSb3dTZWxlY3Rpb25PcHRpb25zLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2FnLWdyaWQtY29tbXVuaXR5QDMzLjMuMi8rZXNtJztcblxuaW1wb3J0ICogYXMgZDNGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy1mb3JtYXRAMy4xLjAvK2VzbSc7XG5pbXBvcnQgKiBhcyBkM1RpbWVGb3JtYXQgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9kMy10aW1lLWZvcm1hdEA0LjEuMC8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tICcuLi91dGlsL2lkJztcbmltcG9ydCB7IEpTVHlwZSB9IGZyb20gJ0B1d2RhdGEvbW9zYWljLWNvcmUnO1xuaW1wb3J0IHsgQWdncmVnYXRlTm9kZSwgRXhwclZhbHVlIH0gZnJvbSAnQHV3ZGF0YS9tb3NhaWMtc3FsJztcblxuLy8gVGhlc2UgdHdvIHZhbHVlcyBzaG91bGQgZ2VuZXJhbGx5IGJlIGNvb3JkaW5hdGVkIHNvIHRoYXQgdGhlIG1heCBoZWlnaHQgaXNcbi8vIHRoZSBzaXplIHRoYXQgd2lsbCBkaXNwbGF5IHRoZSByb3cgY291bnQuXG5jb25zdCBrQXV0b1Jvd0NvdW50ID0gMTI7XG5jb25zdCBrQXV0b1Jvd01heEhlaWdodCA9IDM4MDtcblxudHlwZSBUcmFuc2Zvcm0gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuXG50eXBlIENoYW5uZWwgPSBzdHJpbmcgfCBUcmFuc2Zvcm0gfCBib29sZWFuIHwgbnVtYmVyIHwgdW5kZWZpbmVkIHwgQXJyYXk8Ym9vbGVhbiB8IG51bWJlcj47XG5cbi8vIEEgY29sdW1uIHdoaWNoIGhhcyBiZWVuIHJlc29sdmVkIHdpdGggdXNlciBwcm92aWRlZCBpbmZvcm1hdGlvblxudHlwZSBSZXNvbHZlZENvbHVtbiA9IFJlc29sdmVkU2ltcGxlQ29sdW1uIHwgUmVzb2x2ZWRMaXRlcmFsQ29sdW1uIHwgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW47XG5cbi8vIFJlc29sdmVkIENvbHVtbiBhZGRzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gdGhlIENvbHVtbiB0eXBlXG4vLyBiYXNlZCB1cG9uIHRoZSByYXcgY29sdW1uIHNwZWNpZmljdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlciwgaW5jbHVkaW5nXG4vLyBhbnkgYWdncmVnYXRpbm9uIGJlaGF2aW9yLlxuZXhwb3J0IGludGVyZmFjZSBCYXNlUmVzb2x2ZWRDb2x1bW4gZXh0ZW5kcyBDb2x1bW4ge1xuICAgIC8vIFRoZSBjb2x1bW4gbmFtZSBhcyBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIHF1ZXJ5IChlLmcuIHRoZSBhbGlhcyBmb3IgdGhlIGNvbHVtbilcbiAgICAvLyBUaGlzIGNvdWxkIGJlIHN5bnRoZXNpemVkIGlmIHRoaXMgaXMgYW4gYWdncmVnYXRpb24gb3IgbGl0ZXJhbC5cbiAgICBjb2x1bW5fbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBIGNvbHVtbiB3aGljaCBjb250YWlucyBvbmUgb3IgbW9yZSBsaXRlcmFsIHZhbHVlc1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZExpdGVyYWxDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIHR5cGU6ICdsaXRlcmFsJztcbn1cblxuLy8gQSBjb2x1bW4gd2hpY2ggY29udGFpbnMgYW4gYWdncmVnYXRlIGV4cHJlc3Npb25cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb2x2ZWRBZ2dyZWdhdGVDb2x1bW4gZXh0ZW5kcyBCYXNlUmVzb2x2ZWRDb2x1bW4ge1xuICAgIC8vIFRoZSBhY3R1YWwgY29sdW1uIG5hbWUgaW4gdGhlIGRhdGFiYXNlXG4gICAgY29sdW1uX2lkOiBzdHJpbmc7XG5cbiAgICAvLyBUaGUgYWdncmVnYXRlIGV4cHJlc3Npb24gYW5kIGl0cyBhcmd1bWVudHMsIGlmIHRoaXMgY29sdW1uIGlzIGFuIGFnZ3JlZ2F0aW9uLlxuICAgIGFnZ19leHByOiBzdHJpbmc7XG4gICAgYWdnX2V4cHJfYXJnczogRXhwclZhbHVlW107XG5cbiAgICB0eXBlOiAnYWdncmVnYXRlJztcbn1cbi8vIEEgY29sdW1uIHdoaWNoIGlzIGEgc2ltcGxlIGNvbHVtbiByZWZlcmVuY2UgaW4gdGhlIGRhdGFiYXNlLlxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZFNpbXBsZUNvbHVtbiBleHRlbmRzIEJhc2VSZXNvbHZlZENvbHVtbiB7XG4gICAgLy8gVGhlIGFjdHVhbCBjb2x1bW4gbmFtZSBpbiB0aGUgZGF0YWJhc2VcbiAgICBjb2x1bW5faWQ6IHN0cmluZztcbiAgICB0eXBlOiAnY29sdW1uJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xuICAgIGNvbHVtbjogQ2hhbm5lbDtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5JztcbiAgICBmb3JtYXQ/OiBzdHJpbmc7XG4gICAgc29ydGFibGU/OiBib29sZWFuO1xuICAgIGZpbHRlcmFibGU/OiBib29sZWFuO1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIGZsZXg/OiBudW1iZXI7XG4gICAgcmVzaXphYmxlPzogYm9vbGVhbjtcbiAgICBtaW5fd2lkdGg/OiBudW1iZXI7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIGF1dG9faGVpZ2h0PzogYm9vbGVhbjtcbiAgICB3cmFwX3RleHQ/OiBib29sZWFuO1xuICAgIGhlYWRlcl9hdXRvX2hlaWdodD86IGJvb2xlYW47XG4gICAgaGVhZGVyX2FsaWduPzogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuICAgIGhlYWRlcl93cmFwX3RleHQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU3R5bGUge1xuICAgIGJhY2tncm91bmRfY29sb3I/OiBzdHJpbmc7XG4gICAgZm9yZWdyb3VuZF9jb2xvcj86IHN0cmluZztcbiAgICBhY2NlbnRfY29sb3I/OiBzdHJpbmc7XG4gICAgdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBoZWFkZXJfdGV4dF9jb2xvcj86IHN0cmluZztcbiAgICBjZWxsX3RleHRfY29sb3I/OiBzdHJpbmc7XG5cbiAgICBmb250X2ZhbWlseT86IHN0cmluZztcbiAgICBoZWFkZXJfZm9udF9mYW1pbHk/OiBzdHJpbmc7XG4gICAgY2VsbF9mb250X2ZhbWlseT86IHN0cmluZztcblxuICAgIHNwYWNpbmc/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBib3JkZXJfY29sb3I/OiBzdHJpbmc7XG4gICAgYm9yZGVyX3dpZHRoPzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGJvcmRlcl9yYWRpdXM/OiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgICBzZWxlY3RlZF9yb3dfYmFja2dyb3VuZF9jb2xvcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMgZXh0ZW5kcyBJbnB1dE9wdGlvbnMge1xuICAgIGZpbHRlcl9ieTogYW55O1xuICAgIGZyb206IHN0cmluZztcbiAgICBjb2x1bW5zPzogQXJyYXk8c3RyaW5nIHwgQ29sdW1uPjtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXIgfCAnYXV0byc7XG4gICAgbWF4X3dpZHRoPzogbnVtYmVyO1xuICAgIHBhZ2luYXRpb24/OiB7XG4gICAgICAgIHBhZ2Vfc2l6ZT86IG51bWJlciB8ICdhdXRvJztcbiAgICAgICAgcGFnZV9zaXplX3NlbGVjdG9yPzogbnVtYmVyW10gfCBib29sZWFuO1xuICAgIH07XG4gICAgc29ydGluZz86IGJvb2xlYW47XG4gICAgZmlsdGVyaW5nPzogYm9vbGVhbiB8ICdoZWFkZXInIHwgJ3Jvdyc7XG4gICAgcm93X2hlaWdodD86IG51bWJlcjtcbiAgICBoZWFkZXJfaGVpZ2h0PzogbnVtYmVyIHwgJ2F1dG8nO1xuICAgIHNlbGVjdD86XG4gICAgICAgIHwgJ2hvdmVyJ1xuICAgICAgICB8ICdzaW5nbGVfcm93J1xuICAgICAgICB8ICdtdWx0aXBsZV9yb3cnXG4gICAgICAgIHwgJ3NpbmdsZV9jaGVja2JveCdcbiAgICAgICAgfCAnbXVsdGlwbGVfY2hlY2tib3gnXG4gICAgICAgIHwgJ25vbmUnO1xuICAgIHN0eWxlPzogVGFibGVTdHlsZTtcbiAgICBhdXRvX2ZpbGxpbmc/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sU29ydE1vZGVsIHtcbiAgICBjb2xJZDogc3RyaW5nO1xuICAgIHNvcnQ6ICdhc2MnIHwgJ2Rlc2MnIHwgbnVsbCB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgSW5wdXQge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgaWRfOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjb2x1bW5zXzogUmVzb2x2ZWRDb2x1bW5bXSA9IFtdO1xuICAgIHByaXZhdGUgY29sdW1uc0J5TmFtZV86IFJlY29yZDxzdHJpbmcsIFJlc29sdmVkQ29sdW1uPiA9IHt9O1xuICAgIHByaXZhdGUgY29sdW1uVHlwZXNfOiBSZWNvcmQ8c3RyaW5nLCBKU1R5cGU+ID0ge307XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IGdyaWRDb250YWluZXJfOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGdyaWRfOiBHcmlkQXBpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBncmlkT3B0aW9uc186IEdyaWRPcHRpb25zO1xuXG4gICAgcHJpdmF0ZSBjdXJyZW50Um93XzogbnVtYmVyO1xuICAgIHByaXZhdGUgc29ydE1vZGVsXzogQ29sU29ydE1vZGVsW10gPSBbXTtcbiAgICBwcml2YXRlIGZpbHRlck1vZGVsXzogRmlsdGVyTW9kZWwgPSB7fTtcblxuICAgIHByaXZhdGUgZGF0YV86IHsgbnVtUm93czogbnVtYmVyOyBjb2x1bW5zOiBSZWNvcmQ8c3RyaW5nLCBBcnJheTx1bmtub3duPj4gfSA9IHtcbiAgICAgICAgbnVtUm93czogMCxcbiAgICAgICAgY29sdW1uczoge30sXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogVGFibGVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnNfLmZpbHRlcl9ieSk7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgYWctZ3JpZCBtb2R1bGVzXG4gICAgICAgIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSk7XG5cbiAgICAgICAgLy8gaWRcbiAgICAgICAgdGhpcy5pZF8gPSBnZW5lcmF0ZUlkKCk7XG5cbiAgICAgICAgLy8gc3RhdGVcbiAgICAgICAgdGhpcy5jdXJyZW50Um93XyA9IC0xO1xuXG4gICAgICAgIC8vIGNsYXNzIGRlY29yYXRpb25cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2luc3BlY3Qtdml6LXRhYmxlJyk7XG5cbiAgICAgICAgLy8gaGVpZ2h0IGFuZCB3aWR0aFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9uc18ud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLm9wdGlvbnNfLndpZHRofXB4YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLm1heF93aWR0aCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5vcHRpb25zXy5tYXhfd2lkdGh9cHhgO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uYXV0b19maWxsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYDEwMCVgO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9uc18uaGVpZ2h0ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLm9wdGlvbnNfLmhlaWdodH1weGA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHNpbmNlIHRoZXNlIGFyZSBDU1MgdmFyaWFibGVzIHRoYXQgd2UgZGVmaW5lXG4gICAgICAgICAgICAvLyBmb3IgYWRhcHRpbmcgdG8gUXVhcnRvIHRoZW1lcywgd2UgbmVlZCB0byB1c2UgQ1NTXG4gICAgICAgICAgICAvLyB2YXJzIHRvIG92ZXJyaWRlIHRoZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0eWxlPy5iYWNrZ3JvdW5kX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZS5iYWNrZ3JvdW5kX2NvbG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc18uc3R5bGU/LmZvcmVncm91bmRfY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICctLWFnLWZvcmVncm91bmQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmZvcmVncm91bmRfY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zXy5zdHlsZT8uYWNjZW50X2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAnLS1hZy1hY2NlbnQtY29sb3InLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLnN0eWxlLmFjY2VudF9jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgZ3JpZCBjb250YWluZXJcbiAgICAgICAgdGhpcy5ncmlkQ29udGFpbmVyXyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmdyaWRDb250YWluZXJfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHRoaXMuZ3JpZENvbnRhaW5lcl8uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5ncmlkQ29udGFpbmVyXyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGdyaWQgb3B0aW9uc1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXyA9IHRoaXMuY3JlYXRlR3JpZE9wdGlvbnModGhpcy5vcHRpb25zXyk7XG4gICAgfVxuXG4gICAgLy8gY29udHJpYnV0ZSBhIHNlbGVjdGlvbiBjbGF1c2UgYmFjayB0byB0aGUgdGFyZ2V0IHNlbGVjdGlvblxuICAgIGNsYXVzZShyb3dzOiBudW1iZXJbXSA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkubWFwKGNvbHVtbiA9PiBjb2x1bW4uY29sdW1uX2lkKTtcblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5tYXAoZiA9PiB0aGlzLmRhdGFfLmNvbHVtbnNbZl1bcm93XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xhdXNlUG9pbnRzKGZpZWxkcywgdmFsdWVzLCB7IHNvdXJjZTogdGhpcyB9KTtcbiAgICB9XG5cbiAgICAvLyBtb3NhaWMgY2FsbHMgdGhpcyBhbmQgaW5pdGlhbGl6YXRpb24gdG8gbGV0IHVzIGZldGNoIHRoZSBzY2hlbWFcbiAgICAvLyBhbmQgZG8gcmVsYXRlZCBzZXR1cFxuICAgIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgICAgIC8vIHF1ZXJ5IGF2YWlsYWJsZSBjb2x1bW5zIGZyb20gdGhlIGRhdGFiYXNlXG4gICAgICAgIGNvbnN0IHRhYmxlID0gdGhpcy5vcHRpb25zXy5mcm9tO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCBxdWVyeUZpZWxkSW5mbyh0aGlzLmNvb3JkaW5hdG9yISwgW3sgY29sdW1uOiAnKicsIHRhYmxlIH1dKTtcblxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBjb2x1bW5zIHVzaW5nIGVpdGhlciB0aGUgdXNlciBwcm92aWRlZCBjb2x1bW5zIG9yIGFsbFxuICAgICAgICAvLyB0aGUgZmllbGRzIGluIHRoZSBzY2hlbWFcbiAgICAgICAgY29uc3QgdXNlckNvbHVtbnMgPSB0aGlzLm9wdGlvbnNfLmNvbHVtbnNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zXy5jb2x1bW5zXG4gICAgICAgICAgICA6IHNjaGVtYS5tYXAoZiA9PiBmLmNvbHVtbik7XG4gICAgICAgIHRoaXMuY29sdW1uc18gPSByZXNvbHZlQ29sdW1ucyh1c2VyQ29sdW1ucyk7XG4gICAgICAgIHRoaXMuY29sdW1uc0J5TmFtZV8gPSB0aGlzLmNvbHVtbnNfLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1tjb2wuY29sdW1uX25hbWVdID0gY29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgUmVzb2x2ZWRDb2x1bW4+XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggbm9uLWxpdGVyYWwgY29sdW1uLCB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIHR5cGVcbiAgICAgICAgLy8gRG8gdGhpcyBieSB1c2luZyB0aGUgc2NoZW1hIHF1ZXJ5IHRvIGdldCBjb2x1bW4gdHlwZXMgYW5kIHVzZSB0aGVcbiAgICAgICAgLy8gY29sdW1uIHR5cGUgYXMgdGhlIHR5cGUgKGV2ZW4gZm9yIGFnZ3JlZ2F0ZSBjb2x1bW5zICApXG4gICAgICAgIHRoaXMuY29sdW1uc19cbiAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLnR5cGUgIT09ICdsaXRlcmFsJylcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS5maW5kKHMgPT4gcy5jb2x1bW4gPT09IGNvbHVtbi5jb2x1bW5faWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2NvbHVtbi5jb2x1bW5fbmFtZV0gPSBpdGVtLnR5cGUgYXMgSlNUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZvciBsaXRlcmFscywgd2UgbmVlZCB0byBkZXRlcm1pbmUgdGhlaXIgdHlwZXMgYmFzZWQgb24gdGhlIHZhbHVlcyBwcm92aWRlZC5cbiAgICAgICAgdGhpcy5nZXRMaXRlcmFsQ29sdW1ucygpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2xWYWwgPSBjLmNvbHVtbjtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbFZhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZWVrIGF0IHRoZSBmaXJzdCBlbGVtZW50IHRvIGRldGVybWluZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsID0gY29sVmFsWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTdHIgPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlyc3RWYWwgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm9vbGVhbidcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGZpcnN0VmFsID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uVHlwZXNfW2MuY29sdW1uX25hbWVdID0gdHlwZVN0ciBhcyBKU1R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29sVmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdib29sZWFuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbFZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtblR5cGVzX1tjLmNvbHVtbl9uYW1lXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgY29sdW1uIGRlZmluaXRpb25zIGZvciBhZy1ncmlkXG4gICAgICAgIGNvbnN0IGNvbHVtbkRlZnM6IENvbERlZltdID0gdGhpcy5jb2x1bW5zXy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLmNvbHVtblR5cGVzX1tjb2x1bW4uY29sdW1uX25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29sdW1uRGVmKGNvbHVtbi5jb2x1bW5fbmFtZSwgdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyaWRPcHRpb25zXy5jb2x1bW5EZWZzID0gY29sdW1uRGVmcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkXyA9IGNyZWF0ZUdyaWQodGhpcy5ncmlkQ29udGFpbmVyXywgdGhpcy5ncmlkT3B0aW9uc18pO1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyBjYWxscyB0aGlzIGV2ZXJ5IHRpbWUgaXQgbmVlZHMgdG8gc2hvdyBkYXRhIHRvIGZpbmRcbiAgICAvLyBvdXQgd2hhdCBxdWVyeSB3ZSB3YW50IHRvIHJ1blxuICAgIHF1ZXJ5KGZpbHRlcjogRmlsdGVyRXhwcltdID0gW10pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0SXRlbXM6IFJlY29yZDxzdHJpbmcsIEV4cHJOb2RlIHwgc3RyaW5nPiA9IHt9O1xuICAgICAgICBjb25zdCBncm91cEJ5OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgaGFzX2FnZ3JlZ2F0ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjb2x1bW4gYW5kIGRldGVybWluZSB0aGUgc2VsZWN0IGl0ZW1cbiAgICAgICAgLy8gZm9yIHRoZSBjb2x1bW4uIFNvbWUgY29sdW1ucyBtYXkgbm90IGhhdmUgaXRlbXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IGFyZSBwcm92aWRpbmcgYSBsaXRlcmFsIG9yIGxpc3Qgb2YgbGl0ZXJhbHMuXG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIHRoaXMuZ2V0RGF0YWJhc2VDb2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW4udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gYWdncmVnYXRlRXhwcmVzc2lvbihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIHNlbGVjdEl0ZW1zW2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICAgICAgICBoYXNfYWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdW1uLnR5cGUgPT09ICdjb2x1bW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0SXRlbXNbY29sdW1uLmNvbHVtbl9pZF0gPSBjb2x1bW4uY29sdW1uX2lkO1xuICAgICAgICAgICAgICAgIGdyb3VwQnkucHVzaChjb2x1bW4uY29sdW1uX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgY29sdW1uc1xuICAgICAgICBsZXQgcXVlcnkgPSBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSkuc2VsZWN0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VsZWN0SXRlbXMpLmxlbmd0aCA/IHNlbGVjdEl0ZW1zIDogJyonXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gR3JvdXAgYnkgbm9uIGFnZ3JlZ2F0ZWQgY29sdW1uc1xuICAgICAgICBpZiAoaGFzX2FnZ3JlZ2F0ZSAmJiBncm91cEJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXJ5Lmdyb3VwYnkoZ3JvdXBCeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSB0aGUgZXh0ZXJuYWwgZmlsdGVyXG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkud2hlcmUoLi4uZmlsdGVyKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgZmlsdGVyIG1vZGVsXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZmlsdGVyTW9kZWxfKS5mb3JFYWNoKGNvbHVtbk5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5OYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChjb2wudHlwZSAhPT0gJ2xpdGVyYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlSGF2aW5nID0gY29sLnR5cGUgPT09ICdhZ2dyZWdhdGUnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVyTW9kZWxfW2NvbHVtbk5hbWVdIGFzIFN1cHBvcnRlZEZpbHRlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gZmlsdGVyRXhwcmVzc2lvbihjb2x1bW5OYW1lLCBmaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlSGF2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeS5oYXZpbmcoZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LndoZXJlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBseSBzb3J0aW5nXG4gICAgICAgIGlmICh0aGlzLnNvcnRNb2RlbF8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0TW9kZWxfLmZvckVhY2goc29ydCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tzb3J0LmNvbElkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoY29sLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyYnkoc29ydC5zb3J0ID09PSAnYXNjJyA/IGFzYyhzb3J0LmNvbElkKSA6IGRlc2Moc29ydC5jb2xJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIC8vIG1vc2FpYyByZXR1cm5zIHRoZSByZXN1bHRzIG9mIHRoZSBxdWVyeSgpIGluIHRoaXMgZnVuY3Rpb24uXG4gICAgcXVlcnlSZXN1bHQoZGF0YTogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YV8gPSB0b0RhdGFDb2x1bW5zKGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZXF1ZXN0cyBhIGNsaWVudCBVSSB1cGRhdGUgKGUuZy4gdG8gcmVmbGVjdCByZXN1bHRzIGZyb20gYSBxdWVyeSlcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZChudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVHcmlkID0gdGhyb3R0bGUoYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnZlcnQgY29sdW1uLWJhc2VkIGRhdGEgdG8gcm93LWJhc2VkIGRhdGEgZm9yIGFnLWdyaWRcbiAgICAgICAgY29uc3Qgcm93RGF0YTogYW55W10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGFfLm51bVJvd3M7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm93OiBhbnkgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc18uZm9yRWFjaCgoeyBjb2x1bW5fbmFtZSwgY29sdW1uIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSAlIGNvbHVtbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW5baW5kZXhdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBjb2x1bW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2x1bW5fbmFtZV0gPSBjb2x1bW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2NvbHVtbl9uYW1lXSA9IHRoaXMuZGF0YV8uY29sdW1uc1tjb2x1bW5fbmFtZV1baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJvd0RhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkXy5zZXRHcmlkT3B0aW9uKCdyb3dEYXRhJywgcm93RGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFfLm51bVJvd3MgPCBrQXV0b1Jvd0NvdW50ICYmIHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZF8uc2V0R3JpZE9wdGlvbignZG9tTGF5b3V0JywgJ2F1dG9IZWlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnNfLmF1dG9fZmlsbGluZyAmJlxuICAgICAgICAgICAgKHRoaXMub3B0aW9uc18uaGVpZ2h0ID09PSAnYXV0bycgfHwgdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7a0F1dG9Sb3dNYXhIZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcml2YXRlIGNyZWF0ZUdyaWRPcHRpb25zKG9wdGlvbnM6IFRhYmxlT3B0aW9ucyk6IEdyaWRPcHRpb25zIHtcbiAgICAgICAgY29uc3QgaGVhZGVySGVpZ2h0UGl4ZWxzID1cbiAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmhlYWRlcl9oZWlnaHQgPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogb3B0aW9ucy5oZWFkZXJfaGVpZ2h0O1xuICAgICAgICBjb25zdCBob3ZlclNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInO1xuICAgICAgICBjb25zdCBleHBsaWNpdFNlbGVjdGlvbiA9IHJlc29sdmVSb3dTZWxlY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gVGhlbWVcbiAgICAgICAgY29uc3QgZ3JpZFRoZW1lID0gdGhlbWVCYWxoYW0ud2l0aFBhcmFtcyh7XG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnRleHRfY29sb3IsXG4gICAgICAgICAgICBoZWFkZXJUZXh0Q29sb3I6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5zdHlsZT8uaGVhZGVyX3RleHRfY29sb3IgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8udGV4dF9jb2xvcixcbiAgICAgICAgICAgIGNlbGxUZXh0Q29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfdGV4dF9jb2xvcixcblxuICAgICAgICAgICAgZm9udEZhbWlseTogdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG4gICAgICAgICAgICBoZWFkZXJGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmhlYWRlcl9mb250X2ZhbWlseSB8fCB0aGlzLm9wdGlvbnNfLnN0eWxlPy5mb250X2ZhbWlseSxcbiAgICAgICAgICAgIGNlbGxGb250RmFtaWx5OlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uc3R5bGU/LmNlbGxfZm9udF9mYW1pbHkgfHwgdGhpcy5vcHRpb25zXy5zdHlsZT8uZm9udF9mYW1pbHksXG5cbiAgICAgICAgICAgIHNwYWNpbmc6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNwYWNpbmcgfHwgNCxcblxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LmJvcmRlcl9jb2xvcixcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogdGhpcy5vcHRpb25zXy5zdHlsZT8uYm9yZGVyX3JhZGl1cyxcblxuICAgICAgICAgICAgc2VsZWN0ZWRSb3dCYWNrZ3JvdW5kQ29sb3I6IHRoaXMub3B0aW9uc18uc3R5bGU/LnNlbGVjdGVkX3Jvd19iYWNrZ3JvdW5kX2NvbG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZG9tTGF5b3V0ID0gdGhpcy5vcHRpb25zXy5oZWlnaHQgPT09ICdhdXRvJyA/ICdhdXRvSGVpZ2h0JyA6IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBpbml0aWFsaXplIGdyaWQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHBhc3MgZmlsdGVyIHRvIGFsbG93IHNlcnZlci1zaWRlIGZpbHRlcmluZ1xuICAgICAgICAgICAgcGFnaW5hdGlvbjogISFvcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgICAgICBwYWdpbmF0aW9uQXV0b1BhZ2VTaXplOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplID09PSAnYXV0bycgfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplU2VsZWN0b3I6IG9wdGlvbnMucGFnaW5hdGlvbj8ucGFnZV9zaXplX3NlbGVjdG9yLFxuICAgICAgICAgICAgcGFnaW5hdGlvblBhZ2VTaXplOlxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLnBhZ2luYXRpb24/LnBhZ2Vfc2l6ZSA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnBhZ2luYXRpb24ucGFnZV9zaXplXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZVJvd3M6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVySGVpZ2h0OiBoZWFkZXJIZWlnaHRQaXhlbHMsXG4gICAgICAgICAgICByb3dIZWlnaHQ6IG9wdGlvbnMucm93X2hlaWdodCxcbiAgICAgICAgICAgIGRvbUxheW91dCxcbiAgICAgICAgICAgIGNvbHVtbkRlZnM6IFtdLFxuICAgICAgICAgICAgcm93RGF0YTogW10sXG4gICAgICAgICAgICByb3dTZWxlY3Rpb246IGV4cGxpY2l0U2VsZWN0aW9uLFxuICAgICAgICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRoZW1lOiBncmlkVGhlbWUsXG4gICAgICAgICAgICBvbkZpbHRlckNoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmaWx0ZXIgbW9kZWwgZm9yIHNlcnZlci1zaWRlIHVzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZWxfID0gdGhpcy5ncmlkXz8uZ2V0RmlsdGVyTW9kZWwoKSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgc2VydmVyLXNpZGUgcXVlcnlcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU29ydENoYW5nZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ncmlkXykge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0TW9kZWwgPSB0aGlzLmdyaWRfXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q29sdW1uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihjb2wgPT4gY29sLnNvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGNvbCA9PiAoeyBjb2xJZDogY29sLmNvbElkLCBzb3J0OiBjb2wuc29ydCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ydE1vZGVsXyA9IHNvcnRNb2RlbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXJ5IHVzaW5nIHRoZSBuZXcgc29ydCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RRdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwbGljaXRTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzZWxlY3RlZCByb3dzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dJbmRpY2VzID0gZXZlbnQuc2VsZWN0ZWROb2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAobiA9PiBuLnJvd0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobiA9PiBuICE9PSBudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gY2xhdXNlIGluIHRoZSB0YXJnZXQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh0aGlzLmNsYXVzZShyb3dJbmRpY2VzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DZWxsTW91c2VPdmVyOiBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyU2VsZWN0ICYmIGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gZXZlbnQucm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRleCAhPT0gdGhpcy5jdXJyZW50Um93X1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJvd18gPSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKFtyb3dJbmRleF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNlbGxNb3VzZU91dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChob3ZlclNlbGVjdCAmJiBpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3dfID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc18uYXMudXBkYXRlKHRoaXMuY2xhdXNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkdyaWRSZWFkeTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGdyaWQgaXMgcmVhZHksIHdlIGNhbiB1cGRhdGUgaXQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaEdyaWQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMaXRlcmFsQ29sdW1ucygpOiBSZXNvbHZlZExpdGVyYWxDb2x1bW5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2xpdGVyYWwnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldERhdGFiYXNlQ29sdW1ucygpOiBBcnJheTxSZXNvbHZlZFNpbXBsZUNvbHVtbiB8IFJlc29sdmVkQWdncmVnYXRlQ29sdW1uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNfLmZpbHRlcihjID0+IGMudHlwZSA9PT0gJ2NvbHVtbicgfHwgYy50eXBlID09PSAnYWdncmVnYXRlJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5EZWYoY29sdW1uX25hbWU6IHN0cmluZywgdHlwZTogSlNUeXBlKTogQ29sRGVmIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5jb2x1bW5zQnlOYW1lX1tjb2x1bW5fbmFtZV0gfHwge307XG5cbiAgICAgICAgLy8gQWxpZ24sIG51bWJlcnMgcmlnaHQgYWxpZ25lZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGFsaWduID0gY29sdW1uLmFsaWduIHx8ICh0eXBlID09PSAnbnVtYmVyJyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICBjb25zdCBoZWFkZXJBbGlnbm1lbnQgPSBjb2x1bW4uaGVhZGVyX2FsaWduO1xuXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyRm9yVHlwZSh0eXBlLCBjb2x1bW4uZm9ybWF0KTtcblxuICAgICAgICAvLyBTb3J0aW5nIC8gZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5vcHRpb25zXy5zb3J0aW5nICE9PSBmYWxzZSAmJiBjb2x1bW4uc29ydGFibGUgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBmaWx0ZXJhYmxlID0gdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgIT09IGZhbHNlICYmIGNvbHVtbi5maWx0ZXJhYmxlICE9PSBmYWxzZTtcblxuICAgICAgICAvLyBTaXppbmdcbiAgICAgICAgY29uc3QgcmVzaXphYmxlID0gY29sdW1uLnJlc2l6YWJsZSAhPT0gZmFsc2U7XG5cbiAgICAgICAgLy8gTWluIGFuZCBtYXggd2lkdGhcbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBjb2x1bW4ubWluX3dpZHRoO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IGNvbHVtbi5tYXhfd2lkdGg7XG5cbiAgICAgICAgLy8gYXV0byBoZWlnaHRcbiAgICAgICAgY29uc3QgYXV0b0hlaWdodCA9IGNvbHVtbi5hdXRvX2hlaWdodDtcbiAgICAgICAgY29uc3QgYXV0b0hlYWRlckhlaWdodCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmhlYWRlcl9oZWlnaHQgPT09ICdhdXRvJyAmJiBjb2x1bW4uaGVhZGVyX2F1dG9faGVpZ2h0ICE9PSBmYWxzZTtcblxuICAgICAgICAvLyB3cmFwIHRleHRcbiAgICAgICAgY29uc3Qgd3JhcFRleHQgPSBjb2x1bW4ud3JhcF90ZXh0O1xuICAgICAgICBjb25zdCB3cmFwSGVhZGVyVGV4dCA9IGNvbHVtbi5oZWFkZXJfd3JhcF90ZXh0O1xuXG4gICAgICAgIC8vIGZsZXhcbiAgICAgICAgY29uc3QgZmxleCA9IGNvbHVtbi5mbGV4O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGNsaWVudCBzaWRlIHNvcnRpbmcgKHVzZWQgZm9yIG5vbi1saXRlcmFsIGNvbHVtbnNcbiAgICAgICAgLy8gd2hlcmUgdGhlIGRhdGFiYXNlIGNhbiBoYW5kbGUgdGhlIHNvcnRpbmcpXG4gICAgICAgIGNvbnN0IGRpc2FibGVDbGllbnRTb3J0ID0gKF92YWx1ZUE6IHVua25vd24sIF92YWx1ZUI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBmaWx0ZXIgYmVsb3cgdGhlIGhlYWRlclxuICAgICAgICBjb25zdCBjb2xEZWY6IENvbERlZiA9IHtcbiAgICAgICAgICAgIGZpZWxkOiBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlck5hbWU6IGNvbHVtbi5sYWJlbCB8fCBjb2x1bW5fbmFtZSxcbiAgICAgICAgICAgIGhlYWRlckNsYXNzOiBoZWFkZXJDbGFzc2VzKGhlYWRlckFsaWdubWVudCksXG4gICAgICAgICAgICBjZWxsU3R5bGU6IHsgdGV4dEFsaWduOiBhbGlnbiB9LFxuICAgICAgICAgICAgY29tcGFyYXRvcjogY29sdW1uLnR5cGUgIT09ICdsaXRlcmFsJyA/IGRpc2FibGVDbGllbnRTb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsdGVyOiAhZmlsdGVyYWJsZSA/IGZhbHNlIDogZmlsdGVyRm9yQ29sdW1uVHlwZSh0eXBlKSxcbiAgICAgICAgICAgIGZsZXgsXG4gICAgICAgICAgICBzb3J0YWJsZSxcbiAgICAgICAgICAgIHJlc2l6YWJsZSxcbiAgICAgICAgICAgIG1pbldpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICBhdXRvSGVpZ2h0LFxuICAgICAgICAgICAgYXV0b0hlYWRlckhlaWdodCxcbiAgICAgICAgICAgIHdyYXBUZXh0LFxuICAgICAgICAgICAgd3JhcEhlYWRlclRleHQsXG4gICAgICAgICAgICBmbG9hdGluZ0ZpbHRlcjogdGhpcy5vcHRpb25zXy5maWx0ZXJpbmcgPT09ICdyb3cnLFxuICAgICAgICAgICAgLy8gRGlzYWJsZSBjb2x1bW4gbW92aW5nXG4gICAgICAgICAgICBzdXBwcmVzc01vdmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdHRlcjogcGFyYW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlIGlmIGEgZm9ybWF0IGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlciAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldCBjb2x1bW5zIHdpZHRocywgaWYgZXhwbGljaXRseSBwcm92aWRlZFxuICAgICAgICAvLyBvdGhlcndpc2UgdXNlIGZsZXggdG8gbWFrZSBhbGwgY29sdW1ucyBlcXVhbFxuICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbi53aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBjb2xEZWYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChmbGV4ID09PSB1bmRlZmluZWQgfHwgZmxleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29sRGVmLmZsZXggPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbERlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhdGNoR3JpZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyaWRfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb2x1bW5zID0gdGhpcy5ncmlkXy5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goYXN5bmMgY29sdW1uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xJZCA9IGNvbHVtbi5nZXRDb2xJZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckluc3RhbmNlID0gYXdhaXQgdGhpcy5ncmlkXyEuZ2V0Q29sdW1uRmlsdGVySW5zdGFuY2UoY29sSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuY29sdW1uc0J5TmFtZV9bY29sSWRdIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdG8gZGlzYWJsZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgc28gd2UgY2FuIGltcGxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyB1c2luZyB0aGUgcXVlcnkgbWV0aG9kIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsaXRlcmFsIGNvbHVtbnMgYXJlbid0IGZpbHRlcmVkIGluIHRoZSBkYXRhYmFzZSwgd2UgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHVzZSBjbGllbnQgc2lkZSBmaWx0ZXJpbmcgZm9yIHRoZXNlXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVySW5zdGFuY2UuZG9lc0ZpbHRlclBhc3MgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAgICAgY29sLnR5cGUgIT09ICdsaXRlcmFsJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbnN0YW5jZS5kb2VzRmlsdGVyUGFzcyA9ICgpID0+IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgbW9zYWljIGlucHV0cyBpbXBsZW1lbnQgdGhpcywgbm90IGV4YWN0bHkgc3VyZSB3aGF0IGl0IGRvZXNcbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKFtdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlc29sdmVDb2x1bW5zID0gKGNvbHVtbnM6IEFycmF5PHN0cmluZyB8IENvbHVtbj4pOiBSZXNvbHZlZENvbHVtbltdID0+IHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSAxO1xuICAgIGNvbnN0IGluY3JlbWVudGVkQ29sdW1uTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBjb2xfJHtjb2x1bW5Db3VudCsrfWA7XG4gICAgfTtcblxuICAgIHJldHVybiBjb2x1bW5zLm1hcChjb2wgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIENvbHVtbiBpcyBqdXN0IGEgY29sdW1uIGlkXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uX2lkOiBjb2wsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2wsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvbHVtbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wgPT09ICdvYmplY3QnICYmIGNvbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29sdW1uIGlzIGFuIG9iamVjdCAoYSBDb2x1bW4pLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvIHByb3Blcmx5IHJlc29sdmUgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29sLmNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5faWQ6IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2wuY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBudW1iZXIsIHRyZWF0IGl0IGFzIGFuIGluZGV4XG4gICAgICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGNvbHVtbl9pZCBzaW5jZSBpdCBpc24ndCBpbiB0aGUgZGF0YWJhc2UgLSB3ZSBnZW5lcmF0ZVxuICAgICAgICAgICAgICAgIC8vIGEgZGlzcGxheSBhbGlhcyBmb3IgaXRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2x1bW4gaXMgYSBib29sZWFuLCB0cmVhdCBpdCBhcyBhIGZsYWdcbiAgICAgICAgICAgICAgICAvLyBJdCBoYXMgbm8gY29sdW1uX2lkIHNpbmNlIGl0IGlzbid0IGluIHRoZSBkYXRhYmFzZSAtIHdlIGdlbmVyYXRlXG4gICAgICAgICAgICAgICAgLy8gYSBkaXNwbGF5IGFsaWFzIGZvciBpdFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGluY3JlbWVudGVkQ29sdW1uTmFtZSgpLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbC5jb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gcGVlayBhdCB0aGUgZmlyc3QgZWxlbWVudCB0byBkZXRlcm1pbmUgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoY29sLmNvbHVtbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBhcnJheSBjb2x1bW4gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb2wsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbl9uYW1lOiBpbmNyZW1lbnRlZENvbHVtbk5hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2wuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbC5jb2x1bW4gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWdnID0gT2JqZWN0LmtleXMoY29sLmNvbHVtbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uID0gY29sLmNvbHVtblthZ2ddO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX25hbWU6IGAke2FnZ31fJHt0YXJnZXRDb2x1bW59YCxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uX2lkOiB0YXJnZXRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByOiBhZ2csXG4gICAgICAgICAgICAgICAgICAgIGFnZ19leHByX2FyZ3M6IFt0YXJnZXRDb2x1bW5dLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGNvbHVtbiB0eXBlOiAnICsgdHlwZW9mIGNvbC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbHVtbiBkZWZpbml0aW9uOiAke2NvbH1gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgaGVhZGVyQ2xhc3NlcyA9IChhbGlnbj86ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyB8ICdqdXN0aWZ5Jyk6IHN0cmluZ1tdIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWFsaWduKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBbYGhlYWRlci0ke2FsaWdufWBdO1xufTtcblxuY29uc3QgcmVzb2x2ZVJvd1NlbGVjdGlvbiA9IChvcHRpb25zOiBUYWJsZU9wdGlvbnMpOiBSb3dTZWxlY3Rpb25PcHRpb25zPGFueSwgYW55PiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0ID09PSAnaG92ZXInKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0VHlwZSA9IG9wdGlvbnMuc2VsZWN0IHx8ICdzaW5nbGVfcm93JztcbiAgICBpZiAoc2VsZWN0VHlwZS5zdGFydHNXaXRoKCdzaW5nbGVfJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6ICdzaW5nbGVSb3cnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdzaW5nbGVfY2hlY2tib3gnLFxuICAgICAgICAgICAgZW5hYmxlQ2xpY2tTZWxlY3Rpb246IG9wdGlvbnMuc2VsZWN0ID09PSAnc2luZ2xlX3JvdycsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzZWxlY3RUeXBlLnN0YXJ0c1dpdGgoJ211bHRpcGxlXycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiAnbXVsdGlSb3cnLFxuICAgICAgICAgICAgc2VsZWN0QWxsOiAnZmlsdGVyZWQnLFxuICAgICAgICAgICAgY2hlY2tib3hlczogb3B0aW9ucy5zZWxlY3QgPT09ICdtdWx0aXBsZV9jaGVja2JveCcsXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdCBvcHRpb246ICcgKyBvcHRpb25zLnNlbGVjdCk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsdGVyRm9yQ29sdW1uVHlwZSA9ICh0eXBlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIC8vIFNlbGVjdCB0aGUgcHJvcGVyIGZpbHRlciB0eXBlIGJhc2VkIG9uIHRoZSBjb2x1bW4gdHlwZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICBjYXNlICdkZWNpbWFsJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdOdW1iZXJDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgcmV0dXJuICdhZ0RhdGVDb2x1bW5GaWx0ZXInO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnYWdUZXh0Q29sdW1uRmlsdGVyJztcbiAgICB9XG59O1xuXG5jb25zdCBmb3JtYXR0ZXJGb3JUeXBlID0gKHR5cGU6IHN0cmluZywgZm9ybWF0U3RyPzogc3RyaW5nKSA9PiB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywnKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuMn5mJyk7XG4gICAgICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChmb3JtYXRTdHIgfHwgJywuNH5mJyk7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGUgZm9ybWF0ICgyMDI0LTAzLTE1KVxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQnKTtcbiAgICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgICBjYXNlICd0aW1lc3RhbXAnOlxuICAgICAgICAgICAgLy8gSVNPIGRhdGV0aW1lIGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIGQzVGltZUZvcm1hdC50aW1lRm9ybWF0KGZvcm1hdFN0ciB8fCAnJVktJW0tJWQgJUg6JU06JVMnKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbnR5cGUgQmFzZUZpbHRlciA9XG4gICAgfCBUZXh0RmlsdGVyTW9kZWxcbiAgICB8IE51bWJlckZpbHRlck1vZGVsXG4gICAgfCBEYXRlRmlsdGVyTW9kZWxcbiAgICB8IElNdWx0aUZpbHRlck1vZGVsXG4gICAgfCBTZXRGaWx0ZXJNb2RlbDtcblxudHlwZSBTdXBwb3J0ZWRGaWx0ZXIgPSBCYXNlRmlsdGVyIHwgSUNvbWJpbmVkU2ltcGxlTW9kZWw8QmFzZUZpbHRlcj47XG5cbmNvbnN0IGZpbHRlckV4cHJlc3Npb24gPSAoXG4gICAgY29sSWQ6IHN0cmluZyxcbiAgICBmaWx0ZXI6IFN1cHBvcnRlZEZpbHRlcixcbiAgICBxdWVyeTogU2VsZWN0UXVlcnlcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoaXNDb21iaW5lZFNpbXBsZU1vZGVsKGZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWx0ZXIub3BlcmF0b3IgPT09ICdBTkQnID8gYW5kIDogb3I7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZmlsdGVyLmNvbmRpdGlvbnNcbiAgICAgICAgICAgID8ubWFwKChmOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyRXhwcmVzc2lvbihjb2xJZCwgZiBhcyBTdXBwb3J0ZWRGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICYmIGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciguLi5leHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dEZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGVFeHByZXNzaW9uKGNvbElkLCBmaWx0ZXIudHlwZSwgZmlsdGVyLmZpbHRlciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZmlsdGVyKTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlGaWx0ZXIoZmlsdGVyKSkge1xuICAgICAgICBjb25zdCBleHByID0gZmlsdGVyLmZpbHRlck1vZGVsc1xuICAgICAgICAgICAgPy5tYXAoKGY6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJFeHByZXNzaW9uKGNvbElkLCBmLCBxdWVyeSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuZCguLi5leHByKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEYXRlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUV4cHJlc3Npb24oY29sSWQsIGZpbHRlci50eXBlLCBmaWx0ZXIuZGF0ZUZyb20sIGZpbHRlci5kYXRlVG8gfHwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2V0RmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTZXQgZmlsdGVyIG5vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzaW1wbGVFeHByZXNzaW9uID0gKFxuICAgIGNvbElkOiBzdHJpbmcsXG4gICAgdHlwZTpcbiAgICAgICAgfCAnZW1wdHknXG4gICAgICAgIHwgJ2VxdWFscydcbiAgICAgICAgfCAnbm90RXF1YWwnXG4gICAgICAgIHwgJ2xlc3NUaGFuJ1xuICAgICAgICB8ICdsZXNzVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2dyZWF0ZXJUaGFuJ1xuICAgICAgICB8ICdncmVhdGVyVGhhbk9yRXF1YWwnXG4gICAgICAgIHwgJ2luUmFuZ2UnXG4gICAgICAgIHwgJ2NvbnRhaW5zJ1xuICAgICAgICB8ICdub3RDb250YWlucydcbiAgICAgICAgfCAnc3RhcnRzV2l0aCdcbiAgICAgICAgfCAnZW5kc1dpdGgnXG4gICAgICAgIHwgJ2JsYW5rJ1xuICAgICAgICB8ICdub3RCbGFuaydcbiAgICAgICAgfCBudWxsXG4gICAgICAgIHwgdW5kZWZpbmVkLFxuICAgIGZpbHRlcjogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBmaWx0ZXJUbzogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgICB0ZXh0Q29sdW1uOiBib29sZWFuID0gZmFsc2Vcbik6IEV4cHJOb2RlIHwgdW5kZWZpbmVkID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZXF1YWxzJzpcbiAgICAgICAgICAgIHJldHVybiBlcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnbm90RXF1YWwnOlxuICAgICAgICAgICAgcmV0dXJuIG5lcShjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnY29udGFpbnMnOlxuICAgICAgICAgICAgaWYgKHRleHRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FsYCR7Y29sdW1uKGNvbElkKX0gSUxJS0UgJHtsaXRlcmFsKCclJyArIGZpbHRlciArICclJyl9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGNvbElkLCBTdHJpbmcoZmlsdGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ25vdENvbnRhaW5zJzpcbiAgICAgICAgICAgIHJldHVybiBub3QoY29udGFpbnMoY29sSWQsIFN0cmluZyhmaWx0ZXIpKSk7XG4gICAgICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgICAgICAgIHJldHVybiBpc051bGwoY29sSWQpO1xuICAgICAgICBjYXNlICdub3RCbGFuayc6XG4gICAgICAgICAgICByZXR1cm4gbm90KGlzTnVsbChjb2xJZCkpO1xuICAgICAgICBjYXNlICdzdGFydHNXaXRoJzpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXgoY29sSWQsIFN0cmluZyhmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZW5kc1dpdGgnOlxuICAgICAgICAgICAgcmV0dXJuIHN1ZmZpeChjb2xJZCwgU3RyaW5nKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdncmVhdGVyVGhhbic6XG4gICAgICAgICAgICByZXR1cm4gZ3QoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuJzpcbiAgICAgICAgICAgIHJldHVybiBsdChjb2xJZCwgbGl0ZXJhbChmaWx0ZXIpKTtcbiAgICAgICAgY2FzZSAnZ3JlYXRlclRoYW5PckVxdWFsJzpcbiAgICAgICAgICAgIHJldHVybiBndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSk7XG4gICAgICAgIGNhc2UgJ2xlc3NUaGFuT3JFcXVhbCc6XG4gICAgICAgICAgICByZXR1cm4gbHRlKGNvbElkLCBsaXRlcmFsKGZpbHRlcikpO1xuICAgICAgICBjYXNlICdpblJhbmdlJzpcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUbyAhPT0gdW5kZWZpbmVkICYmIGZpbHRlclRvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChndGUoY29sSWQsIGxpdGVyYWwoZmlsdGVyKSksIGx0ZShjb2xJZCwgbGl0ZXJhbChmaWx0ZXJUbykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBmaWx0ZXIgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgYWdncmVnYXRlRXhwcmVzc2lvbiA9IChcbiAgICBjOiBSZXNvbHZlZEFnZ3JlZ2F0ZUNvbHVtblxuKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgIGNvbnN0IGFnZ0V4cHIgPSBjLmFnZ19leHByO1xuXG4gICAgY29uc3QgZmlyc3RBcmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjLmFnZ19leHByX2FyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGMuYWdnX2V4cHJfYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFnZ3JlZ2F0ZSBleHByZXNzaW9uICR7YWdnRXhwcn0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50YCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNlY29uZEFyZyA9ICgpID0+IHtcbiAgICAgICAgaWYgKGMuYWdnX2V4cHJfYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5hZ2dfZXhwcl9hcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWdncmVnYXRlIGV4cHJlc3Npb24gJHthZ2dFeHByfSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJndW1lbnRzYCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHIgPSAodmFsOiBBZ2dyZWdhdGVOb2RlKTogW2FsaWFzOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlTm9kZV0gPT4ge1xuICAgICAgICByZXR1cm4gW2MuY29sdW1uX25hbWUsIHZhbF07XG4gICAgfTtcblxuICAgIHN3aXRjaCAoYWdnRXhwcikge1xuICAgICAgICBjYXNlICdjb3VudCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3VudChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3N1bSc6XG4gICAgICAgICAgICByZXR1cm4gcihzdW0oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhdmcnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXZnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKGFyZ21heChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdtYWQnOlxuICAgICAgICAgICAgcmV0dXJuIHIobWFkKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgIHJldHVybiByKG1heChmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICByZXR1cm4gcihtaW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdwcm9kdWN0JzpcbiAgICAgICAgICAgIHJldHVybiByKHByb2R1Y3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdnZW9tZWFuJzpcbiAgICAgICAgICAgIHJldHVybiByKGdlb21lYW4oZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdtZWRpYW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIobWVkaWFuKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnbW9kZSc6XG4gICAgICAgICAgICByZXR1cm4gcihtb2RlKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAndmFyaWFuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHIodmFyaWFuY2UoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXYnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2KGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnc2tld25lc3MnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc2tld25lc3MoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdrdXJ0b3Npcyc6XG4gICAgICAgICAgICByZXR1cm4gcihrdXJ0b3NpcyhmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2VudHJvcHknOlxuICAgICAgICAgICAgcmV0dXJuIHIoZW50cm9weShmaXJzdEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcih2YXJQb3AoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdGRkZXZQb3AnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RkZGV2UG9wKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHIoZmlyc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdsYXN0JzpcbiAgICAgICAgICAgIHJldHVybiByKGxhc3QoZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdzdHJpbmdBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoc3RyaW5nQWdnKGZpcnN0QXJnKCkpKTtcbiAgICAgICAgY2FzZSAnYXJyYXlBZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJyYXlBZ2coZmlyc3RBcmcoKSkpO1xuICAgICAgICBjYXNlICdhcmdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIoYXJnbWluKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3F1YW50aWxlJzpcbiAgICAgICAgICAgIHJldHVybiByKHF1YW50aWxlKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ2NvcnInOlxuICAgICAgICAgICAgcmV0dXJuIHIoY29ycihmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdjb3ZhclBvcCc6XG4gICAgICAgICAgICByZXR1cm4gcihjb3ZhclBvcChmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdySW50ZXJjZXB0JzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JJbnRlcmNlcHQoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNsb3BlJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTbG9wZShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyQ291bnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckNvdW50KGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JSMic6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyUjIoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnclNYWCc6XG4gICAgICAgICAgICByZXR1cm4gcihyZWdyU1hYKGZpcnN0QXJnKCksIHNlY29uZEFyZygpKSk7XG4gICAgICAgIGNhc2UgJ3JlZ3JTWVknOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnclNZWShmaXJzdEFyZygpLCBzZWNvbmRBcmcoKSkpO1xuICAgICAgICBjYXNlICdyZWdyU1hZJzpcbiAgICAgICAgICAgIHJldHVybiByKHJlZ3JTWFkoZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1gnOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1goZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgY2FzZSAncmVnckF2Z1knOlxuICAgICAgICAgICAgcmV0dXJuIHIocmVnckF2Z1koZmlyc3RBcmcoKSwgc2Vjb25kQXJnKCkpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWdncmVnYXRlIGV4cHJlc3Npb246ICR7YWdnRXhwcn0uYCk7XG4gICAgfVxufTtcblxuY29uc3QgaXNDb21iaW5lZFNpbXBsZU1vZGVsID0gKFxuICAgIGZpbHRlcjogYW55XG4pOiBmaWx0ZXIgaXMgSUNvbWJpbmVkU2ltcGxlTW9kZWw8VGV4dEZpbHRlck1vZGVsIHwgTnVtYmVyRmlsdGVyTW9kZWw+ID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0eXBlb2YgZmlsdGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBmaWx0ZXIgIT09IG51bGwgJiZcbiAgICAgICAgJ29wZXJhdG9yJyBpbiBmaWx0ZXIgJiZcbiAgICAgICAgJ2NvbmRpdGlvbnMnIGluIGZpbHRlciAmJlxuICAgICAgICAoZmlsdGVyLm9wZXJhdG9yID09PSAnQU5EJyB8fCBmaWx0ZXIub3BlcmF0b3IgPT09ICdPUicpICYmXG4gICAgICAgIHR5cGVvZiBmaWx0ZXIuY29uZGl0aW9ucyA9PT0gJ29iamVjdCdcbiAgICApO1xufTtcblxuY29uc3QgaXNUZXh0RmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIFRleHRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3RleHQnO1xufTtcblxuY29uc3QgaXNOdW1iZXJGaWx0ZXIgPSAoZmlsdGVyOiBhbnkpOiBmaWx0ZXIgaXMgTnVtYmVyRmlsdGVyTW9kZWwgPT4ge1xuICAgIHJldHVybiBmaWx0ZXI/LmZpbHRlclR5cGUgPT09ICdudW1iZXInO1xufTtcblxuY29uc3QgaXNEYXRlRmlsdGVyID0gKGZpbHRlcjogYW55KTogZmlsdGVyIGlzIERhdGVGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGUnIHx8IGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ2RhdGVTdHJpbmcnO1xufTtcblxuY29uc3QgaXNNdWx0aUZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBJTXVsdGlGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ211bHRpJyAmJiAnZmlsdGVyTW9kZWxzJyBpbiBmaWx0ZXI7XG59O1xuXG5jb25zdCBpc1NldEZpbHRlciA9IChmaWx0ZXI6IGFueSk6IGZpbHRlciBpcyBTZXRGaWx0ZXJNb2RlbCA9PiB7XG4gICAgcmV0dXJuIGZpbHRlcj8uZmlsdGVyVHlwZSA9PT0gJ3NldCc7XG59O1xuIiwgImltcG9ydCB7XG4gICAgY2xhdXNlTWF0Y2gsXG4gICAgaXNQYXJhbSxcbiAgICBpc1NlbGVjdGlvbixcbiAgICBTZWxlY3Rpb25DbGF1c2UsXG59IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtY29yZUAwLjE2LjIvK2VzbSc7XG5pbXBvcnQgeyBGaWx0ZXJFeHByLCBRdWVyeSB9IGZyb20gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHV3ZGF0YS9tb3NhaWMtc3FsQDAuMTYuMi8rZXNtJztcbmltcG9ydCB7IElucHV0LCBJbnB1dE9wdGlvbnMgfSBmcm9tICcuL2lucHV0JztcbmltcG9ydCB7IHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSAnLi4vdXRpbC9pZCc7XG5pbXBvcnQgeyBrSW5wdXRTZWFyY2gsIGtTaWRlYmFyRnVsbHdpZHRoIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoT3B0aW9ucyBleHRlbmRzIElucHV0T3B0aW9ucyB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHR5cGU6ICdjb250YWlucycgfCAncHJlZml4JyB8ICdzdWZmaXgnIHwgJ3JlZ2V4cCc7XG4gICAgY29sdW1uOiBzdHJpbmc7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgd2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2ggZXh0ZW5kcyBJbnB1dCB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnB1dF86IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBpZF86IHN0cmluZyA9IGdlbmVyYXRlSWQoKTtcbiAgICBwcml2YXRlIGRhdGFfOiBBcnJheTx7IGxpc3Q6IHN0cmluZyB9PiA9IFtdO1xuICAgIHByaXZhdGUgZGF0YWxpc3RfPzogSFRNTERhdGFMaXN0RWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBvcHRpb25zXzogU2VhcmNoT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zXy5maWx0ZXJCeSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoa1NpZGViYXJGdWxsd2lkdGgpO1xuXG4gICAgICAgIGlmIChvcHRpb25zXy5sYWJlbCkge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIHRoaXMuaWRfKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuaW5uZXJUZXh0ID0gb3B0aW9uc18ubGFiZWw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5wdXRMYWJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmF1dG9jb21wbGV0ZSA9ICdvZmYnO1xuICAgICAgICB0aGlzLmlucHV0Xy5jbGFzc0xpc3QuYWRkKGtJbnB1dFNlYXJjaCk7XG4gICAgICAgIHRoaXMuaW5wdXRfLmlkID0gdGhpcy5pZF87XG4gICAgICAgIHRoaXMuaW5wdXRfLnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNfLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0Xy5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgdGhpcy5vcHRpb25zXy5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc18ud2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRfLnN0eWxlLndpZHRoID0gYCR7b3B0aW9uc18ud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Xyk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBzZWFyY2ggYm94XG4gICAgICAgIHRoaXMuaW5wdXRfLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMuaW5wdXRfLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdHJhY2sgY2hhbmdlcyB0byBwYXJhbVxuICAgICAgICBpZiAoIWlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3ZhbHVlJywgdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5pbnB1dF8udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHVwQWN0aXZhdGlvbkxpc3RlbmVycyh0aGlzLCB0aGlzLmlucHV0Xyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dF8udmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBjbGF1c2UodmFsdWU/OiBzdHJpbmcpOiBTZWxlY3Rpb25DbGF1c2Uge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMub3B0aW9uc18uZmllbGQgfHwgdGhpcy5vcHRpb25zXy5jb2x1bW47XG4gICAgICAgIHJldHVybiBjbGF1c2VNYXRjaChmaWVsZCwgdmFsdWUsIHsgc291cmNlOiB0aGlzLCBtZXRob2Q6IHRoaXMub3B0aW9uc18udHlwZSB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLmFjdGl2YXRlKHRoaXMuY2xhdXNlKCcnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaXNoKHZhbHVlPzogc3RyaW5nKSB7XG4gICAgICAgIGlmIChpc1NlbGVjdGlvbih0aGlzLm9wdGlvbnNfLmFzKSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zXy5hcy51cGRhdGUodGhpcy5jbGF1c2UodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BhcmFtKHRoaXMub3B0aW9uc18uYXMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNfLmFzLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBxdWVyeShmaWx0ZXI6IEZpbHRlckV4cHJbXSA9IFtdKSB7XG4gICAgICAgIHJldHVybiBRdWVyeS5mcm9tKHRoaXMub3B0aW9uc18uZnJvbSlcbiAgICAgICAgICAgIC5zZWxlY3QoeyBsaXN0OiB0aGlzLm9wdGlvbnNfLmNvbHVtbiB9KVxuICAgICAgICAgICAgLmRpc3RpbmN0KClcbiAgICAgICAgICAgIC53aGVyZSguLi5maWx0ZXIpO1xuICAgIH1cblxuICAgIHF1ZXJ5UmVzdWx0KGRhdGE6IGFueSk6IHRoaXMge1xuICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdXBkYXRlKCk6IHRoaXMge1xuICAgICAgICBjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGF0YWxpc3QnKTtcbiAgICAgICAgY29uc3QgaWQgPSBgJHt0aGlzLmlkX31fbGlzdGA7XG4gICAgICAgIGxpc3Quc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIHRoaXMuZGF0YV8pIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICAgICAgb3B0LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkLmxpc3QpO1xuICAgICAgICAgICAgbGlzdC5hcHBlbmQob3B0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhbGlzdF8pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YWxpc3RfLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCgodGhpcy5kYXRhbGlzdF8gPSBsaXN0KSk7XG4gICAgICAgIHRoaXMuaW5wdXRfLnNldEF0dHJpYnV0ZSgnbGlzdCcsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFJhZGlvR3JvdXAgfSBmcm9tICcuL3JhZGlvX2dyb3VwJztcbmltcG9ydCB7IFNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IGlucHV0LCBJbnB1dEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnB1dCc7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwIH0gZnJvbSAnLi9jaGVja2JveF9ncm91cCc7XG5pbXBvcnQgeyBDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgU2xpZGVyIH0gZnJvbSAnLi9zbGlkZXInO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7IFNlYXJjaCB9IGZyb20gJy4vc2VhcmNoJztcblxuZXhwb3J0IGNvbnN0IElOUFVUUzogUmVjb3JkPHN0cmluZywgSW5wdXRGdW5jdGlvbj4gPSB7XG4gICAgc2VsZWN0OiBvcHRpb25zID0+IGlucHV0KFNlbGVjdCwgb3B0aW9ucyksXG4gICAgc2xpZGVyOiBvcHRpb25zID0+IGlucHV0KFNsaWRlciwgb3B0aW9ucyksXG4gICAgc2VhcmNoOiBvcHRpb25zID0+IGlucHV0KFNlYXJjaCwgb3B0aW9ucyksXG4gICAgY2hlY2tib3g6IG9wdGlvbnMgPT4gaW5wdXQoQ2hlY2tib3gsIG9wdGlvbnMpLFxuICAgIHJhZGlvX2dyb3VwOiBvcHRpb25zID0+IGlucHV0KFJhZGlvR3JvdXAsIG9wdGlvbnMpLFxuICAgIGNoZWNrYm94X2dyb3VwOiBvcHRpb25zID0+IGlucHV0KENoZWNrYm94R3JvdXAsIG9wdGlvbnMpLFxuICAgIHRhYmxlOiBvcHRpb25zID0+IGlucHV0KFRhYmxlLCBvcHRpb25zKSxcbn07XG4iLCAiaW1wb3J0IHtcbiAgICBnZXRKc0RlbGl2ckJ1bmRsZXMsXG4gICAgc2VsZWN0QnVuZGxlLFxuICAgIEFzeW5jRHVja0RCLFxuICAgIENvbnNvbGVMb2dnZXIsXG4gICAgQXN5bmNEdWNrREJDb25uZWN0aW9uLFxuICAgIExvZ0xldmVsLFxufSBmcm9tICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0BkdWNrZGIvZHVja2RiLXdhc21AMS4yOS4wLytlc20nO1xuaW1wb3J0IHsgc2xlZXAgfSBmcm9tICcuLi91dGlsL2FzeW5jJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXREdWNrZGIoKSB7XG4gICAgY29uc3QgSlNERUxJVlJfQlVORExFUyA9IGdldEpzRGVsaXZyQnVuZGxlcygpO1xuXG4gICAgLy8gU2VsZWN0IGEgYnVuZGxlIGJhc2VkIG9uIGJyb3dzZXIgY2hlY2tzXG4gICAgY29uc3QgYnVuZGxlID0gYXdhaXQgc2VsZWN0QnVuZGxlKEpTREVMSVZSX0JVTkRMRVMpO1xuXG4gICAgY29uc3Qgd29ya2VyX3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFtgaW1wb3J0U2NyaXB0cyhcIiR7YnVuZGxlLm1haW5Xb3JrZXIhfVwiKTtgXSwge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIHRoZSBhc3luY2hyb25vdXMgdmVyc2lvbiBvZiBEdWNrREItd2FzbVxuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyX3VybCk7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IENvbnNvbGVMb2dnZXIoTG9nTGV2ZWwuV0FSTklORyk7XG4gICAgY29uc3QgZGIgPSBuZXcgQXN5bmNEdWNrREIobG9nZ2VyLCB3b3JrZXIpO1xuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKGJ1bmRsZS5tYWluTW9kdWxlLCBidW5kbGUucHRocmVhZFdvcmtlcik7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh3b3JrZXJfdXJsKTtcblxuICAgIHJldHVybiB7IGRiLCB3b3JrZXIgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUYWJsZShcbiAgICBjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sXG4gICAgdGFibGU6IHN0cmluZyxcbiAgICB7IGludGVydmFsID0gMjUwIH0gPSB7fVxuKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCAxXG4gICAgICAgICAgIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1xuICAgICAgICAgV0hFUkUgdGFibGVfc2NoZW1hID0gJ21haW4nXG4gICAgICAgICAgIEFORCB0YWJsZV9uYW1lICAgPSAnJHt0YWJsZX0nXG4gICAgICAgICBMSU1JVCAxYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJlcy5udW1Sb3dzKSByZXR1cm47IC8vIHN1Y2Nlc3MgXHUyNzI4XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgYFRhYmxlICR7dGFibGV9IG5vdCB5ZXQgYXZhaWxhYmxlLCB0cnlpbmcgYWdhaW4gaW4gJHtpbnRlcnZhbH1tcyAoZXJyb3I6ICR7ZXJyfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc2xlZXAoaW50ZXJ2YWwpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gc2xlZXAobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cbiIsICJpbXBvcnQgeyBWaXpDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRXJyb3JIYW5kbGluZyhjdHg6IFZpekNvbnRleHQsIHdvcmtlcjogV29ya2VyKTogdm9pZCB7XG4gICAgLy8gdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBldmVudCA9PiB7XG4gICAgICAgIGN0eC5yZWNvcmRVbmhhbmRsZWRFcnJvcihlcnJvckluZm8oZXZlbnQuZXJyb3IpKTtcbiAgICB9KTtcblxuICAgIC8vIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbnNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZXZlbnQgPT4ge1xuICAgICAgICBjdHgucmVjb3JkVW5oYW5kbGVkRXJyb3IoZXJyb3JJbmZvKGV2ZW50LnJlYXNvbikpO1xuICAgIH0pO1xuXG4gICAgLy8gd2ViIHdvcmtlciBlcnJvcnNcbiAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgY3R4LnJlY29yZFVuaGFuZGxlZEVycm9yKGVycm9ySW5mbyhldmVudC5kYXRhLmRhdGEubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JJbmZvIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICAgIHN0YWNrOiBzdHJpbmc7XG4gICAgY29kZTogc3RyaW5nIHwgbnVtYmVyIHwgbnVsbDtcbiAgICBvcmlnaW5hbFZhbHVlPzogdW5rbm93bjtcbiAgICBba2V5OiBzdHJpbmddOiB1bmtub3duOyAvLyBBbGxvdyBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9ySW5mbyhlcnJvcjogdW5rbm93bik6IEVycm9ySW5mbyB7XG4gICAgaWYgKGlzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lIHx8ICdFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJyxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IChlcnJvciBhcyBhbnkpLmNvZGUgfHwgbnVsbCxcbiAgICAgICAgICAgIC4uLihlcnJvciBhcyBhbnkpLCAvLyBJbmNsdWRlIGFueSBjdXN0b20gcHJvcGVydGllc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ0Vycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnLFxuICAgICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igbm9uLWVycm9yIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KGVycm9yLCBudWxsLCAyKSxcbiAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCAnJyxcbiAgICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbFZhbHVlOiBlcnJvcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckFzSFRNTChlcnJvcjogRXJyb3JJbmZvKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICAgIGJnOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjogJyNkYzM1NDUnLFxuICAgICAgICB0aXRsZTogJyNkYzM1NDUnLFxuICAgICAgICB0ZXh0OiAnIzIxMjUyOScsXG4gICAgICAgIHN1YnRleHQ6ICcjNmM3NTdkJyxcbiAgICAgICAgY29kZUJnOiAnI2Y4ZjlmYScsXG4gICAgICAgIGxpbms6ICcjMDA3YmZmJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2Ugc3RhY2sgdHJhY2VcbiAgICBjb25zdCBzdGFja0xpbmVzID0gcGFyc2VTdGFja1RyYWNlKGVycm9yLnN0YWNrKTtcblxuICAgIC8vIEJ1aWxkIEhUTUxcbiAgICBsZXQgaHRtbCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiXG4gICAgICBiYWNrZ3JvdW5kOiAke2NvbG9ycy5iZ307XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCAke2NvbG9ycy5ib3JkZXJ9O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90bywgbW9ub3NwYWNlO1xuICAgICAgY29sb3I6ICR7Y29sb3JzLnRleHR9O1xuICAgICAgbWFyZ2luOiAxMHB4IDA7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCA2cHggcmdiYSgwLDAsMCwwLjEpO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgXCI+XG4gICAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgYWxpZ24taXRlbXM6IGNlbnRlcjsgbWFyZ2luLWJvdHRvbTogMTVweDtcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHlsZT1cIm1hcmdpbi1yaWdodDogMTBweDtcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCIgc3Ryb2tlPVwiJHtjb2xvcnMudGl0bGV9XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIGZpbGw9XCJub25lXCIvPlxuICAgICAgICAgIDxwYXRoIGQ9XCJNMTIgOHY1bTAgNGguMDFcIiBzdHJva2U9XCIke2NvbG9ycy50aXRsZX1cIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPGgzIHN0eWxlPVwibWFyZ2luOiAwOyBjb2xvcjogJHtjb2xvcnMudGl0bGV9OyBmb250LXNpemU6IDIwcHg7IGZvbnQtd2VpZ2h0OiA2MDA7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKGVycm9yLm5hbWUpfVxuICAgICAgICA8L2gzPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgYmFja2dyb3VuZDogJHtjb2xvcnMuY29kZUJnfTtcbiAgICAgICAgcGFkZGluZzogMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICAgICAgICBib3JkZXItbGVmdDogNHB4IHNvbGlkICR7Y29sb3JzLmJvcmRlcn07XG4gICAgICBcIj5cbiAgICAgICAgPHAgc3R5bGU9XCJtYXJnaW46IDA7IGZvbnQtc2l6ZTogMTNweDsgbGluZS1oZWlnaHQ6IDEuNTsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsgd2hpdGUtc3BhY2U6IHByZS13cmFwO1wiPiR7ZXNjYXBlSHRtbChlcnJvci5tZXNzYWdlKX08L3A+XG4gICAgICA8L2Rpdj5gO1xuXG4gICAgaWYgKGVycm9yLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IHN0eWxlPVwibWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IGZvbnQtc2l6ZTogMTQzeDtcIj5FcnJvciBDb2RlOjwvc3Bhbj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMudGV4dH07IGZvbnQtd2VpZ2h0OiA1MDA7IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgJHtlc2NhcGVIdG1sKFN0cmluZyhlcnJvci5jb2RlKSl9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHN0YWNrTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgIDxkZXRhaWxzIHN0eWxlPVwibWFyZ2luLXRvcDogMTVweDtcIj5cbiAgICAgICAgPHN1bW1hcnkgc3R5bGU9XCJcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgICAgY29sb3I6ICR7Y29sb3JzLnN1YnRleHR9O1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIFwiPlxuICAgICAgICAgIFN0YWNrIFRyYWNlICgke3N0YWNrTGluZXMubGVuZ3RofSBmcmFtZXMpXG4gICAgICAgIDwvc3VtbWFyeT5cbiAgICAgICAgPGRpdiBzdHlsZT1cIm1hcmdpbi10b3A6IDEwcHg7IGZvbnQtc2l6ZTogMTNweDsgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcIj5gO1xuXG4gICAgICAgIHN0YWNrTGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgICAgICAgICAgaHRtbCArPSBgXG4gICAgICAgIDxkaXYgc3R5bGU9XCJcbiAgICAgICAgICBiYWNrZ3JvdW5kOiAke2kgJSAyID09PSAwID8gY29sb3JzLmNvZGVCZyA6ICd0cmFuc3BhcmVudCd9O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBtYXJnaW46IDJweCAwO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgXCI+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMuc3VidGV4dH07IG1pbi13aWR0aDogMjRweDtcIj4ke2kgKyAxfS48L3NwYW4+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9XCJjb2xvcjogJHtjb2xvcnMubGlua307IG1hcmdpbi1sZWZ0OiA4cHg7XCI+XG4gICAgICAgICAgICAke2VzY2FwZUh0bWwobGluZSl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5gO1xuICAgICAgICB9KTtcblxuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2RldGFpbHM+YDtcbiAgICB9XG5cbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuXG4gICAgcmV0dXJuIGh0bWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5UmVuZGVyRXJyb3IoZXJyb3I6IEVycm9ySW5mbywgcmVuZGVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmVuZGVyRWwuc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKTtcbiAgICByZW5kZXJFbC5pbm5lckhUTUwgPSBlcnJvckFzSFRNTChlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RhY2tUcmFjZShzdGFjazogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RhY2spIHJldHVybiBbXTtcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGZ1bmN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFBhdHRlcm5zIHRvIGV4dHJhY3QgZnVuY3Rpb24gbmFtZXNcbiAgICBjb25zdCBwYXR0ZXJuczogUmVnRXhwW10gPSBbXG4gICAgICAgIC8vIENocm9tZS9FZGdlOiBcIiAgICBhdCBmdW5jdGlvbk5hbWUgKGZpbGU6bGluZTpjb2x1bW4pXCJcbiAgICAgICAgL15cXHMqYXRcXHMrKC4rPylcXHMrXFwoLyxcbiAgICAgICAgLy8gQ2hyb21lL0VkZ2U6IFwiICAgIGF0IGZpbGU6bGluZTpjb2x1bW5cIiAoYW5vbnltb3VzKVxuICAgICAgICAvXlxccyphdFxccytbXihdKyQvLFxuICAgICAgICAvLyBGaXJlZm94L1NhZmFyaTogXCJmdW5jdGlvbk5hbWVAZmlsZTpsaW5lOmNvbHVtblwiXG4gICAgICAgIC9eKC4rPylALyxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcbiAgICAgICAgaWYgKCF0cmltbWVkIHx8IHRyaW1tZWQgPT09ICdFcnJvcicpIGNvbnRpbnVlO1xuXG4gICAgICAgIGxldCBmdW5jdGlvbk5hbWUgPSAnYW5vbnltb3VzJztcblxuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdHJpbW1lZC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcGF0dGVybiBtYXRjaGVkLCB1c2UgdGhlIHdob2xlIGxpbmUgYXMgdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gJ2Fub255bW91cycgJiYgIXBhdHRlcm5zLnNvbWUocCA9PiBwLnRlc3QodHJpbW1lZCkpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWUgPSB0cmltbWVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb25zLnB1c2goZnVuY3Rpb25OYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb25zO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEVycm9yIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNOb3RlYm9vaygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aW4gPSB3aW5kb3cgYXMgV2luZG93ICYge1xuICAgICAgICBKdXB5dGVyPzogYW55O1xuICAgICAgICBfSlVQWVRFUkxBQj86IGFueTtcbiAgICAgICAgZ29vZ2xlPzogeyBjb2xhYj86IGFueSB9O1xuICAgICAgICBJUHl0aG9uPzogYW55O1xuICAgICAgICBtbz86IGFueTtcbiAgICAgICAgYWNxdWlyZVZzQ29kZUFwaT86IGFueTtcbiAgICB9O1xuXG4gICAgY29uc3QgaGFzTm90ZWJvb2tHbG9iYWwgPVxuICAgICAgICB0eXBlb2Ygd2luLkp1cHl0ZXIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiB3aW4uX0pVUFlURVJMQUIgIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICh0eXBlb2Ygd2luLmdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luLmdvb2dsZS5jb2xhYikgfHxcbiAgICAgICAgdHlwZW9mIHdpbi5JUHl0aG9uICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLm1vICE9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICB0eXBlb2Ygd2luLmFjcXVpcmVWc0NvZGVBcGkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgcmV0dXJuIGhhc05vdGVib29rR2xvYmFsIHx8IGlzVlNDb2RlTm90ZWJvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVlNDb2RlTm90ZWJvb2soKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAndnNjb2RlLXdlYnZpZXc6JyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uc2VhcmNoLmluY2x1ZGVzKCdwdXJwb3NlPW5vdGVib29rUmVuZGVyZXInKVxuICAgICk7XG59XG4iLCAiaW1wb3J0IHN2Z1BhdGhQYXJzZXIgZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9zdmctcGF0aC1wYXJzZXJAMS4xLjAvK2VzbSc7XG5pbXBvcnQgdGlwcHksIHsgUGxhY2VtZW50IH0gZnJvbSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS90aXBweS5qc0A2LjMuNy8rZXNtJztcblxuZXhwb3J0IGNvbnN0IHJlcGxhY2VUb29sdGlwSW1wbCA9IChzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gQ2hlY2sgaWYgU1ZHIGFscmVhZHkgZXhpc3RzXG4gICAgY29uZmlndXJlU3BlY1N2Z1Rvb2x0aXBzKHNwZWNFbCk7XG5cbiAgICAvLyBXYXRjaCB0aGUgc3BlYyBlbGVtZW50IGZvciBzdmdzIHRvIGJlIGFkZGVkXG4gICAgLy8gV2hlbiB0aGV5IGFyZSBhZGRlZCwgYXR0ZW1wdCB0byBjb25uZWN0IG91ciB0b29sdGlwXG4gICAgLy8gaGFuZGxlclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMoc3BlY0VsKTtcbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHNwZWNFbCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG59O1xuXG4vLyBUcmFjayB3aGljaCBTVkdzIGhhdmUgYmVlbiBzZXR1cFxuLy8gdG8gYXZvaWQgc2V0dGluZyB1cCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgU1ZHLlxuY29uc3QgY29uZmlndXJlZFN2Z3MgPSBuZXcgV2Vha1NldDxTVkdTVkdFbGVtZW50PigpO1xuXG5jb25zdCBjb25maWd1cmVTcGVjU3ZnVG9vbHRpcHMgPSAoc3BlY0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkU3ZnRWxzID0gc3BlY0VsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xuICAgIGNoaWxkU3ZnRWxzLmZvckVhY2goc3ZnRWwgPT4ge1xuICAgICAgICBpZiAoc3ZnRWwgJiYgIWNvbmZpZ3VyZWRTdmdzLmhhcyhzdmdFbCkpIHtcbiAgICAgICAgICAgIHNldHVwVG9vbHRpcE9ic2VydmVyKHN2Z0VsLCBzcGVjRWwpO1xuICAgICAgICAgICAgY29uZmlndXJlZFN2Z3MuYWRkKHN2Z0VsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxubGV0IHRvb2x0aXBJbnN0YW5jZTogYW55IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBoaWRlVG9vbHRpcCgpIHtcbiAgICB0b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoaWRlVG9vbHRpcCk7XG59XG5cbmZ1bmN0aW9uIHNob3dUb29sdGlwKCkge1xuICAgIHRvb2x0aXBJbnN0YW5jZS5zaG93KCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhpZGVUb29sdGlwLCB7IG9uY2U6IHRydWUgfSk7XG59XG5cbmNvbnN0IHNldHVwVG9vbHRpcE9ic2VydmVyID0gKHN2Z0VsOiBTVkdTVkdFbGVtZW50LCBzcGVjRWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSB0aXBweSBmb3IgdGhpcyBzcGVjIGVsZW1lbnQgaWYgbm90IGFscmVhZHkgZG9uZS5cbiAgICBpZiAoIXRvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICB0b29sdGlwSW5zdGFuY2UgPSB0aXBweShzcGVjRWwsIHtcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgdGhlbWU6ICdpbnNwZWN0JyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2F0Y2ggdGhlIFNWRyBmb3IgY2hpbGRMaXN0IG11dGF0aW9ucyBhbmQgaW5zcGVjdCB0aGUgdGlwIGVsZW1lbnRcbiAgICAvLyB3aGVuZXZlciBpdCBjaGFuZ2VzLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlwRWxlbWVudHMgPSBzdmdFbC5xdWVyeVNlbGVjdG9yQWxsKCdnW2FyaWEtbGFiZWw9XCJ0aXBcIl0nKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwRWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcENvbnRhaW5lckVsID0gdGlwRWxlbWVudHNbMF0gYXMgU1ZHR0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpcENvbnRhaW5lckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRpcCBjb250YWluZXIgaXMgZW1wdHksIHRoZSB0b29sdGlwIGhhcyBiZWVuIGRpc21pc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpcEVsID0gdGlwQ29udGFpbmVyRWwuZmlyc3RDaGlsZCBhcyBTVkdHRWxlbWVudCB8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlwRWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aXAgY29udGFpbmVyIGFuZCBwYXJzZSBpdCB0byBkZXRlcm1pbmUgaG93IHRoZSB0b29sdGlwc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGNvbmZpZ3VyZWQgYW5kIHdoYXQgaXMgYmVpbmcgZGlzcGxheWVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VTVkdUb29sdGlwKHRpcEVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgU1ZHIHBvaW50IHRvIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ZnUG9pbnQgPSBzdmdFbC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ZnUG9pbnQueCA9IHBhcnNlZC50cmFuc2Zvcm0/LnggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN2Z1BvaW50LnkgPSBwYXJzZWQudHJhbnNmb3JtPy55IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5Qb2ludCA9IHN2Z1BvaW50Lm1hdHJpeFRyYW5zZm9ybShzdmdFbC5nZXRTY3JlZW5DVE0oKSEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjcmVlblBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gc2NyZWVuUG9pbnQueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZmlndXJlIHRpcHB5IHRvIGRpc3BsYXkgdGhlIEhUTUwgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHRpcEluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wbGFjZW1lbnQgIT09ICdtaWRkbGUnID8gcGFyc2VkLnBsYWNlbWVudCB8fCAndG9wJyA6ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNlbnRlclksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0pTT046ICgpID0+IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGFzIERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogcGFyc2VkLnBsYWNlbWVudCAhPT0gJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwYXJzZWQucGxhY2VtZW50ID09PSAnbWlkZGxlJyA/IFswLCAwXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3BwZXJPcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaWRkbGUgcGxhY2VtZW50LCB3aGljaCBpc24ndCBhIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aXBweSBwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBsYWNlbWVudCA9PT0gJ21pZGRsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdjdXN0b21NaWRkbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjogKHsgc3RhdGUgfTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZW50ZXIgdGhlIHBvcG92ZXIgYXQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclggLSBzdGF0ZS5yZWN0cy5wb3BwZXIud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclkgLSBzdGF0ZS5yZWN0cy5wb3BwZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSB0b29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsLmNsYXNzTGlzdC5hZGQoJ2luc3BlY3QtdGlwLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHBhcnNlZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5jbGFzc05hbWUgPSAnaW5zcGVjdC10aXAtcm93JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWwuYXBwZW5kQ2hpbGQocm93RWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWtleSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RWwuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdy5rZXkpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmNsYXNzTmFtZSA9ICdpbnNwZWN0LXRpcC12YWx1ZSc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUVsLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb3cudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93LmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yRWwuY2xhc3NOYW1lID0gJ2luc3BlY3QtdGlwLWNvbG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JFbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByb3cuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRWwuYXBwZW5kKGNvbG9yRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0VsLmFwcGVuZENoaWxkKGtleUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dFbC5hcHBlbmRDaGlsZCh2YWx1ZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sdGlwSW5zdGFuY2Uuc2V0Q29udGVudChjb250ZW50RWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFeHBlY3RlZCBleGFjdGx5IG9uZSB0aXAgZWxlbWVudCwgZm91bmQgJHt0aXBFbGVtZW50cy5sZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHN2Z0VsLCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICB9KTtcbn07XG5cbmludGVyZmFjZSBUb29sdGlwUm93IHtcbiAgICBrZXk6IHN0cmluZztcbiAgICB2YWx1ZTogc3RyaW5nO1xuICAgIGNvbG9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUGFyc2VkVG9vbHRpcCB7XG4gICAgdHJhbnNmb3JtPzoge1xuICAgICAgICB4OiBudW1iZXI7XG4gICAgICAgIHk6IG51bWJlcjtcbiAgICB9O1xuICAgIHZhbHVlczogQXJyYXk8VG9vbHRpcFJvdz47XG4gICAgcGxhY2VtZW50PzogUGxhY2VtZW50IHwgJ21pZGRsZSc7XG59XG5cbmNvbnN0IHBhcnNlU1ZHVG9vbHRpcCA9ICh0aXBFbDogU1ZHR0VsZW1lbnQpOiBQYXJzZWRUb29sdGlwID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFRvb2x0aXAgPSB7IHZhbHVlczogW10gfTtcblxuICAgIC8vIFBhcnNlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHRvIGNhcHR1cmUgdGhlIHBvc2l0aW9uXG4gICAgLy8gb2Zmc2V0IChyZWxhdGl2ZSB0byBTVkcgZWxlbWVudClcbiAgICBjb25zdCB0cmFuc2Zvcm1WYWwgPSB0aXBFbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuICAgIGlmICh0cmFuc2Zvcm1WYWwpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0cmFuc2Zvcm1WYWwubWF0Y2goL3RyYW5zbGF0ZVxcKChbXildKylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBtYXRjaFsxXS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgICAgICAgICAgcmVzdWx0LnRyYW5zZm9ybSA9IHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdGhlIGNoaWxkIHNwYW5zXG4gICAgY29uc3QgdHNwYW5FbHMgPSB0aXBFbC5xdWVyeVNlbGVjdG9yQWxsKCd0c3BhbicpO1xuICAgIHRzcGFuRWxzLmZvckVhY2godHNwYW4gPT4ge1xuICAgICAgICBsZXQga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjb2xvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHNwYW4uY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICd0c3BhbicpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgdHNwYW4sIGVpdGhlciBrZXkgb3IgY29sb3JcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckF0dHIgPSAobm9kZSBhcyBFbGVtZW50KS5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JBdHRyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXJlIHRleHQgbm9kZXMgYXJlIGEga2V5XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBub2RlLnRleHRDb250ZW50Py50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlcy5wdXNoKHsga2V5LCB2YWx1ZSwgY29sb3IgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFBhcnNlIHRoZSBwYXRoIHRvIGRldGVybWluZSB0aGUgYXJyb3cgZGlyZWN0aW9uXG4gICAgY29uc3QgcGF0aEVsID0gdGlwRWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgIGlmIChwYXRoRWwpIHtcbiAgICAgICAgY29uc3QgcGF0aERhdGEgPSBwYXRoRWwuZ2V0QXR0cmlidXRlKCdkJyk7XG4gICAgICAgIGlmIChwYXRoRGF0YSkge1xuICAgICAgICAgICAgcmVzdWx0LnBsYWNlbWVudCA9IHBhcnNlQXJyb3dEaXJlY3Rpb24ocGF0aERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dQb3NpdGlvbiA9IChhOiBudW1iZXIsIGI6IG51bWJlcik6ICdzdGFydCcgfCAnY2VudGVyJyB8ICdlbmQnID0+IHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH1cbn07XG5cbmNvbnN0IHBhcnNlQXJyb3dEaXJlY3Rpb24gPSAocGF0aERhdGE6IHN0cmluZyk6IFBsYWNlbWVudCB8ICdtaWRkbGUnID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdmdQYXRoUGFyc2VyLnBhcnNlU1ZHKHBhdGhEYXRhKTtcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIGNvbnN0IG1vdmVUbyA9IHBhcnNlZFswXTtcbiAgICBpZiAobW92ZVRvLmNvZGUgIT09ICdNJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIG1vdmV0byBjb21tYW5kIChNKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIG1vdmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBpZiAobW92ZVRvLnggIT09IDAgJiYgbW92ZVRvLnkgIT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVUbyA9IHBhcnNlZFsxXTtcbiAgICBpZiAobGluZVRvLmNvZGUgIT09ICdsJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0V4cGVjdGVkIGxpbmV0byBjb21tYW5kIChsKSBpbiBwYXRoIGRhdGEsIGZvdW5kOicsIGxpbmVUbyk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEVkZ2VMaW5lVG8gPSBwYXJzZWRbMl07XG4gICAgaWYgKGZpcnN0RWRnZUxpbmVUby5jb2RlICE9PSAnaCcgJiYgZmlyc3RFZGdlTGluZVRvLmNvZGUgIT09ICd2Jykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRXhwZWN0ZWQgaG9yaXpvbnRhbCAoaCkgb3IgdmVydGljYWwgKHYpIGxpbmUgY29tbWFuZCBhZnRlciBtb3ZlLCBmb3VuZDonLFxuICAgICAgICAgICAgZmlyc3RFZGdlTGluZVRvXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RWRnZUxpbmVUbyA9IHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMl07XG4gICAgaWYgKGxhc3RFZGdlTGluZVRvLmNvZGUgIT09ICdoJyAmJiBsYXN0RWRnZUxpbmVUby5jb2RlICE9PSAndicpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIGhvcml6b250YWwgKGgpIG9yIHZlcnRpY2FsICh2KSBsaW5lIGNvbW1hbmQgYmVmb3JlIGNsb3NlLCBmb3VuZDonLFxuICAgICAgICAgICAgbGFzdEVkZ2VMaW5lVG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhcnJvd1xuICAgIGNvbnN0IHggPSBsaW5lVG8ueDtcbiAgICBjb25zdCB5ID0gbGluZVRvLnk7XG5cbiAgICBsZXQgYXJyb3dEaXJlY3Rpb246ICd0b3AnIHwgJ2JvdHRvbScgfCAnbGVmdCcgfCAncmlnaHQnID0gJ3RvcCc7XG4gICAgaWYgKHggPiAwICYmIHkgPiAwKSB7XG4gICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIGlmICh4IDwgMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh4ID4gMCAmJiB5IDwgMCkge1xuICAgICAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAndG9wJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93RGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeCA8IDAgJiYgeSA+IDApIHtcbiAgICAgICAgYXJyb3dEaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnQ291bGQgbm90IGRldGVybWluZSBhcnJvdyBkaXJlY3Rpb24gZnJvbSBwYXRoIGRhdGEsIHJldHVybmluZyBkZWZhdWx0IHBsYWNlbWVudDogdG9wJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIE5leHQgZGV0ZXJtaW5lIHRoZSBwbGFjZW1lbnQgd2l0aGluIHRoZSBzdmcgKHN0YXJ0LCBjZW50ZXIsIGVuZClcbiAgICBsZXQgYXJyb3dQb3NpdGlvbjogJ3N0YXJ0JyB8ICdjZW50ZXInIHwgJ2VuZCcgPSAnY2VudGVyJztcbiAgICBpZiAoZmlyc3RFZGdlTGluZVRvLmNvZGUgPT09ICdoJykge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby54LCBsYXN0RWRnZUxpbmVUby54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcnJvd1Bvc2l0aW9uID0gcGFyc2VBcnJvd1Bvc2l0aW9uKGZpcnN0RWRnZUxpbmVUby55LCBsYXN0RWRnZUxpbmVUby55KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgcGxhY2VtZW50IGJhc2VkIG9uIGRpcmVjdGlvbiBhbmQgcG9zaXRpb25cbiAgICBpZiAoYXJyb3dQb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFycm93RGlyZWN0aW9uIGFzIFBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7YXJyb3dEaXJlY3Rpb259LSR7YXJyb3dQ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QU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsSUFBSSxTQUFTLENBQUMsQ0FBQztBQUFBLElBQzVCLEtBQUs7QUFDRCxhQUFPLEVBQUVDLEtBQUksU0FBUyxDQUFDLENBQUM7QUFBQSxJQUM1QixLQUFLO0FBQ0QsYUFBTyxFQUFFQyxLQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDNUIsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDaEMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDL0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxNQUFNLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDOUIsS0FBSztBQUNELGFBQU8sRUFBRSxLQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDN0IsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDbEMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsQ0FBQyxDQUFDO0FBQUEsSUFDakMsS0FBSztBQUNELGFBQU8sRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzVDLEtBQUs7QUFDRCxhQUFPLEVBQUUsU0FBUyxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFBQSxJQUM5QyxLQUFLO0FBQ0QsYUFBTyxFQUFFLEtBQUssU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDMUMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzlDLEtBQUs7QUFDRCxhQUFPLEVBQUUsY0FBYyxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFBQSxJQUNuRCxLQUFLO0FBQ0QsYUFBTyxFQUFFLFVBQVUsU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDL0MsS0FBSztBQUNELGFBQU8sRUFBRSxVQUFVLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQy9DLEtBQUs7QUFDRCxhQUFPLEVBQUUsT0FBTyxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFBQSxJQUM1QyxLQUFLO0FBQ0QsYUFBTyxFQUFFLFFBQVEsU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDN0MsS0FBSztBQUNELGFBQU8sRUFBRSxRQUFRLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzdDLEtBQUs7QUFDRCxhQUFPLEVBQUUsUUFBUSxTQUFTLEdBQUcsVUFBVSxDQUFDLENBQUM7QUFBQSxJQUM3QyxLQUFLO0FBQ0QsYUFBTyxFQUFFLFNBQVMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDOUMsS0FBSztBQUNELGFBQU8sRUFBRSxTQUFTLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQztBQUFBLElBQzlDO0FBQ0ksWUFBTSxJQUFJLE1BQU0scUNBQXFDLE9BQU8sR0FBRztBQUFBLEVBQ3ZFO0FBQ0o7QUFFQSxJQUFNLHdCQUF3QixDQUMxQixXQUNzRTtBQUN0RSxTQUNJLE9BQU8sV0FBVyxZQUNsQixXQUFXLFFBQ1gsY0FBYyxVQUNkLGdCQUFnQixXQUNmLE9BQU8sYUFBYSxTQUFTLE9BQU8sYUFBYSxTQUNsRCxPQUFPLE9BQU8sZUFBZTtBQUVyQztBQUVBLElBQU0sZUFBZSxDQUFDLFdBQTJDO0FBQzdELFNBQU8sUUFBUSxlQUFlO0FBQ2xDO0FBRUEsSUFBTSxpQkFBaUIsQ0FBQyxXQUE2QztBQUNqRSxTQUFPLFFBQVEsZUFBZTtBQUNsQztBQUVBLElBQU0sZUFBZSxDQUFDLFdBQTJDO0FBQzdELFNBQU8sUUFBUSxlQUFlLFVBQVUsUUFBUSxlQUFlO0FBQ25FO0FBRUEsSUFBTSxnQkFBZ0IsQ0FBQyxXQUE2QztBQUNoRSxTQUFPLFFBQVEsZUFBZSxXQUFXLGtCQUFrQjtBQUMvRDtBQUVBLElBQU0sY0FBYyxDQUFDLFdBQTBDO0FBQzNELFNBQU8sUUFBUSxlQUFlO0FBQ2xDOzs7QUMza0NBO0FBQUEsRUFDSTtBQUFBLEVBQ0EsV0FBQUM7QUFBQSxFQUNBLGVBQUFDO0FBQUEsT0FFRztBQUNQLFNBQXFCLFNBQUFDLGNBQWE7QUFnQjNCLElBQU0sU0FBTixjQUFxQixNQUFNO0FBQUEsRUFNOUIsWUFBK0IsVUFBeUI7QUFDcEQsVUFBTSxTQUFTLFFBQVE7QUFESTtBQUczQixTQUFLLFFBQVEsVUFBVSxJQUFJLGlCQUFpQjtBQUU1QyxRQUFJLFNBQVMsT0FBTztBQUNoQixZQUFNLGFBQWEsT0FBTyxTQUFTLGNBQWMsT0FBTztBQUN4RCxpQkFBVyxhQUFhLE9BQU8sS0FBSyxHQUFHO0FBQ3ZDLGlCQUFXLFlBQVksU0FBUztBQUNoQyxXQUFLLFFBQVEsWUFBWSxVQUFVO0FBQUEsSUFDdkM7QUFHQSxTQUFLLFNBQVMsT0FBTyxTQUFTLGNBQWMsT0FBTztBQUNuRCxTQUFLLE9BQU8sZUFBZTtBQUMzQixTQUFLLE9BQU8sVUFBVSxJQUFJLFlBQVk7QUFDdEMsU0FBSyxPQUFPLEtBQUssS0FBSztBQUN0QixTQUFLLE9BQU8sT0FBTztBQUNuQixRQUFJLEtBQUssU0FBUyxhQUFhO0FBQzNCLFdBQUssT0FBTyxhQUFhLGVBQWUsS0FBSyxTQUFTLFdBQVc7QUFBQSxJQUNyRTtBQUNBLFFBQUksS0FBSyxTQUFTLE9BQU87QUFDckIsV0FBSyxPQUFPLE1BQU0sUUFBUSxHQUFHLFNBQVMsS0FBSztBQUFBLElBQy9DO0FBQ0EsU0FBSyxRQUFRLFlBQVksS0FBSyxNQUFNO0FBR3BDLFNBQUssT0FBTyxpQkFBaUIsU0FBUyxNQUFNO0FBQ3hDLFdBQUssUUFBUSxLQUFLLE9BQU8sS0FBSztBQUFBLElBQ2xDLENBQUM7QUFHRCxRQUFJLENBQUNDLGFBQVksS0FBSyxTQUFTLEVBQUUsR0FBRztBQUNoQyxXQUFLLFNBQVMsR0FBRyxpQkFBaUIsU0FBUyxXQUFTO0FBQ2hELFlBQUksVUFBVSxLQUFLLE9BQU8sT0FBTztBQUM3QixlQUFLLE9BQU8sUUFBUTtBQUFBLFFBQ3hCO0FBQUEsTUFDSixDQUFDO0FBQUEsSUFDTCxPQUFPO0FBQ0gsK0JBQXlCLE1BQU0sS0FBSyxNQUFNO0FBQUEsSUFDOUM7QUFBQSxFQUNKO0FBQUEsRUE5Q2lCO0FBQUEsRUFDQSxNQUFjLFdBQVc7QUFBQSxFQUNsQyxRQUFpQyxDQUFDO0FBQUEsRUFDbEM7QUFBQSxFQTZDUixRQUFRO0FBQ0osU0FBSyxPQUFPLFFBQVE7QUFBQSxFQUN4QjtBQUFBLEVBRUEsT0FBTyxPQUFpQztBQUNwQyxVQUFNLFFBQVEsS0FBSyxTQUFTLFNBQVMsS0FBSyxTQUFTO0FBQ25ELFdBQU8sWUFBWSxPQUFPLE9BQU8sRUFBRSxRQUFRLE1BQU0sUUFBUSxLQUFLLFNBQVMsS0FBSyxDQUFDO0FBQUEsRUFDakY7QUFBQSxFQUVBLFdBQVc7QUFDUCxRQUFJQSxhQUFZLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDL0IsV0FBSyxTQUFTLEdBQUcsU0FBUyxLQUFLLE9BQU8sRUFBRSxDQUFDO0FBQUEsSUFDN0M7QUFBQSxFQUNKO0FBQUEsRUFFQSxRQUFRLE9BQWdCO0FBQ3BCLFFBQUlBLGFBQVksS0FBSyxTQUFTLEVBQUUsR0FBRztBQUMvQixXQUFLLFNBQVMsR0FBRyxPQUFPLEtBQUssT0FBTyxLQUFLLENBQUM7QUFBQSxJQUM5QyxXQUFXQyxTQUFRLEtBQUssU0FBUyxFQUFFLEdBQUc7QUFDbEMsV0FBSyxTQUFTLEdBQUcsT0FBTyxLQUFLO0FBQUEsSUFDakM7QUFBQSxFQUNKO0FBQUEsRUFFQSxNQUFNLFNBQXVCLENBQUMsR0FBRztBQUM3QixXQUFPQyxPQUFNLEtBQUssS0FBSyxTQUFTLElBQUksRUFDL0IsT0FBTyxFQUFFLE1BQU0sS0FBSyxTQUFTLE9BQU8sQ0FBQyxFQUNyQyxTQUFTLEVBQ1QsTUFBTSxHQUFHLE1BQU07QUFBQSxFQUN4QjtBQUFBLEVBRUEsWUFBWSxNQUFpQjtBQUN6QixTQUFLLFFBQVE7QUFDYixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsU0FBZTtBQUNYLFVBQU0sT0FBTyxTQUFTLGNBQWMsVUFBVTtBQUM5QyxVQUFNLEtBQUssR0FBRyxLQUFLLEdBQUc7QUFDdEIsU0FBSyxhQUFhLE1BQU0sRUFBRTtBQUMxQixlQUFXLEtBQUssS0FBSyxPQUFPO0FBQ3hCLFlBQU0sTUFBTSxTQUFTLGNBQWMsUUFBUTtBQUMzQyxVQUFJLGFBQWEsU0FBUyxFQUFFLElBQUk7QUFDaEMsV0FBSyxPQUFPLEdBQUc7QUFBQSxJQUNuQjtBQUNBLFFBQUksS0FBSyxXQUFXO0FBQ2hCLFdBQUssVUFBVSxPQUFPO0FBQUEsSUFDMUI7QUFDQSxTQUFLLFFBQVEsWUFBYSxLQUFLLFlBQVksSUFBSztBQUNoRCxTQUFLLE9BQU8sYUFBYSxRQUFRLEVBQUU7QUFDbkMsV0FBTztBQUFBLEVBQ1g7QUFDSjs7O0FDakhPLElBQU0sU0FBd0M7QUFBQSxFQUNqRCxRQUFRLGFBQVcsTUFBTSxRQUFRLE9BQU87QUFBQSxFQUN4QyxRQUFRLGFBQVcsTUFBTSxRQUFRLE9BQU87QUFBQSxFQUN4QyxRQUFRLGFBQVcsTUFBTSxRQUFRLE9BQU87QUFBQSxFQUN4QyxVQUFVLGFBQVcsTUFBTSxVQUFVLE9BQU87QUFBQSxFQUM1QyxhQUFhLGFBQVcsTUFBTSxZQUFZLE9BQU87QUFBQSxFQUNqRCxnQkFBZ0IsYUFBVyxNQUFNLGVBQWUsT0FBTztBQUFBLEVBQ3ZELE9BQU8sYUFBVyxNQUFNLE9BQU8sT0FBTztBQUMxQzs7O0FDakJBO0FBQUEsRUFDSTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBRUE7QUFBQSxPQUNHOzs7QUNQQSxTQUFTLE1BQU0sSUFBMkI7QUFDN0MsU0FBTyxJQUFJLFFBQVEsYUFBVyxXQUFXLFNBQVMsRUFBRSxDQUFDO0FBQ3pEOzs7QURRQSxlQUFzQixhQUFhO0FBQy9CLFFBQU0sbUJBQW1CLG1CQUFtQjtBQUc1QyxRQUFNLFNBQVMsTUFBTSxhQUFhLGdCQUFnQjtBQUVsRCxRQUFNLGFBQWEsSUFBSTtBQUFBLElBQ25CLElBQUksS0FBSyxDQUFDLGtCQUFrQixPQUFPLFVBQVcsS0FBSyxHQUFHO0FBQUEsTUFDbEQsTUFBTTtBQUFBLElBQ1YsQ0FBQztBQUFBLEVBQ0w7QUFHQSxRQUFNLFNBQVMsSUFBSSxPQUFPLFVBQVU7QUFDcEMsUUFBTSxTQUFTLElBQUksY0FBYyxTQUFTLE9BQU87QUFDakQsUUFBTSxLQUFLLElBQUksWUFBWSxRQUFRLE1BQU07QUFDekMsUUFBTSxHQUFHLFlBQVksT0FBTyxZQUFZLE9BQU8sYUFBYTtBQUM1RCxNQUFJLGdCQUFnQixVQUFVO0FBRTlCLFNBQU8sRUFBRSxJQUFJLE9BQU87QUFDeEI7QUFFQSxlQUFzQixhQUNsQixNQUNBLE9BQ0EsRUFBRSxXQUFXLElBQUksSUFBSSxDQUFDLEdBQ3hCO0FBQ0UsU0FBTyxNQUFNO0FBQ1QsUUFBSTtBQUNBLFlBQU0sTUFBTSxNQUFNLEtBQUs7QUFBQSxRQUNuQjtBQUFBO0FBQUE7QUFBQSxpQ0FHaUIsS0FBSztBQUFBO0FBQUEsTUFFMUI7QUFFQSxVQUFJLElBQUksUUFBUztBQUFBLElBQ3JCLFNBQVMsS0FBSztBQUNWLGNBQVE7QUFBQSxRQUNKLFNBQVMsS0FBSyx1Q0FBdUMsUUFBUSxjQUFjLEdBQUc7QUFBQSxNQUNsRjtBQUFBLElBQ0o7QUFFQSxVQUFNLE1BQU0sUUFBUTtBQUFBLEVBQ3hCO0FBQ0o7OztBRXRETyxTQUFTLHdCQUF3QixLQUFpQixRQUFzQjtBQUUzRSxTQUFPLGlCQUFpQixTQUFTLFdBQVM7QUFDdEMsUUFBSSxxQkFBcUIsVUFBVSxNQUFNLEtBQUssQ0FBQztBQUFBLEVBQ25ELENBQUM7QUFHRCxTQUFPLGlCQUFpQixzQkFBc0IsV0FBUztBQUNuRCxRQUFJLHFCQUFxQixVQUFVLE1BQU0sTUFBTSxDQUFDO0FBQUEsRUFDcEQsQ0FBQztBQUdELFNBQU8saUJBQWlCLFdBQVcsV0FBUztBQUN4QyxRQUFJLE1BQU0sS0FBSyxTQUFTLFNBQVM7QUFDN0IsVUFBSSxxQkFBcUIsVUFBVSxNQUFNLEtBQUssS0FBSyxPQUFPLENBQUM7QUFBQSxJQUMvRDtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBV08sU0FBUyxVQUFVLE9BQTJCO0FBQ2pELE1BQUksUUFBUSxLQUFLLEdBQUc7QUFDaEIsV0FBTztBQUFBLE1BQ0gsTUFBTSxNQUFNLFFBQVE7QUFBQSxNQUNwQixTQUFTLE1BQU0sV0FBVztBQUFBLE1BQzFCLE9BQU8sTUFBTSxTQUFTO0FBQUEsTUFDdEIsTUFBTyxNQUFjLFFBQVE7QUFBQSxNQUM3QixHQUFJO0FBQUE7QUFBQSxJQUNSO0FBQUEsRUFDSixXQUFXLE9BQU8sVUFBVSxVQUFVO0FBQ2xDLFdBQU87QUFBQSxNQUNILE1BQU07QUFBQSxNQUNOLFNBQVM7QUFBQSxNQUNULE9BQU8sSUFBSSxNQUFNLEVBQUUsU0FBUztBQUFBLE1BQzVCLE1BQU07QUFBQSxJQUNWO0FBQUEsRUFDSixPQUFPO0FBRUgsV0FBTztBQUFBLE1BQ0gsTUFBTTtBQUFBLE1BQ04sU0FBUyxLQUFLLFVBQVUsT0FBTyxNQUFNLENBQUM7QUFBQSxNQUN0QyxPQUFPLElBQUksTUFBTSxFQUFFLFNBQVM7QUFBQSxNQUM1QixNQUFNO0FBQUEsTUFDTixlQUFlO0FBQUEsSUFDbkI7QUFBQSxFQUNKO0FBQ0o7QUFFTyxTQUFTLFlBQVksT0FBMEI7QUFDbEQsUUFBTSxTQUFTO0FBQUEsSUFDWCxJQUFJO0FBQUEsSUFDSixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVCxRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsRUFDVjtBQUdBLFFBQU0sYUFBYSxnQkFBZ0IsTUFBTSxLQUFLO0FBRzlDLE1BQUksT0FBTztBQUFBO0FBQUEsb0JBRUssT0FBTyxFQUFFO0FBQUEsMEJBQ0gsT0FBTyxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFJeEIsT0FBTyxJQUFJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbURBT3lCLE9BQU8sS0FBSztBQUFBLDhDQUNqQixPQUFPLEtBQUs7QUFBQTtBQUFBLHVDQUVuQixPQUFPLEtBQUs7QUFBQSxZQUN2QyxXQUFXLE1BQU0sSUFBSSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFLWixPQUFPLE1BQU07QUFBQTtBQUFBO0FBQUE7QUFBQSxpQ0FJRixPQUFPLE1BQU07QUFBQTtBQUFBLGtIQUVvRSxXQUFXLE1BQU0sT0FBTyxDQUFDO0FBQUE7QUFHdkksTUFBSSxNQUFNLFNBQVMsTUFBTTtBQUNyQixZQUFRO0FBQUE7QUFBQSw4QkFFYyxPQUFPLE9BQU87QUFBQSw4QkFDZCxPQUFPLElBQUk7QUFBQSxZQUM3QixXQUFXLE9BQU8sTUFBTSxJQUFJLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQSxFQUd0QztBQUVBLE1BQUksV0FBVyxTQUFTLEdBQUc7QUFDdkIsWUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUlHLE9BQU8sT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFNUixXQUFXLE1BQU07QUFBQTtBQUFBO0FBSWxDLGVBQVcsUUFBUSxDQUFDLE1BQU0sTUFBTTtBQUM1QixjQUFRO0FBQUE7QUFBQSx3QkFFSSxJQUFJLE1BQU0sSUFBSSxPQUFPLFNBQVMsYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQ0FNbkMsT0FBTyxPQUFPLHVCQUF1QixJQUFJLENBQUM7QUFBQSxnQ0FDMUMsT0FBTyxJQUFJO0FBQUEsY0FDN0IsV0FBVyxJQUFJLENBQUM7QUFBQTtBQUFBO0FBQUEsSUFHdEIsQ0FBQztBQUVELFlBQVE7QUFBQTtBQUFBO0FBQUEsRUFHWjtBQUVBLFVBQVE7QUFFUixTQUFPO0FBQ1g7QUFFTyxTQUFTLG1CQUFtQixPQUFrQixVQUF1QjtBQUN4RSxXQUFTLGFBQWEsU0FBUyxFQUFFO0FBQ2pDLFdBQVMsWUFBWSxZQUFZLEtBQUs7QUFDMUM7QUFFQSxTQUFTLGdCQUFnQixPQUF5QjtBQUM5QyxNQUFJLENBQUMsTUFBTyxRQUFPLENBQUM7QUFFcEIsUUFBTSxRQUFRLE1BQU0sTUFBTSxJQUFJO0FBQzlCLFFBQU0sWUFBc0IsQ0FBQztBQUc3QixRQUFNLFdBQXFCO0FBQUE7QUFBQSxJQUV2QjtBQUFBO0FBQUEsSUFFQTtBQUFBO0FBQUEsSUFFQTtBQUFBLEVBQ0o7QUFFQSxhQUFXLFFBQVEsT0FBTztBQUN0QixVQUFNLFVBQVUsS0FBSyxLQUFLO0FBQzFCLFFBQUksQ0FBQyxXQUFXLFlBQVksUUFBUztBQUVyQyxRQUFJLGVBQWU7QUFFbkIsZUFBVyxXQUFXLFVBQVU7QUFDNUIsWUFBTSxRQUFRLFFBQVEsTUFBTSxPQUFPO0FBQ25DLFVBQUksT0FBTztBQUNQLFlBQUksTUFBTSxDQUFDLEdBQUc7QUFDVix5QkFBZSxNQUFNLENBQUMsRUFBRSxLQUFLO0FBQUEsUUFDakM7QUFDQTtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBR0EsUUFBSSxpQkFBaUIsZUFBZSxDQUFDLFNBQVMsS0FBSyxPQUFLLEVBQUUsS0FBSyxPQUFPLENBQUMsR0FBRztBQUN0RSxxQkFBZTtBQUFBLElBQ25CO0FBRUEsY0FBVSxLQUFLLFlBQVk7QUFBQSxFQUMvQjtBQUVBLFNBQU87QUFDWDtBQUVBLFNBQVMsV0FBVyxNQUFzQjtBQUN0QyxRQUFNLE1BQU0sU0FBUyxjQUFjLEtBQUs7QUFDeEMsTUFBSSxjQUFjO0FBQ2xCLFNBQU8sSUFBSTtBQUNmO0FBRUEsU0FBUyxRQUFRLE9BQWdDO0FBQzdDLFNBQU8saUJBQWlCO0FBQzVCOzs7QWpCek1BLElBQU0sYUFBTixjQUF5QixtQkFBbUI7QUFBQSxFQUl4QyxZQUNxQixPQUNqQixjQUNGO0FBQ0UsVUFBTSxFQUFFLGFBQWEsQ0FBQztBQUhMO0FBSWpCLFNBQUssTUFBTSxFQUFFLEdBQUcsS0FBSyxLQUFLLEdBQUcsT0FBTztBQUNwQyxTQUFLLFlBQVksa0JBQWtCLGNBQWMsRUFBRSxZQUFZLEtBQUssTUFBTSxDQUFDLENBQUM7QUFBQSxFQUNoRjtBQUFBLEVBVmlCLFVBQVUsb0JBQUksSUFBWTtBQUFBLEVBQ25DLG1CQUFnQyxDQUFDO0FBQUEsRUFXekMsTUFBTSxZQUFZLE9BQWUsTUFBa0I7QUFFL0MsUUFBSSxLQUFLLFFBQVEsSUFBSSxLQUFLLEdBQUc7QUFDekIsWUFBTSxLQUFLLGFBQWEsS0FBSztBQUM3QjtBQUFBLElBQ0o7QUFHQSxTQUFLLFFBQVEsSUFBSSxLQUFLO0FBR3RCLFVBQU0sS0FBSyxPQUFPLHlCQUF5QixNQUFNO0FBQUEsTUFDN0MsTUFBTTtBQUFBLE1BQ04sUUFBUTtBQUFBLElBQ1osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUVBLE1BQU0sYUFBYSxPQUFlO0FBQzlCLFVBQU0sYUFBYSxLQUFLLE9BQU8sS0FBSztBQUFBLEVBQ3hDO0FBQUEsRUFFQSxxQkFBcUIsT0FBa0I7QUFDbkMsU0FBSyxpQkFBaUIsS0FBSyxLQUFLO0FBQUEsRUFDcEM7QUFBQSxFQUVBLE1BQU0sc0JBQXNCLE9BQWUsS0FBc0M7QUFDN0UsVUFBTSxZQUFZLEtBQUssSUFBSTtBQUMzQixXQUFPLEtBQUssSUFBSSxJQUFJLFlBQVksTUFBTTtBQUNsQyxVQUFJLEtBQUssaUJBQWlCLFNBQVMsR0FBRztBQUNsQyxlQUFPLEtBQUssaUJBQWlCLE1BQU07QUFBQSxNQUN2QztBQUNBLFlBQU0sTUFBTSxHQUFHO0FBQUEsSUFDbkI7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBRUEsdUJBQXVCO0FBQ25CLFNBQUssbUJBQW1CLENBQUM7QUFBQSxFQUM3QjtBQUNKO0FBSUEsSUFBTSxrQkFBa0IsT0FBTyxJQUFJLHVCQUF1QjtBQUMxRCxlQUFlLFdBQVcsY0FBMEM7QUFDaEUsUUFBTSxjQUFtQixPQUFPLFdBQVcsY0FBYyxTQUFTO0FBQ2xFLE1BQUksQ0FBQyxZQUFZLGVBQWUsR0FBRztBQUMvQixnQkFBWSxlQUFlLEtBQUssWUFBWTtBQUN4QyxZQUFNLEVBQUUsSUFBSSxPQUFPLElBQUksTUFBTSxXQUFXO0FBQ3hDLFlBQU0sT0FBTyxNQUFNLEdBQUcsUUFBUTtBQUM5QixZQUFNLE1BQU0sSUFBSSxXQUFXLE1BQU0sWUFBWTtBQUM3Qyw4QkFBd0IsS0FBSyxNQUFNO0FBQ25DLGFBQU87QUFBQSxJQUNYLEdBQUc7QUFBQSxFQUNQO0FBQ0EsU0FBTyxZQUFZLGVBQWU7QUFDdEM7OztBa0JoRk8sU0FBUyxhQUFzQjtBQUNsQyxRQUFNLE1BQU07QUFTWixRQUFNLG9CQUNGLE9BQU8sSUFBSSxZQUFZLGVBQ3ZCLE9BQU8sSUFBSSxnQkFBZ0IsZUFDMUIsT0FBTyxJQUFJLFdBQVcsZUFBZSxJQUFJLE9BQU8sU0FDakQsT0FBTyxJQUFJLFlBQVksZUFDdkIsT0FBTyxJQUFJLE9BQU8sZUFDbEIsT0FBTyxJQUFJLHFCQUFxQjtBQUVwQyxTQUFPLHFCQUFxQixpQkFBaUI7QUFDakQ7QUFFTyxTQUFTLG1CQUFtQjtBQUMvQixTQUNJLE9BQU8sU0FBUyxhQUFhLHFCQUM3QixPQUFPLFNBQVMsT0FBTyxTQUFTLDBCQUEwQjtBQUVsRTs7O0FDMUJBLE9BQU8sbUJBQW1CO0FBQzFCLE9BQU8sV0FBMEI7QUFFMUIsSUFBTSxxQkFBcUIsQ0FBQyxXQUF3QjtBQUV2RCwyQkFBeUIsTUFBTTtBQUsvQixRQUFNLFdBQVcsSUFBSSxpQkFBaUIsTUFBTTtBQUN4Qyw2QkFBeUIsTUFBTTtBQUFBLEVBQ25DLENBQUM7QUFDRCxXQUFTLFFBQVEsUUFBUSxFQUFFLFdBQVcsTUFBTSxTQUFTLEtBQUssQ0FBQztBQUMvRDtBQUlBLElBQU0saUJBQWlCLG9CQUFJLFFBQXVCO0FBRWxELElBQU0sMkJBQTJCLENBQUMsV0FBd0I7QUFDdEQsUUFBTSxjQUFjLE9BQU8saUJBQWlCLEtBQUs7QUFDakQsY0FBWSxRQUFRLFdBQVM7QUFDekIsUUFBSSxTQUFTLENBQUMsZUFBZSxJQUFJLEtBQUssR0FBRztBQUNyQywyQkFBcUIsT0FBTyxNQUFNO0FBQ2xDLHFCQUFlLElBQUksS0FBSztBQUN4QjtBQUFBLElBQ0o7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUVBLElBQUksa0JBQW1DO0FBRXZDLFNBQVMsY0FBYztBQUNuQixrQkFBZ0IsS0FBSztBQUNyQixTQUFPLG9CQUFvQixVQUFVLFdBQVc7QUFDcEQ7QUFFQSxTQUFTLGNBQWM7QUFDbkIsa0JBQWdCLEtBQUs7QUFDckIsU0FBTyxpQkFBaUIsVUFBVSxhQUFhLEVBQUUsTUFBTSxLQUFLLENBQUM7QUFDakU7QUFFQSxJQUFNLHVCQUF1QixDQUFDLE9BQXNCLFdBQXdCO0FBRXhFLE1BQUksQ0FBQyxpQkFBaUI7QUFDbEIsc0JBQWtCLE1BQU0sUUFBUTtBQUFBLE1BQzVCLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxJQUNYLENBQUM7QUFBQSxFQUNMO0FBSUEsUUFBTSxXQUFXLElBQUksaUJBQWlCLGVBQWE7QUFDL0MsY0FBVSxRQUFRLGNBQVk7QUFDMUIsVUFBSSxTQUFTLFNBQVMsYUFBYTtBQUMvQixjQUFNLGNBQWMsTUFBTSxpQkFBaUIscUJBQXFCO0FBQ2hFLFlBQUksWUFBWSxXQUFXLEdBQUc7QUFDMUIsZ0JBQU0saUJBQWlCLFlBQVksQ0FBQztBQUNwQyx5QkFBZSxNQUFNLFVBQVU7QUFJL0IsZ0JBQU0sUUFBUSxlQUFlO0FBQzdCLGNBQUksQ0FBQyxPQUFPO0FBQ1Isd0JBQVk7QUFBQSxVQUNoQixPQUFPO0FBR0gsa0JBQU0sU0FBUyxnQkFBZ0IsS0FBSztBQUdwQyxrQkFBTSxXQUFXLE1BQU0sZUFBZTtBQUN0QyxxQkFBUyxJQUFJLE9BQU8sV0FBVyxLQUFLO0FBQ3BDLHFCQUFTLElBQUksT0FBTyxXQUFXLEtBQUs7QUFDcEMsa0JBQU0sY0FBYyxTQUFTLGdCQUFnQixNQUFNLGFBQWEsQ0FBRTtBQUdsRSxrQkFBTSxVQUFVLFlBQVk7QUFDNUIsa0JBQU0sVUFBVSxZQUFZO0FBRzVCLDRCQUFnQixTQUFTO0FBQUEsY0FDckIsV0FDSSxPQUFPLGNBQWMsV0FBVyxPQUFPLGFBQWEsUUFBUTtBQUFBLGNBQ2hFLHdCQUF3QixNQUFNO0FBQzFCLHVCQUFPO0FBQUEsa0JBQ0gsT0FBTztBQUFBLGtCQUNQLFFBQVE7QUFBQSxrQkFDUixLQUFLO0FBQUEsa0JBQ0wsUUFBUTtBQUFBLGtCQUNSLE1BQU07QUFBQSxrQkFDTixPQUFPO0FBQUEsa0JBQ1AsR0FBRztBQUFBLGtCQUNILEdBQUc7QUFBQSxrQkFDSCxRQUFRLE1BQU07QUFBQSxrQkFBQztBQUFBLGdCQUNuQjtBQUFBLGNBQ0o7QUFBQSxjQUNBLE9BQU8sT0FBTyxjQUFjO0FBQUEsY0FDNUIsUUFBUSxPQUFPLGNBQWMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJO0FBQUEsY0FDakQ7QUFBQTtBQUFBO0FBQUEsZ0JBR0ksT0FBTyxjQUFjLFdBQ2Y7QUFBQSxrQkFDSSxXQUFXO0FBQUEsb0JBQ1A7QUFBQSxzQkFDSSxNQUFNO0FBQUEsc0JBQ04sU0FBUztBQUFBLG9CQUNiO0FBQUEsb0JBQ0E7QUFBQSxzQkFDSSxNQUFNO0FBQUEsc0JBQ04sU0FBUztBQUFBLG9CQUNiO0FBQUEsb0JBQ0E7QUFBQSxzQkFDSSxNQUFNO0FBQUEsc0JBQ04sU0FBUztBQUFBLHNCQUNULE9BQU87QUFBQSxzQkFDUCxJQUFJLENBQUMsRUFBRSxNQUFNLE1BQVc7QUFFcEIsOEJBQU0sY0FBYyxjQUFjLElBQzlCLFVBQVUsTUFBTSxNQUFNLE9BQU8sUUFBUTtBQUN6Qyw4QkFBTSxjQUFjLGNBQWMsSUFDOUIsVUFBVSxNQUFNLE1BQU0sT0FBTyxTQUFTO0FBQUEsc0JBQzlDO0FBQUEsb0JBQ0o7QUFBQSxrQkFDSjtBQUFBLGdCQUNKLElBQ0E7QUFBQTtBQUFBLFlBQ2QsQ0FBQztBQUdELGtCQUFNLFlBQVksU0FBUyxjQUFjLEtBQUs7QUFDOUMsc0JBQVUsVUFBVSxJQUFJLHVCQUF1QjtBQUMvQyxnQkFBSUMsU0FBUTtBQUNaLHVCQUFXLE9BQU8sT0FBTyxRQUFRO0FBRTdCLG9CQUFNLFFBQVEsU0FBUyxjQUFjLEtBQUs7QUFDMUMsb0JBQU0sWUFBWTtBQUNsQix3QkFBVSxZQUFZLEtBQUs7QUFHM0Isb0JBQU0sUUFBUSxTQUFTLGNBQWMsS0FBSztBQUMxQyxvQkFBTSxZQUFZO0FBQ2xCLG9CQUFNLE9BQU8sU0FBUyxlQUFlLElBQUksR0FBRyxDQUFDO0FBRzdDLG9CQUFNLFVBQVUsU0FBUyxjQUFjLEtBQUs7QUFDNUMsc0JBQVEsWUFBWTtBQUVwQixzQkFBUSxPQUFPLFNBQVMsZUFBZSxJQUFJLEtBQUssQ0FBQztBQUNqRCxrQkFBSSxJQUFJLE9BQU87QUFDWCxzQkFBTSxVQUFVLFNBQVMsY0FBYyxNQUFNO0FBQzdDLHdCQUFRLFlBQVk7QUFDcEIsd0JBQVEsTUFBTSxrQkFBa0IsSUFBSTtBQUNwQyx3QkFBUSxPQUFPLE9BQU87QUFBQSxjQUMxQjtBQUVBLG9CQUFNLFlBQVksS0FBSztBQUN2QixvQkFBTSxZQUFZLE9BQU87QUFDekIsY0FBQUE7QUFBQSxZQUNKO0FBR0EsNEJBQWdCLFdBQVcsU0FBUztBQUNwQyx3QkFBWTtBQUFBLFVBQ2hCO0FBQUEsUUFDSixPQUFPO0FBQ0gsZ0JBQU0sSUFBSTtBQUFBLFlBQ04sMkNBQTJDLFlBQVksTUFBTTtBQUFBLFVBQ2pFO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMLENBQUM7QUFFRCxXQUFTLFFBQVEsT0FBTztBQUFBLElBQ3BCLFdBQVc7QUFBQSxJQUNYLFNBQVM7QUFBQSxFQUNiLENBQUM7QUFDTDtBQWlCQSxJQUFNLGtCQUFrQixDQUFDLFVBQXNDO0FBQzNELFFBQU0sU0FBd0IsRUFBRSxRQUFRLENBQUMsRUFBRTtBQUkzQyxRQUFNLGVBQWUsTUFBTSxhQUFhLFdBQVc7QUFDbkQsTUFBSSxjQUFjO0FBQ2QsVUFBTSxRQUFRLGFBQWEsTUFBTSxzQkFBc0I7QUFDdkQsUUFBSSxPQUFPO0FBQ1AsWUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxFQUFFLE1BQU0sR0FBRyxFQUFFLElBQUksTUFBTTtBQUM3QyxhQUFPLFlBQVksRUFBRSxHQUFHLEVBQUU7QUFBQSxJQUM5QjtBQUFBLEVBQ0o7QUFHQSxRQUFNLFdBQVcsTUFBTSxpQkFBaUIsT0FBTztBQUMvQyxXQUFTLFFBQVEsV0FBUztBQUN0QixRQUFJLE1BQU07QUFDVixRQUFJLFFBQVE7QUFDWixRQUFJLFFBQVE7QUFDWixVQUFNLFdBQVcsUUFBUSxVQUFRO0FBQzdCLFVBQUksS0FBSyxhQUFhLFNBQVM7QUFFM0IsY0FBTSxZQUFhLEtBQWlCLGFBQWEsTUFBTTtBQUN2RCxZQUFJLFdBQVc7QUFDWCxrQkFBUTtBQUFBLFFBQ1osT0FBTztBQUNILGdCQUFNLEtBQUssYUFBYSxLQUFLO0FBQUEsUUFDakM7QUFBQSxNQUNKLFdBQVcsS0FBSyxhQUFhLFNBQVM7QUFFbEMsZ0JBQVEsS0FBSyxhQUFhLEtBQUs7QUFBQSxNQUNuQztBQUFBLElBQ0osQ0FBQztBQUNELFFBQUksUUFBUSxVQUFhLFVBQVUsUUFBVztBQUMxQyxhQUFPLE9BQU8sS0FBSyxFQUFFLEtBQUssT0FBTyxNQUFNLENBQUM7QUFBQSxJQUM1QztBQUFBLEVBQ0osQ0FBQztBQUdELFFBQU0sU0FBUyxNQUFNLGNBQWMsTUFBTTtBQUN6QyxNQUFJLFFBQVE7QUFDUixVQUFNLFdBQVcsT0FBTyxhQUFhLEdBQUc7QUFDeEMsUUFBSSxVQUFVO0FBQ1YsYUFBTyxZQUFZLG9CQUFvQixRQUFRO0FBQUEsSUFDbkQ7QUFBQSxFQUNKO0FBRUEsU0FBTztBQUNYO0FBRUEsSUFBTSxxQkFBcUIsQ0FBQyxHQUFXLE1BQTBDO0FBQzdFLE1BQUksSUFBSSxHQUFHO0FBQ1AsV0FBTztBQUFBLEVBQ1gsV0FBVyxJQUFJLEdBQUc7QUFDZCxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLElBQU0sc0JBQXNCLENBQUMsYUFBMkM7QUFDcEUsUUFBTSxTQUFTLGNBQWMsU0FBUyxRQUFRO0FBQzlDLE1BQUksT0FBTyxTQUFTLEdBQUc7QUFDbkIsV0FBTztBQUFBLEVBQ1g7QUFFQSxRQUFNLFNBQVMsT0FBTyxDQUFDO0FBQ3ZCLE1BQUksT0FBTyxTQUFTLEtBQUs7QUFDckIsWUFBUSxLQUFLLG9EQUFvRCxNQUFNO0FBQ3ZFLFdBQU87QUFBQSxFQUNYO0FBRUEsTUFBSSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sR0FBRztBQUNsQyxXQUFPO0FBQUEsRUFDWDtBQUVBLFFBQU0sU0FBUyxPQUFPLENBQUM7QUFDdkIsTUFBSSxPQUFPLFNBQVMsS0FBSztBQUNyQixZQUFRLEtBQUssb0RBQW9ELE1BQU07QUFDdkUsV0FBTztBQUFBLEVBQ1g7QUFFQSxRQUFNLGtCQUFrQixPQUFPLENBQUM7QUFDaEMsTUFBSSxnQkFBZ0IsU0FBUyxPQUFPLGdCQUFnQixTQUFTLEtBQUs7QUFDOUQsWUFBUTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsSUFDSjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBRUEsUUFBTSxpQkFBaUIsT0FBTyxPQUFPLFNBQVMsQ0FBQztBQUMvQyxNQUFJLGVBQWUsU0FBUyxPQUFPLGVBQWUsU0FBUyxLQUFLO0FBQzVELFlBQVE7QUFBQSxNQUNKO0FBQUEsTUFDQTtBQUFBLElBQ0o7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUdBLFFBQU0sSUFBSSxPQUFPO0FBQ2pCLFFBQU0sSUFBSSxPQUFPO0FBRWpCLE1BQUksaUJBQXNEO0FBQzFELE1BQUksSUFBSSxLQUFLLElBQUksR0FBRztBQUNoQixxQkFBaUI7QUFBQSxFQUNyQixXQUFXLElBQUksS0FBSyxJQUFJLEdBQUc7QUFDdkIsUUFBSSxnQkFBZ0IsU0FBUyxLQUFLO0FBQzlCLHVCQUFpQjtBQUFBLElBQ3JCLE9BQU87QUFDSCx1QkFBaUI7QUFBQSxJQUNyQjtBQUFBLEVBQ0osV0FBVyxJQUFJLEtBQUssSUFBSSxHQUFHO0FBQ3ZCLFFBQUksZ0JBQWdCLFNBQVMsS0FBSztBQUM5Qix1QkFBaUI7QUFBQSxJQUNyQixPQUFPO0FBQ0gsdUJBQWlCO0FBQUEsSUFDckI7QUFBQSxFQUNKLFdBQVcsSUFBSSxLQUFLLElBQUksR0FBRztBQUN2QixxQkFBaUI7QUFBQSxFQUNyQixPQUFPO0FBQ0gsWUFBUTtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUdBLE1BQUksZ0JBQTRDO0FBQ2hELE1BQUksZ0JBQWdCLFNBQVMsS0FBSztBQUM5QixvQkFBZ0IsbUJBQW1CLGdCQUFnQixHQUFHLGVBQWUsQ0FBQztBQUFBLEVBQzFFLE9BQU87QUFDSCxvQkFBZ0IsbUJBQW1CLGdCQUFnQixHQUFHLGVBQWUsQ0FBQztBQUFBLEVBQzFFO0FBR0EsTUFBSSxrQkFBa0IsVUFBVTtBQUM1QixXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTyxHQUFHLGNBQWMsSUFBSSxhQUFhO0FBQUEsRUFDN0M7QUFDSjs7O0FwQjVUQSxlQUFlLE9BQU8sRUFBRSxPQUFPLEdBQUcsR0FBNkI7QUFFM0QsUUFBTSxPQUFhLEtBQUssTUFBTSxNQUFNLElBQUksTUFBTSxDQUFDO0FBQy9DLFFBQU0sbUJBQW1CLEVBQUUsY0FBYyxLQUFLLGNBQWMsUUFBUSxFQUFFO0FBQ3RFLFFBQU0sa0JBQWtCLFVBQVUsZ0JBQWdCO0FBR2xELFFBQU0sTUFBTSxNQUFNLFdBQVcsZ0JBQWdCLFlBQVk7QUFHekQsUUFBTSxTQUFpQyxNQUFNLElBQUksUUFBUSxLQUFLLENBQUM7QUFDL0QsUUFBTSxXQUFXLEtBQUssTUFBTTtBQUc1QixLQUFHLFVBQVUsSUFBSSxlQUFlO0FBQ2hDLFFBQU0sZ0JBQWdCLFlBQVksRUFBRTtBQUNwQyxRQUFNLFNBQVMsSUFBSSxJQUFJLE9BQU8sS0FBSyxNQUFNLENBQUM7QUFDMUMsTUFBSSxjQUFjLHFCQUFxQixXQUFXLElBQUksR0FBRztBQUNyRCxPQUFHLE1BQU0sUUFBUTtBQUNqQixPQUFHLE1BQU0sU0FBUztBQUFBLEVBQ3RCO0FBQ0EsTUFBSSxjQUFjLFlBQVksWUFBWSxJQUFJLEdBQUc7QUFHN0MsVUFBTSxPQUFPLEdBQUcsUUFBUSxZQUFZO0FBQ3BDLFFBQUksTUFBTTtBQUNOLFdBQUssTUFBTSxVQUFVO0FBQUEsSUFDekI7QUFBQSxFQUNKO0FBQ0EsUUFBTSxhQUFhLFlBQVk7QUFDM0IsUUFBSTtBQUNBLFVBQUkscUJBQXFCO0FBQ3pCLFlBQU0sYUFBYSxjQUFjLFdBQVcsZUFBZSxNQUFNLEVBQUUsSUFBSTtBQUN2RSxZQUFNLE1BQU0sVUFBVSxZQUFZLEVBQUUsT0FBTyxDQUFDO0FBQzVDLFlBQU0sU0FBVSxNQUFNLFNBQVMsS0FBSyxHQUFHO0FBQ3ZDLFNBQUcsWUFBWTtBQUNmLFNBQUcsWUFBWSxNQUFNO0FBSXJCLHlCQUFvQixNQUFNO0FBRTFCLFlBQU0sdUJBQXVCLEtBQUssRUFBRTtBQUFBLElBQ3hDLFNBQVMsR0FBWTtBQUNqQixjQUFRLE1BQU0sQ0FBQztBQUNmLFlBQU0sUUFBUSxVQUFVLENBQUM7QUFDekIsU0FBRyxZQUFZLFlBQVksS0FBSztBQUFBLElBQ3BDO0FBQUEsRUFDSjtBQUNBLFFBQU0sV0FBVztBQUdqQixNQUFJLGNBQWMsWUFBWSxDQUFDLFlBQVksSUFBSSxHQUFHO0FBQzlDLFFBQUkscUJBQXFCLEdBQUc7QUFDNUIsUUFBSSxzQkFBc0IsR0FBRztBQUc3QixVQUFNLGlCQUFpQixJQUFJO0FBQUEsTUFDdkJDLFVBQVMsWUFBWTtBQUNqQixZQUNJLHVCQUF1QixHQUFHLGVBQzFCLHdCQUF3QixHQUFHLGNBQzdCO0FBQ0UsK0JBQXFCLEdBQUc7QUFDeEIsZ0NBQXNCLEdBQUc7QUFDekIscUJBQVc7QUFBQSxRQUNmO0FBQUEsTUFDSixDQUFDO0FBQUEsSUFDTDtBQUNBLG1CQUFlLFFBQVEsRUFBRTtBQUd6QixXQUFPLE1BQU07QUFDVCxxQkFBZSxXQUFXO0FBQUEsSUFDOUI7QUFBQSxFQUNKO0FBQ0o7QUFHQSxlQUFlLFdBQVcsS0FBaUIsUUFBZ0M7QUFDdkUsYUFBVyxDQUFDLFdBQVcsVUFBVSxLQUFLLE9BQU8sUUFBUSxNQUFNLEdBQUc7QUFDMUQsUUFBSSxZQUFZO0FBRVosWUFBTSxlQUFlLEtBQUssVUFBVTtBQUNwQyxZQUFNLFFBQVEsSUFBSSxXQUFXLGFBQWEsTUFBTTtBQUNoRCxlQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsUUFBUSxLQUFLO0FBQzFDLGNBQU0sQ0FBQyxJQUFJLGFBQWEsV0FBVyxDQUFDO0FBQUEsTUFDeEM7QUFHQSxZQUFNLElBQUksWUFBWSxXQUFXLEtBQUs7QUFBQSxJQUMxQyxPQUFPO0FBRUgsWUFBTSxJQUFJLGFBQWEsU0FBUztBQUFBLElBQ3BDO0FBQUEsRUFDSjtBQUNKO0FBT0EsU0FBUyxZQUFZLGFBQXlDO0FBRzFELFFBQU0sV0FBVyxZQUFZLFFBQVEsaUJBQWlCO0FBQ3RELE1BQUksVUFBVTtBQUNWLGFBQVMsTUFBTSxlQUFlO0FBQUEsRUFDbEM7QUFHQSxRQUFNLFdBQVcsT0FBTyxTQUFTLEtBQUssVUFBVSxTQUFTLGtCQUFrQjtBQUczRSxRQUFNLG9CQUNGLFlBQVksQ0FBQyxPQUFPLFNBQVMsS0FBSyxVQUFVLFNBQVMsZ0JBQWdCO0FBRXpFLFNBQU8sRUFBRSxVQUFVLGtCQUFrQjtBQUN6QztBQUlBLFNBQVMsZUFBZSxNQUFZLGFBQWdDO0FBQ2hFLFFBQU0sZUFBZTtBQUNyQixRQUFNLGdCQUFnQjtBQUV0QixTQUFPLGdCQUFnQixJQUFJO0FBQzNCLE1BQUksV0FBVyxRQUFRLEtBQUssVUFBVSxTQUFTO0FBQzNDLFVBQU0sUUFBUTtBQUVkLElBQUMsTUFBa0MsZUFBZTtBQUFBLEVBQ3RELFdBQVcsYUFBYSxRQUFRLEtBQUssUUFBUSxVQUFVLEdBQUc7QUFFdEQsVUFBTSxVQUFVLEtBQUs7QUFDckIsVUFBTSxPQUFPLFVBQVUsUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDLElBQUk7QUFDakQsUUFBSSxNQUFNO0FBQ04sV0FBSyxRQUFRLFlBQVksZUFBZSxRQUFRLFNBQVMsSUFBSSxlQUFlO0FBQzVFLFdBQUssU0FBUyxZQUFZO0FBQUEsSUFDOUI7QUFBQSxFQUNKLFdBQVcsYUFBYSxRQUFRLEtBQUssUUFBUSxVQUFVLEdBQUc7QUFFdEQsVUFBTSxVQUFVLEtBQUs7QUFDckIsVUFBTSxPQUNGLFVBQVUsUUFBUSxDQUFDLEtBQUssWUFBWSxRQUFRLENBQUMsSUFDdkMsUUFBUSxDQUFDLElBQ1QsVUFBVSxRQUFRLENBQUMsS0FBSyxZQUFZLFFBQVEsQ0FBQyxJQUMzQyxRQUFRLENBQUMsSUFDVDtBQUNaLFFBQUksTUFBTTtBQUNOLFdBQUssUUFBUSxZQUFZLGVBQWUsS0FBSyxRQUFRLFNBQVMsSUFBSSxlQUFlO0FBQ2pGLFdBQUssU0FBUyxZQUFZO0FBQUEsSUFDOUI7QUFBQSxFQUNKLFdBQVcsYUFBYSxRQUFRLEtBQUssUUFBUSxVQUFVLEdBQUc7QUFFdEQsVUFBTSxVQUFVLEtBQUs7QUFDckIsVUFBTSxPQUNGLFVBQVUsUUFBUSxDQUFDLEtBQUssWUFBWSxRQUFRLENBQUMsSUFDdkMsUUFBUSxDQUFDLElBQ1QsVUFBVSxRQUFRLENBQUMsS0FBSyxZQUFZLFFBQVEsQ0FBQyxJQUMzQyxRQUFRLENBQUMsSUFDVDtBQUNaLFFBQUksTUFBTTtBQUNOLFdBQUssUUFBUSxZQUFZO0FBQ3pCLFdBQUssU0FBUyxZQUFZLGdCQUFnQixLQUFLLFFBQVEsU0FBUyxJQUFJLGdCQUFnQjtBQUFBLElBQ3hGO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDtBQUVBLFNBQVMsV0FBVyxNQUFZO0FBQzVCLE1BQUksVUFBVSxNQUFNO0FBQ2hCLFdBQU87QUFBQSxFQUNYLFdBQVcsV0FBVyxRQUFRLEtBQUssVUFBVSxTQUFTO0FBQ2xELFdBQU87QUFBQSxFQUNYLFdBQ0ksYUFBYSxRQUNiLEtBQUssUUFBUSxXQUFXLE1BQ3ZCLFVBQVUsS0FBSyxRQUFRLENBQUMsS0FBSyxVQUFVLEtBQUssUUFBUSxDQUFDLElBQ3hEO0FBQ0UsV0FBTztBQUFBLEVBQ1gsV0FDSSxhQUFhLFFBQ2IsS0FBSyxRQUFRLFdBQVcsTUFDdkIsVUFBVSxLQUFLLFFBQVEsQ0FBQyxLQUFLLFVBQVUsS0FBSyxRQUFRLENBQUMsSUFDeEQ7QUFDRSxXQUFPO0FBQUEsRUFDWCxPQUFPO0FBQ0gsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLFNBQVMsWUFBWSxNQUFZO0FBQzdCLFNBQU8sV0FBVyxRQUFRLEtBQUssVUFBVTtBQUM3QztBQUVBLGVBQWUsU0FBUyxLQUFlLEtBQXlCO0FBRTVELGFBQVcsQ0FBQyxNQUFNLElBQUksS0FBSyxPQUFPLFFBQVEsSUFBSSxNQUFNLEdBQUc7QUFHbkQsUUFBSSxDQUFDLElBQUksYUFBYSxJQUFJLElBQUksS0FBSyxXQUFXLEdBQUc7QUFDN0MsWUFBTSxRQUFTLEtBQWlCLFlBQVksR0FBRztBQUMvQyxVQUFJLGFBQWEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0o7QUFHQSxTQUFPLElBQUksS0FBSyxZQUFZLEdBQUc7QUFDbkM7QUFFQSxlQUFlLHVCQUF1QixLQUFpQixVQUF1QjtBQUcxRSxRQUFNLGdCQUFnQixTQUFTLGlCQUFpQixnQkFBZ0I7QUFDaEUsYUFBVyxZQUFZLGVBQWU7QUFDbEMsVUFBTSxRQUFRLE1BQU0sSUFBSSxzQkFBc0I7QUFDOUMsUUFBSSxPQUFPO0FBQ1AseUJBQW1CLE9BQU8sUUFBdUI7QUFBQSxJQUNyRDtBQUFBLEVBQ0o7QUFDSjtBQUVBLElBQU8saUJBQVEsRUFBRSxPQUFPOyIsCiAgIm5hbWVzIjogWyJ0aHJvdHRsZSIsICJpbnB1dCIsICJpbnB1dCIsICJjb2x1bW4iLCAiaXNTZWxlY3Rpb24iLCAiaW5wdXQiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJpc1NlbGVjdGlvbiIsICJpbnB1dCIsICJpc1NlbGVjdGlvbiIsICJjbGF1c2VQb2ludCIsICJpc1BhcmFtIiwgImNsYXVzZVBvaW50IiwgImlzUGFyYW0iLCAiaXNTZWxlY3Rpb24iLCAiUXVlcnkiLCAibWluIiwgIm1heCIsICJpc1NlbGVjdGlvbiIsICJ2YWx1ZSIsICJjb2x1bW4iLCAiUXVlcnkiLCAiY2xhdXNlUG9pbnQiLCAiaXNQYXJhbSIsICJjbGF1c2VQb2ludHMiLCAiaXNTZWxlY3Rpb24iLCAidG9EYXRhQ29sdW1ucyIsICJRdWVyeSIsICJtYXgiLCAibWluIiwgImNvbHVtbiIsICJjbGF1c2VQb2ludHMiLCAiUXVlcnkiLCAiZmlsdGVyIiwgInRvRGF0YUNvbHVtbnMiLCAiaXNTZWxlY3Rpb24iLCAibWF4IiwgIm1pbiIsICJpc1BhcmFtIiwgImlzU2VsZWN0aW9uIiwgIlF1ZXJ5IiwgImlzU2VsZWN0aW9uIiwgImlzUGFyYW0iLCAiUXVlcnkiLCAiY291bnQiLCAidGhyb3R0bGUiXQp9Cg==\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_9b3c5bc60ac8417d869a2067bd630015","spec":"","tabbable":null,"tables":{},"tooltip":null}}},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/meridianlabs-ai\.github\.io\/inspect_viz");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            trigger: 'click',
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            positionFixed: true,
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../examples/inspect/tool-usage/index.html" class="pagination-link" aria-label="Tool Usage">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Tool Usage</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../examples/general/bias-parameter/index.html" class="pagination-link" aria-label="Bias Parameter">
        <span class="nav-page-text">Bias Parameter</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/">
<p>Meridian Labs</p>
</a>
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz">
<p>Code</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz/blob/main/LICENSE">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz/issues">
<p>Issues</p>
</a>
  </li>  
</ul>
    <div class="toc-actions"><ul><li><a href="https://github.com/meridianlabs-ai/inspect_viz/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz">
<p>Code</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>