<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-99.9.9">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Scores by Limit – Inspect Viz</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../examples/inspect/scores-timeline/index.html" rel="next">
<link href="../../../examples/inspect/scores-by-factor/index.html" rel="prev">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-3aa970819e70fbc78806154e5a1fcd28.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-3ce9b6b5994d5f9c95269e9dba282a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>
<style type="text/css">
.cell {
  display: flex;
  flex-direction: column-reverse;
}
.code-with-filename {
  margin-top: 1em;
}
</style>


<meta property="og:title" content="Inspect Viz">
<meta property="og:description" content="Data visualization for Inspect AI evalutions">
<meta property="og:image" content="https://meridianlabs-ai.github.io/inspect_viz/inspect_viz.png">
<meta property="og:site_name" content="Inspect Viz">
<meta property="og:image:height" content="1122">
<meta property="og:image:width" content="1620">
<meta name="twitter:title" content="Inspect Viz">
<meta name="twitter:description" content="Data visualization for Inspect AI evaluations.">
<meta name="twitter:image" content="https://meridianlabs-ai.github.io/inspect_viz/inspect_viz.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image-height" content="1122">
<meta name="twitter:image-width" content="1620">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Inspect Viz</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="../../../index.html" aria-current="page"> 
<span class="menu-text">Getting Started</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../views.html"> 
<span class="menu-text">Views</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../components-plots.html"> 
<span class="menu-text">Components</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../publishing.html"> 
<span class="menu-text">Publishing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../reference/index.html"> 
<span class="menu-text">Reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../examples/index.html"> 
<span class="menu-text">Examples</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../examples/inspect/scores-by-task/index.html">Inspect</a></li><li class="breadcrumb-item"><a href="../../../examples/inspect/scores-by-limit/index.html">Scores by Limit</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../../../index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Examples</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Inspect</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/scores-by-task/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores by Task</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/scores-by-model/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores by Model</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/scores-by-factor/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores by Factor</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/scores-by-limit/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Scores by Limit</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/scores-timeline/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores Timeline</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/scores-heatmap/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores Heatmap</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/inspect/tool-calls/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tool Calls</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">General</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/penguins/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Penguins Explorer</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/bias-parameter/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bias Parameter</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/seattle-weather/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Seattle Weather</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/athletes-regression/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Athletes (Regression)</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../examples/general/athletes-errorbars/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Athletes (Error Bars)</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link active" data-scroll-target="#data-preparation">Data Preparation</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/meridianlabs-ai/inspect_viz/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../../examples/inspect/scores-by-task/index.html">Inspect</a></li><li class="breadcrumb-item"><a href="../../../examples/inspect/scores-by-limit/index.html">Scores by Limit</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Scores by Limit</h1>
<p class="subtitle lead">Dataset: <a href="swebench_token_limit.parquet">swebench_token_limit.parquet</a></p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>This example illustrates the code behind the <a href="../../../view-scores-by-limit.html"><code>scores_by_limit()</code></a> pre‑built view function. If you want to include this plot in your notebooks or sites, start with that function rather than the lower‑level code below.</p>
<p>The plot shows how model <strong>success rate</strong> changes as the <strong>compute budget</strong> increases (e.g., token limit, messages, cost, or time). It helps answer “<em>Will performance keep improving if I spend more?</em>”. The shaded band displays the confidence interval derived from the standard error.</p>
<div id="62196bbf" class="cell" data-execution_count="1">
<div class="code-with-filename">
<div class="code-with-filename-file">
<pre><strong>Code</strong></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-1"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-1-1"><a href="#annotated-cell-1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz <span class="im">import</span> Data, Selection</span>
<span id="annotated-cell-1-2"><a href="#annotated-cell-1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.mark <span class="im">import</span> area_y, line</span>
<span id="annotated-cell-1-3"><a href="#annotated-cell-1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.plot <span class="im">import</span> plot, legend</span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.transform <span class="im">import</span> sql, ci_bounds</span>
<span id="annotated-cell-1-5"><a href="#annotated-cell-1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.interactor <span class="im">import</span> highlight, nearest_x</span>
<span id="annotated-cell-1-6"><a href="#annotated-cell-1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz._util.stats <span class="im">import</span> z_score</span>
<span id="annotated-cell-1-7"><a href="#annotated-cell-1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-8"><a href="#annotated-cell-1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># read data (see 'Data Preparation' below)</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1">1</button><span id="annotated-cell-1-9" class="code-annotation-target"><a href="#annotated-cell-1-9" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> Data.from_file(<span class="st">"swebench_token_limit.parquet"</span>)</span>
<span id="annotated-cell-1-10"><a href="#annotated-cell-1-10" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="2">2</button><span id="annotated-cell-1-11" class="code-annotation-target"><a href="#annotated-cell-1-11" aria-hidden="true" tabindex="-1"></a>channels <span class="op">=</span> {</span>
<span id="annotated-cell-1-12"><a href="#annotated-cell-1-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Token Limit"</span>: <span class="st">"total_tokens"</span>,</span>
<span id="annotated-cell-1-13"><a href="#annotated-cell-1-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Success Rate"</span>: <span class="st">"success_rate"</span>,</span>
<span id="annotated-cell-1-14"><a href="#annotated-cell-1-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Model"</span>: <span class="st">"model_display_name"</span>,</span>
<span id="annotated-cell-1-15"><a href="#annotated-cell-1-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Log"</span>: <span class="st">"log_viewer"</span></span>
<span id="annotated-cell-1-16"><a href="#annotated-cell-1-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="annotated-cell-1-17"><a href="#annotated-cell-1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-18"><a href="#annotated-cell-1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># confidence interval</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="3">3</button><span id="annotated-cell-1-19" class="code-annotation-target"><a href="#annotated-cell-1-19" aria-hidden="true" tabindex="-1"></a>ci_lower, ci_upper <span class="op">=</span> ci_bounds(<span class="st">"success_rate"</span>, level<span class="op">=</span><span class="fl">0.95</span>, stderr<span class="op">=</span><span class="st">"standard_error"</span>)</span>
<span id="annotated-cell-1-20"><a href="#annotated-cell-1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-21"><a href="#annotated-cell-1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># enable interactive highlighting of a chosen model</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="4">4</button><span id="annotated-cell-1-22" class="code-annotation-target"><a href="#annotated-cell-1-22" aria-hidden="true" tabindex="-1"></a>selection <span class="op">=</span> Selection.single()</span>
<span id="annotated-cell-1-23"><a href="#annotated-cell-1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-24"><a href="#annotated-cell-1-24" aria-hidden="true" tabindex="-1"></a>components <span class="op">=</span> [</span>
<span id="annotated-cell-1-25"><a href="#annotated-cell-1-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># success-rate lines by model (optionally faceted by difficulty)</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="5">5</button><span id="annotated-cell-1-26" class="code-annotation-target"><a href="#annotated-cell-1-26" aria-hidden="true" tabindex="-1"></a>    line(</span>
<span id="annotated-cell-1-27"><a href="#annotated-cell-1-27" aria-hidden="true" tabindex="-1"></a>        data, </span>
<span id="annotated-cell-1-28"><a href="#annotated-cell-1-28" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span><span class="st">"total_tokens"</span>, </span>
<span id="annotated-cell-1-29"><a href="#annotated-cell-1-29" aria-hidden="true" tabindex="-1"></a>        y<span class="op">=</span><span class="st">"success_rate"</span>, </span>
<span id="annotated-cell-1-30"><a href="#annotated-cell-1-30" aria-hidden="true" tabindex="-1"></a>        stroke<span class="op">=</span><span class="st">"model_display_name"</span>, </span>
<span id="annotated-cell-1-31"><a href="#annotated-cell-1-31" aria-hidden="true" tabindex="-1"></a>        tip<span class="op">=</span><span class="va">True</span>, </span>
<span id="annotated-cell-1-32"><a href="#annotated-cell-1-32" aria-hidden="true" tabindex="-1"></a>        channels<span class="op">=</span>channels</span>
<span id="annotated-cell-1-33"><a href="#annotated-cell-1-33" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="annotated-cell-1-34"><a href="#annotated-cell-1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-35"><a href="#annotated-cell-1-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># confidence band from mean ± z * stderr</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="6">6</button><span id="annotated-cell-1-36" class="code-annotation-target"><a href="#annotated-cell-1-36" aria-hidden="true" tabindex="-1"></a>    area_y(</span>
<span id="annotated-cell-1-37"><a href="#annotated-cell-1-37" aria-hidden="true" tabindex="-1"></a>        data,</span>
<span id="annotated-cell-1-38"><a href="#annotated-cell-1-38" aria-hidden="true" tabindex="-1"></a>        x<span class="op">=</span><span class="st">"total_tokens"</span>,</span>
<span id="annotated-cell-1-39"><a href="#annotated-cell-1-39" aria-hidden="true" tabindex="-1"></a>        y<span class="op">=</span><span class="st">"success_rate"</span>,</span>
<span id="annotated-cell-1-40"><a href="#annotated-cell-1-40" aria-hidden="true" tabindex="-1"></a>        y1<span class="op">=</span>ci_lower,</span>
<span id="annotated-cell-1-41"><a href="#annotated-cell-1-41" aria-hidden="true" tabindex="-1"></a>        y2<span class="op">=</span>ci_upper,</span>
<span id="annotated-cell-1-42"><a href="#annotated-cell-1-42" aria-hidden="true" tabindex="-1"></a>        color<span class="op">=</span><span class="st">"model_display_name"</span>,</span>
<span id="annotated-cell-1-43"><a href="#annotated-cell-1-43" aria-hidden="true" tabindex="-1"></a>        fill<span class="op">=</span><span class="st">"model_display_name"</span>,</span>
<span id="annotated-cell-1-44"><a href="#annotated-cell-1-44" aria-hidden="true" tabindex="-1"></a>        fill_opacity<span class="op">=</span><span class="fl">0.3</span>,</span>
<span id="annotated-cell-1-45"><a href="#annotated-cell-1-45" aria-hidden="true" tabindex="-1"></a>        tip<span class="op">=</span><span class="va">False</span></span>
<span id="annotated-cell-1-46"><a href="#annotated-cell-1-46" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="annotated-cell-1-47"><a href="#annotated-cell-1-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-48"><a href="#annotated-cell-1-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-49"><a href="#annotated-cell-1-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># interactions: snap by nearest x and highlight selection</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="7">7</button><span id="annotated-cell-1-50" class="code-annotation-target"><a href="#annotated-cell-1-50" aria-hidden="true" tabindex="-1"></a>    nearest_x(target<span class="op">=</span>selection, channels<span class="op">=</span>[<span class="st">"color"</span>]),</span>
<span id="annotated-cell-1-51"><a href="#annotated-cell-1-51" aria-hidden="true" tabindex="-1"></a>    highlight(by<span class="op">=</span>selection, opacity<span class="op">=</span><span class="fl">0.2</span>, fill_opacity<span class="op">=</span><span class="fl">0.1</span>),</span>
<span id="annotated-cell-1-52"><a href="#annotated-cell-1-52" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="annotated-cell-1-53"><a href="#annotated-cell-1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-54"><a href="#annotated-cell-1-54" aria-hidden="true" tabindex="-1"></a>plot(</span>
<span id="annotated-cell-1-55"><a href="#annotated-cell-1-55" aria-hidden="true" tabindex="-1"></a>    components,</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="8">8</button><span id="annotated-cell-1-56" class="code-annotation-target"><a href="#annotated-cell-1-56" aria-hidden="true" tabindex="-1"></a>    x_label<span class="op">=</span><span class="st">"total_tokens"</span>,</span>
<span id="annotated-cell-1-57"><a href="#annotated-cell-1-57" aria-hidden="true" tabindex="-1"></a>    y_label<span class="op">=</span><span class="st">"Success rate"</span>,</span>
<span id="annotated-cell-1-58"><a href="#annotated-cell-1-58" aria-hidden="true" tabindex="-1"></a>    legend<span class="op">=</span>legend(<span class="st">"color"</span>, frame_anchor<span class="op">=</span><span class="st">"top-left"</span>, inset<span class="op">=</span><span class="dv">20</span>),</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="9">9</button><span id="annotated-cell-1-59" class="code-annotation-target"><a href="#annotated-cell-1-59" aria-hidden="true" tabindex="-1"></a>    x_scale<span class="op">=</span><span class="st">"log"</span>,</span>
<span id="annotated-cell-1-60"><a href="#annotated-cell-1-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># layout tweaks</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="10">10</button><span id="annotated-cell-1-61" class="code-annotation-target"><a href="#annotated-cell-1-61" aria-hidden="true" tabindex="-1"></a>    y_inset_top<span class="op">=</span><span class="dv">10</span>,</span>
<span id="annotated-cell-1-62"><a href="#annotated-cell-1-62" aria-hidden="true" tabindex="-1"></a>    margin_bottom<span class="op">=</span><span class="dv">30</span>,</span>
<span id="annotated-cell-1-63"><a href="#annotated-cell-1-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># dimensions</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="11">11</button><span id="annotated-cell-1-64" class="code-annotation-target"><a href="#annotated-cell-1-64" aria-hidden="true" tabindex="-1"></a>    width<span class="op">=</span><span class="dv">700</span>,</span>
<span id="annotated-cell-1-65"><a href="#annotated-cell-1-65" aria-hidden="true" tabindex="-1"></a>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="9" data-code-annotation="1"><strong>Load data</strong> from a Parquet file into an <code>inspect_viz.Data</code> table.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="11,16" data-code-annotation="2"><strong>Channels</strong> provide readable names for tooltips and the log viewer.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="19" data-code-annotation="3"><strong>Confidence interval</strong>: choose a value like <code>0.80</code>, <code>0.90</code>, or <code>0.95</code>; it’s converted to a z‑score for the shaded band.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="22" data-code-annotation="4"><strong>Selection</strong> enables interactive hovering/clicking to emphasize a single model.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="26" data-code-annotation="5"><strong><code>line()</code> mark</strong> draws success‑rate curves with tooltips.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="36" data-code-annotation="6"><strong><code>area_y()</code></strong> adds a CI band using <code>mean ± z * stderr</code> if <code>standard_error</code> is present.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="7">7</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="50,51" data-code-annotation="7"><strong>Interactions</strong>: <code>nearest_x()</code> snaps the selection to the closest x, and <code>highlight()</code> dims the rest.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="8">8</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="56,57" data-code-annotation="8"><strong>Labels</strong>: x uses the field name; y is set explicitly (pass <code>None</code> to hide).</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="9">9</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="59" data-code-annotation="9"><strong>Log scale</strong> for the budget axis to better separate small and large limits.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="10">10</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="61,62" data-code-annotation="10"><strong>Layout</strong>: small top inset avoids clipping; extra bottom margin leaves room for the legend.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="11">11</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="64" data-code-annotation="11"><strong>Size</strong>: default width is 700px; height defaults to the golden ratio (<code>width / 1.618</code>).</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display" data-execution_count="1">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"b2a1749eb882429cbcc2113c9b696ce8","version_major":2,"version_minor":1,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<section id="data-preparation" class="level2">
<h2 class="anchored" data-anchor-id="data-preparation">Data Preparation</h2>
<p>The data dataset for this example was created using the <code>scores_by_limit_df()</code> function, which reads per-sample metadata, computes token usage, and aggregates a success rate as a function of a limit threshhold.</p>
<p>Above we read the data for the plot from a parquet file. This file was in turn created by:</p>
<ol type="1">
<li><p>Reading sample level data into a data frame with <a href="https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#evals_df"><code>samples_df()</code></a>. In addition to the base sample information, we also read eval specific columns using <code>EvalInfo</code> and <code>EvalModel</code>.</p></li>
<li><p>Converting the samples dataframe into a dataframe specifically used by <code>scores_by_limit()</code> by using the <code>scores_by_limit_df()</code> function.</p></li>
<li><p>Using the <a href="https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#prepare"><code>prepare()</code></a> function to add <a href="https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#model_info"><code>model_info()</code></a> and <a href="https://inspect.aisi.org.uk/reference/inspect_ai.analysis.html#model_info"><code>log_viewer()</code></a> columns to the data frame.</p></li>
</ol>
<p>Here is the data preparation code end-to-end:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="annotated-cell-2"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-2-1"><a href="#annotated-cell-2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_ai.analysis <span class="im">import</span> (</span>
<span id="annotated-cell-2-2"><a href="#annotated-cell-2-2" aria-hidden="true" tabindex="-1"></a>    EvalInfo,</span>
<span id="annotated-cell-2-3"><a href="#annotated-cell-2-3" aria-hidden="true" tabindex="-1"></a>    EvalModel,</span>
<span id="annotated-cell-2-4"><a href="#annotated-cell-2-4" aria-hidden="true" tabindex="-1"></a>    SampleSummary,</span>
<span id="annotated-cell-2-5"><a href="#annotated-cell-2-5" aria-hidden="true" tabindex="-1"></a>    log_viewer,</span>
<span id="annotated-cell-2-6"><a href="#annotated-cell-2-6" aria-hidden="true" tabindex="-1"></a>    model_info,</span>
<span id="annotated-cell-2-7"><a href="#annotated-cell-2-7" aria-hidden="true" tabindex="-1"></a>    prepare,</span>
<span id="annotated-cell-2-8"><a href="#annotated-cell-2-8" aria-hidden="true" tabindex="-1"></a>    samples_df</span>
<span id="annotated-cell-2-9"><a href="#annotated-cell-2-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="annotated-cell-2-10"><a href="#annotated-cell-2-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.view.beta <span class="im">import</span> scores_by_limit_df</span>
<span id="annotated-cell-2-11"><a href="#annotated-cell-2-11" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1">1</button><span id="annotated-cell-2-12" class="code-annotation-target"><a href="#annotated-cell-2-12" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> samples_df(</span>
<span id="annotated-cell-2-13"><a href="#annotated-cell-2-13" aria-hidden="true" tabindex="-1"></a>    [</span>
<span id="annotated-cell-2-14"><a href="#annotated-cell-2-14" aria-hidden="true" tabindex="-1"></a>    <span class="st">"logs/swe-bench/"</span>],</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="2">2</button><span id="annotated-cell-2-15" class="code-annotation-target"><a href="#annotated-cell-2-15" aria-hidden="true" tabindex="-1"></a>    columns<span class="op">=</span>SampleSummary <span class="op">+</span> EvalInfo <span class="op">+</span> EvalModel,</span>
<span id="annotated-cell-2-16"><a href="#annotated-cell-2-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="annotated-cell-2-17"><a href="#annotated-cell-2-17" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="3">3</button><span id="annotated-cell-2-18" class="code-annotation-target"><a href="#annotated-cell-2-18" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> scores_by_limit_df(</span>
<span id="annotated-cell-2-19"><a href="#annotated-cell-2-19" aria-hidden="true" tabindex="-1"></a>    df,</span>
<span id="annotated-cell-2-20"><a href="#annotated-cell-2-20" aria-hidden="true" tabindex="-1"></a>    score<span class="op">=</span><span class="st">"score_swe_bench_scorer_stderr"</span>,</span>
<span id="annotated-cell-2-21"><a href="#annotated-cell-2-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="annotated-cell-2-22"><a href="#annotated-cell-2-22" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="4">4</button><span id="annotated-cell-2-23" class="code-annotation-target"><a href="#annotated-cell-2-23" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> prepare(df,</span>
<span id="annotated-cell-2-24"><a href="#annotated-cell-2-24" aria-hidden="true" tabindex="-1"></a>  model_info(),</span>
<span id="annotated-cell-2-25"><a href="#annotated-cell-2-25" aria-hidden="true" tabindex="-1"></a>  log_viewer(<span class="st">"eval"</span>, { <span class="st">"logs"</span>: <span class="st">"https://samples.meridianlabs.ai/"</span> })</span>
<span id="annotated-cell-2-26"><a href="#annotated-cell-2-26" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="annotated-cell-2-27"><a href="#annotated-cell-2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-28"><a href="#annotated-cell-2-28" aria-hidden="true" tabindex="-1"></a>df.to_parquet(<span class="st">"swebench_token_limit.parquet"</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="12" data-code-annotation="1">Read the samples data info a dataframe.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="15" data-code-annotation="2">Be sure to specify the <code>SampleSummary</code>, <code>EvalInfo</code>, and <code>EvalModel</code> columns.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="18,19,20" data-code-annotation="3">Convert the base dataframe into a <code>scores_by_limit()</code> specific dataframe.</span>
</dd>
<dt data-target-cell="annotated-cell-2" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="23,24,25,26" data-code-annotation="4">Add pretty model names and log links to the dataframe.</span>
</dd>
</dl>


</section>

</main> <!-- /main -->
<script type="application/vnd.jupyter.widget-state+json">
{"state":{"238b52a1f3fc4684ba77e0c2ddef286a":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"35e4db52af80479e822aa4badaa9aca4":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  legendContainerEl.style.padding = \"0.3em\";\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    targetEl.style.background = background === true ? \"white\" : background || \"white\";\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_90508e6a5d7943e582e918fed44ef91a","spec":"","tabbable":null,"tables":{},"tooltip":null}},"638c40e075f14636906bc3edc773aff0":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"900cc40e79ca427584b651c0a5edaf75":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"90508e6a5d7943e582e918fed44ef91a":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"a9cbf119a23e4243a44d8d676812db7c":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.mark._mark.Mark","_css":"\n\n.mosaic-widget fieldset {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n    border: none;\n    margin: 0;\n    padding: 0;\n}\n\n.mosaic-widget fieldset>label {\n    display: inline-flex;\n    align-items: center;\n    margin-bottom: 0;\n}\n\n.mosaic-widget fieldset>label>input[type=\"radio\"] {\n    margin-right: 0.25rem;\n}\n\n.mosaic-widget fieldset>legend {\n    font-size: inherit;\n    margin: 0;\n}\n\n.mosaic-widget {\n    margin-top: 10px;\n    margin-bottom: 0.5rem;\n}\n\n.mosaic-widget label {\n    display: inline-flex;\n    align-items: center;\n    white-space: nowrap;\n    margin-bottom: 10px;\n}\n\n.mosaic-widget label>select,\n.mosaic-widget .input-search,\n.mosaic-widget .ts-wrapper,\nlabel>input[type=\"range\"] {\n    margin-left: 0.25rem;\n    margin-right: 0.5rem;\n}\n\n.mosaic-widget .input-search {\n    width: 150px;\n}\n\n.mosaic-widget label>input[type=\"range\"] {\n    margin-right: 0.25rem;\n}\n\n.mosaic-widget div[style*=\"display: flex\"][style*=\"flex-flow: row\"] {\n    align-items: center !important;\n    /* or whatever you need */\n}\n\n\n.mosaic-widget .slider-input {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-right: 0.5rem;\n}\n\n.mosaic-widget .slider-input label {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.mosaic-widget .slider-input .noUi-target {\n    margin: 0;\n}\n\n.mosaic-widget .slider-input .slider-value {\n    margin: 0;\n    margin-bottom: 10px;\n}\n\n.vscode-dark .mosaic-widget {\n    color: rgb(52, 58, 64);\n}\n\n/* nouislider */\n\n.noUi-target,\n.noUi-target * {\n    -webkit-touch-callout: none;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-user-select: none;\n    -ms-touch-action: none;\n    touch-action: none;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box\n}\n\n.noUi-target {\n    position: relative\n}\n\n.noUi-base,\n.noUi-connects {\n    width: 100%;\n    height: 100%;\n    position: relative;\n    z-index: 1\n}\n\n.noUi-connects {\n    overflow: hidden;\n    z-index: 0\n}\n\n.noUi-connect,\n.noUi-origin {\n    will-change: transform;\n    position: absolute;\n    z-index: 1;\n    top: 0;\n    right: 0;\n    height: 100%;\n    width: 100%;\n    -ms-transform-origin: 0 0;\n    -webkit-transform-origin: 0 0;\n    -webkit-transform-style: preserve-3d;\n    transform-origin: 0 0;\n    transform-style: flat\n}\n\n.noUi-txt-dir-rtl.noUi-horizontal .noUi-origin {\n    left: 0;\n    right: auto\n}\n\n.noUi-vertical .noUi-origin {\n    top: -100%;\n    width: 0\n}\n\n.noUi-horizontal .noUi-origin {\n    height: 0\n}\n\n.noUi-handle {\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    position: absolute\n}\n\n.noUi-touch-area {\n    height: 100%;\n    width: 100%\n}\n\n.noUi-state-tap .noUi-connect,\n.noUi-state-tap .noUi-origin {\n    -webkit-transition: transform .3s;\n    transition: transform .3s\n}\n\n.noUi-state-drag * {\n    cursor: inherit !important\n}\n\n.noUi-horizontal {\n    height: 18px\n}\n\n.noUi-horizontal .noUi-handle {\n    width: 34px;\n    height: 28px;\n    right: -17px;\n    top: -6px\n}\n\n.noUi-vertical {\n    width: 18px\n}\n\n.noUi-vertical .noUi-handle {\n    width: 28px;\n    height: 34px;\n    right: -6px;\n    bottom: -17px\n}\n\n.noUi-txt-dir-rtl.noUi-horizontal .noUi-handle {\n    left: -17px;\n    right: auto\n}\n\n.noUi-target {\n    background: #FAFAFA;\n    border-radius: 4px;\n    border: 1px solid #D3D3D3;\n    box-shadow: inset 0 1px 1px #F0F0F0, 0 3px 6px -5px #BBB\n}\n\n.noUi-connects {\n    border-radius: 3px\n}\n\n.noUi-connect {\n    background: #3FB8AF\n}\n\n.noUi-draggable {\n    cursor: ew-resize\n}\n\n.noUi-vertical .noUi-draggable {\n    cursor: ns-resize\n}\n\n.noUi-handle {\n    border: 1px solid #D9D9D9;\n    border-radius: 3px;\n    background: #FFF;\n    cursor: default;\n    box-shadow: inset 0 0 1px #FFF, inset 0 1px 7px #EBEBEB, 0 3px 6px -3px #BBB\n}\n\n.noUi-active {\n    box-shadow: inset 0 0 1px #FFF, inset 0 1px 7px #DDD, 0 3px 6px -3px #BBB\n}\n\n.noUi-handle:after,\n.noUi-handle:before {\n    content: \"\";\n    display: block;\n    position: absolute;\n    height: 14px;\n    width: 1px;\n    background: #E8E7E6;\n    left: 14px;\n    top: 6px\n}\n\n.noUi-handle:after {\n    left: 17px\n}\n\n.noUi-vertical .noUi-handle:after,\n.noUi-vertical .noUi-handle:before {\n    width: 14px;\n    height: 1px;\n    left: 6px;\n    top: 14px\n}\n\n.noUi-vertical .noUi-handle:after {\n    top: 17px\n}\n\n[disabled] .noUi-connect {\n    background: #B8B8B8\n}\n\n[disabled] .noUi-handle,\n[disabled].noUi-handle,\n[disabled].noUi-target {\n    cursor: not-allowed\n}\n\n.noUi-pips,\n.noUi-pips * {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box\n}\n\n.noUi-pips {\n    position: absolute;\n    color: #999\n}\n\n.noUi-value {\n    position: absolute;\n    white-space: nowrap;\n    text-align: center\n}\n\n.noUi-value-sub {\n    color: #ccc;\n    font-size: 10px\n}\n\n.noUi-marker {\n    position: absolute;\n    background: #CCC\n}\n\n.noUi-marker-sub {\n    background: #AAA\n}\n\n.noUi-marker-large {\n    background: #AAA\n}\n\n.noUi-pips-horizontal {\n    padding: 10px 0;\n    height: 80px;\n    top: 100%;\n    left: 0;\n    width: 100%\n}\n\n.noUi-value-horizontal {\n    -webkit-transform: translate(-50%, 50%);\n    transform: translate(-50%, 50%)\n}\n\n.noUi-rtl .noUi-value-horizontal {\n    -webkit-transform: translate(50%, 50%);\n    transform: translate(50%, 50%)\n}\n\n.noUi-marker-horizontal.noUi-marker {\n    margin-left: -1px;\n    width: 2px;\n    height: 5px\n}\n\n.noUi-marker-horizontal.noUi-marker-sub {\n    height: 10px\n}\n\n.noUi-marker-horizontal.noUi-marker-large {\n    height: 15px\n}\n\n.noUi-pips-vertical {\n    padding: 0 10px;\n    height: 100%;\n    top: 0;\n    left: 100%\n}\n\n.noUi-value-vertical {\n    -webkit-transform: translate(0, -50%);\n    transform: translate(0, -50%);\n    padding-left: 25px\n}\n\n.noUi-rtl .noUi-value-vertical {\n    -webkit-transform: translate(0, 50%);\n    transform: translate(0, 50%)\n}\n\n.noUi-marker-vertical.noUi-marker {\n    width: 5px;\n    height: 2px;\n    margin-top: -1px\n}\n\n.noUi-marker-vertical.noUi-marker-sub {\n    width: 10px\n}\n\n.noUi-marker-vertical.noUi-marker-large {\n    width: 15px\n}\n\n.noUi-tooltip {\n    display: block;\n    position: absolute;\n    border: 1px solid #D9D9D9;\n    border-radius: 3px;\n    background: #fff;\n    color: #000;\n    padding: 5px;\n    text-align: center;\n    white-space: nowrap\n}\n\n.noUi-horizontal .noUi-tooltip {\n    -webkit-transform: translate(-50%, 0);\n    transform: translate(-50%, 0);\n    left: 50%;\n    bottom: 120%\n}\n\n.noUi-vertical .noUi-tooltip {\n    -webkit-transform: translate(0, -50%);\n    transform: translate(0, -50%);\n    top: 50%;\n    right: 120%\n}\n\n.noUi-horizontal .noUi-origin>.noUi-tooltip {\n    -webkit-transform: translate(50%, 0);\n    transform: translate(50%, 0);\n    left: auto;\n    bottom: 10px\n}\n\n.noUi-vertical .noUi-origin>.noUi-tooltip {\n    -webkit-transform: translate(0, -18px);\n    transform: translate(0, -18px);\n    top: auto;\n    right: 28px\n}\n\n.noUi-round {\n    height: 10px;\n}\n\n.noUi-round .noUi-connect {\n    background: #c0392b;\n}\n\n.noUi-round .noUi-handle {\n    height: 18px;\n    width: 18px;\n    top: -5px;\n    right: -9px;\n    /* half the width */\n    border-radius: 9px;\n}\n\n.bslib-sidebar-layout .collapse-toggle {\n    right: 0;\n}\n\n.toolbar {\n    row-gap: 0.7rem;\n}\n\n.panel-input {\n    display: inline-block;\n}\n\n#quarto-content .mosaic-widget {\n    margin-bottom: 1rem;\n}\n\n.toolbar .mosaic-widget,\n.panel-input .mosaic-widget,\n.card-toolbar .mosaic-widget,\n.toolbar .mosaic-widget label,\n.panel-input .mosaic-widget label,\n.card-toolbar .mosaic-widget label {\n    margin-top: 0;\n    margin-bottom: 0;\n}\n\n\n.mosaic-widget .sidebar-fullwidth {\n    margin-bottom: 0;\n}\n\n\n.sidebar .mosaic-widget fieldset>legend,\n.panel-sidebar .mosaic-widget fieldset>legend {\n    margin-bottom: 0.2rem;\n}\n\n.sidebar .mosaic-widget label>select,\n.panel-sidebar .mosaic-widget label>select,\n.sidebar .mosaic-widget .input-search,\n.panel-sidebar .mosaic-widget .input-search,\n.sidebar .mosaic-widget label>input[type=\"range\"],\n.panel-sidebar .mosaic-widget label>input[type=\"range\"],\n.panel-sidebar .mosaic-widget .ts-wrapper,\n.sidebar .mosaic-widget .ts-wrapper {\n    margin-left: 0;\n    margin-right: 0;\n}\n\n.panel-sidebar .mosaic-widget .sidebar-fullwidth,\n.sidebar .mosaic-widget .sidebar-fullwidth,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth>*,\n.sidebar .mosaic-widget .sidebar-fullwidth>*,\n.sidebar .mosaic-widget .sidebar-fullwidth .ts-wrapper,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .ts-wrapper,\n.sidebar .mosaic-widget .sidebar-fullwidth .slider-input,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .slider-input {\n    width: 100%;\n}\n\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .noUi-target,\n.sidebar .mosaic-widget .sidebar-fullwidth .noUi-target {\n    width: 96% !important;\n}\n\n.sidebar .mosaic-widget fieldset,\n.panel-sidebar .mosaic-widget fieldset,\n.sidebar .mosaic-widget .sidebar-fullwidth label,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth label,\n.sidebar .mosaic-widget .slider-input,\n.panel-sidebar .mosaic-widget .slider-input {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 0.1rem;\n}\n\n.mosaic-widget>div>div>label {\n    min-height: 40px;\n}\n\n.mosaic-widget .input-search {\n    padding: .375rem .75rem;\n    border: 1px solid var(--bs-border-color);\n    border-radius: var(--bs-border-radius);\n}\n\n/* remove small top and bottom margin when widgets appear in cards */\n.card-body .mosaic-widget {\n    margin: 0;\n}\n\n/* remove border from ag-grid wrapper (table) when in card */\n.card-body .mosaic-widget .ag-root-wrapper {\n    border: none;\n}\n\n.card-body .mosaic-widget .inspect-viz-table {\n    margin-top: 0;\n    height: 100%;\n}\n\n.mosaic-widget .inspect-viz-table {\n    --ag-foreground-color: var(--bs-body-color);\n    --ag-background-color: var(--bs-body-bg);\n    --ag-accent-color: var(--bs-primary);\n    --ag-font-family: var(--bs-font-sans-serif);\n    --ag-font-size: var(--bs-font-size-base);\n}\n\n.cell-output-display:not(.no-overflow-x) {\n    overflow-x: visible;\n}\n\n.ts-control {\n    border: 1px solid var(--bs-border-color);\n    border-radius: var(--bs-border-radius);\n    box-shadow: none;\n    box-sizing: border-box;\n    flex-wrap: wrap;\n    overflow: hidden;\n    padding: .375rem .75rem;\n    position: relative;\n    width: 100%;\n    z-index: 1\n}\n\n.ts-wrapper.multi.has-items .ts-control {\n    padding: calc(.375rem - 1px) .75rem calc(.375rem - 4px)\n}\n\n.full .ts-control {\n    background-color: var(--bs-body-bg)\n}\n\n.disabled .ts-control,\n.disabled .ts-control * {\n    cursor: default !important\n}\n\n.focus .ts-control {\n    box-shadow: none\n}\n\n.ts-control>* {\n    display: inline-block;\n    vertical-align: initial\n}\n\n.ts-wrapper.multi .ts-control>div {\n    background: #efefef;\n    border: 0 solid #dee2e6;\n    color: #343a40;\n    cursor: pointer;\n    margin: 0 3px 3px 0;\n    padding: 1px 5px\n}\n\n.ts-wrapper.multi .ts-control>div.active {\n    background: #0d6efd;\n    border: 0 solid transparent;\n    color: #fff\n}\n\n.ts-wrapper.multi.disabled .ts-control>div,\n.ts-wrapper.multi.disabled .ts-control>div.active {\n    background: #fff;\n    border: 0 solid #fff;\n    color: #878787\n}\n\n.ts-control>input {\n    background: none !important;\n    border: 0 !important;\n    box-shadow: none !important;\n    display: inline-block !important;\n    flex: 1 1 auto;\n    line-height: inherit !important;\n    margin: 0 !important;\n    max-height: none !important;\n    max-width: 100% !important;\n    min-height: 0 !important;\n    min-width: 7rem;\n    padding: 0 !important;\n    text-indent: 0 !important;\n    -webkit-user-select: auto !important;\n    -moz-user-select: auto !important;\n    -ms-user-select: auto !important;\n    user-select: auto !important\n}\n\n.ts-control>input::-ms-clear {\n    display: none\n}\n\n.ts-control>input:focus {\n    outline: none !important\n}\n\n.has-items .ts-control>input {\n    margin: 0 4px !important\n}\n\n.ts-control.rtl {\n    text-align: right\n}\n\n.ts-control.rtl.single .ts-control:after {\n    left: calc(.75rem + 5px);\n    right: auto\n}\n\n.ts-control.rtl .ts-control>input {\n    margin: 0 4px 0 -2px !important\n}\n\n.disabled .ts-control {\n    background-color: var(--bs-secondary-bg);\n    opacity: .5\n}\n\n.input-hidden .ts-control>input {\n    left: -10000px;\n    opacity: 0;\n    position: absolute\n}\n\n.ts-dropdown {\n    background: var(--bs-body-bg);\n    border: 1px solid #d0d0d0;\n    border-radius: 0 0 var(--bs-border-radius) var(--bs-border-radius);\n    border-top: 0;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, .1);\n    box-sizing: border-box;\n    left: 0;\n    margin: .25rem 0 0;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 10\n}\n\n.ts-dropdown [data-selectable] {\n    cursor: pointer;\n    overflow: hidden\n}\n\n.ts-dropdown [data-selectable] .highlight {\n    background: rgba(255, 237, 40, .4);\n    border-radius: 1px\n}\n\n.ts-dropdown .create,\n.ts-dropdown .no-results,\n.ts-dropdown .optgroup-header,\n.ts-dropdown .option {\n    padding: 3px .75rem\n}\n\n.ts-dropdown .option,\n.ts-dropdown [data-disabled],\n.ts-dropdown [data-disabled] [data-selectable].option {\n    cursor: inherit;\n    opacity: .5\n}\n\n.ts-dropdown [data-selectable].option {\n    cursor: pointer;\n    opacity: 1\n}\n\n.ts-dropdown .optgroup:first-child .optgroup-header {\n    border-top: 0\n}\n\n.ts-dropdown .optgroup-header {\n    background: var(--bs-body-bg);\n    color: #6c757d;\n    cursor: default\n}\n\n.ts-dropdown .active {\n    background-color: var(--bs-tertiary-bg)\n}\n\n.ts-dropdown .active,\n.ts-dropdown .active.create {\n    color: var(--bs-body-color)\n}\n\n.ts-dropdown .create {\n    color: rgba(52, 58, 64, .5)\n}\n\n.ts-dropdown .spinner {\n    display: inline-block;\n    height: 30px;\n    margin: 3px .75rem;\n    width: 30px\n}\n\n.ts-dropdown .spinner:after {\n    animation: lds-dual-ring 1.2s linear infinite;\n    border-color: #d0d0d0 transparent;\n    border-radius: 50%;\n    border-style: solid;\n    border-width: 5px;\n    content: \" \";\n    display: block;\n    height: 24px;\n    margin: 3px;\n    width: 24px\n}\n\n@keyframes lds-dual-ring {\n    0% {\n        transform: rotate(0deg)\n    }\n\n    to {\n        transform: rotate(1turn)\n    }\n}\n\n.ts-dropdown-content {\n    max-height: 200px;\n    overflow: hidden auto;\n    scroll-behavior: smooth\n}\n\n.ts-wrapper.plugin-drag_drop .ts-dragging {\n    color: transparent !important\n}\n\n.ts-wrapper.plugin-drag_drop .ts-dragging>* {\n    visibility: hidden !important\n}\n\n.plugin-checkbox_options:not(.rtl) .option input {\n    margin-right: .5rem\n}\n\n.plugin-checkbox_options.rtl .option input {\n    margin-left: .5rem\n}\n\n.plugin-clear_button {\n    --ts-pr-clear-button: 1em\n}\n\n.plugin-clear_button .clear-button {\n    background: transparent !important;\n    cursor: pointer;\n    margin-right: 0 !important;\n    opacity: 0;\n    position: absolute;\n    right: calc(.75rem - 5px);\n    top: 50%;\n    transform: translateY(-50%);\n    transition: opacity .5s\n}\n\n.plugin-clear_button.form-select .clear-button,\n.plugin-clear_button.single .clear-button {\n    right: max(var(--ts-pr-caret), .75rem)\n}\n\n.plugin-clear_button.focus.has-items .clear-button,\n.plugin-clear_button:not(.disabled):hover.has-items .clear-button {\n    opacity: 1\n}\n\n.ts-wrapper .dropdown-header {\n    background: color-mix(var(--bs-body-bg), #d0d0d0, 85%);\n    border-bottom: 1px solid #d0d0d0;\n    border-radius: var(--bs-border-radius) var(--bs-border-radius) 0 0;\n    padding: 6px .75rem;\n    position: relative\n}\n\n.ts-wrapper .dropdown-header-close {\n    color: #343a40;\n    font-size: 20px !important;\n    line-height: 20px;\n    margin-top: -12px;\n    opacity: .4;\n    position: absolute;\n    right: .75rem;\n    top: 50%\n}\n\n.ts-wrapper .dropdown-header-close:hover {\n    color: #000\n}\n\n.plugin-dropdown_input.focus.dropdown-active .ts-control {\n    border: 1px solid var(--bs-border-color);\n    box-shadow: none;\n    box-shadow: var(--bs-box-shadow-inset)\n}\n\n.plugin-dropdown_input .dropdown-input {\n    background: transparent;\n    border: solid #d0d0d0;\n    border-width: 0 0 1px;\n    box-shadow: none;\n    display: block;\n    padding: .375rem .75rem;\n    width: 100%\n}\n\n.plugin-dropdown_input.focus .ts-dropdown .dropdown-input {\n    border-color: #86b7fe;\n    box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .25);\n    outline: 0\n}\n\n.plugin-dropdown_input .items-placeholder {\n    border: 0 !important;\n    box-shadow: none !important;\n    width: 100%\n}\n\n.plugin-dropdown_input.dropdown-active .items-placeholder,\n.plugin-dropdown_input.has-items .items-placeholder {\n    display: none !important\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items .ts-control>input {\n    min-width: 0\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input {\n    flex: none;\n    min-width: 4px\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input::-ms-input-placeholder {\n    color: transparent\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input::placeholder {\n    color: transparent\n}\n\n.ts-dropdown.plugin-optgroup_columns .ts-dropdown-content {\n    display: flex\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup {\n    border-right: 1px solid #f2f2f2;\n    border-top: 0;\n    flex-basis: 0;\n    flex-grow: 1;\n    min-width: 0\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup:last-child {\n    border-right: 0\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup:before {\n    display: none\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup-header {\n    border-top: 0\n}\n\n.ts-wrapper.plugin-remove_button .item {\n    align-items: center;\n    display: inline-flex\n}\n\n.ts-wrapper.plugin-remove_button .item .remove {\n    border-radius: 0 2px 2px 0;\n    box-sizing: border-box;\n    color: inherit;\n    display: inline-block;\n    padding: 0 5px;\n    text-decoration: none;\n    vertical-align: middle\n}\n\n.ts-wrapper.plugin-remove_button .item .remove:hover {\n    background: rgba(0, 0, 0, .05)\n}\n\n.ts-wrapper.plugin-remove_button.disabled .item .remove:hover {\n    background: none\n}\n\n.ts-wrapper.plugin-remove_button .remove-single {\n    font-size: 23px;\n    position: absolute;\n    right: 0;\n    top: 0\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item {\n    padding-right: 0 !important\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item .remove {\n    border-left: 1px solid #dee2e6;\n    margin-left: 5px\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item.active .remove {\n    border-left-color: transparent\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl).disabled .item .remove {\n    border-left-color: #fff\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item {\n    padding-left: 0 !important\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item .remove {\n    border-right: 1px solid #dee2e6;\n    margin-right: 5px\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item.active .remove {\n    border-right-color: transparent\n}\n\n.ts-wrapper.plugin-remove_button.rtl.disabled .item .remove {\n    border-right-color: #fff\n}\n\n:root {\n    --ts-pr-clear-button: 0px;\n    --ts-pr-caret: 0px;\n    --ts-pr-min: .75rem\n}\n\n.ts-wrapper.single .ts-control,\n.ts-wrapper.single .ts-control input {\n    cursor: pointer\n}\n\n.ts-control:not(.rtl) {\n    padding-right: max(var(--ts-pr-min), var(--ts-pr-clear-button) + var(--ts-pr-caret)) !important\n}\n\n.ts-control.rtl {\n    padding-left: max(var(--ts-pr-min), var(--ts-pr-clear-button) + var(--ts-pr-caret)) !important\n}\n\n.ts-wrapper {\n    position: relative\n}\n\n.ts-control,\n.ts-control input,\n.ts-dropdown {\n    color: #343a40;\n    font-family: inherit;\n    font-size: inherit;\n    line-height: 1.5\n}\n\n.ts-control,\n.ts-wrapper.single.input-active .ts-control {\n    background: var(--bs-body-bg);\n    cursor: text\n}\n\n.ts-hidden-accessible {\n    border: 0 !important;\n    clip: rect(0 0 0 0) !important;\n    -webkit-clip-path: inset(50%) !important;\n    clip-path: inset(50%) !important;\n    overflow: hidden !important;\n    padding: 0 !important;\n    position: absolute !important;\n    white-space: nowrap !important;\n    width: 1px !important\n}\n\n.ts-dropdown,\n.ts-dropdown.form-control,\n.ts-dropdown.form-select {\n    background: var(--bs-body-bg);\n    border: 1px solid var(--bs-border-color-translucent);\n    border-radius: .375rem;\n    box-shadow: 0 6px 12px rgba(0, 0, 0, .175);\n    height: auto;\n    padding: 0;\n    z-index: 1000\n}\n\n.ts-dropdown .optgroup-header {\n    font-size: .875rem;\n    line-height: 1.5\n}\n\n.ts-dropdown .optgroup:first-child:before {\n    display: none\n}\n\n.ts-dropdown .optgroup:before {\n    border-top: 1px solid var(--bs-border-color-translucent);\n    content: \" \";\n    display: block;\n    height: 0;\n    margin: .5rem -.75rem;\n    overflow: hidden\n}\n\n.ts-dropdown .create {\n    padding-left: .75rem\n}\n\n.ts-dropdown-content {\n    padding: 5px 0\n}\n\n.ts-control {\n    align-items: center;\n    display: flex;\n    transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out\n}\n\n@media (prefers-reduced-motion:reduce) {\n    .ts-control {\n        transition: none\n    }\n}\n\n.focus .ts-control {\n    border-color: #86b7fe;\n    box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .25);\n    outline: 0\n}\n\n.ts-control .item {\n    align-items: center;\n    display: flex\n}\n\n.ts-wrapper.is-invalid,\n.was-validated .invalid,\n.was-validated :invalid+.ts-wrapper {\n    border-color: var(--bs-form-invalid-color)\n}\n\n.ts-wrapper.is-invalid:not(.single),\n.was-validated .invalid:not(.single),\n.was-validated :invalid+.ts-wrapper:not(.single) {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3E%3Ccircle cx='6' cy='6' r='4.5'/%3E%3Cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3E%3Ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3E%3C/svg%3E\");\n    background-position: right calc(.375em + .1875rem) center;\n    background-repeat: no-repeat;\n    background-size: calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-invalid.single,\n.was-validated .invalid.single,\n.was-validated :invalid+.ts-wrapper.single {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\"), url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3E%3Ccircle cx='6' cy='6' r='4.5'/%3E%3Cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3E%3Ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3E%3C/svg%3E\");\n    background-position: right .75rem center, center right 2.25rem;\n    background-repeat: no-repeat;\n    background-size: 16px 12px, calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-invalid.focus .ts-control,\n.was-validated .invalid.focus .ts-control,\n.was-validated :invalid+.ts-wrapper.focus .ts-control {\n    border-color: var(--bs-form-invalid-color);\n    box-shadow: 0 0 0 .25rem rgba(var(--bs-form-invalid-color), .25)\n}\n\n.ts-wrapper.is-valid,\n.was-validated .valid,\n.was-validated :valid+.ts-wrapper {\n    border-color: var(--bs-form-valid-color)\n}\n\n.ts-wrapper.is-valid:not(.single),\n.was-validated .valid:not(.single),\n.was-validated :valid+.ts-wrapper:not(.single) {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23198754' d='M2.3 6.73.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1'/%3E%3C/svg%3E\");\n    background-position: right calc(.375em + .1875rem) center;\n    background-repeat: no-repeat;\n    background-size: calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-valid.single,\n.was-validated .valid.single,\n.was-validated :valid+.ts-wrapper.single {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\"), url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23198754' d='M2.3 6.73.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1'/%3E%3C/svg%3E\");\n    background-position: right .75rem center, center right 2.25rem;\n    background-repeat: no-repeat;\n    background-size: 16px 12px, calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-valid.focus .ts-control,\n.was-validated .valid.focus .ts-control,\n.was-validated :valid+.ts-wrapper.focus .ts-control {\n    border-color: var(--bs-form-valid-color);\n    box-shadow: 0 0 0 .25rem rgba(var(--bs-form-valid-color), .25)\n}\n\n.ts-wrapper {\n    display: flex;\n    min-height: calc(1.5em + .75rem + var(--bs-border-width)*2)\n}\n\n.input-group-sm>.ts-wrapper,\n.ts-wrapper.form-control-sm,\n.ts-wrapper.form-select-sm {\n    min-height: calc(1.5em + .5rem + var(--bs-border-width)*2)\n}\n\n.input-group-sm>.ts-wrapper .ts-control,\n.ts-wrapper.form-control-sm .ts-control,\n.ts-wrapper.form-select-sm .ts-control {\n    border-radius: var(--bs-border-radius-sm);\n    font-size: .875rem\n}\n\n.input-group-sm>.ts-wrapper.has-items .ts-control,\n.ts-wrapper.form-control-sm.has-items .ts-control,\n.ts-wrapper.form-select-sm.has-items .ts-control {\n    font-size: .875rem;\n    padding-bottom: 0\n}\n\n.input-group-sm>.ts-wrapper.multi.has-items .ts-control,\n.ts-wrapper.form-control-sm.multi.has-items .ts-control,\n.ts-wrapper.form-select-sm.multi.has-items .ts-control {\n    padding-top: calc(.75em - .40625rem + var(--bs-border-width)*2/2 - (var(--bs-border-width) + 1px)*2/2) !important\n}\n\n.ts-wrapper.multi.has-items .ts-control {\n    padding-left: calc(.75rem - 5px);\n    --ts-pr-min: calc(0.75rem - 5px)\n}\n\n.ts-wrapper.multi .ts-control>div {\n    border-radius: calc(var(--bs-border-radius) - 1px)\n}\n\n.input-group-lg>.ts-wrapper,\n.ts-wrapper.form-control-lg,\n.ts-wrapper.form-select-lg {\n    min-height: calc(1.5em + 1rem + var(--bs-border-width)*2)\n}\n\n.input-group-lg>.ts-wrapper .ts-control,\n.ts-wrapper.form-control-lg .ts-control,\n.ts-wrapper.form-select-lg .ts-control {\n    border-radius: var(--bs-border-radius-lg);\n    font-size: 1.25rem\n}\n\n.ts-wrapper:not(.form-control, .form-select) {\n    background: none;\n    border: none;\n    box-shadow: none;\n    height: auto;\n    padding: 0\n}\n\n.ts-wrapper:not(.form-control, .form-select).single .ts-control {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\");\n    background-position: right .75rem center;\n    background-repeat: no-repeat;\n    background-size: 16px 12px\n}\n\n.ts-wrapper.form-select,\n.ts-wrapper.single {\n    --ts-pr-caret: 2.25rem\n}\n\n.ts-wrapper.form-control,\n.ts-wrapper.form-select {\n    box-shadow: none;\n    display: flex;\n    height: auto;\n    padding: 0 !important\n}\n\n.ts-wrapper.form-control .ts-control,\n.ts-wrapper.form-control.single.input-active .ts-control,\n.ts-wrapper.form-select .ts-control,\n.ts-wrapper.form-select.single.input-active .ts-control {\n    border: none !important\n}\n\n.ts-wrapper.form-control:not(.disabled) .ts-control,\n.ts-wrapper.form-control:not(.disabled).single.input-active .ts-control,\n.ts-wrapper.form-select:not(.disabled) .ts-control,\n.ts-wrapper.form-select:not(.disabled).single.input-active .ts-control {\n    background: transparent !important\n}\n\n.input-group>.ts-wrapper {\n    flex-grow: 1;\n    width: 1%\n}\n\n.input-group>.ts-wrapper:not(:nth-child(2))>.ts-control {\n    border-bottom-left-radius: 0;\n    border-top-left-radius: 0\n}\n\n.input-group>.ts-wrapper:not(:last-child)>.ts-control {\n    border-bottom-right-radius: 0;\n    border-top-right-radius: 0\n}\n\n.ts-wrapper.single {\n    cursor: pointer !important;\n}\n\n.ts-wrapper.single.input-active .ts-control {\n    cursor: pointer !important;\n}\n\n.ts-control {\n    min-width: 150px;\n}\n\n.ts-dropdown.single {\n    width: auto !important;\n    min-width: 150px !important;\n}\n\n.ts-control>input {\n    min-width: 5rem;\n}\n\n.inspect-viz-table {\n    width: 100%;\n    margin-top: 1em;\n    margin-bottom: 0.5em;\n}\n\n.header-center .ag-header-cell-label {\n    justify-content: center;\n}\n\n.header-left .ag-header-cell-label {\n    justify-content: left;\n}\n\n.header-right .ag-header-cell-label {\n    justify-content: right;\n}\n\n.header-justify .ag-header-cell-label {\n    justify-content: space-between;\n}\n\n/* This disables a hard coded min height fo ag-grid.\nThis is their recommended approach (!). See \nhttps://github.com/ag-grid/ag-grid/issues/4095 */\n.ag-layout-auto-height .ag-center-cols-container,\n.ag-layout-auto-height .ag-center-cols-viewport {\n    min-height: 0px !important;\n}\n\n.card-body .ag-column-last:after {\n    border: none !important;\n}\n\n.inspect-tip-container {\n  display: grid;\n  grid-template-columns: max-content auto;\n}\n\n/* Let each row be part of the parent grid */\n.inspect-tip-row {\n  display: contents;\n}\n\n/* Styling for striping */\n.inspect-tip-container > .inspect-tip-row:nth-child(even) > * {\n  background-color: var(--quarto-scss-export-table-striped-bg);\n}\n\n/* Optional padding & border */\n.inspect-tip-container > .inspect-tip-row > div:nth-child(1) {\n    padding-left: 0.5em;\n    padding-right: 0.5em;\n}\n\n.inspect-tip-container > .inspect-tip-row > div:nth-child(2) {\n    padding-right: 0.5em;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-color {\n    display: inline-block;\n    margin-left: 4px;\n    margin-right: 4px;\n    width: .5em;\n    height: .5em;\n    border-radius: 50%;;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-key {\n    font-size: 0.8em;\n    font-weight: 600;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-value {\n    font-size: 0.8em;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.tippy-box[data-theme~='inspect'] {\n  background-color: var(--bs-body-bg, #ffffff);\n  color: var(--bs-body-color, #000000);\n  filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.9));\n  min-width: 200px;\n}\n\n.tippy-box[data-theme~='inspect'] .tippy-content {\n  padding: 0 !important;\n}\n\n.tippy-box[data-theme~='inspect'] .tippy-arrow:before {\n  color: var(--bs-body-bg, #ffffff); \n  filter: drop-shadow(3 1px 1px rgba(0, 0, 0, 0.9));\n  transform: translateY(1.5px); /* Move arrow down to reduce overlap */\n}\n\n\n\n.legend-container {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5em;\n}\n\n.legend-container.top,\n.legend-container.bottom\n {\n    flex-direction: row;\n}\n\ndiv.legend > div {\n    margin-bottom: 0 !important;\n}","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  legendContainerEl.style.padding = \"0.3em\";\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    targetEl.style.background = background === true ? \"white\" : background || \"white\";\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_238b52a1f3fc4684ba77e0c2ddef286a","spec":"","tabbable":null,"tables":{},"tooltip":null}},"ab157077baee4b3083512fe971d8d036":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.interactor._interactors.Interactor","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  legendContainerEl.style.padding = \"0.3em\";\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    targetEl.style.background = background === true ? \"white\" : background || \"white\";\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_ec8bd6a35411442588c62aac4f1c4fc5","spec":"","tabbable":null,"tables":{},"tooltip":null}},"b2a1749eb882429cbcc2113c9b696ce8":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  legendContainerEl.style.padding = \"0.3em\";\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    targetEl.style.background = background === true ? \"white\" : background || \"white\";\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_fe4ced1276f14f17b163057dd875c015","spec":"{\"hconcat\":[{\"plot\":[{\"mark\":\"line\",\"data\":{\"from\":\"EbruUvU4g9QSxbiNUMsZFY\",\"filterBy\":\"$selection_EbruUvU4g9QSxbiNUMsZFY\"},\"x\":{\"column\":\"total_tokens\"},\"y\":{\"column\":\"success_rate\"},\"stroke\":\"model_display_name\",\"tip\":{\"lineWidth\":1000000000},\"channels\":{\"Token Limit\":\"total_tokens\",\"Success Rate\":\"success_rate\",\"Model\":\"model_display_name\",\"Log\":\"log_viewer\",\"_user_channels\":[\"{\\\"Token Limit\\\": \\\"total_tokens\\\", \\\"Success Rate\\\": \\\"success_rate\\\", \\\"Model\\\": \\\"model_display_name\\\", \\\"Log\\\": \\\"log_viewer\\\"}\"]}},{\"mark\":\"areaY\",\"data\":{\"from\":\"EbruUvU4g9QSxbiNUMsZFY\",\"filterBy\":\"$selection_EbruUvU4g9QSxbiNUMsZFY\"},\"y\":{\"column\":\"success_rate\"},\"y1\":{\"sql\":\"success_rate -(1.9599639845400536 * standard_error)\"},\"y2\":{\"sql\":\"success_rate +(1.9599639845400536 * standard_error)\"},\"x\":{\"column\":\"total_tokens\"},\"color\":\"model_display_name\",\"fill\":\"model_display_name\",\"fillOpacity\":0.3,\"tip\":false},{\"select\":\"nearestX\",\"as\":\"$selection_6atLBbFdwLoYW6pT7XidPb\",\"channels\":[\"color\"]},{\"select\":\"highlight\",\"by\":\"$selection_6atLBbFdwLoYW6pT7XidPb\",\"opacity\":0.2,\"fillOpacity\":0.1}],\"xLabel\":\"total_tokens\",\"yLabel\":\"Success rate\",\"width\":700,\"height\":384,\"xScale\":\"log\",\"yInsetTop\":10,\"marginBottom\":30,\"name\":\"plot_YxjHi6u44HLmCwuDKAKrBV\"},{\"legend\":\"color\",\"columns\":1,\"_inset\":20,\"_inset_x\":null,\"_inset_y\":null,\"_border\":true,\"_background\":true,\"_frame_anchor\":\"top-left\",\"for\":\"plot_YxjHi6u44HLmCwuDKAKrBV\"}],\"plotDefaults\":{\"width\":700,\"height\":450},\"params\":{\"selection_EbruUvU4g9QSxbiNUMsZFY\":{\"select\":\"intersect\"},\"selection_6atLBbFdwLoYW6pT7XidPb\":{\"select\":\"single\",\"cross\":false,\"empty\":false}}}","tabbable":null,"tables":{"EbruUvU4g9QSxbiNUMsZFY":"/////xALAAAQAAAAAAAKAA4ABgAFAAgACgAAAAABBAAQAAAAAAAKAAwAAAAEAAgACgAAAPgHAAAEAAAAAQAAAAwAAAAIAAwABAAIAAgAAADQBwAABAAAAMIHAAB7ImluZGV4X2NvbHVtbnMiOiBbeyJraW5kIjogInJhbmdlIiwgIm5hbWUiOiBudWxsLCAic3RhcnQiOiAwLCAic3RvcCI6IDQwMCwgInN0ZXAiOiAxfV0sICJjb2x1bW5faW5kZXhlcyI6IFt7Im5hbWUiOiBudWxsLCAiZmllbGRfbmFtZSI6IG51bGwsICJwYW5kYXNfdHlwZSI6ICJ1bmljb2RlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogeyJlbmNvZGluZyI6ICJVVEYtOCJ9fV0sICJjb2x1bW5zIjogW3sibmFtZSI6ICJ0b3RhbF90b2tlbnMiLCAiZmllbGRfbmFtZSI6ICJ0b3RhbF90b2tlbnMiLCAicGFuZGFzX3R5cGUiOiAiZmxvYXQ2NCIsICJudW1weV90eXBlIjogImZsb2F0NjQiLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogIm1vZGVsIiwgImZpZWxkX25hbWUiOiAibW9kZWwiLCAicGFuZGFzX3R5cGUiOiAidW5pY29kZSIsICJudW1weV90eXBlIjogIm9iamVjdCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAic3VjY2Vzc19yYXRlIiwgImZpZWxkX25hbWUiOiAic3VjY2Vzc19yYXRlIiwgInBhbmRhc190eXBlIjogImZsb2F0NjQiLCAibnVtcHlfdHlwZSI6ICJmbG9hdDY0IiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJzdGFuZGFyZF9lcnJvciIsICJmaWVsZF9uYW1lIjogInN0YW5kYXJkX2Vycm9yIiwgInBhbmRhc190eXBlIjogImZsb2F0NjQiLCAibnVtcHlfdHlwZSI6ICJmbG9hdDY0IiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJvdGhlcl90ZXJtaW5hdGlvbl9yYXRlIiwgImZpZWxkX25hbWUiOiAib3RoZXJfdGVybWluYXRpb25fcmF0ZSIsICJwYW5kYXNfdHlwZSI6ICJmbG9hdDY0IiwgIm51bXB5X3R5cGUiOiAiZmxvYXQ2NCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAiY291bnQiLCAiZmllbGRfbmFtZSI6ICJjb3VudCIsICJwYW5kYXNfdHlwZSI6ICJpbnQ2NCIsICJudW1weV90eXBlIjogImludDY0IiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJsb2ciLCAiZmllbGRfbmFtZSI6ICJsb2ciLCAicGFuZGFzX3R5cGUiOiAidW5pY29kZSIsICJudW1weV90eXBlIjogIm9iamVjdCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAibW9kZWxfb3JnYW5pemF0aW9uX25hbWUiLCAiZmllbGRfbmFtZSI6ICJtb2RlbF9vcmdhbml6YXRpb25fbmFtZSIsICJwYW5kYXNfdHlwZSI6ICJ1bmljb2RlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJtb2RlbF9kaXNwbGF5X25hbWUiLCAiZmllbGRfbmFtZSI6ICJtb2RlbF9kaXNwbGF5X25hbWUiLCAicGFuZGFzX3R5cGUiOiAidW5pY29kZSIsICJudW1weV90eXBlIjogIm9iamVjdCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAibW9kZWxfc25hcHNob3QiLCAiZmllbGRfbmFtZSI6ICJtb2RlbF9zbmFwc2hvdCIsICJwYW5kYXNfdHlwZSI6ICJ1bmljb2RlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJtb2RlbF9yZWxlYXNlX2RhdGUiLCAiZmllbGRfbmFtZSI6ICJtb2RlbF9yZWxlYXNlX2RhdGUiLCAicGFuZGFzX3R5cGUiOiAiZGF0ZSIsICJudW1weV90eXBlIjogIm9iamVjdCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAibW9kZWxfa25vd2xlZGdlX2N1dG9mZl9kYXRlIiwgImZpZWxkX25hbWUiOiAibW9kZWxfa25vd2xlZGdlX2N1dG9mZl9kYXRlIiwgInBhbmRhc190eXBlIjogImRhdGUiLCAibnVtcHlfdHlwZSI6ICJvYmplY3QiLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogImxvZ192aWV3ZXIiLCAiZmllbGRfbmFtZSI6ICJsb2dfdmlld2VyIiwgInBhbmRhc190eXBlIjogInVuaWNvZGUiLCAibnVtcHlfdHlwZSI6ICJvYmplY3QiLCAibWV0YWRhdGEiOiBudWxsfV0sICJjcmVhdG9yIjogeyJsaWJyYXJ5IjogInB5YXJyb3ciLCAidmVyc2lvbiI6ICIyMC4wLjAifSwgInBhbmRhc192ZXJzaW9uIjogIjIuMy4wIn0AAAYAAABwYW5kYXMAAA0AAACwAgAAcAIAADgCAAAAAgAAwAEAAIQBAABcAQAAIAEAAOgAAAC0AAAAeAAAADQAAAAEAAAAlP3//wAAAQUQAAAAHAAAAAQAAAAAAAAACgAAAGxvZ192aWV3ZXIAAMT9///A/f//AAABCBAAAAAsAAAABAAAAAAAAAAbAAAAbW9kZWxfa25vd2xlZGdlX2N1dG9mZl9kYXRlAL79//8AAAAAAP7//wAAAQgQAAAAJAAAAAQAAAAAAAAAEgAAAG1vZGVsX3JlbGVhc2VfZGF0ZQAA9v3//wAAAAA4/v//AAABBRAAAAAgAAAABAAAAAAAAAAOAAAAbW9kZWxfc25hcHNob3QAAGz+//9o/v//AAABBRAAAAAkAAAABAAAAAAAAAASAAAAbW9kZWxfZGlzcGxheV9uYW1lAACg/v//nP7//wAAAQUQAAAAKAAAAAQAAAAAAAAAFwAAAG1vZGVsX29yZ2FuaXphdGlvbl9uYW1lANj+///U/v//AAABBRAAAAAUAAAABAAAAAAAAAADAAAAbG9nAPz+///4/v//AAABAhAAAAAgAAAABAAAAAAAAAAFAAAAY291bnQAAAAIAAwACAAHAAgAAAAAAAABQAAAADD///8AAAEDEAAAACgAAAAEAAAAAAAAABYAAABvdGhlcl90ZXJtaW5hdGlvbl9yYXRlAAAq////AAACAGz///8AAAEDEAAAACAAAAAEAAAAAAAAAA4AAABzdGFuZGFyZF9lcnJvcgAAXv///wAAAgCg////AAABAxAAAAAgAAAABAAAAAAAAAAMAAAAc3VjY2Vzc19yYXRlAAAAAJL///8AAAIA1P///wAAAQUQAAAAHAAAAAQAAAAAAAAABQAAAG1vZGVsAAAABAAEAAQAAAAQABQACAAGAAcADAAAABAAEAAAAAAAAQMQAAAAJAAAAAQAAAAAAAAADAAAAHRvdGFsX3Rva2VucwAABgAIAAYABgAAAAAAAgD/////KAMAABQAAAAAAAAADAAWAAYABQAIAAwADAAAAAADBAAYAAAAMFICAAAAAAAAAAoAGAAMAAQACAAKAAAAHAIAABAAAACQAQAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAwAAAAAAACADAAAAAAAAAAAAAAAAAAAgAwAAAAAAABEBgAAAAAAAMgSAAAAAAAAjCMAAAAAAABYNgAAAAAAAAAAAAAAAAAAWDYAAAAAAACADAAAAAAAANhCAAAAAAAAAAAAAAAAAADYQgAAAAAAAIAMAAAAAAAAWE8AAAAAAAAAAAAAAAAAAFhPAAAAAAAAgAwAAAAAAADYWwAAAAAAAAAAAAAAAAAA2FsAAAAAAACADAAAAAAAAFhoAAAAAAAAAAAAAAAAAABYaAAAAAAAAEQGAAAAAAAAoG4AAAAAAACA7QAAAAAAACBcAQAAAAAAAAAAAAAAAAAgXAEAAAAAAEQGAAAAAAAAaGIBAAAAAAC4CwAAAAAAACBuAQAAAAAAAAAAAAAAAAAgbgEAAAAAAEQGAAAAAAAAaHQBAAAAAAAEEAAAAAAAAHCEAQAAAAAAMgAAAAAAAACohAEAAAAAAEQGAAAAAAAA8IoBAAAAAAB4BQAAAAAAAGiQAQAAAAAAAAAAAAAAAABokAEAAAAAAEAGAAAAAAAAqJYBAAAAAAAAAAAAAAAAAKiWAQAAAAAAQAYAAAAAAADonAEAAAAAAAAAAAAAAAAA6JwBAAAAAABEBgAAAAAAADCjAQAAAAAAAK8AAAAAAAAAAAAADQAAAJABAAAAAAAAAAAAAAAAAACQAQAAAAAAAAAAAAAAAAAAkAEAAAAAAAAAAAAAAAAAAJABAAAAAAAAAAAAAAAAAACQAQAAAAAAAAAAAAAAAAAAkAEAAAAAAAAAAAAAAAAAAJABAAAAAAAAAAAAAAAAAACQAQAAAAAAAAAAAAAAAAAAkAEAAAAAAAAAAAAAAAAAAJABAAAAAAAAyAAAAAAAAACQAQAAAAAAAAAAAAAAAAAAkAEAAAAAAAAAAAAAAAAAAJABAAAAAAAAAAAAAAAAAAAAAAAAQFjYQAAAAABAWNhAAAAAAEBY2EAAAAAAQFjYQFL2hnfPgtlAUvaGd8+C2UBS9oZ3z4LZQFL2hnfPgtlA4AEtcKy72kDgAS1wrLvaQOABLXCsu9pA4AEtcKy72kCvTCNShgPcQK9MI1KGA9xAr0wjUoYD3ECvTCNShgPcQO7oxewUW91A7ujF7BRb3UDu6MXsFFvdQO7oxewUW91AAXKp3RjD3kABcqndGMPeQAFyqd0Yw95AAXKp3RjD3kClQEz+LR7gQKVATP4tHuBApUBM/i0e4EClQEz+LR7gQN7BXubY4+BA3sFe5tjj4EDewV7m2OPgQN7BXubY4+BAyjCc+fuy4UDKMJz5+7LhQMownPn7suFAyjCc+fuy4UDDObFZC4ziQMM5sVkLjOJAwzmxWQuM4kDDObFZC4ziQA85g7iAb+NADzmDuIBv40APOYO4gG/jQA85g7iAb+NASbBqnNtd5EBJsGqc213kQEmwapzbXeRASbBqnNtd5ECdebKnoVflQJ15sqehV+VAnXmyp6FX5UCdebKnoVflQKjPg+NeXeZAqM+D415d5kCoz4PjXl3mQKjPg+NeXeZA7ClpDqZv50DsKWkOpm/nQOwpaQ6mb+dA7ClpDqZv50Bz85PuEI/oQHPzk+4Qj+hAc/OT7hCP6EBz85PuEI/oQHo7E6hAvOlAejsTqEC86UB6OxOoQLzpQHo7E6hAvOlAdrUrF9736kB2tSsX3vfqQHa1Kxfe9+pAdrUrF9736kCjsAMvmkLsQKOwAy+aQuxAo7ADL5pC7ECjsAMvmkLsQEYZ2Fwune1ARhnYXC6d7UBGGdhcLp3tQEYZ2Fwune1A9CPy71wI70D0I/LvXAjvQPQj8u9cCO9A9CPy71wI70Cn9UvDeELwQKf1S8N4QvBAp/VLw3hC8ECn9UvDeELwQKaJGsDgCfFApokawOAJ8UCmiRrA4AnxQKaJGsDgCfFAF7p9Otba8UAXun061trxQBe6fTrW2vFAF7p9Otba8UATb59ZzrXyQBNvn1nOtfJAE2+fWc618kATb59ZzrXyQKceaeFDm/NApx5p4UOb80CnHmnhQ5vzQKceaeFDm/NACONXd7eL9EAI41d3t4v0QAjjV3e3i/RACONXd7eL9EBzqpzqr4f1QHOqnOqvh/VAc6qc6q+H9UBzqpzqr4f1QM7xsH+6j/ZAzvGwf7qP9kDO8bB/uo/2QM7xsH+6j/ZAe2mKP2uk90B7aYo/a6T3QHtpij9rpPdAe2mKP2uk90Bg65lKXcb4QGDrmUpdxvhAYOuZSl3G+EBg65lKXcb4QJpLxC8z9vlAmkvELzP2+UCaS8QvM/b5QJpLxC8z9vlAAMWFR5c0+0AAxYVHlzT7QADFhUeXNPtAAMWFR5c0+0ChG3MTPIL8QKEbcxM8gvxAoRtzEzyC/EChG3MTPIL8QCwATqLc3/1ALABOotzf/UAsAE6i3N/9QCwATqLc3/1Asc/k+DxO/0Cxz+T4PE7/QLHP5Pg8Tv9Asc/k+DxO/0COPvw/FWcAQY4+/D8VZwBBjj78PxVnAEGOPvw/FWcAQZ8gszs+MAFBnyCzOz4wAUGfILM7PjABQZ8gszs+MAFBvNBqNwoDAkG80Go3CgMCQbzQajcKAwJBvNBqNwoDAkGuOxdi798CQa47F2Lv3wJBrjsXYu/fAkGuOxdi798CQW3vDpRpxwNBbe8OlGnHA0Ft7w6UaccDQW3vDpRpxwNBPit6lPq5BEE+K3qU+rkEQT4repT6uQRBPit6lPq5BEFgdxViKrgFQWB3FWIquAVBYHcVYiq4BUFgdxViKrgFQf+NcH+HwgZB/41wf4fCBkH/jXB/h8IGQf+NcH+HwgZBM1bUQqfZB0EzVtRCp9kHQTNW1EKn2QdBM1bUQqfZB0EPu/wpJv4IQQ+7/Ckm/ghBD7v8KSb+CEEPu/wpJv4IQetQ1TGoMApB61DVMagwCkHrUNUxqDAKQetQ1TGoMApB/vhpMtlxC0H++Gky2XELQf74aTLZcQtB/vhpMtlxC0GcDj8/bcIMQZwOPz9twgxBnA4/P23CDEGcDj8/bcIMQQkjRwwhIw5BCSNHDCEjDkEJI0cMISMOQQkjRwwhIw5B+OGuV7qUD0H44a5XupQPQfjhrle6lA9B+OGuV7qUD0FGN10sBIwQQUY3XSwEjBBBRjddLASMEEFGN10sBIwQQRQx+RnyVhFBFDH5GfJWEUEUMfkZ8lYRQRQx+RnyVhFBZsdwupgrEkFmx3C6mCsSQWbHcLqYKxJBZsdwupgrEkGq4tNGbwoTQari00ZvChNBquLTRm8KE0Gq4tNGbwoTQc+TVK7y8xNBz5NUrvLzE0HPk1Su8vMTQc+TVK7y8xNBzXtS3KXoFEHNe1LcpegUQc17Utyl6BRBzXtS3KXoFEEmOMEBEukVQSY4wQES6RVBJjjBARLpFUEmOMEBEukVQev5EuLG9RZB6/kS4sb1FkHr+RLixvUWQev5EuLG9RZB+WfSI1sPGEH5Z9IjWw8YQfln0iNbDxhB+WfSI1sPGEFX/BilbDYZQVf8GKVsNhlBV/wYpWw2GUFX/BilbDYZQd02EdSgaxpB3TYR1KBrGkHdNhHUoGsaQd02EdSgaxpBYkW2C6WvG0FiRbYLpa8bQWJFtgulrxtBYkW2C6WvG0HsIAX1LgMdQewgBfUuAx1B7CAF9S4DHUHsIAX1LgMdQfCc1ez8Zh5B8JzV7PxmHkHwnNXs/GYeQfCc1ez8Zh5Bi4OUbtbbH0GLg5Ru1tsfQYuDlG7W2x9Bi4OUbtbbH0E6Sg1CRrEgQTpKDUJGsSBBOkoNQkaxIEE6Sg1CRrEgQeuMbx39fSFB64xvHf19IUHrjG8d/X0hQeuMbx39fSFB6uRjj4JUIkHq5GOPglQiQerkY4+CVCJB6uRjj4JUIkGkZm3dTjUjQaRmbd1ONSNBpGZt3U41I0GkZm3dTjUjQayKDRDgICRBrIoNEOAgJEGsig0Q4CAkQayKDRDgICRBzkxtOboXJUHOTG05uhclQc5MbTm6FyVBzkxtOboXJUEG3mi/ZxomQQbeaL9nGiZBBt5ov2caJkEG3mi/ZxomQZ1sJ6l5KSdBnWwnqXkpJ0GdbCepeSknQZ1sJ6l5KSdBhYJq8IdFKEGFgmrwh0UoQYWCavCHRShBhYJq8IdFKEEBkcLWMW8pQQGRwtYxbylBAZHC1jFvKUEBkcLWMW8pQWtu2D4epypBa27YPh6nKkFrbtg+HqcqQWtu2D4epypBotT9CfztK0Gi1P0J/O0rQaLU/Qn87StBotT9CfztK0EdVjl6gkQtQR1WOXqCRC1BHVY5eoJELUEdVjl6gkQtQXzBBJlxqy5BfMEEmXGrLkF8wQSZcasuQXzBBJlxqy5BtcZ7UckRMEG1xntRyREwQbXGe1HJETBBtcZ7UckRMEFy1Uw83NYwQXLVTDzc1jBBctVMPNzWMEFy1Uw83NYwQTr/TgpgpTFBOv9OCmClMUE6/04KYKUxQTr/TgpgpTFBhWTjg8h9MkGFZOODyH0yQYVk44PIfTJBhWTjg8h9MkFFu1z9jmAzQUW7XP2OYDNBRbtc/Y5gM0FFu1z9jmAzQQ1OBZsyTjRBDU4FmzJONEENTgWbMk40QQ1OBZsyTjRBKjZnmDhHNUEqNmeYOEc1QSo2Z5g4RzVBKjZnmDhHNUEdx/6SLEw2QR3H/pIsTDZBHcf+kixMNkEdx/6SLEw2QTUNgdigXTdBNQ2B2KBdN0E1DYHYoF03QTUNgdigXTdBmkHiuC58OEGaQeK4Lnw4QZpB4rgufDhBmkHiuC58OEEKMErcdqg5QQowStx2qDlBCjBK3HaoOUEKMErcdqg5QfW/Jp0h4zpB9b8mnSHjOkH1vyadIeM6QfW/Jp0h4zpBbyCPZt8sPEFvII9m3yw8QW8gj2bfLDxBbyCPZt8sPEFjgSwXaYY9QWOBLBdphj1BY4EsF2mGPUFjgSwXaYY9QT/P32iA8D5BP8/faIDwPkE/z99ogPA+QT/P32iA8D5BYkavLvg1QEFiRq8u+DVAQWJGry74NUBBYkavLvg1QEGD1wHYxvxAQYPXAdjG/EBBg9cB2Mb8QEGD1wHYxvxAQX4miqYbzUFBfiaKphvNQUF+JoqmG81BQX4miqYbzUFBTH9dZ2unQkFMf11na6dCQUx/XWdrp0JBTH9dZ2unQkH///9/MIxDQf///38wjENB////fzCMQ0H///9/MIxDQQAAAAAiAAAARAAAAE0AAABbAAAAfQAAAJ8AAACoAAAAtgAAANgAAAD6AAAAAwEAABEBAAAzAQAAVQEAAF4BAABsAQAAjgEAALABAAC5AQAAxwEAAOkBAAALAgAAFAIAACICAABEAgAAZgIAAG8CAAB9AgAAnwIAAMECAADKAgAA2AIAAPoCAAAcAwAAJQMAADMDAABVAwAAdwMAAIADAACOAwAAsAMAANIDAADbAwAA6QMAAAsEAAAtBAAANgQAAEQEAABmBAAAiAQAAJEEAACfBAAAwQQAAOMEAADsBAAA+gQAABwFAAA+BQAARwUAAFUFAAB3BQAAmQUAAKIFAACwBQAA0gUAAPQFAAD9BQAACwYAAC0GAABPBgAAWAYAAGYGAACIBgAAqgYAALMGAADBBgAA4wYAAAUHAAAOBwAAHAcAAD4HAABgBwAAaQcAAHcHAACZBwAAuwcAAMQHAADSBwAA9AcAABYIAAAfCAAALQgAAE8IAABxCAAAeggAAIgIAACqCAAAzAgAANUIAADjCAAABQkAACcJAAAwCQAAPgkAAGAJAACCCQAAiwkAAJkJAAC7CQAA3QkAAOYJAAD0CQAAFgoAADgKAABBCgAATwoAAHEKAACTCgAAnAoAAKoKAADMCgAA7goAAPcKAAAFCwAAJwsAAEkLAABSCwAAYAsAAIILAACkCwAArQsAALsLAADdCwAA/wsAAAgMAAAWDAAAOAwAAFoMAABjDAAAcQwAAJMMAAC1DAAAvgwAAMwMAADuDAAAEA0AABkNAAAnDQAASQ0AAGsNAAB0DQAAgg0AAKQNAADGDQAAzw0AAN0NAAD/DQAAIQ4AACoOAAA4DgAAWg4AAHwOAACFDgAAkw4AALUOAADXDgAA4A4AAO4OAAAQDwAAMg8AADsPAABJDwAAaw8AAI0PAACWDwAApA8AAMYPAADoDwAA8Q8AAP8PAAAhEAAAQxAAAEwQAABaEAAAfBAAAJ4QAACnEAAAtRAAANcQAAD5EAAAAhEAABARAAAyEQAAVBEAAF0RAABrEQAAjREAAK8RAAC4EQAAxhEAAOgRAAAKEgAAExIAACESAABDEgAAZRIAAG4SAAB8EgAAnhIAAMASAADJEgAA1xIAAPkSAAAbEwAAJBMAADITAABUEwAAdhMAAH8TAACNEwAArxMAANETAADaEwAA6BMAAAoUAAAsFAAANRQAAEMUAABlFAAAhxQAAJAUAACeFAAAwBQAAOIUAADrFAAA+RQAABsVAAA9FQAARhUAAFQVAAB2FQAAmBUAAKEVAACvFQAA0RUAAPMVAAD8FQAAChYAACwWAABOFgAAVxYAAGUWAACHFgAAqRYAALIWAADAFgAA4hYAAAQXAAANFwAAGxcAAD0XAABfFwAAaBcAAHYXAACYFwAAuhcAAMMXAADRFwAA8xcAABUYAAAeGAAALBgAAE4YAABwGAAAeRgAAIcYAACpGAAAyxgAANQYAADiGAAABBkAACYZAAAvGQAAPRkAAF8ZAACBGQAAihkAAJgZAAC6GQAA3BkAAOUZAADzGQAAFRoAADcaAABAGgAAThoAAHAaAACSGgAAmxoAAKkaAADLGgAA7RoAAPYaAAAEGwAAJhsAAEgbAABRGwAAXxsAAIEbAACjGwAArBsAALobAADcGwAA/hsAAAccAAAVHAAANxwAAFkcAABiHAAAcBwAAJIcAAC0HAAAvRwAAMscAADtHAAADx0AABgdAAAmHQAASB0AAGodAABzHQAAgR0AAKMdAADFHQAAzh0AANwdAAD+HQAAIB4AACkeAAA3HgAAWR4AAHseAACEHgAAkh4AALQeAADWHgAA3x4AAO0eAAAPHwAAMR8AADofAABIHwAAah8AAIwfAACVHwAAox8AAMUfAADnHwAA8B8AAP4fAAAgIAAAQiAAAEsgAABZIAAAeyAAAJ0gAACmIAAAtCAAANYgAAD4IAAAASEAAA8hAAAxIQAAUyEAAFwhAABqIQAAjCEAAK4hAAC3IQAAxSEAAOchAAAJIgAAEiIAACAiAABCIgAAZCIAAG0iAAB7IgAAnSIAAL8iAADIIgAA1iIAAPgiAAAaIwAAIyMAADEjAABTIwAAdSMAAH4jAACMIwAAAAAAAGFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtbGF0ZXN0YW50aHJvcGljL2NsYXVkZS1zb25uZXQtNC0yMDI1MDUxNG9wZW5haS9vM29wZW5haS9vNC1taW5pYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdGFudGhyb3BpYy9jbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTRvcGVuYWkvbzNvcGVuYWkvbzQtbWluaWFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3RhbnRocm9waWMvY2xhdWRlLXNvbm5ldC00LTIwMjUwNTE0b3BlbmFpL28zb3BlbmFpL280LW1pbmkAAAAAxvdHCiZzYD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADG90cKJnNgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMb3Rwomc2A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxvdHCiZzYD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADG90cKJnNgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMb3Rwomc3A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqvNrD7mseD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACq82sPuax4PwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKrzaw+5rHg/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqvNrD7mseD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC49dmM74+EPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALj12Yzvj4Q/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAm/H9kYLJjD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/9pDLioGSPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALj12Yzvj5Q/AAAAAAAAAAAAAAAAAAAAACntRkBKu2E/sfQiTlSelj8AAAAAAAAAAAAAAAAAAAAAKe1GQEq7YT+i8rTQHbuaPwAAAAAAAAAAAAAAAAAAAAAp7UZASrthP5TwRlPn154/AAAAAAAAAAAAAAAAAAAAACntRkBKu2E/xvdHCiZzoD8AAAAAAAAAAAAAAAAAAAAAKe1GQEq7YT/G90cKJnOgPwAAAAAAAAAAAAAAAAAAAAAp7UZASrthP7/2kMuKgaI/AAAAAAAAAAAAAAAAAAAAACntRkBKu2E/uPXZjO+PpD8AAAAAAAAAAAAAAAAAAAAAKe1GQEq7YT+49dmM74+kPwAAAAAAAAAAAAAAAAAAAAAp7UZASrthP7H0Ik5UnqY/AAAAAAAAAAAAAAAAAAAAACntRkBKu2E/ovK00B27qj8AAAAAAAAAAAAAAAAAAAAAKe1GQEq7YT+i8rTQHbuqPwAAAAAAAAAAAAAAAAAAAAAp7UZASrthPx9yWTFQwqs/AAAAAAAAAAAAAAAAAAAAACntRkBKu2E/lPBGU+fXrj8AAAAAAAAAAAAAAAAAAAAAvmNqYO+Yej+U8EZT59euPwAAAAAAAAAAAAAAAAAAAAC+Y2pg75h6P0N37GpYerE/AAAAAAAAAAAAAAAAAAAAAL5jamDvmHo/v/aQy4qBsj/8qfHSTWJgPwAAAAAAAAAAvmNqYO+Yej80dX7tIZe1P/yp8dJNYmA/AAAAAAAAAAC+Y2pg75h6P6rzaw+5rLg//Knx0k1iYD+EEEIIIYRgP75jamDvmHo/WTFQwhtNvT/8qfHSTWJgP4QQQgghhGA/vmNqYO+Yej/n1x5yWTHAP/yp8dJNYmA/hBBCCCGEYD++Y2pg75h6PyKXFQMlvME//Knx0k1iYD+EEEIIIYRgP75jamDvmHo/nha6Y1fDwj/8qfHSTWJgP4QQQgghhGA/vmNqYO+Yej/Z1bD0Ik7EP/yp8dJNYmA/hBBCCCGEYD++Y2pg75h6P7H0Ik5UnsY//Knx0k1iYD+EEEIIIYRgP75jamDvmHo/67MZ3x8pyD/8qfHSTWJgP4QQQgghhGA/vmNqYO+Yej9oM74/UjDJP/yp8dJNYmA/hBBCCCGEYD8p7UZASruBPwWTOQi49ck//Knx0k1iYD+EEEIIIYRgPyntRkBKu4E/3bGrYelFzD/8qfHSTWJwP4QQQgghhGA/c6hY0Bwqhj/3kMuKgRLOP/p+arx0k3g/hBBCCCGEYD9zqFjQHCqGP9aw9CJOVM4/exSuR+F6hD+EEEIIIYRgP3OoWNAcKoY/MVDCG02dzz/8qfHSTWKQP4QQQgghhGA/vmNqYO+Yij+mF3Gi8rTQP7pJDAIrh5Y/hBBCCCGEYD++Y2pg75iKP3THroalF9E/+n5qvHSTmD+EEEIIIYRgP75jamDvmIo/IpcVAyW80T85tMh2vp+aP4QQQgghhGA/vmNqYO+Yij99NuP7IwXTP7gehetRuJ4/hBBCCCGEYD8IH3zwwQePPxuWXsSJytM/uB6F61G4nj+EEEIIIYRgPwgffPDBB48/yGXFQAlv1D97FK5H4XqkP4QQQgghhGA/CB988MEHjz+XFQMlvNHUP7pJDAIrh6Y/hBBCCCGEYD8IH3zwwQePPzR1fu0hl9U/mpmZmZmZqT+EEEIIIYRgP87KT4iz8pM/AyW80dT51T9YObTIdr6vP8YYY4wxxng/c6hY0Bwqlj/BZA4Cbn3WP+xRuB6F67E/hBBCCCGEgD9zqFjQHCqWP5AUTOYg4NY/y6FFtvP9tD+llFJKKaWEPxiGYRiGYZg/X8SJytNC1z/6fmq8dJO4P6WUUkoppYQ/CB988MEHnz8tdMeuhqXXP4lBYOXQIrs/pZRSSimlhD8p7UZASruhP8vTQnfsatg/VOOlm8QgwD+llFJKKaWEP87KT4iz8qM/aDO+P1Iw2T+cxCCwcmjBP6WUUkoppYQ/oTlULGgOpT9Xw9KLOFHZP4ts5/up8cI/xhhjjDHGiD+Q0m4EpLSrP/UiTlSeFto/c2iR7Xw/xT+EEEIIIYSQP+1GQEq7EbA/caLytNAd2z+yne+nxkvHP6WUUkoppZQ/Ke1GQEq7sT9QwhtNnV/bP0Jg5dAi28k/pZRSSimllD/8W0vk/tayPx9yWTFQwts/iUFg5dAiyz+21lprrbWWPzcCUtqNgLQ//pGCyRwE3D8QWDm0yHbOP/jee++9954/3d9aIve3tj/tIZcVAyXcP0jhehSuR9E/lVJKKaWUoj9GF1100UW3P6xh6UWcqNw/46WbxCCw0j+ttdZaa62lPxiGYRiGYbg/i4ES3mjq3D9/arx0kxjUP9daa6211qo/VCxoDhULuj9qoTt2NSzdP28Sg8DKodU/+N577733rj8nm2yyySa7P2qhO3Y1LN0/CtejcD0K1z8AAAAAAACwP2NBc6hY0Lw/OVF5WuiO3T9SuB6F61HYP4wxxhhjjLE/NbB3TA3svT8YcaLytNDdP/LSTWIQWNk/lVJKKaWUsj/tRkBKuxHAP+Yg4NZnM94/6SYxCKwc2j8hhBBCCCG0P8C1RO5vLcE/xUAJbzR13j+F61G4HoXbP7bWWmuttbY/kiRJkiRJwj+U8EZT59feP83MzMzMzNw/xhhjjDHGuD9HQEq7EZDCP3MQcOuzGd8/HVpkO99P3T/XWmuttda6PxmvTl/Gq8M/Y6CEN5o63z9oke18PzXeP++99957770/CnFWfkKcxT9joIQ3mjrfP7TIdr6fGt8/fO+99957vz+R+1tL5P7GP1IwmYOAW98/BFYOLbKd3z9KKaWUUkrBP/oyXp2+jMc/UjCZg4Bb3z9SuB6F61HgP5VSSimllMI/zaFiQXOoyD9CwK3PZnzfP/YoXI/C9eA/nXPOOeecwz/r9GW8On3JPzFQwhtNnd8/8tJNYhBY4T/nnHPOOefEPwlIaTcCUso/MVDCG02d3z9GtvP91HjhPzLGGGOMMcY/J5tssskmyz8h4NZnM77fP0Jg5dAi2+E/fO+99957xz+Q0m4EpLTLPxBw67MZ398/kxgEVg4t4j8IIYQQQgjJPxdddNFFF80/AAAAAAAA4D8730+Nl27iPxFCCCGEEMo/gZR2IyClzT8AAAAAAADgP4/C9Shcj+I/IYQQQgghzD/qy3h1+jLOP+fXHnJZMeA/4XoUrkfh4j8ppZRSSinNP7w6fRmvTs8/59ceclkx4D/dJAaBlUPjP3TOOeecc84/omJBc6hY0D/n1x5yWTHgP4cW2c73U+M/fO+99957zz988MEHH3zQP98fKZjMQeA/g8DKoUW24z9jjDHGGGPQP3zwwQcffNA/3x8pmMxB4D/Xo3A9CtfjP8YYY4wxxtA/5SfEWfkJ0T/fHymYzEHgP9V46SYxCOQ/zjnnnHPO0T900UUXXXTRP8+vPeSyYuA/f2q8dJMY5D9TSimllFLSPwN7x9TA3tE/z6895LJi4D99PzVeuknkP9daa6211tI/3ghIaTcC0j/Prz3ksmLgPycxCKwcWuQ/Ouecc8450z+SJEmSJEnSP8+vPeSyYuA/0SLb+X5q5D++9957773TP22yySabbNI/vj9SMJmD4D8bL90kBoHlP/jee++999Y/oBBn5SfE2T/H90cKJnNgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMf3Rwomc2A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAx/dHCiZzYD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADH90cKJnNgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMf3Rwomc2A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAclYgEng9Zz8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOWneNO29sPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5ad407b2w/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATlp3jTtvbD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOWneNO29sPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHfGMvQ4UXI/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAd8Yy9DhRcj8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMztXdGKF1PwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKugO4ateXg/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwOjA9nFeT8AAAAAAAAAAAAAAAAAAAAAKu1GQEq7YT/Ki8yRyQB7PwAAAAAAAAAAAAAAAAAAAAAq7UZASrthP6H5JoyLS30/AAAAAAAAAAAAAAAAAAAAACrtRkBKu2E/z6gIOC1nfz8AAAAAAAAAAAAAAAAAAAAAKu1GQEq7YT/Svjf7HDOAPwAAAAAAAAAAAAAAAAAAAAAq7UZASrthP9K+N/scM4A/AAAAAAAAAAAAAAAAAAAAACrtRkBKu2E/8kvz3IolgT8AAAAAAAAAAAAAAAAAAAAAKu1GQEq7YT8JjfGZVQmCPwAAAAAAAAAAAAAAAAAAAAAq7UZASrthPwmN8ZlVCYI/AAAAAAAAAAAAAAAAAAAAACrtRkBKu2E/m+srMo/ggj8AAAAAAAAAAAAAAAAAAAAAKu1GQEq7YT+Zwof0bG+EPwAAAAAAAAAAAAAAAAAAAAAq7UZASrthP5nCh/Rsb4Q/AAAAAAAAAAAAAAAAAAAAACrtRkBKu2E/wNsgMW7NhD8AAAAAAAAAAAAAAAAAAAAAKu1GQEq7YT+g16Ezl9uFPwAAAAAAAAAAAAAAAAAAAACEHMslNaVuP6DXoTOX24U/AAAAAAAAAAAAAAAAAAAAAIQcyyU1pW4/pVlaC3Mrhz8AAAAAAAAAAAAAAAAAAAAAhBzLJTWlbj9jO9UyPsqHP/yp8dJNYmA/AAAAAAAAAACEHMslNaVuP8nRQuVbh4k//Knx0k1iYD8AAAAAAAAAAIQcyyU1pW4/T4Jj2nkciz/8qfHSTWJgP4UQQgghhGA/hBzLJTWlbj9nJv28MT+NP/yp8dJNYmA/hRBCCCGEYD+EHMslNaVuP9oZwUmriY4//Knx0k1iYD+FEEIIIYRgP4QcyyU1pW4/CR56p9q8jz/8qfHSTWJgP4UQQgghhGA/hBzLJTWlbj/LuQxu/j6QP/yp8dJNYmA/hRBCCCGEYD+EHMslNaVuP4O6pk7jx5A//Knx0k1iYD+FEEIIIYRgP4QcyyU1pW4/dHAHdwiFkT/8qfHSTWJgP4UQQgghhGA/hBzLJTWlbj/a/4FHXvmRP/yp8dJNYmA/hRBCCCGEYD+EHMslNaVuP2MfVuzuQpI//Knx0k1iYD+FEEIIIYRgP+95mvp+rHE/Ga5aQh54kj/8qfHSTWJgP4UQQgghhGA/73ma+n6scT8ra9YICA6TP58ij/GxJWc/hRBCCCGEYD8Tyj7PA71zPwEy/4dCeZM/FweIpSxSbD+FEEIIIYRgPxPKPs8DvXM/BjcgzfGHkz+s+HKhij5yP4UQQgghhGA/E8o+zwO9cz9u1vbQFM+TP3j7bdTjAXc/hRBCCCGEYD8KSbezPZl1P+HDRw1/LJQ/MtWWZ2vlej+FEEIIIYRgPwpJt7M9mXU/KQc7JmlSlD/nxfiiOhB8P4UQQgghhGA/Ckm3sz2ZdT9Xz+9h4I6UP1vYONPqLX0/hRBCCCGEYD8KSbezPZl1P/vUur3+/ZQ/pzZeKnxHfz+FEEIIIYRgP/3DafS1TXc/2rVUo6c6lT+nNl4qfEd/P4UQQgghhGA//cNp9LVNdz8aDZlj5WmVP7yWeDo794E/hRBCCCGEYD/9w2n0tU13P8YBLADVhJU/4Zcyl6fNgj+FEEIIIYRgP/3DafS1TXc/XXCbEpu3lT84RRrAPvuDP4UQQgghhGA/QGFzyJhdej9Ww+S+eM+VPxLs4ZcBHIY/oHXFU4aMbD8uqM2v18J7P9sCEa++7ZU/D9OhD2Rkhz9w/FcLTHdwPy6oza/Xwns/84nq6E0Dlj9Smc/rbyeJPz33ga8NZHI/MK7AMHgVfT/SgOQA5ReWP6HWPyspAos/PfeBrw1kcj/b1WTP0VmAP7orWaqGK5Y/MRkL2A45jD8994GvDWRyPwGATWjUcIE/ZRJjsfNPlj+9SjZDn2yOPz33ga8NZHI/MXwyewl1gj8WzSR6p3CWP5cpx3lebY8/PfeBrw1kcj/57cpQC/GCP+JgaES/dZY/cziSRilHkD/lUWzXKCB0P9XSsXJwlIU/NOtXQS+Slj+6n/yibg6RPxydUTkMMXc/ZGEpnbUihz+qolKdg7KWP3gsszH0r5E/BtevgjTgeT8YcW/A7TeIP2wjODScuZY/t8UlEJVnkj8G16+CNOB5P3j7H1nc54g//kGKQ4XDlj9BCy9edbySPzWrUaRfHHs/m10KIdrjiT9Tvs3qo8mWP4w8iUeIhZM/+5ghuR6Hfz/TnQ8LAyCLP29Qj/KNzJY/1i8eYPFZlD9CQolG7TaBP9MfHTTVa4s/MZlxRz7Xlj+g2BMEx9eUP64/MnAQiYI/4Y3EfOb/iz/G1/Q9AtyWP9ncEN18RpU/ututP/WDhD++5OJgmdWMPwo9Lbtj4JY/3x6H3hKvlT+TWTw9c/GFP+VHJbjVXo0/Cj0tu2Pglj/knceQ4gCWP9CjpTctSIY/speMtmYljj9JONvNPeaWP6OsoYwYQJY//pJhxIJChz+DHMslNaWOP4coCgiq6ZY/orFf7EFrlj/mEIdO3eGHP2Z/tmmgmo8/GeacERXulj8c7RUjaIeWPzNgnTW6xog/zMPodrlBkD9lWxwbjfCWP5kDOTjNsZY/WR1IQRksij+iR9cnWrCQP4Xnw3yK85Y/2rbPSS3Olj8QIu3E/TaLP1V85oMoy5A/o+V6Gg/1lj91W3ff2daWP9S4tXkHM4w/tuVfcCozkT+MWDbzrPWWP5Tkp4Zh4pY/x15TcnSUjT9svmiUn92RP4xYNvOs9ZY/Ge6Uu0nplj9g+6wsLzuOP8Mnb+QeT5I/GeTnfzL2lj86b2SEKuuWP3Aieza+do8/lqKNX7l6kj8Z5Od/MvaWP6fjyzhq6pY/MRmFxoo2kD9y5Em8Ac+SPxtzN8Kf9pY/HYMocwThlj80bN9MHZSQPz0xqmLCC5M/OLl/u/T2lj93W3ff2daWP7RpLWZXA5E/S5Fbkn1Gkz84uX+79PaWP+pY+EO00pY/TGHs2qJskT8ZLqmPRX+TP0VIzmwx95Y/++tDTPrDlj/Y7ErdaNCRP5WryUMTpJM/HaHj1lX3lj/k+lJkErWWP7wJDKVYQZI/dPQ114n8kz93PzP6YfeWP4QaEftop5Y/5XEXU8SIkj/pYV2fjB6UP3c/M/ph95Y/S//xGv+flj97bRp67Q6TPzHP6FXMP5Q/OLl/u/T2lj8SB3Q+wIuWP/akS0fnTZM/oZf3TBGAlD84uX+79PaWPwiMlskycJY/s2BtafuYkz+TBjwXXcyUPzi5f7v09pY/oLFf7EFrlj8wc7SCPtKTPy/l1IAZ25Q/HHM3wp/2lj+xaj77fkuWPwB29w11FpQ/L+XUgBnblD8cczfCn/aWP6SsoYwYQJY/0MJCwqU9lD+V5oPlWBSVPxxzN8Kf9pY/k44yqjkulj/6Of+mCKCUP+RDKQSKPZU/i1g286z1lj8xLOfGDyiWPx6jveYAzpQ/6QNxG0ZllT+LWDbzrPWWP6CCVR/yFJY/Ga2hE+b5lD883ztRM3KVP4tYNvOs9ZY/U4fhRV0Olj/1dbVAfRmVP250OzuVi5U/i1g286z1lj+ggORzrQeWPyDnuIzfQZU/lTYWfQqYlT/4TsDzWPSWP/WTVdF8hZU/wOfbjbMTlj8DtkzHrWOXPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMb3Rwomc3A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxvdHCiZzcD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADG90cKJnNwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJvx/ZGCyYw/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxvdHCiZzkD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC/9pDLioGSPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKrzaw+5rJg/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAovK00B27mj8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACb8f2RgsmcPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJTwRlPn154/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxvdHCiZzoD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADG90cKJnOgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEN37GpYeqE/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPHY1LL2Ioz8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtdMeuhqWnPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKrzaw+5rKg/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH3JZMVDCqz8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADG90cKJnOwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEN37GpYerE/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfTbj+yMFsz8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8djUsvYizPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPO00B27GrY/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbzR1fu0htz8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACi8rTQHbu6PwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN2xq2HpRbw//Knx0k1iYD8AAAAAAAAAACntRkBKu2E/EHDrsxnfvz/8qfHSTWJgPwAAAAAAAAAAKe1GQEq7YT+mF3Gi8rTAP/yp8dJNYmA/AAAAAAAAAAAp7UZASrthP2RXw9KLOME//Knx0k1iYD+EEEIIIYRgPyntRkBKu4E/fTbj+yMFwz/8qfHSTWJwP4QQQgghhGA/Ke1GQEq7gT8bll7EicrDP/p+arx0k3g/hBBCCCGEYD8p7UZASruBPzR1fu0hl8U/+n5qvHSTeD+EEEIIIYRgP3OoWNAcKoY/0tT5tYdcxj/6fmq8dJN4P4QQQgghhGA/c6hY0Bwqhj+QFEzmIODGP/p+arx0k3g/xhhjjDHGeD++Y2pg75iKPwyU8EZT58c//Knx0k1igD/GGGOMMcZ4P75jamDvmIo/67MZ3x8pyD/8qfHSTWKAP8YYY4wxxng/CB988MEHjz+q82sPuazIP/yp8dJNYoA/hBBCCCGEgD8IH3zwwQePP2gzvj9SMMk/+n5qvHSTiD+EEEIIIYSAP3OoWNAcKpY/QFIwmYOAyz/8qfHSTWKQP4QQQgghhIA/c6hY0Bwqlj9AUjCZg4DLP/yp8dJNYpA/hBBCCCGEgD8YhmEYhmGYPx9yWTFQwss/exSuR+F6lD+EEEIIIYSAPwgffPDBB58/95DLioESzj85tMh2vp+aP8YYY4wxxog/CB988MEHnz+U8EZT59fOP3npJjEIrJw/55xzzjnnjD8IH3zwwQefPxBw67MZ388/nMQgsHJooT+EEEIIIYSQPyntRkBKu6E/12czvj9S0D97FK5H4XqkP6WUUkoppZQ/oTlULGgOpT+Vp4Xu2NXQP7pJDAIrh6Y/xhhjjDHGmD8YhmEYhmGoP1Pn1x5yWdE/WmQ730+Npz/XWmuttdaaPzWwd0wN7K0/0GZ8f6Rg0j/ZzvdT46WrP4QQQgghhKA/CB988MEHrz99NuP7IwXTP7gehetRuK4/hBBCCCGEoD/tRkBKuxGwPwomcxBw69M//Knx0k1isD+VUkoppZSiP+1GQEq7EbA/2dWw9CJO1D/sUbgeheuxP6WUUkoppaQ/Vn5CnJWfsD92NSy9iBPVP4ts5/up8bI/rbXWWmutpT/8W0vk/tayPxSVp4Xu2NU/arx0kxgEtj/OOeecc86pP2WTTTbZZLM/sfQiTlSe1j/6fmq8dJO4P99777333qs/ZZNNNtlksz9fxInK00LXP+kmMQisHLo/77333nvvrT9lk0022WSzPz7ksmKghNc/uB6F61G4vj8IIYQQQgixPwpxVn5CnLU/LXTHroal1z/8qfHSTWLAP5VSSimllLI/c6hY0Bwqtj/8IwWTOQjYP0SLbOf7qcE/MsYYY4wxtj/d31oi97e2P5mDgFufzdg/O99PjZduwj++99577723P93fWiL3t7Y/mYOAW5/N2D/jpZvEILDCP84555xzzrk/r05fxqvTtz9oM74/UjDZPyuHFtnO98M/W2uttdZauz/r9GW8On25Pzbj+yMFk9k/c2iR7Xw/xT9rrbXWWmu9PyebbLLJJrs/JnMQcOuz2T/D9Shcj8LFP8YYY4wxxsA/NbB3TA3svT/ksmKghDfaPwIrhxbZzsc/zjnnnHPOwT+iYkFzqFjAP7NioIQ3mto/UrgehetRyD+dc84555zDP94ISGk3AsI/koLJHATc2j9SuB6F61HIP2uttdZaa8U/sHdMDewdwz9QwhtNnV/bP5qZmZmZmck/MsYYY4wxxj/sHVMDe8fEPy/iROVpods/4XoUrkfhyj8AAAAAAADIP7+MV6cv48U/7SGXFQMl3D956SYxCKzMP0oppZRSSsk/kftbS+T+xj/tIZcVAyXcP2iR7Xw/Nc4/EUIIIYQQyj+vTl/Gq9PHP81BwK3PZtw/YOXQItv5zj+dc84555zLP6AQZ+UnxMk/m/H9kYLJ3D9YObTIdr7PP99777333ss/J5tssskmyz+LgRLeaOrcP1g5tMh2vs8/77333nvvzT/5CXFWfkLMP3oRJypPC90/qMZLN4lB0D8yxhhjjDHOP8x4dfoyXs0/ehEnKk8L3T9QjZduEoPQP7733nvvvc8/gZR2IyClzT96EScqTwvdP6AaL90kBtE/Y4wxxhhj0D/qy3h1+jLOP3oRJypPC90/SOF6FK5H0T9KKaWUUkrRPwgffPDBB88/aqE7djUs3T9Ei2zn+6nRP6211lprrdE/JnJ/a4nczz9ZMVDCG03dP+xRuB6F69E/MsYYY4wx0j/lJ8RZ+QnRP4SAW5/N+N4/d76fGi/d1D+EEEIIIYTkP7B3TA3sHeM/8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAADyAQAAAAAAAPQBAAAAAAAA8AEAAAAAAADOAQAAAAAAAPIBAAAAAAAA9AEAAAAAAADwAQAAAAAAAM4BAAAAAAAA8gEAAAAAAAD0AQAAAAAAAPABAAAAAAAAzgEAAAAAAAAAAAAAmAAAADABAADIAQAAYAIAAPgCAACQAwAAKAQAAMAEAABYBQAA8AUAAIgGAAAgBwAAuAcAAFAIAADoCAAAgAkAABgKAACwCgAASAsAAOALAAB4DAAAEA0AAKgNAABADgAA2A4AAHAPAAAIEAAAoBAAADgRAADQEQAAaBIAAAATAACYEwAAMBQAAMgUAABgFQAA+BUAAJAWAAAoFwAAwBcAAFgYAADwGAAAiBkAACAaAAC4GgAAUBsAAOgbAACAHAAAGB0AALAdAABIHgAA4B4AAHgfAAAQIAAAqCAAAEAhAADYIQAAcCIAAAgjAACgIwAAOCQAANAkAABoJQAAACYAAJgmAAAwJwAAyCcAAGAoAAD4KAAAkCkAACgqAADAKgAAWCsAAPArAACILAAAIC0AALgtAABQLgAA6C4AAIAvAAAYMAAAsDAAAEgxAADgMQAAeDIAABAzAACoMwAAQDQAANg0AABwNQAACDYAAKA2AAA4NwAA0DcAAGg4AAAAOQAAmDkAADA6AADIOgAAYDsAAPg7AACQPAAAKD0AAMA9AABYPgAA8D4AAIg/AAAgQAAAuEAAAFBBAADoQQAAgEIAABhDAACwQwAASEQAAOBEAAB4RQAAEEYAAKhGAABARwAA2EcAAHBIAAAISQAAoEkAADhKAADQSgAAaEsAAABMAACYTAAAME0AAMhNAABgTgAA+E4AAJBPAAAoUAAAwFAAAFhRAADwUQAAiFIAACBTAAC4UwAAUFQAAOhUAACAVQAAGFYAALBWAABIVwAA4FcAAHhYAAAQWQAAqFkAAEBaAADYWgAAcFsAAAhcAACgXAAAOF0AANBdAABoXgAAAF8AAJhfAAAwYAAAyGAAAGBhAAD4YQAAkGIAAChjAADAYwAAWGQAAPBkAACIZQAAIGYAALhmAABQZwAA6GcAAIBoAAAYaQAAsGkAAEhqAADgagAAeGsAABBsAACobAAAQG0AANhtAABwbgAACG8AAKBvAAA4cAAA0HAAAGhxAAAAcgAAmHIAADBzAADIcwAAYHQAAPh0AACQdQAAKHYAAMB2AABYdwAA8HcAAIh4AAAgeQAAuHkAAFB6AADoegAAgHsAABh8AACwfAAASH0AAOB9AAB4fgAAEH8AAKh/AABAgAAA2IAAAHCBAAAIggAAoIIAADiDAADQgwAAaIQAAACFAACYhQAAMIYAAMiGAABghwAA+IcAAJCIAAAoiQAAwIkAAFiKAADwigAAiIsAACCMAAC4jAAAUI0AAOiNAACAjgAAGI8AALCPAABIkAAA4JAAAHiRAAAQkgAAqJIAAECTAADYkwAAcJQAAAiVAACglQAAOJYAANCWAABolwAAAJgAAJiYAAAwmQAAyJkAAGCaAAD4mgAAkJsAACicAADAnAAAWJ0AAPCdAACIngAAIJ8AALifAABQoAAA6KAAAIChAAAYogAAsKIAAEijAADgowAAeKQAABClAACopQAAQKYAANimAABwpwAACKgAAKCoAAA4qQAA0KkAAGiqAAAAqwAAmKsAADCsAADIrAAAYK0AAPitAACQrgAAKK8AAMCvAABYsAAA8LAAAIixAAAgsgAAuLIAAFCzAADoswAAgLQAABi1AACwtQAASLYAAOC2AAB4twAAELgAAKi4AABAuQAA2LkAAHC6AAAIuwAAoLsAADi8AADQvAAAaL0AAAC+AACYvgAAML8AAMi/AABgwAAA+MAAAJDBAAAowgAAwMIAAFjDAADwwwAAiMQAACDFAAC4xQAAUMYAAOjGAACAxwAAGMgAALDIAABIyQAA4MkAAHjKAAAQywAAqMsAAEDMAADYzAAAcM0AAAjOAACgzgAAOM8AANDPAABo0AAAANEAAJjRAAAw0gAAyNIAAGDTAAD40wAAkNQAACjVAADA1QAAWNYAAPDWAACI1wAAINgAALjYAABQ2QAA6NkAAIDaAAAY2wAAsNsAAEjcAADg3AAAeN0AABDeAACo3gAAQN8AANjfAABw4AAACOEAAKDhAAA44gAA0OIAAGjjAAAA5AAAmOQAADDlAADI5QAAYOYAAPjmAACQ5wAAKOgAAMDoAABY6QAA8OkAAIjqAAAg6wAAuOsAAFDsAADo7AAAgO0AAAAAAAAvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbAAAAAAJAAAAEgAAABgAAAAeAAAAJwAAADAAAAA2AAAAPAAAAEUAAABOAAAAVAAAAFoAAABjAAAAbAAAAHIAAAB4AAAAgQAAAIoAAACQAAAAlgAAAJ8AAACoAAAArgAAALQAAAC9AAAAxgAAAMwAAADSAAAA2wAAAOQAAADqAAAA8AAAAPkAAAACAQAACAEAAA4BAAAXAQAAIAEAACYBAAAsAQAANQEAAD4BAABEAQAASgEAAFMBAABcAQAAYgEAAGgBAABxAQAAegEAAIABAACGAQAAjwEAAJgBAACeAQAApAEAAK0BAAC2AQAAvAEAAMIBAADLAQAA1AEAANoBAADgAQAA6QEAAPIBAAD4AQAA/gEAAAcCAAAQAgAAFgIAABwCAAAlAgAALgIAADQCAAA6AgAAQwIAAEwCAABSAgAAWAIAAGECAABqAgAAcAIAAHYCAAB/AgAAiAIAAI4CAACUAgAAnQIAAKYCAACsAgAAsgIAALsCAADEAgAAygIAANACAADZAgAA4gIAAOgCAADuAgAA9wIAAAADAAAGAwAADAMAABUDAAAeAwAAJAMAACoDAAAzAwAAPAMAAEIDAABIAwAAUQMAAFoDAABgAwAAZgMAAG8DAAB4AwAAfgMAAIQDAACNAwAAlgMAAJwDAACiAwAAqwMAALQDAAC6AwAAwAMAAMkDAADSAwAA2AMAAN4DAADnAwAA8AMAAPYDAAD8AwAABQQAAA4EAAAUBAAAGgQAACMEAAAsBAAAMgQAADgEAABBBAAASgQAAFAEAABWBAAAXwQAAGgEAABuBAAAdAQAAH0EAACGBAAAjAQAAJIEAACbBAAApAQAAKoEAACwBAAAuQQAAMIEAADIBAAAzgQAANcEAADgBAAA5gQAAOwEAAD1BAAA/gQAAAQFAAAKBQAAEwUAABwFAAAiBQAAKAUAADEFAAA6BQAAQAUAAEYFAABPBQAAWAUAAF4FAABkBQAAbQUAAHYFAAB8BQAAggUAAIsFAACUBQAAmgUAAKAFAACpBQAAsgUAALgFAAC+BQAAxwUAANAFAADWBQAA3AUAAOUFAADuBQAA9AUAAPoFAAADBgAADAYAABIGAAAYBgAAIQYAACoGAAAwBgAANgYAAD8GAABIBgAATgYAAFQGAABdBgAAZgYAAGwGAAByBgAAewYAAIQGAACKBgAAkAYAAJkGAACiBgAAqAYAAK4GAAC3BgAAwAYAAMYGAADMBgAA1QYAAN4GAADkBgAA6gYAAPMGAAD8BgAAAgcAAAgHAAARBwAAGgcAACAHAAAmBwAALwcAADgHAAA+BwAARAcAAE0HAABWBwAAXAcAAGIHAABrBwAAdAcAAHoHAACABwAAiQcAAJIHAACYBwAAngcAAKcHAACwBwAAtgcAALwHAADFBwAAzgcAANQHAADaBwAA4wcAAOwHAADyBwAA+AcAAAEIAAAKCAAAEAgAABYIAAAfCAAAKAgAAC4IAAA0CAAAPQgAAEYIAABMCAAAUggAAFsIAABkCAAAaggAAHAIAAB5CAAAgggAAIgIAACOCAAAlwgAAKAIAACmCAAArAgAALUIAAC+CAAAxAgAAMoIAADTCAAA3AgAAOIIAADoCAAA8QgAAPoIAAAACQAABgkAAA8JAAAYCQAAHgkAACQJAAAtCQAANgkAADwJAABCCQAASwkAAFQJAABaCQAAYAkAAGkJAAByCQAAeAkAAH4JAACHCQAAkAkAAJYJAACcCQAApQkAAK4JAAC0CQAAugkAAMMJAADMCQAA0gkAANgJAADhCQAA6gkAAPAJAAD2CQAA/wkAAAgKAAAOCgAAFAoAAB0KAAAmCgAALAoAADIKAAA7CgAARAoAAEoKAABQCgAAWQoAAGIKAABoCgAAbgoAAHcKAACACgAAhgoAAIwKAACVCgAAngoAAKQKAACqCgAAswoAALwKAADCCgAAyAoAANEKAADaCgAA4AoAAOYKAADvCgAA+AoAAP4KAAAECwAADQsAABYLAAAcCwAAIgsAACsLAAA0CwAAOgsAAEALAABJCwAAUgsAAFgLAABeCwAAZwsAAHALAAB2CwAAfAsAAIULAACOCwAAlAsAAJoLAACjCwAArAsAALILAAC4CwAAAAAAAEFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY09wZW5BSU9wZW5BSQAAAAARAAAAIAAAACIAAAApAAAAOgAAAEkAAABLAAAAUgAAAGMAAAByAAAAdAAAAHsAAACMAAAAmwAAAJ0AAACkAAAAtQAAAMQAAADGAAAAzQAAAN4AAADtAAAA7wAAAPYAAAAHAQAAFgEAABgBAAAfAQAAMAEAAD8BAABBAQAASAEAAFkBAABoAQAAagEAAHEBAACCAQAAkQEAAJMBAACaAQAAqwEAALoBAAC8AQAAwwEAANQBAADjAQAA5QEAAOwBAAD9AQAADAIAAA4CAAAVAgAAJgIAADUCAAA3AgAAPgIAAE8CAABeAgAAYAIAAGcCAAB4AgAAhwIAAIkCAACQAgAAoQIAALACAACyAgAAuQIAAMoCAADZAgAA2wIAAOICAADzAgAAAgMAAAQDAAALAwAAHAMAACsDAAAtAwAANAMAAEUDAABUAwAAVgMAAF0DAABuAwAAfQMAAH8DAACGAwAAlwMAAKYDAACoAwAArwMAAMADAADPAwAA0QMAANgDAADpAwAA+AMAAPoDAAABBAAAEgQAACEEAAAjBAAAKgQAADsEAABKBAAATAQAAFMEAABkBAAAcwQAAHUEAAB8BAAAjQQAAJwEAACeBAAApQQAALYEAADFBAAAxwQAAM4EAADfBAAA7gQAAPAEAAD3BAAACAUAABcFAAAZBQAAIAUAADEFAABABQAAQgUAAEkFAABaBQAAaQUAAGsFAAByBQAAgwUAAJIFAACUBQAAmwUAAKwFAAC7BQAAvQUAAMQFAADVBQAA5AUAAOYFAADtBQAA/gUAAA0GAAAPBgAAFgYAACcGAAA2BgAAOAYAAD8GAABQBgAAXwYAAGEGAABoBgAAeQYAAIgGAACKBgAAkQYAAKIGAACxBgAAswYAALoGAADLBgAA2gYAANwGAADjBgAA9AYAAAMHAAAFBwAADAcAAB0HAAAsBwAALgcAADUHAABGBwAAVQcAAFcHAABeBwAAbwcAAH4HAACABwAAhwcAAJgHAACnBwAAqQcAALAHAADBBwAA0AcAANIHAADZBwAA6gcAAPkHAAD7BwAAAggAABMIAAAiCAAAJAgAACsIAAA8CAAASwgAAE0IAABUCAAAZQgAAHQIAAB2CAAAfQgAAI4IAACdCAAAnwgAAKYIAAC3CAAAxggAAMgIAADPCAAA4AgAAO8IAADxCAAA+AgAAAkJAAAYCQAAGgkAACEJAAAyCQAAQQkAAEMJAABKCQAAWwkAAGoJAABsCQAAcwkAAIQJAACTCQAAlQkAAJwJAACtCQAAvAkAAL4JAADFCQAA1gkAAOUJAADnCQAA7gkAAP8JAAAOCgAAEAoAABcKAAAoCgAANwoAADkKAABACgAAUQoAAGAKAABiCgAAaQoAAHoKAACJCgAAiwoAAJIKAACjCgAAsgoAALQKAAC7CgAAzAoAANsKAADdCgAA5AoAAPUKAAAECwAABgsAAA0LAAAeCwAALQsAAC8LAAA2CwAARwsAAFYLAABYCwAAXwsAAHALAAB/CwAAgQsAAIgLAACZCwAAqAsAAKoLAACxCwAAwgsAANELAADTCwAA2gsAAOsLAAD6CwAA/AsAAAMMAAAUDAAAIwwAACUMAAAsDAAAPQwAAEwMAABODAAAVQwAAGYMAAB1DAAAdwwAAH4MAACPDAAAngwAAKAMAACnDAAAuAwAAMcMAADJDAAA0AwAAOEMAADwDAAA8gwAAPkMAAAKDQAAGQ0AABsNAAAiDQAAMw0AAEINAABEDQAASw0AAFwNAABrDQAAbQ0AAHQNAACFDQAAlA0AAJYNAACdDQAArg0AAL0NAAC/DQAAxg0AANcNAADmDQAA6A0AAO8NAAAADgAADw4AABEOAAAYDgAAKQ4AADgOAAA6DgAAQQ4AAFIOAABhDgAAYw4AAGoOAAB7DgAAig4AAIwOAACTDgAApA4AALMOAAC1DgAAvA4AAM0OAADcDgAA3g4AAOUOAAD2DgAABQ8AAAcPAAAODwAAHw8AAC4PAAAwDwAANw8AAEgPAABXDwAAWQ8AAGAPAABxDwAAgA8AAIIPAACJDwAAmg8AAKkPAACrDwAAsg8AAMMPAADSDwAA1A8AANsPAADsDwAA+w8AAP0PAAAEEAAAAAAAAENsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pQ2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDRvM280IE1pbmlDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgNG8zbzQgTWluaUNsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCA0bzNvNCBNaW5pAAAAADMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzAAAAAAAAAAAAAAYAAAAOAAAADgAAAA4AAAAUAAAAHAAAABwAAAAcAAAAIgAAACoAAAAqAAAAKgAAADAAAAA4AAAAOAAAADgAAAA+AAAARgAAAEYAAABGAAAATAAAAFQAAABUAAAAVAAAAFoAAABiAAAAYgAAAGIAAABoAAAAcAAAAHAAAABwAAAAdgAAAH4AAAB+AAAAfgAAAIQAAACMAAAAjAAAAIwAAACSAAAAmgAAAJoAAACaAAAAoAAAAKgAAACoAAAAqAAAAK4AAAC2AAAAtgAAALYAAAC8AAAAxAAAAMQAAADEAAAAygAAANIAAADSAAAA0gAAANgAAADgAAAA4AAAAOAAAADmAAAA7gAAAO4AAADuAAAA9AAAAPwAAAD8AAAA/AAAAAIBAAAKAQAACgEAAAoBAAAQAQAAGAEAABgBAAAYAQAAHgEAACYBAAAmAQAAJgEAACwBAAA0AQAANAEAADQBAAA6AQAAQgEAAEIBAABCAQAASAEAAFABAABQAQAAUAEAAFYBAABeAQAAXgEAAF4BAABkAQAAbAEAAGwBAABsAQAAcgEAAHoBAAB6AQAAegEAAIABAACIAQAAiAEAAIgBAACOAQAAlgEAAJYBAACWAQAAnAEAAKQBAACkAQAApAEAAKoBAACyAQAAsgEAALIBAAC4AQAAwAEAAMABAADAAQAAxgEAAM4BAADOAQAAzgEAANQBAADcAQAA3AEAANwBAADiAQAA6gEAAOoBAADqAQAA8AEAAPgBAAD4AQAA+AEAAP4BAAAGAgAABgIAAAYCAAAMAgAAFAIAABQCAAAUAgAAGgIAACICAAAiAgAAIgIAACgCAAAwAgAAMAIAADACAAA2AgAAPgIAAD4CAAA+AgAARAIAAEwCAABMAgAATAIAAFICAABaAgAAWgIAAFoCAABgAgAAaAIAAGgCAABoAgAAbgIAAHYCAAB2AgAAdgIAAHwCAACEAgAAhAIAAIQCAACKAgAAkgIAAJICAACSAgAAmAIAAKACAACgAgAAoAIAAKYCAACuAgAArgIAAK4CAAC0AgAAvAIAALwCAAC8AgAAwgIAAMoCAADKAgAAygIAANACAADYAgAA2AIAANgCAADeAgAA5gIAAOYCAADmAgAA7AIAAPQCAAD0AgAA9AIAAPoCAAACAwAAAgMAAAIDAAAIAwAAEAMAABADAAAQAwAAFgMAAB4DAAAeAwAAHgMAACQDAAAsAwAALAMAACwDAAAyAwAAOgMAADoDAAA6AwAAQAMAAEgDAABIAwAASAMAAE4DAABWAwAAVgMAAFYDAABcAwAAZAMAAGQDAABkAwAAagMAAHIDAAByAwAAcgMAAHgDAACAAwAAgAMAAIADAACGAwAAjgMAAI4DAACOAwAAlAMAAJwDAACcAwAAnAMAAKIDAACqAwAAqgMAAKoDAACwAwAAuAMAALgDAAC4AwAAvgMAAMYDAADGAwAAxgMAAMwDAADUAwAA1AMAANQDAADaAwAA4gMAAOIDAADiAwAA6AMAAPADAADwAwAA8AMAAPYDAAD+AwAA/gMAAP4DAAAEBAAADAQAAAwEAAAMBAAAEgQAABoEAAAaBAAAGgQAACAEAAAoBAAAKAQAACgEAAAuBAAANgQAADYEAAA2BAAAPAQAAEQEAABEBAAARAQAAEoEAABSBAAAUgQAAFIEAABYBAAAYAQAAGAEAABgBAAAZgQAAG4EAABuBAAAbgQAAHQEAAB8BAAAfAQAAHwEAACCBAAAigQAAIoEAACKBAAAkAQAAJgEAACYBAAAmAQAAJ4EAACmBAAApgQAAKYEAACsBAAAtAQAALQEAAC0BAAAugQAAMIEAADCBAAAwgQAAMgEAADQBAAA0AQAANAEAADWBAAA3gQAAN4EAADeBAAA5AQAAOwEAADsBAAA7AQAAPIEAAD6BAAA+gQAAPoEAAAABQAACAUAAAgFAAAIBQAADgUAABYFAAAWBQAAFgUAABwFAAAkBQAAJAUAACQFAAAqBQAAMgUAADIFAAAyBQAAOAUAAEAFAABABQAAQAUAAEYFAABOBQAATgUAAE4FAABUBQAAXAUAAFwFAABcBQAAYgUAAGoFAABqBQAAagUAAHAFAAB4BQAAeAUAAHgFAAAAAAAAbGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTRsYXRlc3QyMDI1MDUxNGxhdGVzdDIwMjUwNTE0bGF0ZXN0MjAyNTA1MTSqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAqk4AAJFNAADiTgAA4k4AAKpOAACRTQAA4k4AAOJOAACqTgAAkU0AAOJOAADiTgAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AADxOAAC0TgAAok0AAKJNAAA8TgAAtE4AAKJNAACiTQAAPE4AALROAACiTQAAok0AAAAAAABwAAAA4AAAAFABAADAAQAAMAIAAKACAAAQAwAAgAMAAPADAABgBAAA0AQAAEAFAACwBQAAIAYAAJAGAAAABwAAcAcAAOAHAABQCAAAwAgAADAJAACgCQAAEAoAAIAKAADwCgAAYAsAANALAABADAAAsAwAACANAACQDQAAAA4AAHAOAADgDgAAUA8AAMAPAAAwEAAAoBAAABARAACAEQAA8BEAAGASAADQEgAAQBMAALATAAAgFAAAkBQAAAAVAABwFQAA4BUAAFAWAADAFgAAMBcAAKAXAAAQGAAAgBgAAPAYAABgGQAA0BkAAEAaAACwGgAAIBsAAJAbAAAAHAAAcBwAAOAcAABQHQAAwB0AADAeAACgHgAAEB8AAIAfAADwHwAAYCAAANAgAABAIQAAsCEAACAiAACQIgAAACMAAHAjAADgIwAAUCQAAMAkAAAwJQAAoCUAABAmAACAJgAA8CYAAGAnAADQJwAAQCgAALAoAAAgKQAAkCkAAAAqAABwKgAA4CoAAFArAADAKwAAMCwAAKAsAAAQLQAAgC0AAPAtAABgLgAA0C4AAEAvAACwLwAAIDAAAJAwAAAAMQAAcDEAAOAxAABQMgAAwDIAADAzAACgMwAAEDQAAIA0AADwNAAAYDUAANA1AABANgAAsDYAACA3AACQNwAAADgAAHA4AADgOAAAUDkAAMA5AAAwOgAAoDoAABA7AACAOwAA8DsAAGA8AADQPAAAQD0AALA9AAAgPgAAkD4AAAA/AABwPwAA4D8AAFBAAADAQAAAMEEAAKBBAAAQQgAAgEIAAPBCAABgQwAA0EMAAEBEAACwRAAAIEUAAJBFAAAARgAAcEYAAOBGAABQRwAAwEcAADBIAACgSAAAEEkAAIBJAADwSQAAYEoAANBKAABASwAAsEsAACBMAACQTAAAAE0AAHBNAADgTQAAUE4AAMBOAAAwTwAAoE8AABBQAACAUAAA8FAAAGBRAADQUQAAQFIAALBSAAAgUwAAkFMAAABUAABwVAAA4FQAAFBVAADAVQAAMFYAAKBWAAAQVwAAgFcAAPBXAABgWAAA0FgAAEBZAACwWQAAIFoAAJBaAAAAWwAAcFsAAOBbAABQXAAAwFwAADBdAACgXQAAEF4AAIBeAADwXgAAYF8AANBfAABAYAAAsGAAACBhAACQYQAAAGIAAHBiAADgYgAAUGMAAMBjAAAwZAAAoGQAABBlAACAZQAA8GUAAGBmAADQZgAAQGcAALBnAAAgaAAAkGgAAABpAABwaQAA4GkAAFBqAADAagAAMGsAAKBrAAAQbAAAgGwAAPBsAABgbQAA0G0AAEBuAACwbgAAIG8AAJBvAAAAcAAAcHAAAOBwAABQcQAAwHEAADByAACgcgAAEHMAAIBzAADwcwAAYHQAANB0AABAdQAAsHUAACB2AACQdgAAAHcAAHB3AADgdwAAUHgAAMB4AAAweQAAoHkAABB6AACAegAA8HoAAGB7AADQewAAQHwAALB8AAAgfQAAkH0AAAB+AABwfgAA4H4AAFB/AADAfwAAMIAAAKCAAAAQgQAAgIEAAPCBAABgggAA0IIAAECDAACwgwAAIIQAAJCEAAAAhQAAcIUAAOCFAABQhgAAwIYAADCHAACghwAAEIgAAICIAADwiAAAYIkAANCJAABAigAAsIoAACCLAACQiwAAAIwAAHCMAADgjAAAUI0AAMCNAAAwjgAAoI4AABCPAACAjwAA8I8AAGCQAADQkAAAQJEAALCRAAAgkgAAkJIAAACTAABwkwAA4JMAAFCUAADAlAAAMJUAAKCVAAAQlgAAgJYAAPCWAABglwAA0JcAAECYAACwmAAAIJkAAJCZAAAAmgAAcJoAAOCaAABQmwAAwJsAADCcAACgnAAAEJ0AAICdAADwnQAAYJ4AANCeAABAnwAAsJ8AACCgAACQoAAAAKEAAHChAADgoQAAUKIAAMCiAAAwowAAoKMAABCkAACApAAA8KQAAGClAADQpQAAQKYAALCmAAAgpwAAkKcAAACoAABwqAAA4KgAAFCpAADAqQAAMKoAAKCqAAAQqwAAgKsAAPCrAABgrAAA0KwAAECtAACwrQAAIK4AAJCuAAAArwAAAAAAAGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfYXN4ZUd4dGR5OVdzYmJ4NHZoTnZVbS5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1BTVXpmMjdrMldwcnJ0NmZZYUc1Y1IuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9TRnBaZGlOZWhmZ0tpOFAyVTNlNG12LmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfVVhBU1NLUEhNNTlqQjVWTmt2V3I0TC5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX2FzeGVHeHRkeTlXc2JieDR2aE52VW0uZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9QU1V6ZjI3azJXcHJydDZmWWFHNWNSLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfU0ZwWmRpTmVoZmdLaThQMlUzZTRtdi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1VYQVNTS1BITTU5akI1Vk5rdldyNEwuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9hc3hlR3h0ZHk5V3NiYng0dmhOdlVtLmV2YWxodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy9zd2UtYmVuY2gvMjAyNS0wNi0yNFQxMC00Mi01NiswMC0wMF9zd2UtYmVuY2hfUFNVemYyN2syV3BycnQ2ZllhRzVjUi5ldmFsaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvc3dlLWJlbmNoLzIwMjUtMDYtMjRUMTAtNDItNTYrMDAtMDBfc3dlLWJlbmNoX1NGcFpkaU5laGZnS2k4UDJVM2U0bXYuZXZhbGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3N3ZS1iZW5jaC8yMDI1LTA2LTI0VDEwLTQyLTU2KzAwLTAwX3N3ZS1iZW5jaF9VWEFTU0tQSE01OWpCNVZOa3ZXcjRMLmV2YWz/////AAAAAA=="},"tooltip":null}},"b5f21b7d257449a99923a18203a9ffea":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.plot._legend.Legend","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  legendContainerEl.style.padding = \"0.3em\";\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    targetEl.style.background = background === true ? \"white\" : background || \"white\";\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_fdd45541e9b54ed095d135e37054d01d","spec":"","tabbable":null,"tables":{},"tooltip":null}},"bc7c6ec3eeb14813b2389eebb88b70b6":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.interactor._interactors.Interactor","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  legendContainerEl.style.padding = \"0.3em\";\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    targetEl.style.background = background === true ? \"white\" : background || \"white\";\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_638c40e075f14636906bc3edc773aff0","spec":"","tabbable":null,"tables":{},"tooltip":null}},"c27de9e1d2a749648dfb7f36e07b3c90":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.mark._mark.Mark","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  legendContainerEl.style.padding = \"0.3em\";\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    targetEl.style.background = background === true ? \"white\" : background || \"white\";\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_900cc40e79ca427584b651c0a5edaf75","spec":"","tabbable":null,"tables":{},"tooltip":null}},"ec8bd6a35411442588c62aac4f1c4fc5":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"fdd45541e9b54ed095d135e37054d01d":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"fe4ced1276f14f17b163057dd875c015":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}}},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/meridianlabs-ai\.github\.io\/inspect_viz");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            trigger: 'click',
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            positionFixed: true,
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../../examples/inspect/scores-by-factor/index.html" class="pagination-link" aria-label="Scores by Factor">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Scores by Factor</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../../../examples/inspect/scores-timeline/index.html" class="pagination-link" aria-label="Scores Timeline">
        <span class="nav-page-text">Scores Timeline</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/">
<p>Meridian Labs</p>
</a>
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz">
<p>Code</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz/blob/main/LICENSE">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz/issues">
<p>Issues</p>
</a>
  </li>  
</ul>
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/meridianlabs-ai/inspect_viz/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz">
<p>Code</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>