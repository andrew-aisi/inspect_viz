<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-99.9.9">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sample Heatmap – Inspect Viz</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./components-plots.html" rel="next">
<link href="./view-sample-tool-calls.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-3aa970819e70fbc78806154e5a1fcd28.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-3ce9b6b5994d5f9c95269e9dba282a5b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>


<meta property="og:title" content="Inspect Viz">
<meta property="og:description" content="Data visualization for Inspect AI evalutions">
<meta property="og:image" content="https://meridianlabs-ai.github.io/inspect_viz/inspect_viz.png">
<meta property="og:site_name" content="Inspect Viz">
<meta property="og:image:height" content="1122">
<meta property="og:image:width" content="1620">
<meta name="twitter:title" content="Inspect Viz">
<meta name="twitter:description" content="Data visualization for Inspect AI evaluations.">
<meta name="twitter:image" content="https://meridianlabs-ai.github.io/inspect_viz/inspect_viz.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image-height" content="1122">
<meta name="twitter:image-width" content="1620">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Inspect Viz</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Getting Started</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./views.html"> 
<span class="menu-text">Views</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./components-plots.html"> 
<span class="menu-text">Components</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./publishing.html"> 
<span class="menu-text">Publishing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./reference/index.html"> 
<span class="menu-text">Reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./examples/index.html"> 
<span class="menu-text">Examples</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./views.html">Views</a></li><li class="breadcrumb-item"><a href="./view-sample-heatmap.html">Sample Heatmap</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true">
 <span class="menu-text">Getting Started</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./llm-assistance.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">LLM Assistance</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./views.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Views</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./view-scores-by-task.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores by Task</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./view-scores-by-model.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores by Model</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./view-scores-by-factor.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores by Factor</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./view-scores-by-limit.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores by Limit</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./view-scores-timeline.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores Timeline</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./view-scores-heatmap.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Scores Heatmap</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./view-sample-tool-calls.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sample Tool Calls</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./view-sample-heatmap.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Sample Heatmap</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true">
 <span class="menu-text">Components</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./components-plots.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Plots</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./components-marks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Marks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./components-links.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Links</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./components-tables.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tables</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./components-inputs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Inputs</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./components-interactivity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Interactivty</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./publishing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Publishing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./publishing-plots.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Plots</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./publishing-notebooks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Notebooks</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./publishing-websites.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Websites</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./publishing-dashboards.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Dashboards</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./publishing-png-output.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">PNG Output</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation">Data Preparation</a></li>
  <li><a href="#function-reference" id="toc-function-reference" class="nav-link" data-scroll-target="#function-reference">Function Reference</a></li>
  <li><a href="#implementation" id="toc-implementation" class="nav-link" data-scroll-target="#implementation">Implementation</a></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/meridianlabs-ai/inspect_viz/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./views.html">Views</a></li><li class="breadcrumb-item"><a href="./view-sample-heatmap.html">Sample Heatmap</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Sample Heatmap</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>The <span class="element-type-name ref-interlink"><a href="./reference/inspect_viz.view.html#sample_heatmap">sample_heatmap()</a></span>function renders a heatmap for viewing individual sample scores. Each sample is shown along one axis, models are shown along the other axis.</p>
<div id="aafed7f4" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz <span class="im">import</span> Data</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_viz.view.beta <span class="im">import</span> sample_heatmap</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>samples <span class="op">=</span> Data.from_file(<span class="st">"writing_bench_samples.parquet"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>sample_heatmap(</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  samples, </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  score_value<span class="op">=</span><span class="st">"score_multi_scorer_wrapper"</span>, </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  height<span class="op">=</span><span class="dv">200</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"62c7c13b83654e06ae0eeb4389e8658c","version_major":2,"version_minor":1,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
</section>
<section id="data-preparation" class="level2">
<h2 class="anchored" data-anchor-id="data-preparation">Data Preparation</h2>
<p>Above we read the data for the plot from a parquet file. This file was in turn created by:</p>
<ol type="1">
<li><p>Reading logs into a dataframe with <code>samples_df</code>, specifying the SampleSummaryColumns and the EvaalModel columns.</p></li>
<li><p>Using the <code>prepare()</code> function to <code>model_info()</code> and <code>log_viewer()</code> columns to the data frame.</p></li>
</ol>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_ai.analysis <span class="im">import</span> samples_df, log_viewer, model_info, prepare, EvalModel, SampleSummary</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> samples_df(<span class="st">"logs"</span>, columns<span class="op">=</span>SampleSummary <span class="op">+</span> EvalModel)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> prepare(df, </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    model_info(), </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    log_viewer(<span class="st">"sample"</span>, {<span class="st">"logs"</span>: <span class="st">"https://samples.meridianlabs.ai/"</span>}),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>df.to_parquet(<span class="st">"writing_bench_samples.parquet"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>If your samples are using non-numeric values (for example ‘C’ and ‘I’ to represent correct and incorrect), you can use the <code>score_to_float</code> prepare function in <code>inspect.analysis</code> to convert the score values to floats. For example:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect_ai.analysis <span class="im">import</span> samples_df, log_viewer, model_info, score_to_float, prepare, EvalModel, SampleSummary</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> samples_df(<span class="st">"logs"</span>, columns<span class="op">=</span>SampleSummary <span class="op">+</span> EvalModel)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> prepare(df, </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    model_info(), </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    log_viewer(<span class="st">"sample"</span>, {<span class="st">"logs"</span>: <span class="st">"https://samples.meridianlabs.ai/"</span>}),</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    score_to_float(<span class="st">"score_includes"</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>Note that both the log viewer links and model names are optional (the plot will render without links and use raw model strings if the data isn’t prepared with <code>log_viewer()</code> and <code>model_info()</code>).</p>
</section>
<section id="function-reference" class="level2" data-reference="sample_heatmap">
<h2 data-reference="sample_heatmap" class="anchored" data-anchor-id="function-reference">Function Reference</h2>
<p>Creates a heatmap plot of success rate of eval data.</p>
<div class="source-link">
<a href="https://github.com/meridianlabs-ai/inspect_viz/blob/96f6ba17a9211475b9f33f4fe7fdad9f0d881f0b/src/inspect_viz/view/beta/_sample_heatmap.py#L15">Source</a>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode python doc-declaration code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sample_heatmap(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    data: Data,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">id</span>: <span class="bu">str</span> <span class="op">=</span> <span class="st">"id"</span>,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    id_label: <span class="bu">str</span> <span class="op">|</span> <span class="va">None</span> <span class="op">|</span> NotGiven <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    model_name: <span class="bu">str</span> <span class="op">=</span> <span class="st">"model_display_name"</span>,</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    model_label: <span class="bu">str</span> <span class="op">|</span> <span class="va">None</span> <span class="op">|</span> NotGiven <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    score_value: <span class="bu">str</span> <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    cell: CellOptions <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    tip: <span class="bu">bool</span> <span class="op">=</span> <span class="va">True</span>,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    title: <span class="bu">str</span> <span class="op">|</span> Title <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    marks: Marks <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    height: <span class="bu">float</span> <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    width: <span class="bu">float</span> <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    legend: Legend <span class="op">|</span> NotGiven <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> NOT_GIVEN,</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    sort: Literal[<span class="st">"ascending"</span>, <span class="st">"descending"</span>] <span class="op">|</span> SortOrder <span class="op">|</span> <span class="va">None</span> <span class="op">=</span> <span class="st">"ascending"</span>,</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    orientation: Literal[<span class="st">"horizontal"</span>, <span class="st">"vertical"</span>] <span class="op">=</span> <span class="st">"horizontal"</span>,</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">**</span>attributes: Unpack[PlotAttributes],</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Component</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<dl>
<dt><code class="ref-definition">data</code> <span class="element-type"><span class="element-type-name"><a href="./reference/inspect_viz.html#data">Data</a></span></span></dt>
<dd>
<p>Evals data table.</p>
</dd>
<dt><code class="ref-definition">id</code> <span class="element-type"><span class="element-type-name">str</span></span></dt>
<dd>
<p>Name of column to use for displaying the sample id.</p>
</dd>
<dt><code class="ref-definition">id_label</code> <span class="element-type"><span class="element-type-name">str</span> | <span class="element-type-name">None</span> | <span class="element-type-name">NotGiven</span></span></dt>
<dd>
<p>x-axis label (defaults to None).</p>
</dd>
<dt><code class="ref-definition">model_name</code> <span class="element-type"><span class="element-type-name">str</span></span></dt>
<dd>
<p>Name of column to use for rows.</p>
</dd>
<dt><code class="ref-definition">model_label</code> <span class="element-type"><span class="element-type-name">str</span> | <span class="element-type-name">None</span> | <span class="element-type-name">NotGiven</span></span></dt>
<dd>
<p>y-axis label (defaults to None).</p>
</dd>
<dt><code class="ref-definition">score_value</code> <span class="element-type"><span class="element-type-name">str</span> | <span class="element-type-name">None</span></span></dt>
<dd>
<p>Name of the column to use as values to determine cell color.</p>
</dd>
<dt><code class="ref-definition">cell</code> <span class="element-type"><span class="element-type-name"><a href="./reference/inspect_viz.view.html#celloptions">CellOptions</a></span> | <span class="element-type-name">None</span></span></dt>
<dd>
<p>Options for the cell marks.</p>
</dd>
<dt><code class="ref-definition">tip</code> <span class="element-type"><span class="element-type-name">bool</span></span></dt>
<dd>
<p>Whether to show a tooltip with the value when hovering over a cell (defaults to True).</p>
</dd>
<dt><code class="ref-definition">title</code> <span class="element-type"><span class="element-type-name">str</span> | <span class="element-type-name"><a href="./reference/inspect_viz.mark.html#title">Title</a></span> | <span class="element-type-name">None</span></span></dt>
<dd>
<p>Title for plot (<code>str</code> or mark created with the <span class="element-type-name ref-interlink"><a href="./reference/inspect_viz.mark.html#title">title()</a></span> function)</p>
</dd>
<dt><code class="ref-definition">marks</code> <span class="element-type"><span class="element-type-name"><a href="./reference/inspect_viz.mark.html#marks">Marks</a></span> | <span class="element-type-name">None</span></span></dt>
<dd>
<p>Additional marks to include in the plot.</p>
</dd>
<dt><code class="ref-definition">height</code> <span class="element-type"><span class="element-type-name">float</span> | <span class="element-type-name">None</span></span></dt>
<dd>
<p>The outer height of the plot in pixels, including margins. The default is width / 1.618 (the <a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a>).</p>
</dd>
<dt><code class="ref-definition">width</code> <span class="element-type"><span class="element-type-name">float</span> | <span class="element-type-name">None</span></span></dt>
<dd>
<p>The outer width of the plot in pixels, including margins. Defaults to 700.</p>
</dd>
<dt><code class="ref-definition">legend</code> <span class="element-type"><span class="element-type-name"><a href="./reference/inspect_viz.plot.html#legend">Legend</a></span> | <span class="element-type-name">NotGiven</span> | <span class="element-type-name">None</span></span></dt>
<dd>
<p>Options for the legend. Pass None to disable the legend.</p>
</dd>
<dt><code class="ref-definition">sort</code> <span class="element-type"><span class="element-type-name">Literal</span>['ascending', 'descending'] | <span class="element-type-name">SortOrder</span> | <span class="element-type-name">None</span></span></dt>
<dd>
<p>Sort order for the x and y axes. If ascending, the highest values will be sorted to the top right. If descending, the highest values will appear in the bottom left. If None, no sorting is applied. If a SortOrder is provided, it will be used to sort the x and y axes.</p>
</dd>
<dt><code class="ref-definition">orientation</code> <span class="element-type"><span class="element-type-name">Literal</span>['horizontal', 'vertical']</span></dt>
<dd>
<p>The orientation of the heatmap. If “horizontal”, the tasks will be on the x-axis and models on the y-axis. If “vertical”, the tasks will be on the y-axis and models on the x-axis.</p>
</dd>
<dt><code class="ref-definition">**attributes</code> <span class="element-type"><span class="element-type-name">Unpack</span>[<span class="element-type-name"><a href="./reference/inspect_viz.plot.html#plotattributes">PlotAttributes</a></span>]</span></dt>
<dd>
<p>Additional `PlotAttributes</p>
</dd>
</dl>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>The <a href="./examples/inspect/sample-heatmap/index.html">Sample Heatmap</a> example demonstrates how this view was implemented using lower level plotting components.</p>


</section>

</main> <!-- /main -->
<script type="application/vnd.jupyter.widget-state+json">
{"state":{"362885b8805c4d9782c5a2cece527aeb":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.mark._mark.Mark","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  if (options.frameAnchor === \"bottom\" || options.frameAnchor === \"top\") {\n    legendContainerEl.style.padding = \"0 0.3em\";\n  } else {\n    legendContainerEl.style.padding = \"0.3em\";\n  }\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    const backgroundDefaultColor = \"var(--bs-body-bg, var(--jp-cell-editor-background, #ffffff))\";\n    targetEl.style.background = background === true ? backgroundDefaultColor : background || backgroundDefaultColor;\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_bd01a5a407664d389148d161333f37f6","spec":"","tabbable":null,"tables":{},"tooltip":null}},"45000effa7d8404484c29651d0bd36d6":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"4e7df9550006457bb1d881e2419698e7":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.mark._mark.Mark","_css":"\n\n.mosaic-widget fieldset {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n    border: none;\n    margin: 0;\n    padding: 0;\n}\n\n.mosaic-widget fieldset>label {\n    display: inline-flex;\n    align-items: center;\n    margin-bottom: 0;\n}\n\n.mosaic-widget fieldset>label>input[type=\"radio\"] {\n    margin-right: 0.25rem;\n}\n\n.mosaic-widget fieldset>legend {\n    font-size: inherit;\n    margin: 0;\n}\n\n.mosaic-widget {\n    margin-top: 10px;\n    margin-bottom: 0.5rem;\n}\n\n.mosaic-widget label {\n    display: inline-flex;\n    align-items: center;\n    white-space: nowrap;\n    margin-bottom: 10px;\n}\n\n.mosaic-widget label>select,\n.mosaic-widget .input-search,\n.mosaic-widget .ts-wrapper,\nlabel>input[type=\"range\"] {\n    margin-left: 0.25rem;\n    margin-right: 0.5rem;\n}\n\n.mosaic-widget .input-search {\n    width: 150px;\n}\n\n.mosaic-widget label>input[type=\"range\"] {\n    margin-right: 0.25rem;\n}\n\n.mosaic-widget div[style*=\"display: flex\"][style*=\"flex-flow: row\"] {\n    align-items: center !important;\n    /* or whatever you need */\n}\n\n\n.mosaic-widget .slider-input {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    margin-right: 0.5rem;\n}\n\n.mosaic-widget .slider-input label {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n.mosaic-widget .slider-input .noUi-target {\n    margin: 0;\n}\n\n.mosaic-widget .slider-input .slider-value {\n    margin: 0;\n    margin-bottom: 10px;\n}\n\n.vscode-dark .mosaic-widget {\n    color: rgb(52, 58, 64);\n}\n\n/* nouislider */\n\n.noUi-target,\n.noUi-target * {\n    -webkit-touch-callout: none;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-user-select: none;\n    -ms-touch-action: none;\n    touch-action: none;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box\n}\n\n.noUi-target {\n    position: relative\n}\n\n.noUi-base,\n.noUi-connects {\n    width: 100%;\n    height: 100%;\n    position: relative;\n    z-index: 1\n}\n\n.noUi-connects {\n    overflow: hidden;\n    z-index: 0\n}\n\n.noUi-connect,\n.noUi-origin {\n    will-change: transform;\n    position: absolute;\n    z-index: 1;\n    top: 0;\n    right: 0;\n    height: 100%;\n    width: 100%;\n    -ms-transform-origin: 0 0;\n    -webkit-transform-origin: 0 0;\n    -webkit-transform-style: preserve-3d;\n    transform-origin: 0 0;\n    transform-style: flat\n}\n\n.noUi-txt-dir-rtl.noUi-horizontal .noUi-origin {\n    left: 0;\n    right: auto\n}\n\n.noUi-vertical .noUi-origin {\n    top: -100%;\n    width: 0\n}\n\n.noUi-horizontal .noUi-origin {\n    height: 0\n}\n\n.noUi-handle {\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    position: absolute\n}\n\n.noUi-touch-area {\n    height: 100%;\n    width: 100%\n}\n\n.noUi-state-tap .noUi-connect,\n.noUi-state-tap .noUi-origin {\n    -webkit-transition: transform .3s;\n    transition: transform .3s\n}\n\n.noUi-state-drag * {\n    cursor: inherit !important\n}\n\n.noUi-horizontal {\n    height: 18px\n}\n\n.noUi-horizontal .noUi-handle {\n    width: 34px;\n    height: 28px;\n    right: -17px;\n    top: -6px\n}\n\n.noUi-vertical {\n    width: 18px\n}\n\n.noUi-vertical .noUi-handle {\n    width: 28px;\n    height: 34px;\n    right: -6px;\n    bottom: -17px\n}\n\n.noUi-txt-dir-rtl.noUi-horizontal .noUi-handle {\n    left: -17px;\n    right: auto\n}\n\n.noUi-target {\n    background: #FAFAFA;\n    border-radius: 4px;\n    border: 1px solid #D3D3D3;\n    box-shadow: inset 0 1px 1px #F0F0F0, 0 3px 6px -5px #BBB\n}\n\n.noUi-connects {\n    border-radius: 3px\n}\n\n.noUi-connect {\n    background: #3FB8AF\n}\n\n.noUi-draggable {\n    cursor: ew-resize\n}\n\n.noUi-vertical .noUi-draggable {\n    cursor: ns-resize\n}\n\n.noUi-handle {\n    border: 1px solid #D9D9D9;\n    border-radius: 3px;\n    background: #FFF;\n    cursor: default;\n    box-shadow: inset 0 0 1px #FFF, inset 0 1px 7px #EBEBEB, 0 3px 6px -3px #BBB\n}\n\n.noUi-active {\n    box-shadow: inset 0 0 1px #FFF, inset 0 1px 7px #DDD, 0 3px 6px -3px #BBB\n}\n\n.noUi-handle:after,\n.noUi-handle:before {\n    content: \"\";\n    display: block;\n    position: absolute;\n    height: 14px;\n    width: 1px;\n    background: #E8E7E6;\n    left: 14px;\n    top: 6px\n}\n\n.noUi-handle:after {\n    left: 17px\n}\n\n.noUi-vertical .noUi-handle:after,\n.noUi-vertical .noUi-handle:before {\n    width: 14px;\n    height: 1px;\n    left: 6px;\n    top: 14px\n}\n\n.noUi-vertical .noUi-handle:after {\n    top: 17px\n}\n\n[disabled] .noUi-connect {\n    background: #B8B8B8\n}\n\n[disabled] .noUi-handle,\n[disabled].noUi-handle,\n[disabled].noUi-target {\n    cursor: not-allowed\n}\n\n.noUi-pips,\n.noUi-pips * {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box\n}\n\n.noUi-pips {\n    position: absolute;\n    color: #999\n}\n\n.noUi-value {\n    position: absolute;\n    white-space: nowrap;\n    text-align: center\n}\n\n.noUi-value-sub {\n    color: #ccc;\n    font-size: 10px\n}\n\n.noUi-marker {\n    position: absolute;\n    background: #CCC\n}\n\n.noUi-marker-sub {\n    background: #AAA\n}\n\n.noUi-marker-large {\n    background: #AAA\n}\n\n.noUi-pips-horizontal {\n    padding: 10px 0;\n    height: 80px;\n    top: 100%;\n    left: 0;\n    width: 100%\n}\n\n.noUi-value-horizontal {\n    -webkit-transform: translate(-50%, 50%);\n    transform: translate(-50%, 50%)\n}\n\n.noUi-rtl .noUi-value-horizontal {\n    -webkit-transform: translate(50%, 50%);\n    transform: translate(50%, 50%)\n}\n\n.noUi-marker-horizontal.noUi-marker {\n    margin-left: -1px;\n    width: 2px;\n    height: 5px\n}\n\n.noUi-marker-horizontal.noUi-marker-sub {\n    height: 10px\n}\n\n.noUi-marker-horizontal.noUi-marker-large {\n    height: 15px\n}\n\n.noUi-pips-vertical {\n    padding: 0 10px;\n    height: 100%;\n    top: 0;\n    left: 100%\n}\n\n.noUi-value-vertical {\n    -webkit-transform: translate(0, -50%);\n    transform: translate(0, -50%);\n    padding-left: 25px\n}\n\n.noUi-rtl .noUi-value-vertical {\n    -webkit-transform: translate(0, 50%);\n    transform: translate(0, 50%)\n}\n\n.noUi-marker-vertical.noUi-marker {\n    width: 5px;\n    height: 2px;\n    margin-top: -1px\n}\n\n.noUi-marker-vertical.noUi-marker-sub {\n    width: 10px\n}\n\n.noUi-marker-vertical.noUi-marker-large {\n    width: 15px\n}\n\n.noUi-tooltip {\n    display: block;\n    position: absolute;\n    border: 1px solid #D9D9D9;\n    border-radius: 3px;\n    background: #fff;\n    color: #000;\n    padding: 5px;\n    text-align: center;\n    white-space: nowrap\n}\n\n.noUi-horizontal .noUi-tooltip {\n    -webkit-transform: translate(-50%, 0);\n    transform: translate(-50%, 0);\n    left: 50%;\n    bottom: 120%\n}\n\n.noUi-vertical .noUi-tooltip {\n    -webkit-transform: translate(0, -50%);\n    transform: translate(0, -50%);\n    top: 50%;\n    right: 120%\n}\n\n.noUi-horizontal .noUi-origin>.noUi-tooltip {\n    -webkit-transform: translate(50%, 0);\n    transform: translate(50%, 0);\n    left: auto;\n    bottom: 10px\n}\n\n.noUi-vertical .noUi-origin>.noUi-tooltip {\n    -webkit-transform: translate(0, -18px);\n    transform: translate(0, -18px);\n    top: auto;\n    right: 28px\n}\n\n.noUi-round {\n    height: 10px;\n}\n\n.noUi-round .noUi-connect {\n    background: #c0392b;\n}\n\n.noUi-round .noUi-handle {\n    height: 18px;\n    width: 18px;\n    top: -5px;\n    right: -9px;\n    /* half the width */\n    border-radius: 9px;\n}\n\n.bslib-sidebar-layout .collapse-toggle {\n    right: 0;\n}\n\n.toolbar {\n    row-gap: 0.7rem;\n}\n\n.panel-input {\n    display: inline-block;\n}\n\n#quarto-content .mosaic-widget {\n    margin-bottom: 1rem;\n}\n\n.toolbar .mosaic-widget,\n.panel-input .mosaic-widget,\n.card-toolbar .mosaic-widget,\n.toolbar .mosaic-widget label,\n.panel-input .mosaic-widget label,\n.card-toolbar .mosaic-widget label {\n    margin-top: 0;\n    margin-bottom: 0;\n}\n\n\n.mosaic-widget .sidebar-fullwidth {\n    margin-bottom: 0;\n}\n\n\n.sidebar .mosaic-widget fieldset>legend,\n.panel-sidebar .mosaic-widget fieldset>legend {\n    margin-bottom: 0.2rem;\n}\n\n.sidebar .mosaic-widget label>select,\n.panel-sidebar .mosaic-widget label>select,\n.sidebar .mosaic-widget .input-search,\n.panel-sidebar .mosaic-widget .input-search,\n.sidebar .mosaic-widget label>input[type=\"range\"],\n.panel-sidebar .mosaic-widget label>input[type=\"range\"],\n.panel-sidebar .mosaic-widget .ts-wrapper,\n.sidebar .mosaic-widget .ts-wrapper {\n    margin-left: 0;\n    margin-right: 0;\n}\n\n.panel-sidebar .mosaic-widget .sidebar-fullwidth,\n.sidebar .mosaic-widget .sidebar-fullwidth,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth>*,\n.sidebar .mosaic-widget .sidebar-fullwidth>*,\n.sidebar .mosaic-widget .sidebar-fullwidth .ts-wrapper,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .ts-wrapper,\n.sidebar .mosaic-widget .sidebar-fullwidth .slider-input,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .slider-input {\n    width: 100%;\n}\n\n.panel-sidebar .mosaic-widget .sidebar-fullwidth .noUi-target,\n.sidebar .mosaic-widget .sidebar-fullwidth .noUi-target {\n    width: 96% !important;\n}\n\n.sidebar .mosaic-widget fieldset,\n.panel-sidebar .mosaic-widget fieldset,\n.sidebar .mosaic-widget .sidebar-fullwidth label,\n.panel-sidebar .mosaic-widget .sidebar-fullwidth label,\n.sidebar .mosaic-widget .slider-input,\n.panel-sidebar .mosaic-widget .slider-input {\n    flex-direction: column;\n    align-items: flex-start;\n    gap: 0.1rem;\n}\n\n.mosaic-widget>div>div>label {\n    min-height: 40px;\n}\n\n.mosaic-widget .input-search {\n    padding: .375rem .75rem;\n    border: 1px solid var(--bs-border-color);\n    border-radius: var(--bs-border-radius);\n}\n\n/* remove small top and bottom margin when widgets appear in cards */\n.card-body .mosaic-widget {\n    margin: 0;\n}\n\n/* remove border from ag-grid wrapper (table) when in card */\n.card-body .mosaic-widget .ag-root-wrapper {\n    border: none;\n}\n\n.card-body .mosaic-widget .inspect-viz-table {\n    margin-top: 0;\n    height: 100%;\n}\n\n.mosaic-widget .inspect-viz-table {\n    --ag-foreground-color: var(--bs-body-color);\n    --ag-background-color: var(--bs-body-bg);\n    --ag-accent-color: var(--bs-primary);\n    --ag-font-family: var(--bs-font-sans-serif);\n    --ag-font-size: var(--bs-font-size-base);\n}\n\n.cell-output-display:not(.no-overflow-x) {\n    overflow-x: visible;\n}\n\n.ts-control {\n    border: 1px solid var(--bs-border-color);\n    border-radius: var(--bs-border-radius);\n    box-shadow: none;\n    box-sizing: border-box;\n    flex-wrap: wrap;\n    overflow: hidden;\n    padding: .375rem .75rem;\n    position: relative;\n    width: 100%;\n    z-index: 1\n}\n\n.ts-wrapper.multi.has-items .ts-control {\n    padding: calc(.375rem - 1px) .75rem calc(.375rem - 4px)\n}\n\n.full .ts-control {\n    background-color: var(--bs-body-bg)\n}\n\n.disabled .ts-control,\n.disabled .ts-control * {\n    cursor: default !important\n}\n\n.focus .ts-control {\n    box-shadow: none\n}\n\n.ts-control>* {\n    display: inline-block;\n    vertical-align: initial\n}\n\n.ts-wrapper.multi .ts-control>div {\n    background: #efefef;\n    border: 0 solid #dee2e6;\n    color: #343a40;\n    cursor: pointer;\n    margin: 0 3px 3px 0;\n    padding: 1px 5px\n}\n\n.ts-wrapper.multi .ts-control>div.active {\n    background: #0d6efd;\n    border: 0 solid transparent;\n    color: #fff\n}\n\n.ts-wrapper.multi.disabled .ts-control>div,\n.ts-wrapper.multi.disabled .ts-control>div.active {\n    background: #fff;\n    border: 0 solid #fff;\n    color: #878787\n}\n\n.ts-control>input {\n    background: none !important;\n    border: 0 !important;\n    box-shadow: none !important;\n    display: inline-block !important;\n    flex: 1 1 auto;\n    line-height: inherit !important;\n    margin: 0 !important;\n    max-height: none !important;\n    max-width: 100% !important;\n    min-height: 0 !important;\n    min-width: 7rem;\n    padding: 0 !important;\n    text-indent: 0 !important;\n    -webkit-user-select: auto !important;\n    -moz-user-select: auto !important;\n    -ms-user-select: auto !important;\n    user-select: auto !important\n}\n\n.ts-control>input::-ms-clear {\n    display: none\n}\n\n.ts-control>input:focus {\n    outline: none !important\n}\n\n.has-items .ts-control>input {\n    margin: 0 4px !important\n}\n\n.ts-control.rtl {\n    text-align: right\n}\n\n.ts-control.rtl.single .ts-control:after {\n    left: calc(.75rem + 5px);\n    right: auto\n}\n\n.ts-control.rtl .ts-control>input {\n    margin: 0 4px 0 -2px !important\n}\n\n.disabled .ts-control {\n    background-color: var(--bs-secondary-bg);\n    opacity: .5\n}\n\n.input-hidden .ts-control>input {\n    left: -10000px;\n    opacity: 0;\n    position: absolute\n}\n\n.ts-dropdown {\n    background: var(--bs-body-bg);\n    border: 1px solid #d0d0d0;\n    border-radius: 0 0 var(--bs-border-radius) var(--bs-border-radius);\n    border-top: 0;\n    box-shadow: 0 1px 3px rgba(0, 0, 0, .1);\n    box-sizing: border-box;\n    left: 0;\n    margin: .25rem 0 0;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 10\n}\n\n.ts-dropdown [data-selectable] {\n    cursor: pointer;\n    overflow: hidden\n}\n\n.ts-dropdown [data-selectable] .highlight {\n    background: rgba(255, 237, 40, .4);\n    border-radius: 1px\n}\n\n.ts-dropdown .create,\n.ts-dropdown .no-results,\n.ts-dropdown .optgroup-header,\n.ts-dropdown .option {\n    padding: 3px .75rem\n}\n\n.ts-dropdown .option,\n.ts-dropdown [data-disabled],\n.ts-dropdown [data-disabled] [data-selectable].option {\n    cursor: inherit;\n    opacity: .5\n}\n\n.ts-dropdown [data-selectable].option {\n    cursor: pointer;\n    opacity: 1\n}\n\n.ts-dropdown .optgroup:first-child .optgroup-header {\n    border-top: 0\n}\n\n.ts-dropdown .optgroup-header {\n    background: var(--bs-body-bg);\n    color: #6c757d;\n    cursor: default\n}\n\n.ts-dropdown .active {\n    background-color: var(--bs-tertiary-bg)\n}\n\n.ts-dropdown .active,\n.ts-dropdown .active.create {\n    color: var(--bs-body-color)\n}\n\n.ts-dropdown .create {\n    color: rgba(52, 58, 64, .5)\n}\n\n.ts-dropdown .spinner {\n    display: inline-block;\n    height: 30px;\n    margin: 3px .75rem;\n    width: 30px\n}\n\n.ts-dropdown .spinner:after {\n    animation: lds-dual-ring 1.2s linear infinite;\n    border-color: #d0d0d0 transparent;\n    border-radius: 50%;\n    border-style: solid;\n    border-width: 5px;\n    content: \" \";\n    display: block;\n    height: 24px;\n    margin: 3px;\n    width: 24px\n}\n\n@keyframes lds-dual-ring {\n    0% {\n        transform: rotate(0deg)\n    }\n\n    to {\n        transform: rotate(1turn)\n    }\n}\n\n.ts-dropdown-content {\n    max-height: 200px;\n    overflow: hidden auto;\n    scroll-behavior: smooth\n}\n\n.ts-wrapper.plugin-drag_drop .ts-dragging {\n    color: transparent !important\n}\n\n.ts-wrapper.plugin-drag_drop .ts-dragging>* {\n    visibility: hidden !important\n}\n\n.plugin-checkbox_options:not(.rtl) .option input {\n    margin-right: .5rem\n}\n\n.plugin-checkbox_options.rtl .option input {\n    margin-left: .5rem\n}\n\n.plugin-clear_button {\n    --ts-pr-clear-button: 1em\n}\n\n.plugin-clear_button .clear-button {\n    background: transparent !important;\n    cursor: pointer;\n    margin-right: 0 !important;\n    opacity: 0;\n    position: absolute;\n    right: calc(.75rem - 5px);\n    top: 50%;\n    transform: translateY(-50%);\n    transition: opacity .5s\n}\n\n.plugin-clear_button.form-select .clear-button,\n.plugin-clear_button.single .clear-button {\n    right: max(var(--ts-pr-caret), .75rem)\n}\n\n.plugin-clear_button.focus.has-items .clear-button,\n.plugin-clear_button:not(.disabled):hover.has-items .clear-button {\n    opacity: 1\n}\n\n.ts-wrapper .dropdown-header {\n    background: color-mix(var(--bs-body-bg), #d0d0d0, 85%);\n    border-bottom: 1px solid #d0d0d0;\n    border-radius: var(--bs-border-radius) var(--bs-border-radius) 0 0;\n    padding: 6px .75rem;\n    position: relative\n}\n\n.ts-wrapper .dropdown-header-close {\n    color: #343a40;\n    font-size: 20px !important;\n    line-height: 20px;\n    margin-top: -12px;\n    opacity: .4;\n    position: absolute;\n    right: .75rem;\n    top: 50%\n}\n\n.ts-wrapper .dropdown-header-close:hover {\n    color: #000\n}\n\n.plugin-dropdown_input.focus.dropdown-active .ts-control {\n    border: 1px solid var(--bs-border-color);\n    box-shadow: none;\n    box-shadow: var(--bs-box-shadow-inset)\n}\n\n.plugin-dropdown_input .dropdown-input {\n    background: transparent;\n    border: solid #d0d0d0;\n    border-width: 0 0 1px;\n    box-shadow: none;\n    display: block;\n    padding: .375rem .75rem;\n    width: 100%\n}\n\n.plugin-dropdown_input.focus .ts-dropdown .dropdown-input {\n    border-color: #86b7fe;\n    box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .25);\n    outline: 0\n}\n\n.plugin-dropdown_input .items-placeholder {\n    border: 0 !important;\n    box-shadow: none !important;\n    width: 100%\n}\n\n.plugin-dropdown_input.dropdown-active .items-placeholder,\n.plugin-dropdown_input.has-items .items-placeholder {\n    display: none !important\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items .ts-control>input {\n    min-width: 0\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input {\n    flex: none;\n    min-width: 4px\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input::-ms-input-placeholder {\n    color: transparent\n}\n\n.ts-wrapper.plugin-input_autogrow.has-items.focus .ts-control>input::placeholder {\n    color: transparent\n}\n\n.ts-dropdown.plugin-optgroup_columns .ts-dropdown-content {\n    display: flex\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup {\n    border-right: 1px solid #f2f2f2;\n    border-top: 0;\n    flex-basis: 0;\n    flex-grow: 1;\n    min-width: 0\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup:last-child {\n    border-right: 0\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup:before {\n    display: none\n}\n\n.ts-dropdown.plugin-optgroup_columns .optgroup-header {\n    border-top: 0\n}\n\n.ts-wrapper.plugin-remove_button .item {\n    align-items: center;\n    display: inline-flex\n}\n\n.ts-wrapper.plugin-remove_button .item .remove {\n    border-radius: 0 2px 2px 0;\n    box-sizing: border-box;\n    color: inherit;\n    display: inline-block;\n    padding: 0 5px;\n    text-decoration: none;\n    vertical-align: middle\n}\n\n.ts-wrapper.plugin-remove_button .item .remove:hover {\n    background: rgba(0, 0, 0, .05)\n}\n\n.ts-wrapper.plugin-remove_button.disabled .item .remove:hover {\n    background: none\n}\n\n.ts-wrapper.plugin-remove_button .remove-single {\n    font-size: 23px;\n    position: absolute;\n    right: 0;\n    top: 0\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item {\n    padding-right: 0 !important\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item .remove {\n    border-left: 1px solid #dee2e6;\n    margin-left: 5px\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl) .item.active .remove {\n    border-left-color: transparent\n}\n\n.ts-wrapper.plugin-remove_button:not(.rtl).disabled .item .remove {\n    border-left-color: #fff\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item {\n    padding-left: 0 !important\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item .remove {\n    border-right: 1px solid #dee2e6;\n    margin-right: 5px\n}\n\n.ts-wrapper.plugin-remove_button.rtl .item.active .remove {\n    border-right-color: transparent\n}\n\n.ts-wrapper.plugin-remove_button.rtl.disabled .item .remove {\n    border-right-color: #fff\n}\n\n:root {\n    --ts-pr-clear-button: 0px;\n    --ts-pr-caret: 0px;\n    --ts-pr-min: .75rem\n}\n\n.ts-wrapper.single .ts-control,\n.ts-wrapper.single .ts-control input {\n    cursor: pointer\n}\n\n.ts-control:not(.rtl) {\n    padding-right: max(var(--ts-pr-min), var(--ts-pr-clear-button) + var(--ts-pr-caret)) !important\n}\n\n.ts-control.rtl {\n    padding-left: max(var(--ts-pr-min), var(--ts-pr-clear-button) + var(--ts-pr-caret)) !important\n}\n\n.ts-wrapper {\n    position: relative\n}\n\n.ts-control,\n.ts-control input,\n.ts-dropdown {\n    color: #343a40;\n    font-family: inherit;\n    font-size: inherit;\n    line-height: 1.5\n}\n\n.ts-control,\n.ts-wrapper.single.input-active .ts-control {\n    background: var(--bs-body-bg);\n    cursor: text\n}\n\n.ts-hidden-accessible {\n    border: 0 !important;\n    clip: rect(0 0 0 0) !important;\n    -webkit-clip-path: inset(50%) !important;\n    clip-path: inset(50%) !important;\n    overflow: hidden !important;\n    padding: 0 !important;\n    position: absolute !important;\n    white-space: nowrap !important;\n    width: 1px !important\n}\n\n.ts-dropdown,\n.ts-dropdown.form-control,\n.ts-dropdown.form-select {\n    background: var(--bs-body-bg);\n    border: 1px solid var(--bs-border-color-translucent);\n    border-radius: .375rem;\n    box-shadow: 0 6px 12px rgba(0, 0, 0, .175);\n    height: auto;\n    padding: 0;\n    z-index: 1000\n}\n\n.ts-dropdown .optgroup-header {\n    font-size: .875rem;\n    line-height: 1.5\n}\n\n.ts-dropdown .optgroup:first-child:before {\n    display: none\n}\n\n.ts-dropdown .optgroup:before {\n    border-top: 1px solid var(--bs-border-color-translucent);\n    content: \" \";\n    display: block;\n    height: 0;\n    margin: .5rem -.75rem;\n    overflow: hidden\n}\n\n.ts-dropdown .create {\n    padding-left: .75rem\n}\n\n.ts-dropdown-content {\n    padding: 5px 0\n}\n\n.ts-control {\n    align-items: center;\n    display: flex;\n    transition: border-color .15s ease-in-out, box-shadow .15s ease-in-out\n}\n\n@media (prefers-reduced-motion:reduce) {\n    .ts-control {\n        transition: none\n    }\n}\n\n.focus .ts-control {\n    border-color: #86b7fe;\n    box-shadow: 0 0 0 .25rem rgba(13, 110, 253, .25);\n    outline: 0\n}\n\n.ts-control .item {\n    align-items: center;\n    display: flex\n}\n\n.ts-wrapper.is-invalid,\n.was-validated .invalid,\n.was-validated :invalid+.ts-wrapper {\n    border-color: var(--bs-form-invalid-color)\n}\n\n.ts-wrapper.is-invalid:not(.single),\n.was-validated .invalid:not(.single),\n.was-validated :invalid+.ts-wrapper:not(.single) {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3E%3Ccircle cx='6' cy='6' r='4.5'/%3E%3Cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3E%3Ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3E%3C/svg%3E\");\n    background-position: right calc(.375em + .1875rem) center;\n    background-repeat: no-repeat;\n    background-size: calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-invalid.single,\n.was-validated .invalid.single,\n.was-validated :invalid+.ts-wrapper.single {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\"), url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23dc3545' viewBox='0 0 12 12'%3E%3Ccircle cx='6' cy='6' r='4.5'/%3E%3Cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3E%3Ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3E%3C/svg%3E\");\n    background-position: right .75rem center, center right 2.25rem;\n    background-repeat: no-repeat;\n    background-size: 16px 12px, calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-invalid.focus .ts-control,\n.was-validated .invalid.focus .ts-control,\n.was-validated :invalid+.ts-wrapper.focus .ts-control {\n    border-color: var(--bs-form-invalid-color);\n    box-shadow: 0 0 0 .25rem rgba(var(--bs-form-invalid-color), .25)\n}\n\n.ts-wrapper.is-valid,\n.was-validated .valid,\n.was-validated :valid+.ts-wrapper {\n    border-color: var(--bs-form-valid-color)\n}\n\n.ts-wrapper.is-valid:not(.single),\n.was-validated .valid:not(.single),\n.was-validated :valid+.ts-wrapper:not(.single) {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23198754' d='M2.3 6.73.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1'/%3E%3C/svg%3E\");\n    background-position: right calc(.375em + .1875rem) center;\n    background-repeat: no-repeat;\n    background-size: calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-valid.single,\n.was-validated .valid.single,\n.was-validated :valid+.ts-wrapper.single {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\"), url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'%3E%3Cpath fill='%23198754' d='M2.3 6.73.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1'/%3E%3C/svg%3E\");\n    background-position: right .75rem center, center right 2.25rem;\n    background-repeat: no-repeat;\n    background-size: 16px 12px, calc(.75em + .375rem) calc(.75em + .375rem)\n}\n\n.ts-wrapper.is-valid.focus .ts-control,\n.was-validated .valid.focus .ts-control,\n.was-validated :valid+.ts-wrapper.focus .ts-control {\n    border-color: var(--bs-form-valid-color);\n    box-shadow: 0 0 0 .25rem rgba(var(--bs-form-valid-color), .25)\n}\n\n.ts-wrapper {\n    display: flex;\n    min-height: calc(1.5em + .75rem + var(--bs-border-width)*2)\n}\n\n.input-group-sm>.ts-wrapper,\n.ts-wrapper.form-control-sm,\n.ts-wrapper.form-select-sm {\n    min-height: calc(1.5em + .5rem + var(--bs-border-width)*2)\n}\n\n.input-group-sm>.ts-wrapper .ts-control,\n.ts-wrapper.form-control-sm .ts-control,\n.ts-wrapper.form-select-sm .ts-control {\n    border-radius: var(--bs-border-radius-sm);\n    font-size: .875rem\n}\n\n.input-group-sm>.ts-wrapper.has-items .ts-control,\n.ts-wrapper.form-control-sm.has-items .ts-control,\n.ts-wrapper.form-select-sm.has-items .ts-control {\n    font-size: .875rem;\n    padding-bottom: 0\n}\n\n.input-group-sm>.ts-wrapper.multi.has-items .ts-control,\n.ts-wrapper.form-control-sm.multi.has-items .ts-control,\n.ts-wrapper.form-select-sm.multi.has-items .ts-control {\n    padding-top: calc(.75em - .40625rem + var(--bs-border-width)*2/2 - (var(--bs-border-width) + 1px)*2/2) !important\n}\n\n.ts-wrapper.multi.has-items .ts-control {\n    padding-left: calc(.75rem - 5px);\n    --ts-pr-min: calc(0.75rem - 5px)\n}\n\n.ts-wrapper.multi .ts-control>div {\n    border-radius: calc(var(--bs-border-radius) - 1px)\n}\n\n.input-group-lg>.ts-wrapper,\n.ts-wrapper.form-control-lg,\n.ts-wrapper.form-select-lg {\n    min-height: calc(1.5em + 1rem + var(--bs-border-width)*2)\n}\n\n.input-group-lg>.ts-wrapper .ts-control,\n.ts-wrapper.form-control-lg .ts-control,\n.ts-wrapper.form-select-lg .ts-control {\n    border-radius: var(--bs-border-radius-lg);\n    font-size: 1.25rem\n}\n\n.ts-wrapper:not(.form-control, .form-select) {\n    background: none;\n    border: none;\n    box-shadow: none;\n    height: auto;\n    padding: 0\n}\n\n.ts-wrapper:not(.form-control, .form-select).single .ts-control {\n    background-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='m2 5 6 6 6-6'/%3E%3C/svg%3E\");\n    background-position: right .75rem center;\n    background-repeat: no-repeat;\n    background-size: 16px 12px\n}\n\n.ts-wrapper.form-select,\n.ts-wrapper.single {\n    --ts-pr-caret: 2.25rem\n}\n\n.ts-wrapper.form-control,\n.ts-wrapper.form-select {\n    box-shadow: none;\n    display: flex;\n    height: auto;\n    padding: 0 !important\n}\n\n.ts-wrapper.form-control .ts-control,\n.ts-wrapper.form-control.single.input-active .ts-control,\n.ts-wrapper.form-select .ts-control,\n.ts-wrapper.form-select.single.input-active .ts-control {\n    border: none !important\n}\n\n.ts-wrapper.form-control:not(.disabled) .ts-control,\n.ts-wrapper.form-control:not(.disabled).single.input-active .ts-control,\n.ts-wrapper.form-select:not(.disabled) .ts-control,\n.ts-wrapper.form-select:not(.disabled).single.input-active .ts-control {\n    background: transparent !important\n}\n\n.input-group>.ts-wrapper {\n    flex-grow: 1;\n    width: 1%\n}\n\n.input-group>.ts-wrapper:not(:nth-child(2))>.ts-control {\n    border-bottom-left-radius: 0;\n    border-top-left-radius: 0\n}\n\n.input-group>.ts-wrapper:not(:last-child)>.ts-control {\n    border-bottom-right-radius: 0;\n    border-top-right-radius: 0\n}\n\n.ts-wrapper.single {\n    cursor: pointer !important;\n}\n\n.ts-wrapper.single.input-active .ts-control {\n    cursor: pointer !important;\n}\n\n.ts-control {\n    min-width: 150px;\n}\n\n.ts-dropdown.single {\n    width: auto !important;\n    min-width: 150px !important;\n}\n\n.ts-control>input {\n    min-width: 5rem;\n}\n\n.inspect-viz-table {\n    width: 100%;\n    margin-top: 1em;\n    margin-bottom: 0.5em;\n}\n\n.header-center .ag-header-cell-label {\n    justify-content: center;\n}\n\n.header-left .ag-header-cell-label {\n    justify-content: left;\n}\n\n.header-right .ag-header-cell-label {\n    justify-content: right;\n}\n\n.header-justify .ag-header-cell-label {\n    justify-content: space-between;\n}\n\n/* This disables a hard coded min height fo ag-grid.\nThis is their recommended approach (!). See \nhttps://github.com/ag-grid/ag-grid/issues/4095 */\n.ag-layout-auto-height .ag-center-cols-container,\n.ag-layout-auto-height .ag-center-cols-viewport {\n    min-height: 0px !important;\n}\n\n.card-body .ag-column-last:after {\n    border: none !important;\n}\n\n.inspect-tip-container {\n  display: grid;\n  grid-template-columns: max-content auto;\n}\n\n/* Let each row be part of the parent grid */\n.inspect-tip-row {\n  display: contents;\n}\n\n/* Styling for striping */\n.inspect-tip-container > .inspect-tip-row:nth-child(even) > * {\n  background-color: var(--quarto-scss-export-table-striped-bg, var(--jp-cell-editor-active-background, #f7f7f7));\n}\n\n/* Optional padding & border */\n.inspect-tip-container > .inspect-tip-row > div:nth-child(1) {\n    padding-left: 0.5em;\n    padding-right: 0.5em;\n}\n\n.inspect-tip-container > .inspect-tip-row > div:nth-child(2) {\n    padding-right: 0.5em;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-color {\n    display: inline-block;\n    margin-left: 4px;\n    margin-right: 4px;\n    width: .5em;\n    height: .5em;\n    border-radius: 50%;;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-key {\n    font-size: 0.8em;\n    font-weight: 600;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.inspect-tip-container > .inspect-tip-row  .inspect-tip-value {\n    font-size: 0.8em;\n    padding-top: 5px;\n    padding-bottom: 5px;\n}\n\n.tippy-box[data-theme~='inspect'] {\n  background-color: var(--bs-body-bg, var(--jp-cell-editor-background, #ffffff));\n  color: var(--bs-body-color, var(--jp-content-font-color0, #000000));\n  filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.9));\n  min-width: 200px;\n}\n\n.tippy-box[data-theme~='inspect'] .tippy-content {\n  padding: 0 !important;\n}\n\n.tippy-box[data-theme~='inspect'] .tippy-arrow:before {\n  color: var(--bs-body-bg, var(--jp-cell-editor-background, #ffffff));\n  filter: drop-shadow(3 1px 1px rgba(0, 0, 0, 0.9));\n  transform: translateY(1.5px); /* Move arrow down to reduce overlap */\n}\n\n\n\n.legend-container {\n    display: flex;\n    flex-direction: column;\n    gap: 0.5em;\n}\n\n.legend-container.top,\n.legend-container.bottom\n {\n    flex-direction: row;\n}\n\ndiv.legend > div {\n    margin-bottom: 0 !important;\n}","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  if (options.frameAnchor === \"bottom\" || options.frameAnchor === \"top\") {\n    legendContainerEl.style.padding = \"0 0.3em\";\n  } else {\n    legendContainerEl.style.padding = \"0.3em\";\n  }\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    const backgroundDefaultColor = \"var(--bs-body-bg, var(--jp-cell-editor-background, #ffffff))\";\n    targetEl.style.background = background === true ? backgroundDefaultColor : background || backgroundDefaultColor;\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_45000effa7d8404484c29651d0bd36d6","spec":"","tabbable":null,"tables":{},"tooltip":null}},"62c7c13b83654e06ae0eeb4389e8658c":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  if (options.frameAnchor === \"bottom\" || options.frameAnchor === \"top\") {\n    legendContainerEl.style.padding = \"0 0.3em\";\n  } else {\n    legendContainerEl.style.padding = \"0.3em\";\n  }\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    const backgroundDefaultColor = \"var(--bs-body-bg, var(--jp-cell-editor-background, #ffffff))\";\n    targetEl.style.background = background === true ? backgroundDefaultColor : background || backgroundDefaultColor;\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_9dca8ca926c94032924dd6d15415597b","spec":"{\"hconcat\":[{\"plot\":[{\"mark\":\"cell\",\"data\":{\"from\":\"FbHhkBZ5eKApgB5szabsAh\",\"filterBy\":\"$selection_FbHhkBZ5eKApgB5szabsAh\"},\"x\":{\"column\":\"id\"},\"y\":{\"column\":\"model_display_name\"},\"inset\":1,\"tip\":{\"lineWidth\":1000000000},\"fill\":{\"avg\":\"score_multi_scorer_wrapper\"},\"sort\":{\"y\":{\"value\":\"fill\",\"reduce\":\"sum\",\"reverse\":true},\"x\":{\"value\":\"fill\",\"reduce\":\"sum\",\"reverse\":false}},\"channels\":{\"Sample Id\":\"id\",\"Model\":\"model_display_name\",\"Log Viewer\":\"log_viewer\",\"_user_channels\":[\"{\\\"Sample Id\\\": \\\"id\\\", \\\"Model\\\": \\\"model_display_name\\\", \\\"Log Viewer\\\": \\\"log_viewer\\\"}\"]}},{\"mark\":\"text\",\"data\":{\"from\":\"FbHhkBZ5eKApgB5szabsAh\",\"filterBy\":\"$selection_FbHhkBZ5eKApgB5szabsAh\"},\"x\":{\"column\":\"id\"},\"y\":{\"column\":\"model_display_name\"},\"text\":{\"avg\":\"score_multi_scorer_wrapper\"},\"fontWeight\":600,\"fill\":null}],\"xLabel\":null,\"yLabel\":null,\"width\":768,\"height\":200,\"xTickRotate\":45,\"marginBottom\":75,\"colorScale\":\"linear\",\"xScale\":\"band\",\"padding\":0,\"colorScheme\":\"purples\",\"colorDomain\":[5.2,9.0],\"marginLeft\":120,\"name\":\"plot_DQSXe2HNch55sMceBPr5GH\"},{\"legend\":\"color\",\"width\":370,\"_inset\":null,\"_inset_x\":null,\"_inset_y\":null,\"_border\":false,\"_background\":false,\"_frame_anchor\":\"bottom\",\"for\":\"plot_DQSXe2HNch55sMceBPr5GH\"}],\"plotDefaults\":{\"width\":700,\"height\":450},\"params\":{\"selection_FbHhkBZ5eKApgB5szabsAh\":{\"select\":\"intersect\"}}}","tabbable":null,"tables":{"FbHhkBZ5eKApgB5szabsAh":"/////1AUAAAQAAAAAAAKAA4ABgAFAAgACgAAAAABBAAQAAAAAAAKAAwAAAAEAAgACgAAAJAOAAAEAAAAAQAAAAwAAAAIAAwABAAIAAgAAABoDgAABAAAAFoOAAB7ImluZGV4X2NvbHVtbnMiOiBbeyJraW5kIjogInJhbmdlIiwgIm5hbWUiOiBudWxsLCAic3RhcnQiOiAwLCAic3RvcCI6IDEwMCwgInN0ZXAiOiAxfV0sICJjb2x1bW5faW5kZXhlcyI6IFt7Im5hbWUiOiBudWxsLCAiZmllbGRfbmFtZSI6IG51bGwsICJwYW5kYXNfdHlwZSI6ICJ1bmljb2RlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogeyJlbmNvZGluZyI6ICJVVEYtOCJ9fV0sICJjb2x1bW5zIjogW3sibmFtZSI6ICJzYW1wbGVfaWQiLCAiZmllbGRfbmFtZSI6ICJzYW1wbGVfaWQiLCAicGFuZGFzX3R5cGUiOiAib2JqZWN0IiwgIm51bXB5X3R5cGUiOiAic3RyaW5nIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJldmFsX2lkIiwgImZpZWxkX25hbWUiOiAiZXZhbF9pZCIsICJwYW5kYXNfdHlwZSI6ICJvYmplY3QiLCAibnVtcHlfdHlwZSI6ICJzdHJpbmciLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogIm1vZGVsIiwgImZpZWxkX25hbWUiOiAibW9kZWwiLCAicGFuZGFzX3R5cGUiOiAib2JqZWN0IiwgIm51bXB5X3R5cGUiOiAic3RyaW5nIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJtb2RlbF9iYXNlX3VybCIsICJmaWVsZF9uYW1lIjogIm1vZGVsX2Jhc2VfdXJsIiwgInBhbmRhc190eXBlIjogIm9iamVjdCIsICJudW1weV90eXBlIjogInN0cmluZyIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAibW9kZWxfYXJncyIsICJmaWVsZF9uYW1lIjogIm1vZGVsX2FyZ3MiLCAicGFuZGFzX3R5cGUiOiAib2JqZWN0IiwgIm51bXB5X3R5cGUiOiAic3RyaW5nIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJtb2RlbF9nZW5lcmF0ZV9jb25maWciLCAiZmllbGRfbmFtZSI6ICJtb2RlbF9nZW5lcmF0ZV9jb25maWciLCAicGFuZGFzX3R5cGUiOiAib2JqZWN0IiwgIm51bXB5X3R5cGUiOiAic3RyaW5nIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJtb2RlbF9yb2xlcyIsICJmaWVsZF9uYW1lIjogIm1vZGVsX3JvbGVzIiwgInBhbmRhc190eXBlIjogIm9iamVjdCIsICJudW1weV90eXBlIjogInN0cmluZyIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAibG9nIiwgImZpZWxkX25hbWUiOiAibG9nIiwgInBhbmRhc190eXBlIjogIm9iamVjdCIsICJudW1weV90eXBlIjogInN0cmluZyIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAiaWQiLCAiZmllbGRfbmFtZSI6ICJpZCIsICJwYW5kYXNfdHlwZSI6ICJvYmplY3QiLCAibnVtcHlfdHlwZSI6ICJzdHJpbmciLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogImVwb2NoIiwgImZpZWxkX25hbWUiOiAiZXBvY2giLCAicGFuZGFzX3R5cGUiOiAiaW50NjQiLCAibnVtcHlfdHlwZSI6ICJpbnQ2NFtweWFycm93XSIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAiaW5wdXQiLCAiZmllbGRfbmFtZSI6ICJpbnB1dCIsICJwYW5kYXNfdHlwZSI6ICJvYmplY3QiLCAibnVtcHlfdHlwZSI6ICJzdHJpbmciLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogInRhcmdldCIsICJmaWVsZF9uYW1lIjogInRhcmdldCIsICJwYW5kYXNfdHlwZSI6ICJvYmplY3QiLCAibnVtcHlfdHlwZSI6ICJzdHJpbmciLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogIm1ldGFkYXRhX2RvbWFpbjEiLCAiZmllbGRfbmFtZSI6ICJtZXRhZGF0YV9kb21haW4xIiwgInBhbmRhc190eXBlIjogIm9iamVjdCIsICJudW1weV90eXBlIjogInN0cmluZyIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAibWV0YWRhdGFfZG9tYWluMiIsICJmaWVsZF9uYW1lIjogIm1ldGFkYXRhX2RvbWFpbjIiLCAicGFuZGFzX3R5cGUiOiAib2JqZWN0IiwgIm51bXB5X3R5cGUiOiAic3RyaW5nIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJzY29yZV9tdWx0aV9zY29yZXJfd3JhcHBlciIsICJmaWVsZF9uYW1lIjogInNjb3JlX211bHRpX3Njb3Jlcl93cmFwcGVyIiwgInBhbmRhc190eXBlIjogImZsb2F0NjQiLCAibnVtcHlfdHlwZSI6ICJkb3VibGVbcHlhcnJvd10iLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogIm1vZGVsX3VzYWdlIiwgImZpZWxkX25hbWUiOiAibW9kZWxfdXNhZ2UiLCAicGFuZGFzX3R5cGUiOiAib2JqZWN0IiwgIm51bXB5X3R5cGUiOiAic3RyaW5nIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJ0b3RhbF90aW1lIiwgImZpZWxkX25hbWUiOiAidG90YWxfdGltZSIsICJwYW5kYXNfdHlwZSI6ICJmbG9hdDY0IiwgIm51bXB5X3R5cGUiOiAiZG91YmxlW3B5YXJyb3ddIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJ3b3JraW5nX3RpbWUiLCAiZmllbGRfbmFtZSI6ICJ3b3JraW5nX3RpbWUiLCAicGFuZGFzX3R5cGUiOiAiZmxvYXQ2NCIsICJudW1weV90eXBlIjogImRvdWJsZVtweWFycm93XSIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAiZXJyb3IiLCAiZmllbGRfbmFtZSI6ICJlcnJvciIsICJwYW5kYXNfdHlwZSI6ICJvYmplY3QiLCAibnVtcHlfdHlwZSI6ICJzdHJpbmciLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogImxpbWl0IiwgImZpZWxkX25hbWUiOiAibGltaXQiLCAicGFuZGFzX3R5cGUiOiAib2JqZWN0IiwgIm51bXB5X3R5cGUiOiAic3RyaW5nIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJyZXRyaWVzIiwgImZpZWxkX25hbWUiOiAicmV0cmllcyIsICJwYW5kYXNfdHlwZSI6ICJpbnQ2NCIsICJudW1weV90eXBlIjogImludDY0W3B5YXJyb3ddIiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJtb2RlbF9vcmdhbml6YXRpb25fbmFtZSIsICJmaWVsZF9uYW1lIjogIm1vZGVsX29yZ2FuaXphdGlvbl9uYW1lIiwgInBhbmRhc190eXBlIjogInVuaWNvZGUiLCAibnVtcHlfdHlwZSI6ICJvYmplY3QiLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogIm1vZGVsX2Rpc3BsYXlfbmFtZSIsICJmaWVsZF9uYW1lIjogIm1vZGVsX2Rpc3BsYXlfbmFtZSIsICJwYW5kYXNfdHlwZSI6ICJ1bmljb2RlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJtb2RlbF9zbmFwc2hvdCIsICJmaWVsZF9uYW1lIjogIm1vZGVsX3NuYXBzaG90IiwgInBhbmRhc190eXBlIjogInVuaWNvZGUiLCAibnVtcHlfdHlwZSI6ICJvYmplY3QiLCAibWV0YWRhdGEiOiBudWxsfSwgeyJuYW1lIjogIm1vZGVsX3JlbGVhc2VfZGF0ZSIsICJmaWVsZF9uYW1lIjogIm1vZGVsX3JlbGVhc2VfZGF0ZSIsICJwYW5kYXNfdHlwZSI6ICJkYXRlIiwgIm51bXB5X3R5cGUiOiAib2JqZWN0IiwgIm1ldGFkYXRhIjogbnVsbH0sIHsibmFtZSI6ICJtb2RlbF9rbm93bGVkZ2VfY3V0b2ZmX2RhdGUiLCAiZmllbGRfbmFtZSI6ICJtb2RlbF9rbm93bGVkZ2VfY3V0b2ZmX2RhdGUiLCAicGFuZGFzX3R5cGUiOiAiZGF0ZSIsICJudW1weV90eXBlIjogIm9iamVjdCIsICJtZXRhZGF0YSI6IG51bGx9LCB7Im5hbWUiOiAibG9nX3ZpZXdlciIsICJmaWVsZF9uYW1lIjogImxvZ192aWV3ZXIiLCAicGFuZGFzX3R5cGUiOiAidW5pY29kZSIsICJudW1weV90eXBlIjogIm9iamVjdCIsICJtZXRhZGF0YSI6IG51bGx9XSwgImNyZWF0b3IiOiB7ImxpYnJhcnkiOiAicHlhcnJvdyIsICJ2ZXJzaW9uIjogIjIwLjAuMCJ9LCAicGFuZGFzX3ZlcnNpb24iOiAiMi4zLjAifQAABgAAAHBhbmRhcwAAGwAAAFwFAAAgBQAA9AQAAMAEAACQBAAAVAQAACQEAAD8AwAA1AMAAJgDAABsAwAAQAMAAAgDAADQAgAAhAIAAFQCAAAgAgAA6AEAALwBAACQAQAAXAEAACABAADoAAAAtAAAAHgAAAA0AAAABAAAACD7//8AAAEFEAAAABwAAAAEAAAAAAAAAAoAAABsb2dfdmlld2VyAAAQ+///TPv//wAAAQgQAAAALAAAAAQAAAAAAAAAGwAAAG1vZGVsX2tub3dsZWRnZV9jdXRvZmZfZGF0ZQDa/f//AAAAAIz7//8AAAEIEAAAACQAAAAEAAAAAAAAABIAAABtb2RlbF9yZWxlYXNlX2RhdGUAABL+//8AAAAAxPv//wAAAQUQAAAAIAAAAAQAAAAAAAAADgAAAG1vZGVsX3NuYXBzaG90AAC4+///9Pv//wAAAQUQAAAAJAAAAAQAAAAAAAAAEgAAAG1vZGVsX2Rpc3BsYXlfbmFtZQAA7Pv//yj8//8AAAEFEAAAACgAAAAEAAAAAAAAABcAAABtb2RlbF9vcmdhbml6YXRpb25fbmFtZQAk/P//YPz//wAAAQIQAAAAGAAAAAQAAAAAAAAABwAAAHJldHJpZXMA8P3//wAAAAFAAAAAkPz//wAAARQQAAAAGAAAAAQAAAAAAAAABQAAAGxpbWl0AAAAfPz//7j8//8AAAEUEAAAABgAAAAEAAAAAAAAAAUAAABlcnJvcgAAAKT8///g/P//AAABAxAAAAAgAAAABAAAAAAAAAAMAAAAd29ya2luZ190aW1lAAAAAGL///8AAAIAFP3//wAAAQMQAAAAHAAAAAQAAAAAAAAACgAAAHRvdGFsX3RpbWUAAJL///8AAAIARP3//wAAARQQAAAAHAAAAAQAAAAAAAAACwAAAG1vZGVsX3VzYWdlADT9//9w/f//AAABAxAAAAA0AAAABAAAAAAAAAAaAAAAc2NvcmVfbXVsdGlfc2NvcmVyX3dyYXBwZXIAAAAABgAIAAYABgAAAAAAAgC4/f//AAABFBAAAAAkAAAABAAAAAAAAAAQAAAAbWV0YWRhdGFfZG9tYWluMgAAAACw/f//7P3//wAAARQQAAAAJAAAAAQAAAAAAAAAEAAAAG1ldGFkYXRhX2RvbWFpbjEAAAAA5P3//yD+//8AAAEUEAAAABgAAAAEAAAAAAAAAAYAAAB0YXJnZXQAAAz+//9I/v//AAABFBAAAAAYAAAABAAAAAAAAAAFAAAAaW5wdXQAAAA0/v//cP7//wAAAQIQAAAAIAAAAAQAAAAAAAAABQAAAGVwb2NoAAAACAAMAAgABwAIAAAAAAAAAUAAAACo/v//AAABFBAAAAAUAAAABAAAAAAAAAACAAAAaWQAAJD+///M/v//AAABFBAAAAAUAAAABAAAAAAAAAADAAAAbG9nALT+///w/v//AAABFBAAAAAcAAAABAAAAAAAAAALAAAAbW9kZWxfcm9sZXMA4P7//xz///8AAAEUEAAAACgAAAAEAAAAAAAAABUAAABtb2RlbF9nZW5lcmF0ZV9jb25maWcAAAAY////VP///wAAARQQAAAAHAAAAAQAAAAAAAAACgAAAG1vZGVsX2FyZ3MAAET///+A////AAABFBAAAAAgAAAABAAAAAAAAAAOAAAAbW9kZWxfYmFzZV91cmwAAHT///+w////AAABFBAAAAAYAAAABAAAAAAAAAAFAAAAbW9kZWwAAACc////2P///wAAARQQAAAAGAAAAAQAAAAAAAAABwAAAGV2YWxfaWQAxP///xAAFAAIAAYABwAMAAAAEAAQAAAAAAABFBAAAAAgAAAABAAAAAAAAAAJAAAAc2FtcGxlX2lkAAAABAAEAAQAAAAAAAAA/////6gGAAAUAAAAAAAAAAwAFgAGAAUACAAMAAwAAAAAAwQAGAAAAMA2CQAAAAAAAAAKABgADAAEAAgACgAAALwEAAAQAAAAZAAAAAAAAAAAAAAASgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgDAAAAAAAAKAMAAAAAAACYCAAAAAAAAMALAAAAAAAAAAAAAAAAAADACwAAAAAAACgDAAAAAAAA6A4AAAAAAACYCAAAAAAAAIAXAAAAAAAAAAAAAAAAAACAFwAAAAAAACgDAAAAAAAAqBoAAAAAAABHCQAAAAAAAPAjAAAAAAAADQAAAAAAAAAAJAAAAAAAACgDAAAAAAAAKCcAAAAAAAAAAAAAAAAAACgnAAAAAAAADQAAAAAAAAA4JwAAAAAAACgDAAAAAAAAYCoAAAAAAAAAAAAAAAAAAGAqAAAAAAAAAAAAAAAAAABgKgAAAAAAACgDAAAAAAAAiC0AAAAAAADIAAAAAAAAAFAuAAAAAAAAAAAAAAAAAABQLgAAAAAAACgDAAAAAAAAeDEAAAAAAADIAAAAAAAAAEAyAAAAAAAAAAAAAAAAAABAMgAAAAAAACgDAAAAAAAAaDUAAAAAAACAVwAAAAAAAOiMAAAAAAAAAAAAAAAAAADojAAAAAAAACgDAAAAAAAAEJAAAAAAAACkAAAAAAAAALiQAAAAAAAAAAAAAAAAAAC4kAAAAAAAACADAAAAAAAA2JMAAAAAAAAAAAAAAAAAANiTAAAAAAAAKAMAAAAAAAAAlwAAAAAAAIysBwAAAAAAkEMIAAAAAAAAAAAAAAAAAJBDCAAAAAAAKAMAAAAAAAC4RggAAAAAAAAAAAAAAAAAuEYIAAAAAAAAAAAAAAAAALhGCAAAAAAAKAMAAAAAAADgSQgAAAAAAJgIAAAAAAAAeFIIAAAAAAAAAAAAAAAAAHhSCAAAAAAAKAMAAAAAAACgVQgAAAAAAJwEAAAAAAAAQFoIAAAAAAAAAAAAAAAAAEBaCAAAAAAAIAMAAAAAAABgXQgAAAAAAAAAAAAAAAAAYF0IAAAAAAAoAwAAAAAAAIhgCAAAAAAABn4AAAAAAACQ3ggAAAAAAAAAAAAAAAAAkN4IAAAAAAAgAwAAAAAAALDhCAAAAAAAAAAAAAAAAACw4QgAAAAAACADAAAAAAAA0OQIAAAAAAAAAAAAAAAAANDkCAAAAAAAKAMAAAAAAAD45wgAAAAAAAAAAAAAAAAA+OcIAAAAAAANAAAAAAAAAAjoCAAAAAAAKAMAAAAAAAAw6wgAAAAAAAAAAAAAAAAAMOsIAAAAAAAAAAAAAAAAADDrCAAAAAAAIAMAAAAAAABQ7ggAAAAAAAAAAAAAAAAAUO4IAAAAAACUAQAAAAAAAOjvCAAAAAAA7gIAAAAAAADY8ggAAAAAAAAAAAAAAAAA2PIIAAAAAACUAQAAAAAAAHD0CAAAAAAAMwQAAAAAAACo+AgAAAAAAA0AAAAAAAAAuPgIAAAAAACUAQAAAAAAAFD6CAAAAAAAkAEAAAAAAADg+wgAAAAAAAAAAAAAAAAA4PsIAAAAAACQAQAAAAAAAHD9CAAAAAAAAAAAAAAAAABw/QgAAAAAAJABAAAAAAAAAP8IAAAAAAAAAAAAAAAAAAD/CAAAAAAAlAEAAAAAAACYAAkAAAAAACg2AAAAAAAAAAAAABsAAABkAAAAAAAAAAAAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAAAAAABkAAAAAAAAAGQAAAAAAAAAZAAAAAAAAABkAAAAAAAAAGQAAAAAAAAAAAAAAAAAAABkAAAAAAAAAAAAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAAAAAABkAAAAAAAAAAAAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAAAAAABkAAAAAAAAAAAAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAAAAAABkAAAAAAAAAAAAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAAAAAABkAAAAAAAAAAAAAAAAAAAAZAAAAAAAAABkAAAAAAAAAGQAAAAAAAAAAAAAAAAAAABkAAAAAAAAAAAAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAMgAAAAAAAABkAAAAAAAAAAAAAAAAAAAAZAAAAAAAAAAAAAAAAAAAAGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAAAAAAAALAAAAAAAAABCAAAAAAAAAFgAAAAAAAAAbgAAAAAAAACEAAAAAAAAAJoAAAAAAAAAsAAAAAAAAADGAAAAAAAAANwAAAAAAAAA8gAAAAAAAAAIAQAAAAAAAB4BAAAAAAAANAEAAAAAAABKAQAAAAAAAGABAAAAAAAAdgEAAAAAAACMAQAAAAAAAKIBAAAAAAAAuAEAAAAAAADOAQAAAAAAAOQBAAAAAAAA+gEAAAAAAAAQAgAAAAAAACYCAAAAAAAAPAIAAAAAAABSAgAAAAAAAGgCAAAAAAAAfgIAAAAAAACUAgAAAAAAAKoCAAAAAAAAwAIAAAAAAADWAgAAAAAAAOwCAAAAAAAAAgMAAAAAAAAYAwAAAAAAAC4DAAAAAAAARAMAAAAAAABaAwAAAAAAAHADAAAAAAAAhgMAAAAAAACcAwAAAAAAALIDAAAAAAAAyAMAAAAAAADeAwAAAAAAAPQDAAAAAAAACgQAAAAAAAAgBAAAAAAAADYEAAAAAAAATAQAAAAAAABiBAAAAAAAAHgEAAAAAAAAjgQAAAAAAACkBAAAAAAAALoEAAAAAAAA0AQAAAAAAADmBAAAAAAAAPwEAAAAAAAAEgUAAAAAAAAoBQAAAAAAAD4FAAAAAAAAVAUAAAAAAABqBQAAAAAAAIAFAAAAAAAAlgUAAAAAAACsBQAAAAAAAMIFAAAAAAAA2AUAAAAAAADuBQAAAAAAAAQGAAAAAAAAGgYAAAAAAAAwBgAAAAAAAEYGAAAAAAAAXAYAAAAAAAByBgAAAAAAAIgGAAAAAAAAngYAAAAAAAC0BgAAAAAAAMoGAAAAAAAA4AYAAAAAAAD2BgAAAAAAAAwHAAAAAAAAIgcAAAAAAAA4BwAAAAAAAE4HAAAAAAAAZAcAAAAAAAB6BwAAAAAAAJAHAAAAAAAApgcAAAAAAAC8BwAAAAAAANIHAAAAAAAA6AcAAAAAAAD+BwAAAAAAABQIAAAAAAAAKggAAAAAAABACAAAAAAAAFYIAAAAAAAAbAgAAAAAAACCCAAAAAAAAJgIAAAAAAAAVVRSR3RwUVZMbm9MNnZVVFBic2JURWZoZEU4RkFiR25TQk1DNUpCUDVqUjNLZVh0czVxaUNTd2YzVjdhSllkQnF2TUVpVDZIRUd5eE41Q1ZZYnVzM1dKbWFHNTJROTVCUVUyajJCVXVqTVU2b0szaEZRM3FYV2NNUXF1eHdNTlFNWWQ3WnRaRzVVdXZRU0RLZ2JZcHNDS0RZN284bzdhTGNVcXJuVFpDRW9rZm1zdjdRZXlQVVp1Y25UczRjZXdNOGtTbnBaYkZCSFhZNnhWcmFHWXZzS1BISGF6Tm5BTUxXbWtEd1I4S2tuSHlRdjdjVDM2N0c1eUtmWkJtdjVoWldTOFh3OXk3UVFZbWZjZmtSRzhpd0pteXhnUzJ3ejlFSzl2ZzRRVGRwWXdZekg2eG85YVNacmJ6RVF1NE1jbmhyRTJYMkphWEZVbmFadzlQUnJ4a2p2SGVDbWl2U1dxVkpoVGhGRkxNYnlrZDdIMnJDTmU0cHYyWkZjSzhyNFFrQjJaaXlIQ0JjbmkzbnNORmlYenNEWHF3M1RUaEhtSEJidFBFTEZvcTRUd2NLYXd2TFhjbXpaRWJCdnBzZ3F3VzljNGdTNjduZnZlTVZhS215N1NhSHFWcVRuNUIzNFc1SzNkUzlxeThyQXNGMk02REJTS0xkUlpwUGVhS1BSQWZyUERXYnZXZnlIUFM3OHFERmEyUnBuOVdhQzNndlNnYjdjM3J6aUxXdFBqZ3oyOGJFcDhBV25FYXZuellBQTYzTVp6RFVyYzZGTXNUQzNqWjZmU2FiYlZwazJpZTlUMzVjaW9xc1pMUzQ5Rm1qWkc0WW0yd05nRXZwZHZqNWMyWFZSTEtxblZIS3Q1OW1RRXNHMlZDa2Y2RlpLYXNYdG5peU5CaDZnZ3c0cUd1ZW9NSFBQY3BFVmc5WFU2UWVNV1NQVzVNRlJLWkU2ODNVRzVyTmNUbWZjVlBoOXNYd2RxZmRBQnFNWGF3dDJWSkNyTUtwWkt6ejVFNmdUbWo1N1o0TEQzZnhRWjJRdU1aQUVLSERpenR5amMyWkhhc1NWU2h5bnRwR0Y4Ym9OSDZ1QWRpVFVnNDk1ekJiUFR2NDZKN3loRnRHU2NxRUZzMlloZHpBTUdtWjZqd0VaUHNqSmFFeFp5NnNna0pMZmt4WDZ6YTR5OUtjN2ZKUm5rZTJMSnRqa1d3TTY4Yzc0RUY5b1V1dVZwS1dMRndYNWp6VWlzUkV2NjVxUGpSOHdLaGJ6QXZpREY1d2NHTVZhYnlBSzdNb3BOU254UUZTcGlVTWlBN29NcENmeW1ieWtmd3hqQ3RFRlFFNHo0d2RYUHVDclB6UXlMVm5uNzJNVnJWY2hzTjZXVE1pREN5WHVVZHZqWHhGZW5mUE5wN2lWSDhxeUpZQWJ1RlhUM3c5RVpCcXBDYW55VVhaYVE2RDZXZTlEUHZGOFU3UUsyRWdSeDNkUmZFU0xlSExFVnNYa3lHczlQeWpRblBpMngzNml6WmRiaktWOWFCNkVVeU1nUkI0dVlRb2FOdmRTZ1daNEw1SFM5YTJWUUU1eWlrcG5IV3NUOU5Vd013NUI2YlpvbjVIOUpMbzdzNEZuQjRDTWRDMldSUlRjV3BRVXJuM3NielFhaW1UNmpXRnVranVLWnhwRDZ5YkcyUURDZFRXalRDTmVSaTlUZVhISDRXZUtVNmM5Y0N0b202WnltOFU0M2dLZEVTZUc5VVZIUjhkSldTZmZtQlRlblhLTVVlZm9HUzJZQXVnN3dzS25FajlzZkFvUDlkTnd5c25VRTVWTjhDQlFMWUhxZUhhVXRBamhwUW9UcXpMNEhTTFhxb2Qzanc3eHJqWHFESlBMTkd6aXNpZkxKM0RzQXh6dWV3WU5OeUhwU1h2c25najNhSGhIdEtNdlF1QUVHcVlXWUxKOGFwZVIyYllyTG9Xc0ZqWXBGSEp6U3RIb2lmdldBbmJYWTVMczhXYUJLUzNrbURRd2E2QnlOM0hVekJ2dTRIeWNSZ0hXWGZqWE1ZYlo4OUt5ZWJ1OWs3WGZvd2JxUVpIb3JadHlFZDRFUUttQlRFRkJnUzdVUk5ZR0xFQXhMR2FNZDMyTGI4SEEyb280cXVBaGF5VWR5dTJxQ2lkamdoc3lQaDZSQWt6c21YZ1JVeHd1WWlBWFBHRUxDREZTdzRiVEZ4eGdwQ2dIVFlZQnBvSHpjTGt5M0hmUXdKM0VZcmo0RW1majYzVDg5bWpXS0EzeFFQRk5iSjJiemhua2VmNGZKVGI5S1NjSHE5MktBSkhvN2RMSDZHQXF0Nzhvc1hrdVBNRzd0V3pLcXBzSmQ3amVHUUpMUTdTQTR0VmdEQ1IzNU13NmpCeW9UNHVvTWhDR29pVVhWN1c0VXFyYlZIR0wzUThabmllVTNGN0FOVTQ1V0NFQ3I4aHA4ZjdRdTlGNmhmeFJEZzhjcExvOEZya1FuRlFBQVBnU3g1Q0JVMmh5dDNYUFRiS3hDQkJrV2c4Rmt6bWZ5OUM1bmtMQkNQSlpXblh1dER1VVVyY0hLRlFZZFhNbXlNUk1oUFVpQzNuVFdwdkVoc1lDamhzU1QzZ3ZweWhXc2o5Z1dTMnNKemZzaUZTMnBUSnpCQUZpTnlHR0prQXhxUzdxU2VCaUV0UHBZcGh4TjNVNm1OeE5TZ0E0ekVDakJwanJ3eUNFVGttNXY5dW5iS05MWDVqZ2s1dlA5OE5oY29uck56N3lmY3BqRXFMQ1YzVkVha1ZRUW1QbU52ZXVEcHVkekdrRk5SNW5CWUV2ZkxQOGNzNUV5Vnh5RDJrNVV1bmtnaDI5aEo1cUI3RmszbmtyeHBZSlRHdGlrVlZLeVdhYmZ5ZjlSbmlOSlBINml3VVhON0pOUkVxcFh2Um5wZDhWV0Zmc2Y2c1ZlMjNicHVTVnBKVUpoYwAAAAAAAAAAFgAAAAAAAAAsAAAAAAAAAEIAAAAAAAAAWAAAAAAAAABuAAAAAAAAAIQAAAAAAAAAmgAAAAAAAACwAAAAAAAAAMYAAAAAAAAA3AAAAAAAAADyAAAAAAAAAAgBAAAAAAAAHgEAAAAAAAA0AQAAAAAAAEoBAAAAAAAAYAEAAAAAAAB2AQAAAAAAAIwBAAAAAAAAogEAAAAAAAC4AQAAAAAAAM4BAAAAAAAA5AEAAAAAAAD6AQAAAAAAABACAAAAAAAAJgIAAAAAAAA8AgAAAAAAAFICAAAAAAAAaAIAAAAAAAB+AgAAAAAAAJQCAAAAAAAAqgIAAAAAAADAAgAAAAAAANYCAAAAAAAA7AIAAAAAAAACAwAAAAAAABgDAAAAAAAALgMAAAAAAABEAwAAAAAAAFoDAAAAAAAAcAMAAAAAAACGAwAAAAAAAJwDAAAAAAAAsgMAAAAAAADIAwAAAAAAAN4DAAAAAAAA9AMAAAAAAAAKBAAAAAAAACAEAAAAAAAANgQAAAAAAABMBAAAAAAAAGIEAAAAAAAAeAQAAAAAAACOBAAAAAAAAKQEAAAAAAAAugQAAAAAAADQBAAAAAAAAOYEAAAAAAAA/AQAAAAAAAASBQAAAAAAACgFAAAAAAAAPgUAAAAAAABUBQAAAAAAAGoFAAAAAAAAgAUAAAAAAACWBQAAAAAAAKwFAAAAAAAAwgUAAAAAAADYBQAAAAAAAO4FAAAAAAAABAYAAAAAAAAaBgAAAAAAADAGAAAAAAAARgYAAAAAAABcBgAAAAAAAHIGAAAAAAAAiAYAAAAAAACeBgAAAAAAALQGAAAAAAAAygYAAAAAAADgBgAAAAAAAPYGAAAAAAAADAcAAAAAAAAiBwAAAAAAADgHAAAAAAAATgcAAAAAAABkBwAAAAAAAHoHAAAAAAAAkAcAAAAAAACmBwAAAAAAALwHAAAAAAAA0gcAAAAAAADoBwAAAAAAAP4HAAAAAAAAFAgAAAAAAAAqCAAAAAAAAEAIAAAAAAAAVggAAAAAAABsCAAAAAAAAIIIAAAAAAAAmAgAAAAAAABoRlJqRzR1dFNpcGVweFpjQ3VyNlFGaEZSakc0dXRTaXBlcHhaY0N1cjZRRmhGUmpHNHV0U2lwZXB4WmNDdXI2UUZoRlJqRzR1dFNpcGVweFpjQ3VyNlFGaEZSakc0dXRTaXBlcHhaY0N1cjZRRmhGUmpHNHV0U2lwZXB4WmNDdXI2UUZoRlJqRzR1dFNpcGVweFpjQ3VyNlFGaEZSakc0dXRTaXBlcHhaY0N1cjZRRmhGUmpHNHV0U2lwZXB4WmNDdXI2UUZoRlJqRzR1dFNpcGVweFpjQ3VyNlFGaEZSakc0dXRTaXBlcHhaY0N1cjZRRmhGUmpHNHV0U2lwZXB4WmNDdXI2UUZoRlJqRzR1dFNpcGVweFpjQ3VyNlFGaEZSakc0dXRTaXBlcHhaY0N1cjZRRmhGUmpHNHV0U2lwZXB4WmNDdXI2UUZoRlJqRzR1dFNpcGVweFpjQ3VyNlFGaEZSakc0dXRTaXBlcHhaY0N1cjZRRmhGUmpHNHV0U2lwZXB4WmNDdXI2UUZoRlJqRzR1dFNpcGVweFpjQ3VyNlFGaEZSakc0dXRTaXBlcHhaY0N1cjZRRmhGUmpHNHV0U2lwZXB4WmNDdXI2UUZoRlJqRzR1dFNpcGVweFpjQ3VyNlFGaEZSakc0dXRTaXBlcHhaY0N1cjZRRmhGUmpHNHV0U2lwZXB4WmNDdXI2UUZoRlJqRzR1dFNpcGVweFpjQ3VyNlFGZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRGdISDZCeXRHY1BBZWdhSzNXV2RvQkRnSEg2Qnl0R2NQQWVnYUszV1dkb0JEZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRGdISDZCeXRHY1BBZWdhSzNXV2RvQkRnSEg2Qnl0R2NQQWVnYUszV1dkb0JEZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRGdISDZCeXRHY1BBZWdhSzNXV2RvQkRnSEg2Qnl0R2NQQWVnYUszV1dkb0JEZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRGdISDZCeXRHY1BBZWdhSzNXV2RvQkRnSEg2Qnl0R2NQQWVnYUszV1dkb0JEZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRGdISDZCeXRHY1BBZWdhSzNXV2RvQkRnSEg2Qnl0R2NQQWVnYUszV1dkb0JEZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRGdISDZCeXRHY1BBZWdhSzNXV2RvQkRnSEg2Qnl0R2NQQWVnYUszV1dkb0JEZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRGdISDZCeXRHY1BBZWdhSzNXV2RvQkRnSEg2Qnl0R2NQQWVnYUszV1dkb0JEZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRGdISDZCeXRHY1BBZWdhSzNXV2RvQkRnSEg2Qnl0R2NQQWVnYUszV1dkb0JEZ0hINkJ5dEdjUEFlZ2FLM1dXZG9CRG1XNEZLdzREOFEza2lFa1hVQmJOVEhtVzRGS3c0RDhRM2tpRWtYVUJiTlRIbVc0Rkt3NEQ4UTNraUVrWFVCYk5USG1XNEZLdzREOFEza2lFa1hVQmJOVEhtVzRGS3c0RDhRM2tpRWtYVUJiTlRIbVc0Rkt3NEQ4UTNraUVrWFVCYk5USG1XNEZLdzREOFEza2lFa1hVQmJOVEhtVzRGS3c0RDhRM2tpRWtYVUJiTlRIbVc0Rkt3NEQ4UTNraUVrWFVCYk5USG1XNEZLdzREOFEza2lFa1hVQmJOVEhtVzRGS3c0RDhRM2tpRWtYVUJiTlRIbVc0Rkt3NEQ4UTNraUVrWFVCYk5USG1XNEZLdzREOFEza2lFa1hVQmJOVEhtVzRGS3c0RDhRM2tpRWtYVUJiTlRIbVc0Rkt3NEQ4UTNraUVrWFVCYk5USG1XNEZLdzREOFEza2lFa1hVQmJOVEhtVzRGS3c0RDhRM2tpRWtYVUJiTlRIbVc0Rkt3NEQ4UTNraUVrWFVCYk5USG1XNEZLdzREOFEza2lFa1hVQmJOVEhtVzRGS3c0RDhRM2tpRWtYVUJiTlRIbVc0Rkt3NEQ4UTNraUVrWFVCYk5USG1XNEZLdzREOFEza2lFa1hVQmJOVEhtVzRGS3c0RDhRM2tpRWtYVUJiTlRIbVc0Rkt3NEQ4UTNraUVrWFVCYk5USG1XNEZLdzREOFEza2lFa1hVQmJOVEhSeWZZc0phaEM5QkZaY1dNUlc0MkNvUnlmWXNKYWhDOUJGWmNXTVJXNDJDb1J5ZllzSmFoQzlCRlpjV01SVzQyQ29SeWZZc0phaEM5QkZaY1dNUlc0MkNvUnlmWXNKYWhDOUJGWmNXTVJXNDJDb1J5ZllzSmFoQzlCRlpjV01SVzQyQ29SeWZZc0phaEM5QkZaY1dNUlc0MkNvUnlmWXNKYWhDOUJGWmNXTVJXNDJDb1J5ZllzSmFoQzlCRlpjV01SVzQyQ29SeWZZc0phaEM5QkZaY1dNUlc0MkNvUnlmWXNKYWhDOUJGWmNXTVJXNDJDb1J5ZllzSmFoQzlCRlpjV01SVzQyQ29SeWZZc0phaEM5QkZaY1dNUlc0MkNvUnlmWXNKYWhDOUJGWmNXTVJXNDJDb1J5ZllzSmFoQzlCRlpjV01SVzQyQ29SeWZZc0phaEM5QkZaY1dNUlc0MkNvUnlmWXNKYWhDOUJGWmNXTVJXNDJDb1J5ZllzSmFoQzlCRlpjV01SVzQyQ29SeWZZc0phaEM5QkZaY1dNUlc0MkNvUnlmWXNKYWhDOUJGWmNXTVJXNDJDb1J5ZllzSmFoQzlCRlpjV01SVzQyQ29SeWZZc0phaEM5QkZaY1dNUlc0MkNvUnlmWXNKYWhDOUJGWmNXTVJXNDJDb1J5ZllzSmFoQzlCRlpjV01SVzQyQ29SeWZZc0phaEM5QkZaY1dNUlc0MkNvAAAAAAAAAAAMAAAAAAAAABgAAAAAAAAAJAAAAAAAAAAwAAAAAAAAADwAAAAAAAAASAAAAAAAAABUAAAAAAAAAGAAAAAAAAAAbAAAAAAAAAB4AAAAAAAAAIQAAAAAAAAAkAAAAAAAAACcAAAAAAAAAKgAAAAAAAAAtAAAAAAAAADAAAAAAAAAAMwAAAAAAAAA2AAAAAAAAADkAAAAAAAAAPAAAAAAAAAA/AAAAAAAAAAIAQAAAAAAABQBAAAAAAAAIAEAAAAAAAAsAQAAAAAAADkBAAAAAAAARgEAAAAAAABTAQAAAAAAAGABAAAAAAAAbQEAAAAAAAB6AQAAAAAAAIcBAAAAAAAAlAEAAAAAAAChAQAAAAAAAK4BAAAAAAAAuwEAAAAAAADIAQAAAAAAANUBAAAAAAAA4gEAAAAAAADvAQAAAAAAAPwBAAAAAAAACQIAAAAAAAAWAgAAAAAAACMCAAAAAAAAMAIAAAAAAAA9AgAAAAAAAEoCAAAAAAAAVwIAAAAAAABkAgAAAAAAAHECAAAAAAAAlQIAAAAAAAC5AgAAAAAAAN0CAAAAAAAAAQMAAAAAAAAlAwAAAAAAAEkDAAAAAAAAbQMAAAAAAACRAwAAAAAAALUDAAAAAAAA2QMAAAAAAAD9AwAAAAAAACEEAAAAAAAARQQAAAAAAABpBAAAAAAAAI0EAAAAAAAAsQQAAAAAAADVBAAAAAAAAPkEAAAAAAAAHQUAAAAAAABBBQAAAAAAAGUFAAAAAAAAiQUAAAAAAACtBQAAAAAAANEFAAAAAAAA9QUAAAAAAAAXBgAAAAAAADkGAAAAAAAAWwYAAAAAAAB9BgAAAAAAAJ8GAAAAAAAAwQYAAAAAAADjBgAAAAAAAAUHAAAAAAAAJwcAAAAAAABJBwAAAAAAAGsHAAAAAAAAjQcAAAAAAACvBwAAAAAAANEHAAAAAAAA8wcAAAAAAAAVCAAAAAAAADcIAAAAAAAAWQgAAAAAAAB7CAAAAAAAAJ0IAAAAAAAAvwgAAAAAAADhCAAAAAAAAAMJAAAAAAAAJQkAAAAAAABHCQAAAAAAAG9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNW9wZW5haS9ncHQtNG9vcGVuYWkvZ3B0LTRvb3BlbmFpL2dwdC00b29wZW5haS9ncHQtNG9vcGVuYWkvZ3B0LTRvb3BlbmFpL2dwdC00b29wZW5haS9ncHQtNG9vcGVuYWkvZ3B0LTRvb3BlbmFpL2dwdC00b29wZW5haS9ncHQtNG9vcGVuYWkvZ3B0LTRvb3BlbmFpL2dwdC00b29wZW5haS9ncHQtNG9vcGVuYWkvZ3B0LTRvb3BlbmFpL2dwdC00b29wZW5haS9ncHQtNG9vcGVuYWkvZ3B0LTRvb3BlbmFpL2dwdC00b29wZW5haS9ncHQtNG9vcGVuYWkvZ3B0LTRvb3BlbmFpL2dwdC00b29wZW5haS9ncHQtNG9vcGVuYWkvZ3B0LTRvb3BlbmFpL2dwdC00b29wZW5haS9ncHQtNG9hbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTlhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1YW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNWFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDVhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1YW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNWFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDVhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1YW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNWFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDVhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1YW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNWFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDVhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1YW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNWFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDVhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1YW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNWFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDVhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1YW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNWFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDVhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1YW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNWFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDVhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAgAAAAAAAAACgAAAAAAAAAMAAAAAAAAAA4AAAAAAAAAEAAAAAAAAAASAAAAAAAAABQAAAAAAAAAFgAAAAAAAAAYAAAAAAAAABoAAAAAAAAAHAAAAAAAAAAeAAAAAAAAACAAAAAAAAAAIgAAAAAAAAAkAAAAAAAAACYAAAAAAAAAKAAAAAAAAAAqAAAAAAAAACwAAAAAAAAALgAAAAAAAAAwAAAAAAAAADIAAAAAAAAANAAAAAAAAAA2AAAAAAAAADgAAAAAAAAAOgAAAAAAAAA8AAAAAAAAAD4AAAAAAAAAQAAAAAAAAABCAAAAAAAAAEQAAAAAAAAARgAAAAAAAABIAAAAAAAAAEoAAAAAAAAATAAAAAAAAABOAAAAAAAAAFAAAAAAAAAAUgAAAAAAAABUAAAAAAAAAFYAAAAAAAAAWAAAAAAAAABaAAAAAAAAAFwAAAAAAAAAXgAAAAAAAABgAAAAAAAAAGIAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGgAAAAAAAAAagAAAAAAAABsAAAAAAAAAG4AAAAAAAAAcAAAAAAAAAByAAAAAAAAAHQAAAAAAAAAdgAAAAAAAAB4AAAAAAAAAHoAAAAAAAAAfAAAAAAAAAB+AAAAAAAAAIAAAAAAAAAAggAAAAAAAACEAAAAAAAAAIYAAAAAAAAAiAAAAAAAAACKAAAAAAAAAIwAAAAAAAAAjgAAAAAAAACQAAAAAAAAAJIAAAAAAAAAlAAAAAAAAACWAAAAAAAAAJgAAAAAAAAAmgAAAAAAAACcAAAAAAAAAJ4AAAAAAAAAoAAAAAAAAACiAAAAAAAAAKQAAAAAAAAApgAAAAAAAACoAAAAAAAAAKoAAAAAAAAArAAAAAAAAACuAAAAAAAAALAAAAAAAAAAsgAAAAAAAAC0AAAAAAAAALYAAAAAAAAAuAAAAAAAAAC6AAAAAAAAALwAAAAAAAAAvgAAAAAAAADAAAAAAAAAAMIAAAAAAAAAxAAAAAAAAADGAAAAAAAAAMgAAAAAAAAAe317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e30AAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAgAAAAAAAAACgAAAAAAAAAMAAAAAAAAAA4AAAAAAAAAEAAAAAAAAAASAAAAAAAAABQAAAAAAAAAFgAAAAAAAAAYAAAAAAAAABoAAAAAAAAAHAAAAAAAAAAeAAAAAAAAACAAAAAAAAAAIgAAAAAAAAAkAAAAAAAAACYAAAAAAAAAKAAAAAAAAAAqAAAAAAAAACwAAAAAAAAALgAAAAAAAAAwAAAAAAAAADIAAAAAAAAANAAAAAAAAAA2AAAAAAAAADgAAAAAAAAAOgAAAAAAAAA8AAAAAAAAAD4AAAAAAAAAQAAAAAAAAABCAAAAAAAAAEQAAAAAAAAARgAAAAAAAABIAAAAAAAAAEoAAAAAAAAATAAAAAAAAABOAAAAAAAAAFAAAAAAAAAAUgAAAAAAAABUAAAAAAAAAFYAAAAAAAAAWAAAAAAAAABaAAAAAAAAAFwAAAAAAAAAXgAAAAAAAABgAAAAAAAAAGIAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGgAAAAAAAAAagAAAAAAAABsAAAAAAAAAG4AAAAAAAAAcAAAAAAAAAByAAAAAAAAAHQAAAAAAAAAdgAAAAAAAAB4AAAAAAAAAHoAAAAAAAAAfAAAAAAAAAB+AAAAAAAAAIAAAAAAAAAAggAAAAAAAACEAAAAAAAAAIYAAAAAAAAAiAAAAAAAAACKAAAAAAAAAIwAAAAAAAAAjgAAAAAAAACQAAAAAAAAAJIAAAAAAAAAlAAAAAAAAACWAAAAAAAAAJgAAAAAAAAAmgAAAAAAAACcAAAAAAAAAJ4AAAAAAAAAoAAAAAAAAACiAAAAAAAAAKQAAAAAAAAApgAAAAAAAACoAAAAAAAAAKoAAAAAAAAArAAAAAAAAACuAAAAAAAAALAAAAAAAAAAsgAAAAAAAAC0AAAAAAAAALYAAAAAAAAAuAAAAAAAAAC6AAAAAAAAALwAAAAAAAAAvgAAAAAAAADAAAAAAAAAAMIAAAAAAAAAxAAAAAAAAADGAAAAAAAAAMgAAAAAAAAAe317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e317fXt9e30AAAAAAAAAAOAAAAAAAAAAwAEAAAAAAACgAgAAAAAAAIADAAAAAAAAYAQAAAAAAABABQAAAAAAACAGAAAAAAAAAAcAAAAAAADgBwAAAAAAAMAIAAAAAAAAoAkAAAAAAACACgAAAAAAAGALAAAAAAAAQAwAAAAAAAAgDQAAAAAAAAAOAAAAAAAA4A4AAAAAAADADwAAAAAAAKAQAAAAAAAAgBEAAAAAAABgEgAAAAAAAEATAAAAAAAAIBQAAAAAAAAAFQAAAAAAAOAVAAAAAAAAwBYAAAAAAACgFwAAAAAAAIAYAAAAAAAAYBkAAAAAAABAGgAAAAAAACAbAAAAAAAAABwAAAAAAADgHAAAAAAAAMAdAAAAAAAAoB4AAAAAAACAHwAAAAAAAGAgAAAAAAAAQCEAAAAAAAAgIgAAAAAAAAAjAAAAAAAA4CMAAAAAAADAJAAAAAAAAKAlAAAAAAAAgCYAAAAAAABgJwAAAAAAAEAoAAAAAAAAICkAAAAAAAAAKgAAAAAAAOAqAAAAAAAAwCsAAAAAAACgLAAAAAAAAIAtAAAAAAAAYC4AAAAAAABALwAAAAAAACAwAAAAAAAAADEAAAAAAADgMQAAAAAAAMAyAAAAAAAAoDMAAAAAAACANAAAAAAAAGA1AAAAAAAAQDYAAAAAAAAgNwAAAAAAAAA4AAAAAAAA4DgAAAAAAADAOQAAAAAAAKA6AAAAAAAAgDsAAAAAAABgPAAAAAAAAEA9AAAAAAAAID4AAAAAAAAAPwAAAAAAAOA/AAAAAAAAwEAAAAAAAACgQQAAAAAAAIBCAAAAAAAAYEMAAAAAAABARAAAAAAAACBFAAAAAAAAAEYAAAAAAADgRgAAAAAAAMBHAAAAAAAAoEgAAAAAAACASQAAAAAAAGBKAAAAAAAAQEsAAAAAAAAgTAAAAAAAAABNAAAAAAAA4E0AAAAAAADATgAAAAAAAKBPAAAAAAAAgFAAAAAAAABgUQAAAAAAAEBSAAAAAAAAIFMAAAAAAAAAVAAAAAAAAOBUAAAAAAAAwFUAAAAAAACgVgAAAAAAAIBXAAAAAAAAL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvVXNlcnMvY2hhcmxlc3RlYWd1ZS9EZXZlbG9wbWVudC9tZXJpZGlhbmxhYnMtYWkvaW5zcGVjdF92aXovZG9jcy9leGFtcGxlcy9pbnNwZWN0L3NhbXBsZXMtaGVhdG1hcC8uLi8uLi8uLi8uLi8uLi9pbnNwZWN0LXZpei1leGFtcGxlLWxvZ3MvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9Vc2Vycy9jaGFybGVzdGVhZ3VlL0RldmVsb3BtZW50L21lcmlkaWFubGFicy1haS9pbnNwZWN0X3Zpei9kb2NzL2V4YW1wbGVzL2luc3BlY3Qvc2FtcGxlcy1oZWF0bWFwLy4uLy4uLy4uLy4uLy4uL2luc3BlY3Qtdml6LWV4YW1wbGUtbG9ncy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL1VzZXJzL2NoYXJsZXN0ZWFndWUvRGV2ZWxvcG1lbnQvbWVyaWRpYW5sYWJzLWFpL2luc3BlY3Rfdml6L2RvY3MvZXhhbXBsZXMvaW5zcGVjdC9zYW1wbGVzLWhlYXRtYXAvLi4vLi4vLi4vLi4vLi4vaW5zcGVjdC12aXotZXhhbXBsZS1sb2dzL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwAAAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAUAAAAAAAAABgAAAAAAAAAHAAAAAAAAAAgAAAAAAAAACQAAAAAAAAAKAAAAAAAAAAsAAAAAAAAADQAAAAAAAAAPAAAAAAAAABEAAAAAAAAAEwAAAAAAAAAVAAAAAAAAABcAAAAAAAAAGQAAAAAAAAAbAAAAAAAAAB0AAAAAAAAAHwAAAAAAAAAhAAAAAAAAACMAAAAAAAAAJQAAAAAAAAAnAAAAAAAAACkAAAAAAAAAKwAAAAAAAAAsAAAAAAAAAC0AAAAAAAAALgAAAAAAAAAvAAAAAAAAADAAAAAAAAAAMQAAAAAAAAAyAAAAAAAAADMAAAAAAAAANAAAAAAAAAA2AAAAAAAAADgAAAAAAAAAOgAAAAAAAAA8AAAAAAAAAD4AAAAAAAAAQAAAAAAAAABCAAAAAAAAAEQAAAAAAAAARgAAAAAAAABIAAAAAAAAAEoAAAAAAAAATAAAAAAAAABOAAAAAAAAAFAAAAAAAAAAUgAAAAAAAABTAAAAAAAAAFQAAAAAAAAAVQAAAAAAAABWAAAAAAAAAFcAAAAAAAAAWAAAAAAAAABZAAAAAAAAAFoAAAAAAAAAXAAAAAAAAABdAAAAAAAAAF8AAAAAAAAAYQAAAAAAAABjAAAAAAAAAGUAAAAAAAAAZwAAAAAAAABpAAAAAAAAAGsAAAAAAAAAbQAAAAAAAABvAAAAAAAAAHEAAAAAAAAAcwAAAAAAAAB1AAAAAAAAAHcAAAAAAAAAeQAAAAAAAAB7AAAAAAAAAH0AAAAAAAAAfgAAAAAAAAB/AAAAAAAAAIAAAAAAAAAAgQAAAAAAAACCAAAAAAAAAIMAAAAAAAAAhAAAAAAAAACFAAAAAAAAAIYAAAAAAAAAiAAAAAAAAACKAAAAAAAAAIwAAAAAAAAAjgAAAAAAAACQAAAAAAAAAJIAAAAAAAAAlAAAAAAAAACWAAAAAAAAAJgAAAAAAAAAmgAAAAAAAACcAAAAAAAAAJ4AAAAAAAAAoAAAAAAAAACiAAAAAAAAAKQAAAAAAAAAODkxMDU3NjIzNDExMTE1MTMxODE3MTIxNDIwMTYxOTIxMjMyMjI1MjQxMDk4NDU3MzE2MjExMTMxMjE3MTUxNDE4MTYyMDE5MjEyMzI0MjUyMjQyNTczNjg5MTAxMTExMzE1MTIxNDE3MTgxNjE5MjAyMzIxMjIyNDI1MTA4Nzk0NTYzMjExMTEyMTMxNTE0MTcxODE2MjAxOTIzMjEyMjI0MjUAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAB4UAAAAAAAA/EgAAAAAAAAaXQAAAAAAAMNdAAAAAAAA4XEAAAAAAAD7cwAAAAAAABx2AAAAAAAAPIoAAAAAAADDigAAAAAAAIu8AAAAAAAAuNAAAAAAAADW5AAAAAAAAPr4AAAAAAAAIA0BAAAAAAA+IQEAAAAAACsuAQAAAAAATUIBAAAAAABxVgEAAAAAAJFqAQAAAAAAKWsBAAAAAAAPnwEAAAAAAPigAQAAAAAAA6QBAAAAAABn2QEAAAAAACPrAQAAAAAAQf8BAAAAAAAfNAIAAAAAAD1IAgAAAAAAxEgCAAAAAABtSQIAAAAAAItdAgAAAAAAq3ECAAAAAABzowIAAAAAAI2lAgAAAAAArqcCAAAAAADbuwIAAAAAAP/PAgAAAAAA7NwCAAAAAAAK8QIAAAAAACgFAwAAAAAAShkDAAAAAABwLQMAAAAAAJBBAwAAAAAAtFUDAAAAAABMVgMAAAAAADKKAwAAAAAAG4wDAAAAAADXnQMAAAAAADvTAwAAAAAARtYDAAAAAADN1gMAAAAAAO7YAwAAAAAAl9kDAAAAAAC17QMAAAAAANUBBAAAAAAA7wMEAAAAAAANGAQAAAAAAOtMBAAAAAAACWEEAAAAAADRkgQAAAAAAP6mBAAAAAAAIrsEAAAAAABAzwQAAAAAAC3cBAAAAAAAT/AEAAAAAABtBAUAAAAAAJMYBQAAAAAAsywFAAAAAABLLQUAAAAAAG9BBQAAAAAAWEMFAAAAAAA+dwUAAAAAAEl6BQAAAAAABYwFAAAAAABpwQUAAAAAAIfVBQAAAAAApekFAAAAAADD/QUAAAAAAKEyBgAAAAAAKDMGAAAAAADRMwYAAAAAAOs1BgAAAAAAC0oGAAAAAAAsTAYAAAAAAPR9BgAAAAAAIZIGAAAAAAAOnwYAAAAAADKzBgAAAAAAUMcGAAAAAABy2wYAAAAAAJDvBgAAAAAAtgMHAAAAAADWFwcAAAAAAPorBwAAAAAAkiwHAAAAAAB7LgcAAAAAAGFiBwAAAAAAbGUHAAAAAAAodwcAAAAAAIysBwAAAAAAdXNlcjoKKipEZXNpZ24gYW5kIE9wdGltaXphdGlvbiBvZiBJbnRlbGxpZ2VudCBNYW51ZmFjdHVyaW5nIFN5c3RlbXMgQmFzZWQgb24gQXJ0aWZpY2lhbCBJbnRlbGxpZ2VuY2UgVGVjaG5vbG9neSoqICAKCiMjIyAxIEFuYWx5c2lzIG9mIEFJIEFwcGxpY2F0aW9ucyBpbiBNYW51ZmFjdHVyaW5nICAKCiMjIyMgMS4xIFZpc3VhbCBJbnNwZWN0aW9uIGFuZCBEZWZlY3QgUmVjb2duaXRpb24gIApJbiB0aGUgZmllbGQgb2YgbWFudWZhY3R1cmluZywgdmlzdWFsIGluc3BlY3Rpb24gYW5kIGRlZmVjdCByZWNvZ25pdGlvbiB0ZWNobm9sb2dpZXMgaGF2ZSBiZWVuIGRldmVsb3BpbmcgcmFwaWRseS4gVGhlc2UgdGVjaG5vbG9naWVzIGxldmVyYWdlIGltYWdlIHByb2Nlc3NpbmcgYW5kIG1hY2hpbmUgdmlzaW9uIHByaW5jaXBsZXMgdG8gZWZmaWNpZW50bHkgYW5kIGFjY3VyYXRlbHkgaWRlbnRpZnkgZGVmZWN0cyBvbiB0aGUgc3VyZmFjZSBvciBpbnNpZGUgb2YgcHJvZHVjdHMgd2l0aG91dCBodW1hbiBpbnRlcnZlbnRpb24sIGVuc3VyaW5nIHByb2R1Y3QgcXVhbGl0eS4gV2l0aCB0aGUgYXBwbGljYXRpb24gb2YgZGVlcCBsZWFybmluZyB0ZWNobm9sb2d5LCB0aGUgcmVjb2duaXRpb24gY2FwYWJpbGl0aWVzIG9mIHZpc3VhbCBpbnNwZWN0aW9uIHN5c3RlbXMgaGF2ZSBncmVhdGx5IGltcHJvdmVkLiBUaGV5IGNhbiBkZXRlY3QgZXZlbiB0aGUgc21hbGxlc3QgZmxhd3MgYW5kIG9wZXJhdGUgcmVsaWFibHkgaW4gY29tcGxleCBpbmR1c3RyaWFsIGVudmlyb25tZW50cy4gIAoKRm9yIGV4YW1wbGUsIGluIHRoZSBlbGVjdHJvbmljcyBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5LCB2aXN1YWwgaW5zcGVjdGlvbiBzeXN0ZW1zIGNhbiBpZGVudGlmeSB0aW55IGNyYWNrcyBhbmQgc29sZGVyaW5nIGlzc3VlcyBvbiBwcmludGVkIGNpcmN1aXQgYm9hcmRzLCBlbnN1cmluZyB0aGUgZnVuY3Rpb25hbGl0eSBhbmQgc2FmZXR5IG9mIGVsZWN0cm9uaWMgcHJvZHVjdHMuIFdpdGggaW5jcmVhc2VkIGNvbXB1dGluZyBwb3dlciBhbmQgb3B0aW1pemVkIGFsZ29yaXRobXMsIHZpc3VhbCBpbnNwZWN0aW9uIHRlY2hub2xvZ3kgaGFzIGFsc28gbWFkZSBzaWduaWZpY2FudCBwcm9ncmVzcyBpbiBpbXByb3ZpbmcgZGV0ZWN0aW9uIHNwZWVkIGFuZCBhY2N1cmFjeS4gQnkgcHJvY2Vzc2luZyBsYXJnZSBhbW91bnRzIG9mIGltYWdlIGRhdGEgaW4gcmVhbCB0aW1lLCB0aGVzZSBzeXN0ZW1zIGNhbiBxdWlja2x5IHByb3ZpZGUgZGV0ZWN0aW9uIHJlc3VsdHMsIGdyZWF0bHkgZW5oYW5jaW5nIHByb2R1Y3Rpb24gbGluZSBlZmZpY2llbmN5LiAgCgpJbiB0aGUgYXV0b21vdGl2ZSBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5LCB2aXN1YWwgaW5zcGVjdGlvbiB0ZWNobm9sb2d5IGlzIHdpZGVseSB1c2VkIGZvciBjaGVja2luZyB0aGUgcXVhbGl0eSBvZiBjYXIgYm9keSBjb2F0aW5ncywgYWNjdXJhdGVseSBpZGVudGlmeWluZyBpc3N1ZXMgc3VjaCBhcyB1bmV2ZW4gY29hdGluZyB0aGlja25lc3MgYW5kIGNvbG9yIGluY29uc2lzdGVuY2llcy4gIAoKIyMjIyAxLjIgUHJlZGljdGl2ZSBNYWludGVuYW5jZSBhbmQgRmF1bHQgRGlhZ25vc2lzICAKUHJlZGljdGl2ZSBtYWludGVuYW5jZSBhbmQgZmF1bHQgZGlhZ25vc2lzIHBsYXkgYSBjcnVjaWFsIHJvbGUgaW4gbW9kZXJuIG1hbnVmYWN0dXJpbmcuIEJ5IGxldmVyYWdpbmcgYmlnIGRhdGEgYW5hbHlzaXMgYW5kIG1hY2hpbmUgbGVhcm5pbmcgYWxnb3JpdGhtcywgdGhlc2UgdGVjaG5vbG9naWVzIGNhbiBhY2N1cmF0ZWx5IHByZWRpY3QgcG90ZW50aWFsIGVxdWlwbWVudCBmYWlsdXJlcywgZW5hYmxpbmcgcHJvYWN0aXZlIG1haW50ZW5hbmNlIHRvIHByZXZlbnQgcHJvZHVjdGlvbiBkaXNydXB0aW9ucyBhbmQgZWNvbm9taWMgbG9zc2VzLiBUaGlzIGFwcHJvYWNoIHNoaWZ0cyBmcm9tIHRyYWRpdGlvbmFsIHJlYWN0aXZlIG1haW50ZW5hbmNlIHRvIGEgbW9yZSBwcm9hY3RpdmUgbWFpbnRlbmFuY2Ugc3RyYXRlZ3ksIGVmZmVjdGl2ZWx5IGV4dGVuZGluZyBlcXVpcG1lbnQgbGlmZXNwYW4gYW5kIGltcHJvdmluZyBwcm9kdWN0aW9uIGVmZmljaWVuY3kuICAKCkZvciBleGFtcGxlLCBpbiBoZWF2eSBpbmR1c3RyaWVzLCBwcmVkaWN0aXZlIG1haW50ZW5hbmNlIHN5c3RlbXMgY2FuIG1vbml0b3IgcGFyYW1ldGVycyBzdWNoIGFzIGVxdWlwbWVudCB2aWJyYXRpb24sIHRlbXBlcmF0dXJlLCBhbmQgc291bmQgdG8gZGV0ZWN0IGFub21hbGllcyBpbiByZWFsIHRpbWUgYW5kIGludGVydmVuZSBiZWZvcmUgcHJvYmxlbXMgZXNjYWxhdGUuIFdpdGggY29udGludW91cyBhZHZhbmNlbWVudHMgaW4gdGVjaG5vbG9neSwgZmF1bHQgZGlhZ25vc2lzIHN5c3RlbXMgaGF2ZSBzaWduaWZpY2FudGx5IGltcHJvdmVkIGluIHByZWRpY3Rpb24gYWNjdXJhY3kgYW5kIHJlc3BvbnNlIHNwZWVkLiBUaGVzZSBzeXN0ZW1zIGFuYWx5emUgaGlzdG9yaWNhbCBhbmQgcmVhbC10aW1lIGRhdGEsIHV0aWxpemluZyBjb21wbGV4IGFsZ29yaXRobSBtb2RlbHMgdG8gcHJlZGljdCBlcXVpcG1lbnQgZmFpbHVyZXMuIFRoZXkgY2FuIGV2ZW4gYXV0b21hdGljYWxseSBhZGp1c3QgcHJvZHVjdGlvbiBwYXJhbWV0ZXJzIGJhc2VkIG9uIGVxdWlwbWVudCBzdGF0dXMgdG8gZW5zdXJlIHVuaW50ZXJydXB0ZWQgcHJvZHVjdGlvbi4gIAoKSW4gdGhlIGF1dG9tb3RpdmUgaW5kdXN0cnksIHByZWRpY3RpdmUgbWFpbnRlbmFuY2UgYW5kIGZhdWx0IGRpYWdub3NpcyB0ZWNobm9sb2dpZXMgYXJlIHVzZWQgdG8gbW9uaXRvciB0aGUgcGVyZm9ybWFuY2Ugb2Yga2V5IGNvbXBvbmVudHMgc3VjaCBhcyBlbmdpbmVzIGFuZCB0cmFuc21pc3Npb25zLCBwcmV2ZW50aW5nIGZhaWx1cmVzIGFuZCBlbnN1cmluZyBkcml2aW5nIHNhZmV0eS4gIAoKIyMjIDIgRGVzaWduIG9mIEFJLUJhc2VkIEludGVsbGlnZW50IE1hbnVmYWN0dXJpbmcgU3lzdGVtcyAgCgojIyMjIDIuMSBTeXN0ZW0gQXJjaGl0ZWN0dXJlIERlc2lnbiAgClN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduIGlzIHRoZSBmb3VuZGF0aW9uIG9mIEFJLWJhc2VkIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgc3lzdGVtcy4gSXQgaW52b2x2ZXMgcGxhbm5pbmcgdGhlIGVudGlyZSBwcm9kdWN0aW9uIHN5c3RlbSwgZnJvbSBkYXRhIGZsb3cgdG8gY29udHJvbCBsb2dpYywgZW5zdXJpbmcgZWZmaWNpZW50IGNvbGxhYm9yYXRpb24gYmV0d2VlbiBjb21wb25lbnRzIGFuZCB0aGUgc3lzdGVtJ3MgYWRhcHRhYmlsaXR5IGFuZCBzY2FsYWJpbGl0eS4gVGhlIGhpZXJhcmNoaWNhbCBkZXNpZ24gY29uY2VwdCBpbnRlZ3JhdGVzIGFuZCBvcHRpbWl6ZXMgbWFudWZhY3R1cmluZyByZXNvdXJjZXMgZWZmZWN0aXZlbHkuICAKCkZvciBleGFtcGxlLCBwaHlzaWNhbCBkZXZpY2VzIGF0IHRoZSBib3R0b20gbGF5ZXIgY29tbXVuaWNhdGUgaW4gcmVhbCB0aW1lIHdpdGggdXBwZXItbGF5ZXIgZGVjaXNpb24tbWFraW5nIG1vZHVsZXMgdmlhIHNlbnNvcnMuIFRoZSBkYXRhIHByb2Nlc3NpbmcgbGF5ZXIgYW5hbHl6ZXMgdGhlIGNvbGxlY3RlZCBpbmZvcm1hdGlvbiwgcHJvdmlkaW5nIGEgYmFzaXMgZm9yIGludGVsbGlnZW50IGRlY2lzaW9uLW1ha2luZy4gRmlndXJlIDEgaWxsdXN0cmF0ZXMgdGhlIHN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduLiBUaGlzIHN0cnVjdHVyZWQgYXBwcm9hY2ggZW5oYW5jZXMgc3lzdGVtIHN0YWJpbGl0eSBhbmQgZWZmaWNpZW5jeSB3aGlsZSBmYWNpbGl0YXRpbmcgbWFpbnRlbmFuY2UgYW5kIHVwZ3JhZGVzLiAgCgoqKkZpZ3VyZSAxOiBTeXN0ZW0gQXJjaGl0ZWN0dXJlIERlc2lnbioqICAKClN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduIG11c3QgYWxzbyBpbmNvcnBvcmF0ZSBBSSB0ZWNobm9sb2dpZXMsIHJlcXVpcmluZyBkZXNpZ25lcnMgdG8gaGF2ZSBpbnRlcmRpc2NpcGxpbmFyeSBrbm93bGVkZ2UsIGluY2x1ZGluZyBtYW51ZmFjdHVyaW5nIHByb2Nlc3NlcywgZGF0YSBzY2llbmNlLCBhbmQgbWFjaGluZSBsZWFybmluZy4gSW4gcHJhY3RpY2UsIHRoZSBzeXN0ZW0gYXJjaGl0ZWN0dXJlIHNob3VsZCBzdXBwb3J0IGNvbXBsZXggYWxnb3JpdGhtIG9wZXJhdGlvbnMsIHN1Y2ggYXMgbmV1cmFsIG5ldHdvcmtzIGFuZCBkZWVwIGxlYXJuaW5nIG1vZGVscywgZW5hYmxpbmcgc2VsZi1sZWFybmluZyBhbmQgc2VsZi1vcHRpbWl6YXRpb24gZHVyaW5nIHByb2R1Y3Rpb24uIFRoaXMgYWxsb3dzIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgc3lzdGVtcyB0byBhZGFwdCBmbGV4aWJseSB0byB2YXJpb3VzIHByb2R1Y3Rpb24gdGFza3MgYW5kIG1hcmtldCBjaGFuZ2VzIHdoaWxlIGNvbnRpbnVvdXNseSBpbXByb3ZpbmcgdGhlaXIgaW50ZWxsaWdlbmNlIGJ5IGxlYXJuaW5nIGZyb20gcHJvZHVjdGlvbiBkYXRhLiAgCgojIyMjIDIuMiBIdW1hbi1NYWNoaW5lIEludGVyZmFjZSAoSE1JKSBEZXNpZ24gIApUaGUgaHVtYW4tbWFjaGluZSBpbnRlcmZhY2UgKEhNSSkgc2VydmVzIGFzIGEgYnJpZGdlIGJldHdlZW4gaHVtYW4gb3BlcmF0aW9uIGFuZCBtYWNoaW5lIGV4ZWN1dGlvbiBpbiBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHN5c3RlbXMuIEl0cyBpbnR1aXRpdmVuZXNzIGFuZCBlYXNlIG9mIHVzZSBkaXJlY3RseSBhZmZlY3Qgc3lzdGVtIGVmZmljaWVuY3kuIEEgd2VsbC1kZXNpZ25lZCBITUkgc2ltcGxpZmllcyBjb21wbGV4IG9wZXJhdGlvbnMsIGVmZmVjdGl2ZWx5IHRyYW5zbGF0aW5nIGh1bWFuIGludGVudGlvbnMgaW50byBwcmVjaXNlIG1hY2hpbmUgcmVzcG9uc2VzLiAgCgpVc2VyIGV4cGVyaWVuY2UgaXMgYSB0b3AgcHJpb3JpdHkgaW4gSE1JIGRlc2lnbiwgZW5zdXJpbmcgaW50dWl0aXZlIG9wZXJhdGlvbiBhbmQgcmVkdWNpbmcgZXJyb3JzIHRocm91Z2ggcHJvcGVyIHVzZSBvZiBncmFwaGljcywgaWNvbnMsIGFuZCBjb2xvcnMuIEZvciBleGFtcGxlLCBpbnR1aXRpdmUgZ3JhcGhpY2FsIGludGVyZmFjZXMgb24gdG91Y2ggc2NyZWVucyBoZWxwIG9wZXJhdG9ycyBxdWlja2x5IGlkZW50aWZ5IHN5c3RlbSBzdGF0dXNlcyBhbmQgcmVzcG9uZCB0byBhbGVydHMsIGltcHJvdmluZyBlZmZpY2llbmN5IGFuZCBzYWZldHkuICAKCldpdGguLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgror7fkuLrkuIDnr4fmjqLorqjljLrlnZfpk77mioDmnK/lnKjkvpvlupTpk77kuK3lupTnlKjnmoTlrabmnK/orrrmlofmkrDlhpnkuK3mlofmkZjopoHvvIzorrrmloflhbbku5bpg6jliIblpoLkuIs65LiA44CB5byV6KiAIOiHqjIwMDjlubTkuK3mnKzogarlnKjmr5TnibnluIHorrrlnZvkuIrlj5HooajlkI3kuLrigJxCaXRjb2luOkEgUGVlci10by1QZWVyIEVsZWN0cm9uaWMgQ2FzaCBTeXN0ZW3igJ1bMV3nmoTorrrmlofku6XmnaXvvIzljLrlnZfpk77nmoTmpoLlv7Xpmo/nnYDmr5TnibnluIHnmoTngavniIblj5fliLDkuoblkITlm73mlL/lupzlkozlrabogIXnmoTpq5jluqblhbPms6jjgILlkITkuKrlm73lrrbnm7jnu6fmjqjlh7rmtonlj4rljLrlnZfpk77mioDmnK/nmoTns7vliJfmlL/nrZbmlofku7bvvIzliqDpgJ/ljLrlnZfpk77nmoTlupTnlKjokL3lnLDvvIzkvb/lhbbmiJDkuLrlvJXpoobmlrDkuIDku6Pkv6Hmga/mioDmnK/nmoTkuLvop5LjgILmiJHlm73ml6nlnKgyMDE25bm05bCx5Y+R6KGo5LqG6aaW5Lu944CK5Lit5Zu95Yy65Z2X6ZO+5oqA5pyv5ZKM5bqU55So5Y+R5bGV55m955qu5Lmm44CL44CC44CK55m955qu5Lmm44CL6K+m57uG5LuL57uN5LqG5Yy65Z2X6ZO+5Zyo5Zu95YaF5aSW55qE5Y+R5bGV546w54q244CB5bqU55So5Zy65pmv5LiO5pyq5p2l5Y+R5bGV5pa55ZCRWzJd44CC5ZCM5bm077yM5Zu95Yqh6Zmi5Y2w5Y+R55qE44CK4oCc5Y2B5LiJ5LqU4oCd5Zu95a625L+h5oGv5YyW6KeE5YiS44CL5Lit5piO56Gu5bCG5Yy65Z2X6ZO+5oqA5pyv5YiX5Li65oiY55Wl5oCn5YmN5rK/5oqA5pyvWzNd44CCMjAxOeW5tDEw5pyIMjTml6XvvIzkuaDov5HlubPmgLvkuaborrDlnKjkuK3lpK7mlL/msrvlsYDnrKzljYHlhavmrKHpm4bkvZPlrabkuaDml7blvLrosIPvvIzigJzmiorljLrlnZfpk77kvZzkuLrmoLjlv4PmioDmnK/oh6rkuLvliJvmlrDph43opoHnqoHnoLTlj6PvvIzliqDlv6vmjqjliqjljLrlnZfpk77mioDmnK/lkozkuqfkuJrliJvmlrDlj5HlsZXigJ1bNF3vvIzov5vkuIDmraXlh7jmmL7kuobljLrlnZfpk77nmoTph43opoHkvZznlKjjgIIg5Yy65Z2X6ZO+5oqA5pyv57uZ5ZCE6KGM5ZCE5Lia5bim5p2l5LqG5paw55qE5Y+R5bGV5py66YGH77yM5YW25bqU55So6YCQ5riQ5LuO6YeR6J6N6aKG5Z+f5omp5bGV5Yiw5YW25LuW6aKG5Z+f77yM5L6b5bqU6ZO+5bCx5piv5YW25Lit5LmL5LiA44CC6ZqP552A5Yy65Z2X6ZO+5oqA5pyv55qE5LiN5pat5Y+R5bGV77yM5Lyg57uf55qE5L6b5bqU6ZO+566h55CG5qih5byP5Lqf6aG75Zyo6J6N5YWl5paw5oqA5pyv55qE5Z+656GA5LiK6L+b6KGM5YWo5paw55qE5Y+Y6Z2p44CC5Zug5q2k77yM56eR5a2m5Zyw5qKz55CG5bm25oC757uT4oCc5Yy65Z2X6ZO+K+S+m+W6lOmTvuKAnemihuWfn+eahOeglOeptueDreeCueS4juWJjeayv+i2i+WKv++8jOWFt+aciemHjeimgeeahOeQhuiuuuWSjOWunui3teaEj+S5ieOAguacrOaWh+S7pUNpdGUgU3BhY2XmlofnjK7orqHph4/liIbmnpDkuLrmjIflvJXvvIzlr7nljLrlnZfpk77mioDmnK/lnKjkvpvlupTpk77kuK3nmoTlupTnlKjnoJTnqbbov5vooYzov7Dor4TvvIzpgJrov4fmorPnkIbnjrDmnInmlofnjK7vvIzlnKjmmI7mmbDljLrlnZfpk77mioDmnK/nu5nkvpvlupTpk77luKbmnaXnmoTmt7HliLvlj5jpnanlj4rlupTnlKjnjrDnirbnmoTln7rnoYDkuIrvvIzlr7nmnKrmnaXnoJTnqbbmlrnlkJHov5vooYzlsZXmnJvjgIIg5LqM44CB5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So56CU56m25paH54yu6K6h6YeP5YiG5p6QIOS4uuWFqOmdouS6huino+WMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOeglOeptueOsOeKtu+8jOWAn+WKqUNpdGUgU3BhY2Xlj6/op4bljJbliIbmnpDova/ku7bov5vooYzmlofnjK7lhbHooqvlvJXliIbmnpDjgIHlhbPplK7or43lhbHnjrDliIbmnpDjgIHlhbPplK7or43ogZrnsbvliIbmnpBbNV3jgILku6XigJxibG9ja2NoYWlu4oCd5ZKM4oCcc3VwcGx5IGNoYWlu4oCd5Li65qOA57Si5Li76aKY6K+N5ZyoV2ViIG9mIFNjaWVuY2XmlbDmja7lupPkuK3ov5vooYzmlofnjK7mo4DntKLvvIzor63np43orr7lrprkuLroi7Hor63vvIzmlofnjK7nsbvlnovpgInmi6nigJxBcnRpY2xl4oCd5oiW4oCcUmV2aWV34oCd77yM5qOA57Si5pe26Ze05Li6MjAyMOW5tDEy5pyI77yM5pe26Ze06Leo5bqm6K6+5Li6MjAwOOKAlDIwMjDvvIzlhbHmo4DntKLliLDoi7HmlofmlofnjK40NTXnr4fjgIIg6YCa6L+H5paH54yu5YWx6KKr5byV5YiG5p6Q77yM5Y+R546w5pyJ5LiA5Lqb5a+55Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So56CU56m25b2x5ZON6L6D5aSn55qE5paH54yu44CC5aaCU3dhbls2XeWcqDIwMTXlubTlh7rniYjkuobokZfkvZxCbG9ja2NoYWluOkJsdWVwcmludCBmb3IgYSBOZXcgRWNvbm9tee+8jOiuqOiuuuS6huavlOeJueW4geWSjOWMuuWdl+mTvuaKgOacr+eahOS4ieS4quS4jeWQjOmYtuautTrljLrlnZfpk74xLjDjgIHljLrlnZfpk74yLjDlkozljLrlnZfpk74zLjDvvIzlubbmj5Dlh7rljLrlnZfpk74zLjDlnKjotKfluIHjgIHph5Hono3jgIHnp5HmioDjgIHln7rlm6Dnu4TlrabjgIHlgaXlurfjgIHlrabkuaDjgIHlrabmnK/lh7rniYjjgIHlvIDlj5HjgIHmlZHmj7TlkozmlofljJbnrYnpoobln5/nmoTor7jlpJrlupTnlKjliY3mma/vvIzkuLrlkI7nu63noJTnqbblpaDlrprkuobln7rnoYDjgIJLc2hldHJpWzdd5ZyoMjAxOOW5tOWPkeihqOS6huiuuuaWh+KAnEJsb2NrY2hhaW4ncyBSb2xlcyBpbiBNZWV0aW5nIEtleSBTdXBwbHkgQ2hhaW4gTWFuYWdlbWVudCBPYmplY3RpdmVz4oCd77yM5Lul6ams5aOr5Z+644CB6Zi/6YeM5be05be044CB5rKD5bCU546b562JMTHlrrbmiJDlip/ov5DnlKjljLrlnZfpk77nmoTku6PooajmgKfkvIHkuJrkuLrkvovvvIznoJTnqbbkuobljLrlnZfpk77lr7nlhbPplK7kvpvlupTpk77nrqHnkIbnm67moIfvvIzlpoLmiJDmnKzjgIHotKjph4/jgIHpgJ/luqbjgIHlj6/pnaDmgKfjgIHpo47pmanpmY3kvY7jgIHlj6/mjIHnu63mgKflkozngbXmtLvmgKfnmoTlvbHlk43vvIzmjIflh7rkuobljLrlnZfpk77lnKjpo5/lk4HkvpvlupTpk77jgIHlm73pmYXnianmtYHjgIHnvZHnu5zlronlhajnrYnor7jlpJrpoobln5/nmoTlupTnlKjjgIJTYWJlcmkgZXQgYWwuWzhd5ZyoMjAxOeW5tOWPkeihqOeahOiuuuaWh+KAnEJsb2NrY2hhaW4gVGVjaG5vbG9neSBhbmQgSXRzIFJlbGF0aW9uc2hpcHMgdG8gU3VzdGFpbmFibGUgU3VwcGx5IENoYWluIE1hbmFnZW1lbnTigJ3ns7vnu5/ku4vnu43kuobljLrlnZfpk77lnKjkvpvlupTpk77nrqHnkIbkuK3nmoTlupTnlKjvvIzlubbku47nu4/mtY7jgIHnpL7kvJrlkoznjq/looPkuInkuKrnu7TluqbpmJDph4rkuobljLrlnZfpk77lnKjlj6/mjIHnu63kvpvlupTpk77nvZHnu5zkuK3nmoTkvJjlir875Z+65LqO5a+55paH54yu55qE5Zue6aG+77yM5bCG5Yy65Z2X6ZO+5oqA5pyv5bqU55So6Z2i5Li055qE6Zqc56KN5YiG5Li65Zub5Liq5pa56Z2iOue7hOe7h+mXtOOAgee7hOe7h+WGheOAgeaKgOacr+WSjOWklumDqOmanOeijTvmnIDlkI7mj5Dlh7rkuobmnKrmnaXnmoTnoJTnqbbmlrnlkJHku6XmnInmlYjop6PlhrPljLrlnZfpk77nmoTmioDmnK/pmpznoo3vvIzkvb/ljLrlnZfpk77mm7Tlpb3lnLDlupTnlKjliLDkvpvlupTpk77nrqHnkIbkuK3jgILov5nkupvmlofnjK7lvJXpoobkuobljLrlnZfpk77lnKjkvpvlupTpk77poobln5/nmoTlupTnlKjnoJTnqbbvvIzlubbkvb/nm7jlhbPnoJTnqbblvpfku6XkuI3mlq3mt7HljJbjgIIg5YWz6ZSu6K+N5YWx546w5YiG5p6Q5pi+56S6KOWmguihqDHmiYDnpLop77yM5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So5Li76aKY6L6D5aSa77yM5LuO5Yy65Z2X6ZO+44CB5L6b5bqU6ZO+44CB5pm66IO95ZCI57qm5Yiw6aOf5ZOB5L6b5bqU6ZO+44CB5L6b5bqU6ZO+57up5pWI44CB5b2x5ZON44CB5oyR5oiY44CB5Y+v5oyB57ut5oCn562J44CC6L+b5LiA5q2l6YCa6L+H5YWz6ZSu6K+N6IGa57G75YiG5p6QKOWmguihqDLmiYDnpLop5Y+R546w77yM56CU56m255qE54Ot54K55Li76aKY5Li76KaB5raJ5Y+K5Yy65Z2X6ZO+5oqA5pyv44CB5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So6aKG5Z+f44CB5a+55L6b5bqU6ZO+55qE5b2x5ZON44CB5pyq5p2l5oyR5oiY562J5pa56Z2i44CC5Z+65LqO5q2k77yM5LiL6Z2i5bCG5Zu057uV5Lul5LiL5LqU5Liq5pa56Z2i6Zeu6aKY5a+5546w5pyJ5paH54yu6L+b6KGM6L+w6K+EOigxKeS7gOS5iOaYr+WMuuWdl+mTvuaKgOacrz8oMinkuLrku4DkuYjopoHlnKjkvpvlupTpk77kuK3ono3lhaXljLrlnZfpk77mioDmnK8/KDMp5Yy65Z2X6ZO+5oqA5pyv5Li76KaB5bqU55So5Zyo5L6b5bqU6ZO+55qE5ZOq5Lqb6aKG5Z+fPyg0Kei/meS6m+W6lOeUqOe7meS+m+W6lOmTvuW4puadpeS7gOS5iOW9seWTjT8oNSnmnKrmnaXpnaLkuLTlk6rkupvmjJHmiJg/IOihqDEg5YWz6ZSu6K+N5YWx546w5YiG5p6QICDooagyIOWFs+mUruivjeiBmuexu+e7k+aenCAg5LiJ44CB5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So56CU56m25Li76aKY546w54q26L+w6K+EICjkuIAp5Yy65Z2X6ZO+5oqA5pyvOuamguW/teOAgeS9nOeUqOS4juexu+WeiyDljLrlnZfpk77mnIDliJ3kvZzkuLrkuIDnp43mlK/mjIHliqDlr4botKfluIHpoobln5/kuqTmmJPnmoTmioDmnK/ogIzlh7rnjrBbMV3jgIJDaHJpc3RpZGlzIGFuZCBEZXZldHNpb2tpb3Rpc1s5XeWwhuWMuuWdl+mTvuWumuS5ieS4uuKAnOWcqOe9kee7nOaIkOWRmOS5i+mXtOWkjeWItuWSjOWFseS6q+eahOWIhuW4g+W8j+aVsOaNrue7k+aehOKAneOAgkFsLVNhcWFmIGFuZCBTZWlkbGVyWzEwXeWImeWwhuWMuuWdl+mTvuWumuS5ieS4uuKAnOWIhuW4g+W8j+aVsOWtl+WIhuexu+i0puaIluS8muiuoei0puewv+KAneOAguWcqOatpOWfuuehgOS4iu+8jFJpc2l1cyBhbmQgU3BvaHJlclsxMV3lr7nljLrlnZfpk77mioDmnK/nu5nlh7rkuobkuIDkuKrovoPmraPlvI/nmoTlrprkuYnvvIzljbPigJzljLrlnZfpk77mioDmnK/mmK/mjIfkuIDnp43nlKjkuo7ku6XliqDlr4bmlrnlvI/mjZXojrflkozlrZjlgqjnvZHnu5zlj4LkuI7ogIXkuYvpl7TkuIDoh7TnmoTjgIHkuI3lj5jnmoTjgIHnur/mgKfnmoTkuovliqHml6Xlv5fnmoTlrozlhajliIbluIPlvI/ns7vnu5/jgILlnKjlip/og73kuIrnsbvkvLzkuo7liIbluIPlvI/liIbnsbvotKbvvIznlLHnvZHnu5zlhoXmiYDmnInlj4LkuI7kuqTmmJPnmoTlkITmlrnkuIDoh7Tkv53lrZjjgIHmm7TmlrDlkozpqozor4HjgILor6XmioDmnK/liqDlvLrkuobnvZHnu5zpgI/mmI7luqbvvIzlubbnoa7kv53mnIDnu4jlnKjns7vnu5/ojIPlm7TlhoXlsLHmlbTkuKrkuqTmmJPljoblj7LnmoTmnInmlYjmgKfovr7miJDlhbHor4bigJ3jgILlsL3nrqHnu5nlh7rkuobov5nkuKrmraPlvI/lrprkuYnvvIzkvYbmmL7nhLbljLrlnZfpk77ov5jmnInkuIDkupvlhbbku5bnibnlvoHvvIzlpoLljrvkuK3lv4PjgIHljrvkuK3ku4vjgIHpmLLnr6HmlLnnrYnjgILlm73lhoXlrabogIXnjovlhYPlnLDnrYlbMTJd57u86L+w5LqG5pyJ5YWz5Yy65Z2X6ZO+5oqA5pyv55qE5YaF5ra177yM5bCG5YW25YiG5Li65LqU57G7OuS4gOaYr+WfuuS6juaVsOaNrueahOinhuinkuWwhuWMuuWdl+mTvuWumuS5ieS4uuS4gOenjeaVsOaNrue7k+aehOaIluaVsOaNruW6kzvkuozmmK/ln7rkuo7orrDotKbnmoTop4bop5LlsIbljLrlnZfpk77lrprkuYnkuLrkuIDnp43liIbluIPlvI/orrDotKbnmoTlupXlsYLmioDmnK875LiJ5piv5Z+65LqO5Y2P6K6u55qE6KeG6KeS5bCG5Yy65Z2X6ZO+5a6a5LmJ5Li65LiA56eN5LqS6IGU572R5Y2P6K6uO+Wbm+aYr+WfuuS6juaKgOacr+eahOinhuinkuWwhuWMuuWdl+mTvuWumuS5ieS4uuS4gOenjeeUseWkmuenjeaKgOacr+aehOaIkOeahOaWsOaKgOacr+aWueahiDvkupTmmK/ln7rkuo7nu4/mtY7nmoTop4bop5LlsIbljLrlnZfpk77lrprkuYnkuLrkuIDnp43ku7flgLzkupLogZTnvZHnu5zjgILku47kvpvlupTpk77op4bop5LmnaXnnIvvvIzljLrlnZfpk77mioDmnK/lj6/ku6XnkIbop6PkuLrkuI7kuqTmmJPnmoTljrvkuK3ku4vljJbnm7jlhbPvvIzljbPml6DpobvkuK3ku4vmnLrmnoTmnaXpqozor4HkuqTmmJPlubbkuLrkuqTmmJPmj5Dkvpvlj6/kv6HluqbnmoTmioDmnK9bMTNd44CCIOWMuuWdl+mTvuaKgOacr+S4u+imgeino+WGs+S6pOaYk+eahOS/oeS7u+WSjOWuieWFqOmXrumimO+8jOmSiOWvuei/meS4qumXrumimO+8jOS4u+imgeacieWbm+mhueaguOW/g+aKgOacr++8jOWMheaLrOWIhuW4g+W8j+WtmOWCqOOAgemdnuWvueensOWKoOWvhuOAgeWFseivhuacuuWItuOAgeaZuuiDveWQiOe6plsxNC0xN13jgILljLrlnZfpk77mioDmnK/lhbfmnInljrvkuK3lv4PljJbjgIHljrvkv6Hku7vjgIHlhazlvIDpgI/mmI7jgIHlvIDmlL7mgKfjgIHpmLLnr6HmlLnjgIHlj6/ov73muq/mgKfjgIHlronlhajlj6/pnaDnrYnnibnngrlbMTgtMTld44CC5Yy65Z2X6ZO+5oqA5pyv55qE6L+Z5Lqb54m55oCn5oSP5ZGz552A5YW25bCG5a+55L6b5bqU6ZO+566h55CG6K+45aaC5oiQ5ZGY5YWz57O744CB5Y2P5L2c44CB5L+h5Lu75ZKM5Z+65LqO6KeS6Imy55qE5LqR5pWP5o235oCn5pON5L2c5qih5Z6L55qE5Y+Y5YyW562J5pa56Z2i5Lqn55Sf5b2x5ZONWzEzXeOAguWug+iDveacieaViOino+WGs+e9kee7nOS/oeaBr+S4jeWvueensO+8jOWFtuacgOS4uuaguOW/g+eahOS7t+WAvOWcqOS6juWvuee9kee7nOS4reeahOavj+S4gOS4quiKgueCueWFheWIhui1i+iDve+8jOino+WGs+S6pOaYk+eahOS/oeS7u+acuuWItuWSjOa/gOWKseacuuWItumXrumimFsyMF3jgIIg5qC55o2u6K+75Y+W5Yy65Z2X6ZO+44CB5ZCR5Yy65Z2X6ZO+5o+Q5Lqk5Lqk5piT5bm25Y+C5LiO5YWx6K+G5rWB56iL5o6n5Yi2562J5pa56Z2i55qE6K6/6Zeu5p2D6ZmQ77yM5Y+v5Lul5bCG5Yy65Z2X6ZO+5Yy65YiG5Li65LiJ56eN5Li76KaB57G75Z6LOuWFrOaciemTvihwdWJsaWMgYmxvY2tjaGFpbinjgIHnp4HmnInpk74ocHJpdmF0ZSBibG9ja2NoYWluKeWSjOiBlOebn+mTvihjb25zb3J0aXVtIGJsb2NrY2hhaW4pWzE5XeOAguWcqOWFrOaciemTvuS4re+8jOavj+S4quS6pOaYk+mDveaYr+WFrOW8gOeahO+8jOeUqOaIt+WPr+S7peS/neaMgeWMv+WQjeOAgue9kee7nOmAmuW4uOacieS4gOS4qua/gOWKseacuuWItuadpem8k+WKseWPguS4juiAheWKoOWFpee9kee7nOOAguavlOeJueW4geWSjOS7peWkquWdiuWwseaYr+WFrOaciemTvueahOS+i+WtkOOAguWcqOacieadg+mZkOiuuOWPr+eahOWMuuWdl+mTvuS4re+8jOWPguS4juiAhemcgOimgeiOt+W+l+WKoOWFpeeahOmCgOivt+aIluiuuOWPr++8jOiuv+mXruadg+mZkOeUseaIkOWRmOiBlOebnyjogZTnm5/pk74p5oiW5Y2V5Liq57uE57uHKOengeaciemTvinmjqfliLbjgILkvpvlupTpk77lsLHmmK/kuIDnp43ogZTnm5/pk77vvIzmiJDlkZjpgJrov4fmjojmnYPlkI7miY3og73liqDlhaXkuI7pgIDlh7rnvZHnu5zjgILlnKjogZTnm5/pk77kuIrvvIzkvpvlupTpk77lkITlj4LkuI7mlrnlhbHkuqvkuIDkuKrpgI/mmI7lj6/pnaDnmoTkv6Hmga/lubPlj7Dlkozov73muq/mtYHnqIvvvIzlkIzml7bvvIzlkITlj4LkuI7mlrnkuZ/lj6/ku6Xln7rkuo7ljLrlnZfpk77mlbDmja7lvIDlsZXlpoLkvpvlupTpk77ph5Hono3jgIHnsr7lh4bokKXplIDnrYnmnI3liqFbMjFd44CCICjkuowp5L6b5bqU6ZO+5bqU55So5Yy65Z2X6ZO+5oqA5pyv55qE6amx5Yqo5Zug57SgIOWFs+S6juS4uuS7gOS5iOimgeWcqOS+m+W6lOmTvuS4reW6lOeUqOWMuuWdl+mTvuaKgOacr++8jOWbveWkluWtpuiAhei/kOeUqOaKgOacr+aOpeWPl+WSjOmHh+eUqOeQhuiuuuS7peWPiuihjOS4uueQhuiuuu+8jOS7jue7qeaViOmihOacn+OAgeekvuS8muW9seWTjeOAgeacieWIqeadoeS7tuOAgeWvueaKgOacr+eahOS/oeS7u+OAgee7hOe7h+mXtOeahOS/oeS7u+etieaWuemdouWIhuaekOS6huS+m+W6lOmTvumHh+eUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oFsyMl3vvIzlubblr7nmr5TliIbmnpDkuobljbDluqblkoznvo7lm73mg4Xmma/kuIvnmoTlt67lvIJbMjNd44CC5L6b5bqU6ZO+6YeH55So5Yy65Z2X6ZO+5oqA5pyv55qE6amx5Yqo5Zug57Sg5aaC5Zu+MeaJgOekuuOAgiDlm74xIOS+m+W6lOmTvumHh+eUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oCAg6LWE5paZ5p2l5rqQOueslOiAheagueaNrkZyYW5jaXNjbyBhbmQgU3dhbnNvbiAoMjAxOClbMjJd5Y+KUXVlaXJveiBhbmQgV2FtYmEgKDIwMTgpWzIzXeeahOebuOWFs+aWh+eMruaVtOeQhuOAgiAg6aaW5YWI77yM57up5pWI6aKE5pyf5piv5L6b5bqU6ZO+5bqU55So5Yy65Z2X6ZO+5oqA5pyv55qE5pyA6YeN6KaB55qE6amx5Yqo5Yqb44CC5bey5pyJ56CU56m26KGo5piO77yM5Liq5L2T6YeH57qz5ZKM5L2/55So5oqA5pyv55qE5oSP5oS/5Zyo5b6I5aSn56iL5bqm5LiK5Y+W5Yaz5LqO57up5pWI6aKE5pyfWzI0LTI2Xe+8jOiAjOWMuuWdl+mTvuaKgOacr+W6lOeUqOWvueS+m+W6lOmTvuS7juaViOeOh+WSjOS6p+WTgei0qOmHj+WIsOWFs+mUrua1geeoi+eahOaUuei/m+aWuemdoumDveS6p+eUn+S6huW+iOmrmOeahOmihOacn1s3XeOAguWFtuasoeaYr+ekvuS8muW9seWTjeWboOe0oOOAguekvuS8muW9seWTjeaYr+aMh+S4quS9k+WvueWFtuS7luS6uuiupOS4uuW6lOivpeS9v+eUqOaWsOaKgOacr+eahOmHjeimgeeoi+W6pueahOiupOefpVsyN13jgILljLrlnZfpk77lupTnlKjmmK/kuIDnp43igJznpL7kvJrmgKfigJ3mioDmnK/vvIzlpoLmnpzpmo/nnYDop4TojIPmgKfljovlipvlkoznlKjmiLfigJzkuLTnlYzmlbDph4/igJ3nmoTlop7liqDvvIzov5vogIzlrp7njrDnvZHnu5zmlYjlupTnmoTlop7liqDvvIzov5nnp43mg4XlhrXkuIvlj6/og73kvJrlr7zoh7Tmm7Tpq5jnmoTkvb/nlKjmhI/mhL9bMjJd44CC5Zug5q2k5L6b5bqU6ZO+5oiQ5ZGY6Ze0546w5pyJ5YWz57O75a+55piv5ZCm6YeH55So6Leo572R57uc55qE5Yy65Z2X6ZO+5oqA5pyv5Lya5Lqn55Sf6YeN5aSn5b2x5ZON44CC5YaN5qyh5piv5L6/5Yip5p2h5Lu25Zug57Sg44CC5L6/5Yip5p2h5Lu25piv5oyH4oCc5Liq5L2T6K6k5Li657uE57uH5oqA5pyv5Z+656GA6K6+5pa96LWW5Lul5pSv5oyB57O757uf5L2/55So55qE56iL5bqm4oCdWzI3XeOAguWwseWMuuWdl+mTvuiAjOiogO+8jOWwseaYr+aMh+S4quS9k+Wvuee7hOe7h+S4reWPr+eUqOS6juaUr+aMgeWMuuWdl+mTvuS9v+eUqOeahOi1hOa6kOeahOeQhuino+OAguW3suacieeglOeptuihqOaYju+8jOWMheaLrOiuoeeul+acuuOAgee9kemAn+OAgeS4juWFtuS7luezu+e7n+eahOmbhuaIkOetieWcqOWGheeahOS+v+WIqeadoeS7tumDveS8muW9seWTjeebuOWFs+aKgOacr+eahOmHh+e6s+WSjOS9v+eUqFsyOC0zMF3jgILmnIDlkI7mmK/kv6Hku7vlm6DntKDvvIzljIXmi6zlr7nmioDmnK/nmoTkv6Hku7vku6Xlj4rkvpvlupTpk77liKnnm4rnm7jlhbPogIXkuYvpl7TnmoTkv6Hku7vjgILmioDmnK/lhazkv6HlipvkvJrlvbHlk43kurrku6zlr7nmioDmnK/nmoTmgIHluqbvvIzov5vogIzlvbHlk43kurrku6zkvb/nlKjmioDmnK/nmoTmhI/mhL/jgIJUaGF0Y2hlciBldCBhbC5bMzFd5oyH5Ye677yM57y65LmP5a+5SVTnmoTkv6Hku7vlj6/og73lr7zoh7TnlKjmiLflh7rkuo7lr7nlj6/pnaDmgKfmiJbmgKfog73nvLrkuY/kv6Hlv4PogIzlgZzmraLkvb/nlKjor6XmioDmnK/jgILlpoLmnpznlKjmiLfmhI/or4bliLDljLrlnZfpk77mioDmnK/kuI3lronlhajvvIzku5bku6zlsIbkuI3kvJrkvb/nlKjor6XmioDmnK/jgILlvZPnhLbvvIzpmo/nnYDnlKjmiLflr7nmioDmnK/nmoTkuobop6PlkozlrabkuaDotorlpJrvvIzku5bku6zmi6XmnInnmoTnu4/pqozlkoznn6Xor4blsLHotorlpJrvvIzmioDmnK/lnKjku5bku6znnIvmnaXlsLHotorlj6/kv6HjgILlm6DmraTvvIzlr7nmioDmnK/nmoTkv6Hku7vmiJDkuLrkuobop6PnlKjmiLfkvb/nlKjmhI/mhL/nmoTkuIDkuKrph43opoHlm6DntKDjgILkvpvlupTpk77liKnnm4rnm7jlhbPogIXkuYvpl7TnmoTkv6Hku7vmmK/mjIfkvpvlupTpk77nvZHnu5zkuK3kuKTkuKrmiJbkuKTkuKrku6XkuIrnmoTmiJDlkZjkuYvpl7Tnm7jkupLkvp3otZblubbnu7TmiqTlvbzmraTmnJ/mnJvnmoTmhI/mhL9bMjNd44CC5L6b5bqU6ZO+5Yip55uK55u45YWz6ICF5LmL6Ze055qE5L+h5Lu75piv5bCG5Yy65Z2X6ZO+5oqA5pyv5bqU55So5LqO5L6b5bqU6ZO+572R57uc5Lit55qE5Z+65pys5YmN5o+Q44CCIOatpOWklu+8jOi/mOacieWtpuiAheS7juS+m+W6lOmTvueuoeeQhuebruagh+inkuW6puWIhuaekOW6lOeUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oO+8jOavlOWmguWFi+acjeS+m+W6lOmTvuS4reaWreS4juWkjeadguaAp1szMi0zM13vvIznoa7kv53kuqflk4HnmoTlronlhajjgIHnnJ/lrp7jgIHlkIjms5VbMzQtMzVd77yM5Lul5Y+K5YWs5YWx5a6J5YWo5LiO5Y+N6IWQ6LSlWzM2LTM3XeetieOAgiAo5LiJKeWMuuWdl+mTvuWcqOS+m+W6lOmTvuS4reeahOS4u+imgeW6lOeUqOmihuWfnyDljLrlnZfpk77mioDmnK/otbfliJ3kuLvopoHlupTnlKjkuo7ph5Hono3ooYzkuJrvvIzkuYvlkI7pgJDmuJDmi5PlsZXliLDlhpzkuJrjgIHpm7bllK7jgIHljLvnlpfjgIHliLbpgKDkuJrku6Xlj4rog73mupDnrYnlpJrooYzkuJrvvIzlm73lhoXlpJbnoJTnqbbmma7pgY3orqTkuLrnianmtYHlkozkvpvlupTpk77poobln5/mmK/ov5npobnmioDmnK/og73lpJ/luKbmnaXlvbvlupXlj5jpnannmoTkuLvopoHpoobln5/kuYvkuIBbMzgtNDJd44CCIOmmluWFiO+8jOKAnOWMuuWdl+mTvivkvpvlupTpk77ph5Hono3igJ3mmK/lm73lhoXlpJbnoJTnqbbnmoTng63pl6jpoobln5/jgILljLrlnZfpk77mioDmnK/nmoTov5DnlKjog73op6PlhrPkvKDnu5/kvpvlupTpk77ph5Hono3kuK3kvpvlupTllYbkv6HnlKjkv6Hmga/orrDlvZXkuI3lhajjgIHkuoznuqfku6XkuIrnmoTkvpvlupTllYbkuI7nu4/plIDllYbpmr7ojrfotLfmrL7jgIHkuK3lsI/lvq7kvIHkuJrpmr7ojrfmjojkv6HjgIHmjojkv6Hpop3luqbpmr7ku6Xnoa7orqTjgIHono3otYTlkI7lsaXnuqbjgIHmuIXnrpfmu57lkI7nrYnpl67pophbMjFd44CC5Yy65Z2X6ZO+5Zyo5o+Q6auY5L6b5bqU6ZO+6YeR6J6N6KGM5Lia55qE6YCP5piO5bqm44CB5omp5aSn5pyN5Yqh5a+56LGh44CB5o+Q6auY5pWI546H44CB6ZmN5L2O6aOO6Zmp44CB5Yqg5by66LWE6YeR5rWB566h55CG5Lit5YW35pyJ5piO5pi+5LyY5Yq/WzQzXeOAguWMuuWdl+mTvuWcqOWbveWGheS+m+W6lOmTvumHkeiejeW6lOeUqOahiOS+i+ihqOeOsOS4uuS7peaguOW/g+S8geS4muS4uuS4u+WvvOeahOKAnENoYWluZWQgRmluYW5jZeKAneWMuuWdl+mTvumHkeiejeW5s+WPsOOAgeS7peaKgOacr+aPkOS+m+aWueS4uuS4u+WvvOeahOiFvuiur+KAnOWMuuWdl+mTvivkvpvlupTpk77ph5Hono3op6PlhrPmlrnmoYjigJ3jgIHku6Xph5Hono3mnLrmnoTkuLrkuLvlr7znmoTlubPlronpk7booYzkvpvlupTpk77lupTmlLbotKbmrL7mnI3liqHlubPlj7DnrYnkuInkuKrkuLvopoHnsbvlnotbNDRd44CC5Zyo5Zu95aSW77yM6YeR6J6N56eR5oqA5YWs5Y+4T0dZRG9jc+aehOW7uuWMuuWdl+mTvui0uOaYk+mHkeiejeW5s+WPsFdhdmXvvIzliKnnlKjliIbluIPlvI/otKbmnKzlr7nmlofku7blkozllYblk4HlnKjov5DovpPov4fnqIvkuK3nmoTmiYDmnInmnYPov5vooYznrqHnkIbvvIzmm7/ku6PkvKDnu5/nmoTlkITpobnnurjotKjljZXor4HvvIzku6Xmj5Dpq5jlm73pmYXotLjmmJPnmoTkuqTmmJPmlYjnjoflkozlronlhajmgKfvvIzljrvpmaTnuqDnurfjgIHkvKrpgKDlk4HlkozkuI3lv4XopoHnmoTpo47pmalbNDRd44CCIOWFtuasoe+8jOeJqea1geS+m+W6lOmTvumihuWfn+aYr+WMuuWdl+mTvuacgOacieW6lOeUqOWJjeaZr+eahOmihuWfn+S5i+S4gFs0NV3jgILljLrlnZfpk77mioDmnK/nmoTliIbluIPlvI/orrDotKbnibnmgKfog73kvb/kvpvlupTpk77kuIrnmoTkv6Hmga/kv53mjIHkuIDoh7TvvIzlkIToioLngrnmiJDlkZjlhbHkuqvlhazlvIDnmoTkv6Hmga/otYTmupDvvIzmnInliKnkuo7op6PlhrPkv6Hmga/kuI3lr7nnp7Dpl67popg75pm66IO95ZCI57qm5py65Yi25Y+v5Zyo5peg6ZyA56ys5LiJ5pa55LuL5YWl55qE5oOF5Ya15LiL5oyJ6KeE5YiZ6Ieq5Yqo55Sf5oiQ5ZCI57qm77yM5bm25Zyo5ruh6Laz5Lqk5piT5p2h5Lu25pe26Ieq5Yqo5omn6KGM5ZCI57qm5p2h5qy+77yM6IO95o+Q6auY5ZCE546v6IqC5pSv5LuY5ZKM5Lqk5piT5pWI546H77yM6YG/5YWN6LWE6YeR5bu26L+f6aOO6ZmpO+aXtumXtOaIs+WSjOa6r+a6kOmYsuS8quaKgOacr+WPr+WvueeJqea1geS+m+W6lOmTvuS4iueahOS6p+WTgei/m+ihjOWFqOmTvui3n+i4qu+8jOWunueOsOWuieWFqOOAgemrmOaViOOAgeWPr+mdoOeahOS/oeaBr+S8oOi+kzvpnZ7lr7nnp7DliqDlr4bmioDmnK/lj6/ku6Xkv53or4HmlbDmja7kuI3ooqvnr6HmlLnvvIzmnInliqnkuo7kuqTmmJPkuLvpopjkuYvpl7Tkv6Hku7vlhbPns7vnmoTlu7rnq4tbNDZd44CC5Zyo5ZCE5Zu95pS/5bqc5ZKM55u45YWz5LyB5Lia55qE5pSv5oyB5LiL77yM5LiA5Lqb4oCc5Yy65Z2X6ZO+K+eJqea1geS+m+W6lOmTvuKAnemhueebruW+l+S7peWunui3te+8jOWmguS4uem6puiIqui/kOWFrOWPuOmprOWjq+WfuuS4jklCTeeahOWFqOeQg+i3qOWig+eJqea1geezu+e7n1s0N13jgIHmlrDliqDlnaHlhazlj7hZb2plZeeahOi/kOi+k+S8mOWMluezu+e7n1s0OF3jgIHnkZ7lo6vlhazlj7hNb2R1beS4juiLj+m7juS4luWkp+WtpuWQiOS9nOiuvuiuoeeahOWMu+iNr+i/kOi+k+ezu+e7n1s3XeOAgeiLseWbveWFrOWPuEV2ZXJsZWRnZXLln7rkuo7ljLrlnZfpk77nmoTkuqflk4HmnaXmupDpqozor4Hns7vnu59bNDld562J44CC6L+Z5Lqb6aG555uu55qE5oiQ5Yqf5a6e5pa95Li65Yy65Z2X6ZO+5bqU55So56ev57Sv5LqG5a6d6LS157uP6aqM44CCIOacgOWQju+8jOWMuuWdl+mTvuWcqOWFtuS7lumihuWfn+S+m+W6lOmTvuS4iueahOW6lOeUqOS9k+eOsOS6huWMuuWdl+mTvuaKgOacr+W6lOeUqOeahOWkmuagt+aAp++8jOWFt+S9k+ihqOeOsOS4uuWcqOWGnOS6p+WTgeOAgemjn+WTgeOAgeWMu+iNr+OAgeeUteWKm+OAgeWGm+S6i+S+m+W6lOmTvuetieS8l+WkmumihuWfn+eahOWFt+S9k+i/kOeUqOOAguWMuuWdl+mTvuWcqOWGnOS6p+WTgVs1MF3lkozpo5/lk4FbNTFd5L6b5bqULi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKV3JpdGUgYW4gYWJzdHJhY3QgZm9yIHRoaXMgcGFwZXIgb24gdGhlIGRlc2lnbiBvZiBhIHNvZnR3YXJlIHRlc3RpbmcgYXV0b21hdGlvbiBmcmFtZXdvcmsgZm9yICoqMS4gSW50cm9kdWN0aW9uKioKClNvIGZhciwgdGhlIHJhcGlkIGRldmVsb3BtZW50IG9mIGluZm9ybWF0aW9uIHRlY2hub2xvZ3kgaGFzIGxlZCB0byB0aGUgYXBwbGljYXRpb24gb2Ygc29mdHdhcmUgcHJvZHVjdHMgaW4gdmFyaW91cyBzZWN0b3JzIG9mIHNvY2lldHkuIE5hdHVyYWxseSwgdGhlIHF1YWxpdHkgb2Ygc29mdHdhcmUgcHJvZHVjdHMgaGFzIGJlY29tZSBhIGNvbW1vbiBmb2N1cyBvZiBhdHRlbnRpb24uIFRvIGVuc3VyZSBwcm9kdWN0IHF1YWxpdHksIHNvZnR3YXJlIHRlc3Rpbmcgd2lsbCByZW1haW4gYW4gZWZmZWN0aXZlIG1ldGhvZCBmb3Igc29mdHdhcmUgcHJvZHVjdCBxdWFsaXR5IGFzc3VyYW5jZSBmb3IgYSBsb25nIHRpbWUgaW4gdGhlIGZ1dHVyZS4gQXV0b21hdGVkIHRlc3RpbmcgaXMgYSB3aWRlbHkgZGlzY3Vzc2VkIGRpcmVjdGlvbiBpbiB0b2RheSdzIHNvZnR3YXJlIHRlc3RpbmcgaW5kdXN0cnkuIEN1cnJlbnRseSwgcGVyZm9ybWFuY2UgdGVzdGluZyBhdXRvbWF0aW9uIGlzIHRoZSBtb3N0IG1hdHVyZSBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgaW5kdXN0cnkuIEFzIGZvciBzeXN0ZW0gdGVzdGluZyBhdXRvbWF0aW9uLCBpbmNsdWRpbmcgVUkgdGVzdGluZyBhdXRvbWF0aW9uLCB1bml0IHRlc3RpbmcgYXV0b21hdGlvbiwgYW5kIGZ1bmN0aW9uYWwgdGVzdGluZyBhdXRvbWF0aW9uLCBhbHRob3VnaCBwb3dlcmZ1bCB0aGlyZC1wYXJ0eSBzb2Z0d2FyZSB0ZXN0aW5nIHRvb2xzIHN1Y2ggYXMgUVRQLCBXSU5SVU5ORVIsIGFuZCBTRUxFTklVTSBjYW4gYmUgdXNlZCBhcyBzb2x1dGlvbnMsIGluIHByYWN0aWNlLCBjb21wYW5pZXMgZmluZCBpdCBkaWZmaWN1bHQgdG8gc3VjY2Vzc2Z1bGx5IGltcGxlbWVudCB0ZXN0IGF1dG9tYXRpb24gcmVseWluZyBvbiBhIHNpbmdsZSB0b29sLiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoZSBsYWNrIG9mIGEgY29tcGxldGUgc2V0IG9mIHRlc3QgYXV0b21hdGlvbiBzb2x1dGlvbnMsIGkuZS4sIHRoZSBhYnNlbmNlIG9mIGEgdGVzdGluZyBmcmFtZXdvcmsuIFRoZXJlZm9yZSwgbW9yZSBtYW5wb3dlciBpcyBvZnRlbiByZXF1aXJlZCB0byBsZWFybiBob3cgdG8gdXNlIHRoZSB0b29scywgd3JpdGUgY29tcGxleCB0ZXN0IHNjcmlwdHMsIG1hbnVhbGx5IG9idGFpbiB0ZXN0IHJlc3VsdHMgYW5kIGFuYWx5emUgdGhlbSwgYW5kIGRlYWwgd2l0aCB0aGUgZGFtYWdlIGNhdXNlZCBieSBjaGFuZ2VzIGluIHByb2plY3QgcGVyc29ubmVsLiBIZW5jZSwgYnVpbGRpbmcgYSBjb21wbGV0ZSB0ZXN0IGF1dG9tYXRpb24gZnJhbWV3b3JrIGlzIGFuIGluZXZpdGFibGUgdHJlbmQuIAoKQW4gYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3JrIGlzIGEgY29tcHJlaGVuc2l2ZSBzb2x1dGlvbiBmb3IgdGVzdCBhdXRvbWF0aW9uLCBwbGF5aW5nIGEga2V5IHJvbGUgaW4gdGhlIHNwZWNpZmljIHdvcmsgb2Ygc29mdHdhcmUgdGVzdCBhdXRvbWF0aW9uLiBUaGUgaW5kdXN0cnkgaXMgYWN0aXZlbHkgY29uc3RydWN0aW5nIGF1dG9tYXRlZCB0ZXN0aW5nIGZyYW1ld29ya3MgdGFpbG9yZWQgdG8gdGhlIG5lZWRzIG9mIHRoZWlyIHJlc3BlY3RpdmUgY29tcGFuaWVzLiBDb21tb25seSBtZW50aW9uZWQgYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3JrcyBpbiB0aGUgaW5kdXN0cnkgaW5jbHVkZSBkYXRhLWRyaXZlbiBhdXRvbWF0ZWQgdGVzdGluZyBmcmFtZXdvcmtzLCBrZXl3b3JkLWRyaXZlbiB0ZXN0aW5nIGZyYW1ld29ya3MsIGFuZCB0YWJsZS1kcml2ZW4gYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3Jrcy4gVGhlc2UgdGVzdGluZyBmcmFtZXdvcmtzIGltcHJvdmUgdGVzdGluZyBlZmZpY2llbmN5IGluIGNlcnRhaW4gc3RhZ2VzIG9mIHNvZnR3YXJlIHRlc3RpbmcsIGJ1dCBhbHNvIGludHJvZHVjZSBvdGhlciBpc3N1ZXMuIFRoaXMgYXJ0aWNsZSBhcmd1ZXMgdGhhdCB0ZXN0aW5nIGZyYW1ld29ya3Mgc2hvdWxkIG5vdCBiZSBkZXNpZ25lZCBmb3Igc3BlY2lmaWMgdGVzdGluZyBhY3Rpdml0aWVzIGJ1dCBzaG91bGQgYmUgY2F0ZWdvcml6ZWQgYWNjb3JkaW5nIHRvIGRldmVsb3BtZW50IHR5cGVzLCB3aGljaCBpcyBhIG1vcmUgcmVhc29uYWJsZSBhcHByb2FjaC4gVGhpcyBwYXBlciBwcm9wb3NlcyBhIHRlc3QgZnJhbWV3b3JrIHN1aXRhYmxlIGZvciBpdGVyYXRpdmUgZGV2ZWxvcG1lbnQuCgoqKjIuIERlc2lnbiBvZiB0aGUgU29mdHdhcmUgVGVzdGluZyBBdXRvbWF0aW9uIEZyYW1ld29yayBCYXNlZCBvbiBJdGVyYXRpdmUgU29mdHdhcmUgRGV2ZWxvcG1lbnQqKgoKKioyLjEgU29mdHdhcmUgVGVzdCBBdXRvbWF0aW9uKioKCkN1cnJlbnRseSwgc29mdHdhcmUgdGVzdCBhdXRvbWF0aW9uIHJlZmVycyB0byB0aGUgdXNlIG9mIHByb2dyYW0gZXhlY3V0aW9uIHRvIHJlcGxhY2UgbWFudWFsIHRlc3RpbmcsIHRodXMgcmVkdWNpbmcgbWFudWFsIHdvcmtsb2FkIGFuZCBpbXByb3ZpbmcgdGVzdGluZyBlZmZpY2llbmN5LiBBdXRvbWF0ZWQgdGVzdGluZyBmcmFtZXdvcmtzIGFyZSBjb21wcmVoZW5zaXZlIHNvbHV0aW9ucyB0aGF0IGFjaGlldmUgaGlnaC1lZmZpY2llbmN5LCBoaWdoLXF1YWxpdHkgYXV0b21hdGVkIHRlc3RpbmcuIEl0ZXJhdGl2ZSBkZXZlbG9wbWVudCBpcyBhIGdyYWR1YWwgZGV2ZWxvcG1lbnQgbWV0aG9kIHRoYXQgZGl2aWRlcyB0aGUgZW50aXJlIGRldmVsb3BtZW50IHByb2Nlc3MgaW50byBzZXZlcmFsIGl0ZXJhdGl2ZSBjeWNsZXMsIHdpdGggZWFjaCBjeWNsZSBwcm9kdWNpbmcgYSBydW5uYWJsZSBzb2Z0d2FyZS4gSXRlcmF0aXZlIGRldmVsb3BtZW50IGlzIHRoZSBtb3N0IHN1aXRhYmxlIGRldmVsb3BtZW50IGFjdGl2aXR5IGZvciB0ZXN0IGF1dG9tYXRpb24gYW5kIGNhbiBtYXhpbWl6ZSB0aGUgYmVuZWZpdHMgb2YgYXV0b21hdGVkIHRlc3RpbmcuIAoKSW4gaXRlcmF0aXZlIGRldmVsb3BtZW50LCBlYWNoIHNvZnR3YXJlIGRldmVsb3BtZW50IGN5Y2xlIGFkZHMgbmV3IGZlYXR1cmVzLCB3aGVyZSB0ZXN0ZXJzIGRlc2lnbiB0ZXN0cyBmb3IgdGhlIG5ldyBmZWF0dXJlcywgdHJhbnNpdGlvbiB0byBmdW5jdGlvbmFsIHZlcmlmaWNhdGlvbiwgZXhlY3V0ZSB0ZXN0cyBmb3IgbmV3IGZlYXR1cmVzLCBhbmQgcGVyZm9ybSByZWdyZXNzaW9uIHRlc3RpbmcgZm9yIGlzc3VlcyBkaXNjb3ZlcmVkIGluIHRoZSBwcmV2aW91cyByb3VuZCBvZiB0ZXN0aW5nLiBJbiB0aGVzZSB0ZXN0aW5nIGFjdGl2aXRpZXMsIGFjdGl2aXRpZXMgc3VjaCBhcyB0ZXN0IHZlcmlmaWNhdGlvbiwgbmV3IGZlYXR1cmUgdGVzdGluZywgYW5kIHJlZ3Jlc3Npb24gdGVzdGluZyBhcmUgZWFzeSB0byBhdXRvbWF0ZSBhbmQgc3VpdGFibGUgZm9yIGF1dG9tYXRpb24uIAoKSW4gdGhlIHRlc3RpbmcgcHJvY2VzcyAoYXMgc2hvd24gaW4gRmlndXJlIDEpOgoKMS4gQWZ0ZXIgdmVyc2lvbiB0cmFuc2l0aW9uIHRlc3RpbmcsIGZ1bmN0aW9uYWwgdmVyaWZpY2F0aW9uIGlzIGNvbmR1Y3RlZCBmaXJzdCB0byBwcm92ZSB0aGF0IG5vIG5ldyBzZXJpb3VzIGlzc3VlcyBoYXZlIGJlZW4gaW50cm9kdWNlZCBpbiB0aGUgdHJhbnNpdGlvbmVkIHZlcnNpb24uIEFwcHJvcHJpYXRlIHRlc3QgY2FzZXMgYXJlIHNlbGVjdGVkIGZyb20gdGhlIHNjcmlwdCBsaWJyYXJ5IGZvciB0ZXN0aW5nLgoyLiBSZWdyZXNzaW9uIHRlc3RpbmcgaXMgcGVyZm9ybWVkIGZvciBkZWZlY3RzIGZvdW5kIGluIHRoZSBwcmV2aW91cyBzdGFnZS4gVGhlIHVzZSBvZiBwcmV2aW91cyBzY3JpcHRzIGNhbiBwcmV2ZW50IHRoZSBhcmJpdHJhcmluZXNzIG9mIG1hbnVhbCB0ZXN0aW5nIGFuZCBhY2hpZXZlIGEgY29tcGxldGVseSByZXN0b3JlZCBvbi1zaXRlIHNjZW5hcmlvLgozLiBOZXcgZnVuY3Rpb25hbGl0eSBpcyB0ZXN0ZWQgdXNpbmcgbmV3IHRlc3Qgc2NyaXB0cy4gQWZ0ZXIgdGVzdGluZywgdGhlIG5ldyBmZWF0dXJlIHNjcmlwdHMgYXJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBzY3JpcHQgbGlicmFyeSBmb3IgdGhlIG5leHQgcm91bmQgb2YgdHJhbnNpdGlvbiB0ZXN0aW5nIGFuZCByZWdyZXNzaW9uIHRlc3RpbmcuCgoqKkZpZ3VyZSAxKioKCkNsZWFybHksIHRlc3Qgc2NyaXB0cyBhcmUgcnVuIG11bHRpcGxlIHRpbWVzIHRocm91Z2hvdXQgdGhlIGVudGlyZSBpdGVyYXRpdmUgcHJvY2VzcywgbWFraW5nIHRoZWlyIHVzYWdlIGhpZ2hseSBlZmZpY2llbnQsIHdoaWNoIGRpcmVjdGx5IGltcHJvdmVzIHRoZSBvdXRwdXQtdG8taW5wdXQgcmF0aW8gb2YgYXV0b21hdGVkIHRlc3RpbmcuCgoqKjIuMiBEZXNpZ24gb2YgU29mdHdhcmUgVGVzdGluZyBBdXRvbWF0aW9uIEZyYW1ld29yayoqCgpUaGUgc29mdHdhcmUgdGVzdGluZyBhdXRvbWF0aW9uIGZyYW1ld29yayBpcyBhIGNvbXByZWhlbnNpdmUgc29sdXRpb24gZm9yIHRlc3QgYXV0b21hdGlvbiwgcHJvdmlkaW5nIGEgY29tcGxldGUgc2V0IG9mIHRlc3RpbmcgYWN0aXZpdGllcy4gSXQgY2VudHJhbGl6ZXMsIHNwZWNpYWxpemVzLCBhbmQgYWJzdHJhY3RzIHRoZSB3b3JrIG9mIHRlc3RlcnMuIEluIHRoZSB0ZXN0aW5nIGZyYW1ld29yaywgdGhlIHdvcmsgb2YgdGVzdGVycyBpcyBhcyBzaG93biBpbiBGaWd1cmUgMjoKCjEuICoqVGVzdCBEZXNpZ24qKjogVGVzdGVycyB1c2UgdmFyaW91cyB0ZXN0IGRlc2lnbiBtZXRob2RzIHN1Y2ggYXMgZXF1aXZhbGVuY2UgY2xhc3MgcGFydGl0aW9uaW5nLCBib3VuZGFyeSB2YWx1ZSBhbmFseXNpcywgYW5kIGNhdXNlLWVmZmVjdCBncmFwaGluZyB0byBjcmVhdGUgZGVzaWduIHBsYW5zIGFuZCB0ZXN0IGNhc2VzLCBhbmQgdXBsb2FkIHRoZSB0ZXN0IGNhc2VzIHRvIHRoZSB0ZXN0aW5nIGZyYW1ld29yay4KMi4gKipSZXN1bHQgQW5hbHlzaXMqKjogQW5hbHl6ZSB0aGUgdGVzdCByZXN1bHRzIGZlZWRiYWNrIGZyb20gZXhlY3V0aW5nIHRoZSB0ZXN0IGNhc2VzIGluIHRoZSB0ZXN0aW5nIGZyYW1ld29yay4KClRvIHJlbGlldmUgdGVzdGVycyBmcm9tIHRoZSBjb21wbGV4aXR5IG9mIHZhcmlvdXMgdGVzdGluZyBhY3RpdmkuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2UgaGVscCBtZSBkcmFmdCBhbiBvdXRsaW5lIGZvciBhIHJldmlldyBwYXBlciBvbiB0aGUgYXBwbGljYXRpb24gb2YgYXVnbWVudGVkIHJlYWxpdHkgdGVjaG5vbG9neSBpbiBpbmR1c3RyaWFsIG1haW50ZW5hbmNlLCB0YXJnZXRpbmcgaW5kdXN0cnkgcHJvZmVzc2lvbmFscy4KdXNlcjoKKipEZXNpZ24gb2YgRGlzdHJpYnV0ZWQgSGlnaC1Db25jdXJyZW5jeSBTeXN0ZW0gQXJjaGl0ZWN0dXJlIEJhc2VkIG9uIFBvbGFyREIqKgoKMCBJbnRyb2R1Y3Rpb24KClRoZSBkZW1hbmQgZm9yIGRpc3RyaWJ1dGVkIGhpZ2gtY29uY3VycmVuY3kgc3lzdGVtcyBoYXMgYmVlbiBncm93aW5nIHdpdGggdGhlIGNvbnRpbnVvdXMgZGV2ZWxvcG1lbnQgb2YgaW50ZXJuZXQgYXBwbGljYXRpb25zLiBBbiBpbXBvcnRhbnQgY2hhbGxlbmdlIGluIHRoaXMgY29udGV4dCBpcyBob3cgdG8gZGVzaWduIGEgcG93ZXJmdWwsIHJlbGlhYmxlLCBhbmQgc3RhYmxlIHN5c3RlbSBmcmFtZXdvcmsuIEFzIGEgaGlnaC1wZXJmb3JtYW5jZSBhbmQgc2NhbGFibGUgY2xvdWQtbmF0aXZlIGRpc3RyaWJ1dGVkIGRhdGFiYXNlLCBQb2xhckRCIHByb3ZpZGVzIGEgbmV3IHBvc3NpYmlsaXR5IGZvciBidWlsZGluZyBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMuIFRoaXMgYXJ0aWNsZSBhaW1zIHRvIGV4cGxvcmUgdGhlIGRpc3RyaWJ1dGVkIHN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduIGJhc2VkIG9uIFBvbGFyREIsIGZvY3VzaW5nIG9uIGtleSBpc3N1ZXMgc3VjaCBhcyBwZXJmb3JtYW5jZSwgYXZhaWxhYmlsaXR5LCBhbmQgY29uc2lzdGVuY3kuIEl0IGRlbHZlcyBpbnRvIHRoZSBQb2xhckRCIGFyY2hpdGVjdHVyZSwgc3VtbWFyaXplcyBwcmFjdGljYWwgZXhwZXJpZW5jZSwgcHJvdmlkZXMgdGVjaG5pY2FsIHN1cHBvcnQgYW5kIHJlZmVyZW5jZSBmb3IgYWRkcmVzc2luZyB0aGUgaW5jcmVhc2luZyBidXNpbmVzcyBkZW1hbmRzLCBhbmQgb2ZmZXJzIG5ldyBpZGVhcyBhbmQgbWV0aG9kcyBmb3IgZGlzdHJpYnV0ZWQgc3lzdGVtIGFyY2hpdGVjdHVyZSBkZXNpZ24uCgoxIEludHJvZHVjdGlvbiB0byBQb2xhckRCCgoxLjEgQXJjaGl0ZWN0dXJlIE92ZXJ2aWV3CgpUaGUgZGlzdHJpYnV0ZWQgc3lzdGVtIGFyY2hpdGVjdHVyZSBkZXNpZ24gYmFzZWQgb24gUG9sYXJEQiBpcyBhbiBpbm5vdmF0aXZlIHNvbHV0aW9uIHRvIGFkZHJlc3MgbGFyZ2Utc2NhbGUgZGF0YSBzdG9yYWdlIGFuZCBoaWdoLWNvbmN1cnJlbmN5IGFjY2VzcyBjaGFsbGVuZ2VzIGluIGNsb3VkIGNvbXB1dGluZyBlbnZpcm9ubWVudHMuIFRoZSBjb3JlIGZlYXR1cmUgb2YgdGhlIFBvbGFyREIgYXJjaGl0ZWN0dXJlIGlzIHRoZSBzZXBhcmF0aW9uIG9mIHN0b3JhZ2UgYW5kIGNvbXB1dGF0aW9uLCB3aGVyZSBkaXN0cmlidXRlZCBkYXRhYmFzZSBjbHVzdGVycyBhcmUgYnVpbHQgdXNpbmcgaW5kZXBlbmRlbnQgY29tcHV0ZSBub2RlcyBhbmQgc3RvcmFnZSBub2RlcywgdGh1cyBhY2hpZXZpbmcgaG9yaXpvbnRhbCBzY2FsYWJpbGl0eSBhbmQgZWxhc3RpYyBleHBhbnNpb24uIEluIHRoZSBQb2xhckRCIGFyY2hpdGVjdHVyZSwgc3RvcmFnZSBub2RlcyBhcmUgcmVzcG9uc2libGUgZm9yIGRhdGEgcGVyc2lzdGVuY2Ugc3RvcmFnZSBhbmQgbWFuYWdlbWVudCwgd2hpbGUgY29tcHV0ZSBub2RlcyBoYW5kbGUgU1FMIHJlcXVlc3RzIGFuZCBjb21wdXRhdGlvbmFsIGxvZ2ljLiBUaGlzIGRpc3RyaWJ1dGVkIGFyY2hpdGVjdHVyZSBtb2RlbCBhbGxvd3MgUG9sYXJEQiB0byBwcm92aWRlIGhpZ2gtcGVyZm9ybWFuY2UsIGhpZ2gtYXZhaWxhYmlsaXR5LCBhbmQgaGlnaGx5IHNjYWxhYmxlIGRhdGFiYXNlIHNlcnZpY2VzLiBQb2xhckRCIGFsc28gYWRvcHRzIGEgc2hhcmVkIGFyY2hpdGVjdHVyZSwgZW5hYmxpbmcgZGF0YSBzaGFyaW5nIGFuZCByZXVzZSB0aHJvdWdoIGEgc2hhcmVkIHN0b3JhZ2UgbGF5ZXIsIHRoZXJlYnkgcmVkdWNpbmcgdGhlIHN5c3RlbSdzIGNvc3QgYW5kIGNvbXBsZXhpdHkuIEluIHRlcm1zIG9mIGFyY2hpdGVjdHVyYWwgZGVzaWduLCBQb2xhckRCIGZ1bGx5IGNvbnNpZGVycyBzeXN0ZW0gc2VjdXJpdHkgYW5kIHJlbGlhYmlsaXR5LCBvZmZlcmluZyBmZWF0dXJlcyBzdWNoIGFzIGRhdGEgZW5jcnlwdGlvbiwgYWNjZXNzIGNvbnRyb2wsIGFuZCBmYXVsdCByZWNvdmVyeSB0byBwcm90ZWN0IHVzZXIgZGF0YSBzZWN1cml0eSBhbmQgcHJpdmFjeS4gVGhlIFBvbGFyREIgYXJjaGl0ZWN0dXJlIG91dGxpbmVzIGFuIGlubm92YXRpdmUgZGlzdHJpYnV0ZWQgZGF0YWJhc2UgbW9kZWwsIHByb3ZpZGluZyBuZXcgaWRlYXMgYW5kIG1ldGhvZHMgZm9yIGJ1aWxkaW5nIGhpZ2gtcGVyZm9ybWFuY2UsIGhpZ2gtYXZhaWxhYmlsaXR5IGRpc3RyaWJ1dGVkIHN5c3RlbXMuCgoxLjIgRmVhdHVyZXMgYW5kIEFkdmFudGFnZXMKClBvbGFyREIgaGFzIG1hbnkgb3V0c3RhbmRpbmcgZmVhdHVyZXMgYW5kIGFkdmFudGFnZXMgdGhhdCBtYWtlIGl0IHRoZSBwcmVmZXJyZWQgZGF0YWJhc2Ugc29sdXRpb24gZm9yIGVudGVycHJpc2VzIGJ1aWxkaW5nIGRpc3RyaWJ1dGVkIGhpZ2gtY29uY3VycmVuY3kgc3lzdGVtcy4gUG9sYXJEQiBhZG9wdHMgYSBzaGFyZWQgYXJjaGl0ZWN0dXJlLCBzZXBhcmF0aW5nIGNvbXB1dGF0aW9uIGFuZCBzdG9yYWdlIHRvIGFjaGlldmUgZWxhc3RpYyBzY2FsaW5nIGFuZCBoaWdoIHBlcmZvcm1hbmNlLCBlZmZlY3RpdmVseSBzb2x2aW5nIHRoZSBib3R0bGVuZWNrIGlzc3VlcyBvZiB0cmFkaXRpb25hbCBkYXRhYmFzZXMuIFBvbGFyREIgc3VwcG9ydHMgb25saW5lIGhvcml6b250YWwgc2NhbGluZywgZW5hYmxpbmcgbm9kZXMgdG8gYmUgZHluYW1pY2FsbHkgYWRkZWQgYmFzZWQgb24gYnVzaW5lc3MgcmVxdWlyZW1lbnRzIHdpdGhvdXQgZG93bnRpbWUgb3IgZGF0YSBtaWdyYXRpb24sIGVuc3VyaW5nIGhpZ2ggYXZhaWxhYmlsaXR5IGFuZCBzdGFiaWxpdHkuIFBvbGFyREIgYWxzbyBmZWF0dXJlcyBpbnRlbGxpZ2VudCBvcHRpbWl6YXRpb24gYW5kIGF1dG9tYXRlZCBtYW5hZ2VtZW50LCBtYWtpbmcgYWRhcHRpdmUgYWRqdXN0bWVudHMgYmFzZWQgb24gcmVhbC10aW1lIGxvYWQgYW5kIGRhdGEgYWNjZXNzIHBhdHRlcm5zIHRvIGltcHJvdmUgc3lzdGVtIGVmZmljaWVuY3kgYW5kIHJlc291cmNlIHV0aWxpemF0aW9uLiBQb2xhckRCIGlzIGhpZ2hseSBjb21wYXRpYmxlLCBlYXN5IHRvIHVzZSwgc3VwcG9ydHMgc3RhbmRhcmQgU1FMIHN5bnRheCBhbmQgcHJvdG9jb2xzLCBhbmQgZmFjaWxpdGF0ZXMgdGhlIG1pZ3JhdGlvbiBhbmQgaW50ZWdyYXRpb24gb2YgZXhpc3RpbmcgYXBwbGljYXRpb25zLCByZWR1Y2luZyBzeXN0ZW0gbWFpbnRlbmFuY2UgYW5kIGRldmVsb3BtZW50IGNvc3RzLCB3aGlsZSBpbXByb3ZpbmcgZGV2ZWxvcG1lbnQgZWZmaWNpZW5jeSBhbmQgdXNlciBleHBlcmllbmNlLiBQb2xhckRCIGlzIGFuIGlkZWFsIGNob2ljZSBmb3IgYnVpbGRpbmcgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW1zLCB3aXRoIGl0cyBwZXJmb3JtYW5jZSwgc3RhYmlsaXR5LCBhbmQgZWFzZSBvZiB1c2Ugc3RhbmRpbmcgb3V0LgoKMiBSZXF1aXJlbWVudHMgZm9yIERpc3RyaWJ1dGVkIEhpZ2gtQ29uY3VycmVuY3kgU3lzdGVtIERlc2lnbgoKMi4xIFBlcmZvcm1hbmNlIFJlcXVpcmVtZW50cyBBbmFseXNpcwoKV2hlbiBkZXNpZ25pbmcgYSBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbSwgcGVyZm9ybWFuY2UgaXMgb25lIG9mIHRoZSBtb3N0IGltcG9ydGFudCBjb25zaWRlcmF0aW9ucy4gUGVyZm9ybWFuY2UgcmVxdWlyZW1lbnRzIGFuYWx5c2lzIGlzIHRoZSBrZXkgcHJvY2VzcyBmb3IgZGV0ZXJtaW5pbmcgdGhlIHBlcmZvcm1hbmNlIG1ldHJpY3MgYW5kIHJlcXVpcmVtZW50cyB0aGF0IHRoZSBzeXN0ZW0gbXVzdCBtZWV0IHdoZW4gcHJvY2Vzc2luZyBsYXJnZS1zY2FsZSBjb25jdXJyZW50IHJlcXVlc3RzLiBUbyBhY2NvbW1vZGF0ZSB0aGUgZ3Jvd2luZyBudW1iZXIgb2YgdXNlcnMsIHRoZSBzeXN0ZW0ncyB0aHJvdWdocHV0IG11c3QgYmUgZHluYW1pY2FsbHkgc2NhbGFibGUgdG8gbWVldCBwZWFrIGFjY2VzcyBwcmVzc3VyZS4gQW5vdGhlciBjcml0aWNhbCBmYWN0b3IgYWZmZWN0aW5nIHN5c3RlbSBwZXJmb3JtYW5jZSBpcyBsYXRlbmN5LCB3aGljaCByZWZlcnMgdG8gdGhlIHJlc3BvbnNlIHRpbWUgb2YgdGhlIHN5c3RlbSBpbiBwcm9jZXNzaW5nIHJlcXVlc3RzLiBGb3IgZGlzdHJpYnV0ZWQgc3lzdGVtcywgdG8gbWluaW1pemUgdGhlIGltcGFjdCBvZiBuZXR3b3JrIGxhdGVuY3kgYW5kIGRhdGEgdHJhbnNtaXNzaW9uIGxhdGVuY3kgb24gdGhlIHN5c3RlbSdzIHJlc3BvbnNlIHRpbWUsIGl0IGlzIG5lY2Vzc2FyeSB0byBhZG9wdCBhcHByb3ByaWF0ZSBuZXR3b3JrIGFyY2hpdGVjdHVyZXMgYW5kIGRhdGEgZGlzdHJpYnV0aW9uIHN0cmF0ZWdpZXMgdG8gb3B0aW1pemUgc3lzdGVtIHBlcmZvcm1hbmNlLiBXaGVuIGRlc2lnbmluZyBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMsIHBlcmZvcm1hbmNlIG1ldHJpY3MgYW5kIHJlcXVpcmVtZW50cyBtdXN0IGJlIGNvbXByZWhlbnNpdmVseSBjb25zaWRlcmVkLiBJbiBhZGRpdGlvbiwgdGhlIHN5c3RlbSdzIGNvbmN1cnJlbmN5IGNhcGFiaWxpdHkgYW5kIGxvYWQgYmFsYW5jaW5nIG1lY2hhbmlzbXMgbXVzdCBiZSBjb25zaWRlcmVkIHRvIGVuc3VyZSB0aGF0IHRoZSBzeXN0ZW0gY2FuIGVmZmVjdGl2ZWx5IGhhbmRsZSBsYXJnZSB2b2x1bWVzIG9mIGNvbmN1cnJlbnQgcmVxdWVzdHMgYW5kIG1haW50YWluIHN0YWJsZSBvcGVyYXRpb24gaW4gdGhlIGV2ZW50IG9mIG5vZGUgZmFpbHVyZXMgb3IgbmV0d29yayBhYm5vcm1hbGl0aWVzLiBQZXJmb3JtYW5jZSByZXF1aXJlbWVudHMgYW5hbHlzaXMgaXMgYSBjcnVjaWFsIHBhcnQgb2YgZGVzaWduaW5nIGRpc3RyaWJ1dGVkIGhpZ2gtY29uY3VycmVuY3kgc3lzdGVtcy4gSXQgaXMgZXNzZW50aWFsIHRvIGZ1bGx5IGNvbnNpZGVyIHZhcmlvdXMgcGVyZm9ybWFuY2UgcmVxdWlyZW1lbnRzLCBzdWNoIGFzIHRocm91Z2hwdXQgc2NhbGFiaWxpdHksIGxhdGVuY3kgc3RhYmlsaXR5LCBjb25jdXJyZW5jeSBjYXBhYmlsaXR5LCBhbmQgbG9hZCBiYWxhbmNpbmcsIHRvIGVuc3VyZSBleGNlbGxlbnQgc3lzdGVtIHBlcmZvcm1hbmNlLgoKMi4yIEF2YWlsYWJpbGl0eSBSZXF1aXJlbWVudHMgQW5hbHlzaXMKCkFub3RoZXIgY3JpdGljYWwgZGVzaWduIHJlcXUuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2UgaGVscCBtZSB3cml0ZSBhbiBvdXRsaW5lIGZvciBhIHJlc2VhcmNoIHBhcGVyIG9uIHRoZSBjb250cm9sIHN5c3RlbSBvZiBzb2Z0IHJvYm90cy4gVGhlIHBhcGVyIG1haW5seSBmb2N1c2VzIG9uIHRoZSBpc3N1ZSBvZiBwcmVjaXNlIGVuZC1lZmZlY3RvciBjb250cm9sIG9mIHNvZnQgcm9ib3RzIGJhc2VkIG9uIHZpc3VhbCBmZWVkYmFjaywgdXNpbmcgUk9TIGFuZCBHYXplYm8gcGxhdGZvcm1zIGZvciBzaW11bGF0aW9uIGV4cGVyaW1lbnRzLCB2ZXJpZnlpbmcgdGhlIGNvbnRyb2wgYWxnb3JpdGhtIG9uIGEgcGh5c2ljYWwgcHJvdG90eXBlLCBhbmQgY29sbGVjdGluZyBleHBlcmltZW50YWwgZGF0YSB1bmRlciB0aHJlZSBkaWZmZXJlbnQgbG9hZCBjb25kaXRpb25zIChubyBsb2FkLCAxMDBnLCAyMDBnKS4gVGhlIHBhcGVyIG5lZWRzIHRvIGNvbXBhcmUgYW5kIGFuYWx5emUgdGhlIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VzIGJldHdlZW4gUElEIGNvbnRyb2wgYW5kIGFkYXB0aXZlIGNvbnRyb2wgYXBwcm9hY2hlcy4KdXNlcjoKSSBhbSBjb25kdWN0aW5nIHJlc2VhcmNoIG9uIGludGVsbGlnZW50IGJ1aWxkaW5nIGVuZXJneS1zYXZpbmcgY29udHJvbC4gSSBoYXZlIGEgc2V0IG9mIG9wZXJhdGlvbmFsIGRhdGEgZnJvbSBhbiBvZmZpY2UgYnVpbGRpbmcncyBhaXIgY29uZGl0aW9uaW5nIHN5c3RlbSBzcGFubmluZyA2IG1vbnRocywgaW5jbHVkaW5nIG1lYXN1cmVkIGRhdGEgc3VjaCBhcyBpbmRvb3IgdGVtcGVyYXR1cmUsIGh1bWlkaXR5LCBDTzIgY29uY2VudHJhdGlvbiwgZW5lcmd5IGNvbnN1bXB0aW9uLCBhbmQgb3B0aW1pemF0aW9uIHJlY29yZHMgb2YgdGhlIGFpciBjb25kaXRpb25pbmcgc3lzdGVtIGNvbnRyb2wgYWxnb3JpdGhtIGJhc2VkIG9uIGRlZXAgcmVpbmZvcmNlbWVudCBsZWFybmluZy4gSSBob3BlIHRvIHdyaXRlIGEgcGFwZXIgZm9sbG93aW5nIHRoZSBzdWJtaXNzaW9uIGd1aWRlbGluZXMgb2YgdGhlIGpvdXJuYWwgKkJ1aWxkaW5nIGFuZCBFbnZpcm9ubWVudCouIFBsZWFzZSBwcm92aWRlIGEgZGV0YWlsZWQgb3V0bGluZSBmb3IgdGhlIHBhcGVyLgp1c2VyOgpJIGFtIGEgdHJhZmZpYyBjb250cm9sIHN5c3RlbSBlbmdpbmVlciBhbmQgd291bGQgbGlrZSB0byB3cml0ZSBhIHBhcGVyIG9uIHRoZSB0b3BpYyBvZiB1cmJhbiB0cmFmZmljIHNpZ25hbCBvcHRpbWl6YXRpb24gY29udHJvbCBzeXN0ZW1zLiBQbGVhc2UgaGVscCBtZSBjb21wbGV0ZSBhbiBvdXRsaW5lIGZvciB0aGUgcGFwZXIsIHJldHVybmluZyBpdCBpbiBoaWVyYXJjaGljYWwgZm9ybS4gVGhlIHBhcGVyIHNob3VsZCBiZSBhaW1lZCBhdCBwcm9mZXNzaW9uYWwgcmVhZGVycyBpbiB0aGUgZmllbGQgb2YgdHJhZmZpYyBlbmdpbmVlcmluZywgd2l0aCBhIHJpZ29yb3VzIGFuZCBwcm9mZXNzaW9uYWwgd3JpdGluZyBzdHlsZSB0aGF0IGVtcGhhc2l6ZXMgZW5naW5lZXJpbmcgcHJhY3RpY2UuIFRoZSBmb2xsb3dpbmcgcG9pbnRzIG5lZWQgdG8gYmUgaGlnaGxpZ2h0ZWQ6IDEpIEludGVncmF0aW5nIGFjdHVhbCBkZXBsb3ltZW50IHByb2plY3QgY2FzZXMgYW5kIGRhdGEgdGhhdCBJIGFtIHJlc3BvbnNpYmxlIGZvcjsgMikgSGlnaGxpZ2h0aW5nIHRlY2huaWNhbCBpbm5vdmF0aW9uLCBlc3BlY2lhbGx5IGltcHJvdmVtZW50cyBpbiBhbGdvcml0aG0gb3B0aW1pemF0aW9uIGFuZCByZWFsLXRpbWUgY29udHJvbDsgMykgVGhlIHdyaXRpbmcgc3R5bGUgc2hvdWxkIG1lZXQgdGhlIHN1Ym1pc3Npb24gcmVxdWlyZW1lbnRzIGZvciBjb3JlIGpvdXJuYWxzLiAgCk15IHByb2Nlc3MgZG9jdW1lbnRhdGlvbiBhbmQgZm9ybWF0dGluZyByZXF1aXJlbWVudHMgZm9yIHRoZSBwYXBlciBjYW4gYmUgcmVmZXJlbmNlZCBpbjogKioxLiBEZXRhaWxlZCBUZWNobmljYWwgRG9jdW1lbnRhdGlvbiBvZiB0aGUgQWN0dWFsIERlcGxveW1lbnQgUHJvamVjdCwgSW5jbHVkaW5nIFN5c3RlbSBBcmNoaXRlY3R1cmUsIEFsZ29yaXRobSBEZXNpZ24sIGFuZCBJbnRlcmZhY2UgU3BlY2lmaWNhdGlvbnM6KiogIAoKVGhlIHN5c3RlbSBhZG9wdHMgYSBjb250cm9sIHNjaGVtZSBjZW50ZXJlZCBhcm91bmQgdGhlIEFUODlDNTEgbWljcm9jb250cm9sbGVyLiBJdCBjYWxjdWxhdGVzIHRoZSBncmVlbiBhbmQgcmVkIGxpZ2h0IGR1cmF0aW9ucyBmb3IgZGlmZmVyZW50IGRpcmVjdGlvbnMgdXNpbmcgYW4gYWxnb3JpdGhtIGFuZCBkaXNwbGF5cyB0aGUgY291bnRkb3duIG9uIGEgZGlnaXRhbCBkaXNwbGF5LiBBdCB0aGUgc2FtZSB0aW1lLCB0aGUgc3lzdGVtIGNvbnRyb2xzIHZlaGljbGUgcGFzc2FnZSBhbmQgc3RvcHBpbmcgYnkgdHVybmluZyB0aGUgdHJhZmZpYyBsaWdodHMgYXQgdGhlIGludGVyc2VjdGlvbiBvbiBhbmQgb2ZmLiBBZGRpdGlvbmFsbHksIHRoZSBzY2hlbWUgaW5jbHVkZXMgYW4gZW1lcmdlbmN5IHZlaGljbGUgcGFzc2FnZSBidXR0b24uIFdoZW5ldmVyIGFuIGVtZXJnZW5jeSB2ZWhpY2xlIG5lZWRzIHRvIHBhc3MsIHRoZSBvcGVyYXRvciBwcmVzc2VzIHRoZSBidXR0b24sIHR1cm5pbmcgYWxsIHRyYWZmaWMgbGlnaHRzIGluIGJvdGggZWFzdC13ZXN0IGFuZCBub3J0aC1zb3V0aCBkaXJlY3Rpb25zIHJlZCB3aGlsZSBzb3VuZGluZyBhbiBhbGFybSB0byBwcm9oaWJpdCByZWd1bGFyIHZlaGljbGVzIGZyb20gcGFzc2luZywgYWxsb3dpbmcgdGhlIGVtZXJnZW5jeSB2ZWhpY2xlIHRvIGdvIGZpcnN0LiAgCgpUaGUgaW50ZXJzZWN0aW9uIGNvbnNpc3RzIG9mIHR3byBtYWluIHJvYWRzIGNyb3NzaW5nIGVhY2ggb3RoZXIsIHdpdGggZWFjaCByb2FkIGhhdmluZyBhIHNldCBvZiByZWQsIHllbGxvdywgYW5kIGdyZWVuIHRyYWZmaWMgbGlnaHRzLCBhcyB3ZWxsIGFzIGEgbGVmdC10dXJuIGluZGljYXRvci4gVGhlc2UgbGlnaHRzIGRpcmVjdCB2ZWhpY2xlcyBmb3Igc2FmZSBwYXNzYWdlOiByZWQgbWVhbnMgc3RvcCwgZ3JlZW4gbWVhbnMgZ28sIGFuZCB5ZWxsb3cgc2VydmVzIGFzIGEgd2FybmluZyBpbmRpY2F0aW5nIGFuIGltbWluZW50IGNoYW5nZSBiZXR3ZWVuIHJlZCBhbmQgZ3JlZW4uIFRoZSBkdXJhdGlvbiBvZiB0aGUgeWVsbG93IGxpZ2h0IGlzIHNldCBhcyB0aGUgc2hhcmVkIHN0b3BwaW5nIHRpbWUgZm9yIGJvdGggdGhlIGVhc3Qtd2VzdCBhbmQgbm9ydGgtc291dGggcm9hZHMuIFRoZSBsZWZ0LXR1cm4gaW5kaWNhdG9yIGFsbG93cyB2ZWhpY2xlcyBvbiB0aGUgbWFpbiByb2FkIHRvIG1ha2UgYSBsZWZ0IHR1cm4uICAKClRoaXMgc3lzdGVtIHV0aWxpemVzIHRoZSBBVDg5QzUxIG1pY3JvY29udHJvbGxlciBhcyBpdHMgY29yZSBjb250cm9sIGNvbXBvbmVudC4gSXQgZW1wbG95cyB0aW1lcnMgdG8gY29udHJvbCB0aGUgb24vb2ZmIHN0YXRlcyBvZiB0aGUgdHJhZmZpYyBsaWdodHMgY29ubmVjdGVkIHRvIHRoZSBQMCBwb3J0IHdoaWxlIGRpc3BsYXlpbmcgdGhlIGNvdW50ZG93biBvbiBhbiA4LXNlZ21lbnQgZGlnaXRhbCBkaXNwbGF5IGNvbm5lY3RlZCB0byB0aGUgUDEgYW5kIFAyIHBvcnRzLiBUaGUgY2lyY3VpdCBkaWFncmFtIG1haW5seSBjb25zaXN0cyBvZiBhIHBvd2VyIHN1cHBseSBjaXJjdWl0LCBhIHRyYWZmaWMgbGlnaHQgZGlzcGxheSBjaXJjdWl0LCBhIHRyYWZmaWMgbGlnaHQgY291bnRkb3duIHRpbWVyIGNpcmN1aXQsIGFuZCBhbiBlbWVyZ2VuY3kgYnV0dG9uIChLMSkgY2lyY3VpdC4gIAoKVGhlIHBvd2VyIHN1cHBseSBhZG9wdHMgYSByZWd1bGF0ZWQgcG93ZXIgY2lyY3VpdCB0aGF0IG91dHB1dHMgYSBzdGFibGUgKzVWIERDIHZvbHRhZ2UuIFRoZSBJQyB1c2VzIHRoZSBpbnRlZ3JhdGVkIHZvbHRhZ2UgcmVndWxhdG9yIDc4MDUsIGEgc3RhbmRhcmRpemVkLCB3aWRlbHkgdXNlZCBsaW5lYXIgdm9sdGFnZSByZWd1bGF0b3Igd2l0aCBhZHZhbnRhZ2VzIHN1Y2ggYXMgc21hbGwgc2l6ZSwgbG93IGNvc3QsIGdvb2QgcGVyZm9ybWFuY2UsIGhpZ2ggcmVsaWFiaWxpdHksIGFuZCBlYXNlIG9mIHVzZS4gSXQgaXMgb25lIG9mIHRoZSBtb3N0IHdpZGVseSBhcHBsaWVkIG1vbm9saXRoaWMgaW50ZWdyYXRlZCByZWd1bGF0b3JzIGluIHJlZ3VsYXRlZCBwb3dlciBzdXBwbGllcy4gV2hlbiB0aGUgb3V0cHV0IGN1cnJlbnQgaXMgcmVsYXRpdmVseSBoaWdoLCB0aGUgNzgwNSBzaG91bGQgYmUgZXF1aXBwZWQgd2l0aCBhIGhlYXQgc2luay4gQ2FwYWNpdG9yIEMzIHNlcnZlcyBhcyB0aGUgaW5wdXQgZmlsdGVyIGNhcGFjaXRvciwgd2hpbGUgQzUgYWN0cyBhcyB0aGUgb3V0cHV0IGZpbHRlciBjYXBhY2l0b3IuICAKClRoZSBzeXN0ZW0gdXNlcyBhIDIyMFYgQUMgcG93ZXIgc291cmNlLiBBZnRlciBwYXNzaW5nIHRocm91Z2ggYSA1ViBhZGFwdGVyIGFuZCBmaWx0ZXJpbmcsIGl0IGZvcm1zIGEgcmVsYXRpdmVseSB1bnN0YWJsZSBEQyB2b2x0YWdlIGF0IHRoZSBWaW4gYW5kIEdORCB0ZXJtaW5hbHMgb2YgdGhlIGZpeGVkIHRocmVlLXRlcm1pbmFsIHZvbHRhZ2UgcmVndWxhdG9yIExNNzgwNS4gVGhpcyB2b2x0YWdlIG9mdGVuIGZsdWN0dWF0ZXMgZHVlIHRvIHZhcmlhdGlvbnMgaW4gdGhlIG1haW5zIHZvbHRhZ2Ugb3IgbG9hZCBjaGFuZ2VzLiBBZnRlciBMTTc4MDUgcmVndWxhdGlvbiBhbmQgY2FwYWNpdG9yIGZpbHRlcmluZywgdGhlIG91dHB1dCBzaWRlIG9mIHRoZSByZWd1bGF0ZWQgcG93ZXIgc3VwcGx5IGdlbmVyYXRlcyBhIGhpZ2hseSBhY2N1cmF0ZSBhbmQgc3RhYmxlIERDIHZvbHRhZ2UuICAKClRoaXMgZGVzaWduIGFkb3B0cyBDIGxhbmd1YWdlIGFzIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZS4gQ29tcGFyZWQgdG8gYXNzZW1ibHkgbGFuZ3VhZ2UsIEMgZ2VuZXJhdGVzIG1hY2hpbmUgY29kZSB3aXRoIHNpbWlsYXIgZWZmaWNpZW5jeSB3aGlsZSBvZmZlcmluZyBtdWNoIGJldHRlciByZWFkYWJpbGl0eSBhbmQgcG9ydGFiaWxpdHkuIEFsdGhvdWdoIGFzc2VtYmx5IGxhbmd1YWdlIGFsbG93cyBmb3IgaGlnaGx5IGVmZmljaWVudCBtYWNoaW5lIGNvZGUgZ2VuZXJhdGlvbiwgaXQgaXMgZGlmZmljdWx0IHRvIHJlYWQsIGVzcGVjaWFsbHkgZm9yIGNvbXBsZXggcHJvZ3JhbXMuIEMgbGFuZ3VhZ2UsIGluIG1vc3QgY2FzZXMsIG1hdGNoZXMgYXNzZW1ibHkgbGFuZ3VhZ2UgaW4gbWFjaGluZSBjb2RlIGVmZmljaWVuY3kgd2hpbGUgZ3JlYXRseSBzdXJwYXNzaW5nIGl0IGluIHJlYWRhYmlsaXR5IGFuZCBwb3J0YWJpbGl0eS4gQWRkaXRpb25hbGx5LCBDIGFsbG93cyBmb3IgZW1iZWRkZWQgYXNzZW1ibHkgY29kZSB0byBoYW5kbGUgcmVhbC10aW1lIGNyaXRpY2FsIHRhc2tzLiAgCgpGb3IgZGV2ZWxvcG1lbnQgdGltZSwgbWVkaXVtLXRvLWxhcmdlIHNvZnR3YXJlIHByb2plY3RzIHdyaXR0ZW4gaW4gQyBnZW5lcmFsbHkgaGF2ZSBhIHNpZ25pZmljYW50bHkgc2hvcnRlciBkZXZlbG9wbWVudCBjeWNsZSB0aGFuIHRob3NlIHdyaXR0ZW4gaW4gYXNzZW1ibHkuIENvbnNpZGVyaW5nIHRoZXNlIGFkdmFudGFnZXMsIHRoaXMgZGVzaWduIHVzZXMgQyBhcyB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UuICAKClRoZSBwcm9ncmFtbWluZyBlbnZpcm9ubWVudCBjaG9zZW4gZm9yIHRoaXMgcHJvamVjdCBpcyBLZWlsIMK1VmlzaW9uIDIuMC4gVGhpcyBzb2Z0d2FyZSBzdXBwb3J0cyB2YXJpb3VzIE1DUy01MSBhcmNoaXRlY3R1cmUgbWljcm9jb250cm9sbGVycyBmcm9tIGRpZmZlcmVudCBtYW51ZmFjdHVyZXJzLCBpbnRlZ3JhdGluZyBlZGl0aW5nLCBjb21waWxpbmcsIGFuZCBzaW11bGF0aW9uIGZ1bmN0aW9uYWxpdGllcy4gSXQgYWxzbyBzdXBwb3J0cyBQTE0sIGFzc2VtYmx5LCBhbmQgQyBwcm9ncmFtbWluZywgZmVhdHVyaW5nIGEgdXNlci1mcmllbmRseSBpbnRlcmZhY2UgdGhhdCBpcyBlYXN5IHRvIGxlYXJuLiBLZWlsIMK1VmlzaW9uIHByb3ZpZGVzIGEgY29udmVuaWVudCBkZWJ1Z2dpbmcgZW52aXJvbm1lbnQgaW4gdGhlIGVhcmx5IHN0YWdlcyBvZiBzb2Z0d2FyZSB0ZXN0aW5nIGFuZCBvZmZlcnMgc3Ryb25nIHNpbXVsYXRpb24gY2FwYWJpbGl0aWVzLiAgCgpDdXJyZW50bHksIHRoZSBtb3N0IGNvbW1vbiBwcm9ncmFtbWluZyBsYW5ndWFnZXMgZm9yIE1DUy01MSBtaWNyb2NvbnRyb2xsZXJzIGluY2x1ZGUgUExNLCBhc3NlbWJseSwgYW5kIEMuIEFtb25nIHRoZW0sIGFzc2VtYmx5IGFuZCBDIGFyZSB0aGUgbW9zdCB3aWRlbHkgdXNlZC4gQXNzZW1ibHkgbGFuZ3VhLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKSSBuZWVkIHRvIHdyaXRlIGEgcmVzZWFyY2ggcGFwZXIgb24gYW4gQUktYmFzZWQgbWVkaWNhbCBpbWFnaW5nLWFzc2lzdGVkIGRpYWdub3NpcyBzeXN0ZW0uIFBsZWFzZSBoZWxwIG1lIGRyYWZ0IGEgcGFwZXIgb3V0bGluZS4KdXNlcjoK5oiR5oOz5pKw5YaZ5LiA56+H5py65Zmo5a2m5Lmg5Zyo5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi25Lit55qE5bqU55So56CU56m26K665paH77yM5YeG5aSH5oqV56i/44CK5pm66IO95Yi26YCg44CL5pyf5YiK44CC6K665paH56qB5Ye65py65Zmo5a2m5Lmg566X5rOV5Zyo5bel5Lia5Zy65pmv5LiL55qE5pS56L+b5Yib5paw54K55ZKM5a6e6ZmF5bel56iL5bqU55So5pWI5p6c44CC6K+35oyJ54Wn44CK5pm66IO95Yi26YCg44CL5pyf5YiK5qC85byP6KaB5rGC77yM5biu5oiR5YaZ5LiA5Liq6K665paH5aSn57qy44CC5Y+v5Lul5Y+C6ICD5Lul5LiL6IyD5paH57Sg5p2Q44CC5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi2ICDoooHoiqwgICDljZfkuqzmnLrnlLXogYzkuJrmioDmnK/lrabpmaLoh6rliqjljJblt6XnqIvns7sgICDmkZjopoHvvJrln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbmmK/lvZPliY3lt6XkuJrnlJ/kuqfkuK3lhbPms6jnmoTng63ngrnpoobln5/jgILmnKzmlofns7vnu5/lnLDmjqLorqjkuobln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTlhbPplK7mioDmnK/lkozkuLvopoHmtYHnqIvvvIzmj5Dlh7rkuobln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTlupTnlKjnrZbnlaXvvIzljIXmi6zln7rkuo7mmbrog73kvKDmhJ/lmajnmoTlrp7ml7botKjph4/nm5HmtYvjgIHln7rkuo7pooTmtYvliIbmnpDnmoTmlYXpmpzmo4DmtYvkuI7pooTorabjgIHln7rkuo7ov5znqIvnm5HmjqfnmoTliIbluIPlvI/otKjph4/mjqfliLbvvIzku6Xlj4rln7rkuo7nn6Xor4blm77osLHnmoTnn6Xor4bmjqjnkIbkuI7lhrPnrZbvvIzku6Xkvpvlj4LogIPjgIIgIOWfuumHke+8miAyMDIz5bm05bqm5rGf6IuP6auY5qCh4oCc6Z2S6JOd5bel56iL4oCd6LWE5YqpIDsgMjAyM+W5tOW6puaxn+iLj+mrmOagoeWTsuWtpuekvuS8muenkeWtpueglOeptumhueebrueglOeptuaIkOaenO+8iDIwMjNTSllCMDgyNu+8iSA7IOWNl+S6rOacuueUteiBjOS4muaKgOacr+WtpumZouenjeWtkOWfuumHkemhueebrueglOeptuaIkOaenO+8iExEMjAyMzAx77yJICAg5YWz6ZSu6K+N77ya5py65qKw5pm66IO95Yi26YCgO+i0qOmHj+aOp+WItjvmt7HluqblrabkuaA75pWw5o2u5aSE55CGO+WunuaXtuebkea1iyAg5L2c6ICF566A5LuL77ya6KKB6Iqs77yIMTk4M+KAlO+8ie+8jOWls++8jOehleWjq++8jOiusuW4iO+8jOS4u+imgeeglOeptuaWueWQkeeUteawlOiHquWKqOWMliAg5pS256i/5pel5pyf77yaMjAyMy0wNy0yNSAgRGVlcCBsZWFybmluZy1iYXNlZCBxdWFsaXR5IGNvbnRyb2wgZm9yIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgb2YgbWFjaGluZXJ5ICBZVUFOIEZlbiAgRGVwYXJ0bWVudCBvZiBBdXRvbWF0aW9uIEVuZ2luZWVyaW5nLCBOYW5qaW5nIEluc3RpdHV0ZSBvZiBNZWNoYW5pY2FsIGFuZCBFbGVjdHJpY2FsIFRlY2hub2xvZ3kgIEFic3RyYWN077yaUXVhbGl0eSBjb250cm9sIG9mIG1lY2hhbmljYWwgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBiYXNlZCBvbiBkZWVwIGxlYXJuaW5nIGlzIGEgaG90IGFyZWEgb2YgY29uY2VybiBpbiBjdXJyZW50IGluZHVzdHJpYWwgcHJvZHVjdGlvbi4gVGhpcyBwYXBlciBzeXN0ZW1hdGljYWxseSBkaXNjdXNzZXMgdGhlIGtleSB0ZWNobm9sb2dpZXMgYW5kIG1haW4gcHJvY2Vzc2VzIG9mIGRlZXAgbGVhcm5pbmctYmFzZWQgbWVjaGFuaWNhbCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHF1YWxpdHkgY29udHJvbCwgYW5kIHB1dHMgZm9yd2FyZCB0aGUgYXBwbGljYXRpb24gc3RyYXRlZ2llcyBvZiBkZWVwIGxlYXJuaW5nLWJhc2VkIG1lY2hhbmljYWwgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBxdWFsaXR5IGNvbnRyb2wsIGluY2x1ZGluZyByZWFsLXRpbWUgcXVhbGl0eSBtb25pdG9yaW5nIGJhc2VkIG9uIGludGVsbGlnZW50IHNlbnNvcnMsIGZhdWx0IGRldGVjdGlvbiBhbmQgZWFybHkgd2FybmluZyBiYXNlZCBvbiBwcmVkaWN0aXZlIGFuYWx5dGljcywgZGlzdHJpYnV0ZWQgcXVhbGl0eSBjb250cm9sIGJhc2VkIG9uIHJlbW90ZSBtb25pdG9yaW5nIGFuZCBkaXN0cmlidXRlZCBxdWFsaXR5IGNvbnRyb2wsIGFzIHdlbGwgYXMga25vd2xlZGdlIHJlYXNvbmluZyBhbmQgZGVjaXNpb24tbWFraW5nIGJhc2VkIG9uIGtub3dsZWRnZSBncmFwaCwgZm9yIHJlZmVyZW5jZS4gS2V5IHdvcmRz77yaTWVjaGFuaWNhbCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIDsgUXVhbGl0eSBjb250cm9sIDsgRGVlcCBsZWFybmluZyA7IERhdGEgcHJvY2Vzc2luZyA7IFJlYWwtdGltZSBtb25pdG9yaW5nIFJlY2VpdmVk77yaMjAyMy0wNy0yNSAgMCDlvJXoqIAg6ZqP552A5py65qKw5pm66IO95Yi26YCg5oqA5pyv55qE5LiN5pat5Y+R5bGV77yM5Yi26YCg6KGM5Lia5a+55Lqn5ZOB6LSo6YeP55qE6KaB5rGC5Lmf6LaK5p2l6LaK6auY44CC5Lyg57uf55qE6LSo6YeP5o6n5Yi25pa55rOV5Zyo6Z2i5a+55aSn6KeE5qih5pWw5o2u5ZKM5aSN5p2C55Sf5Lqn6L+H56iL5pe26Z2i5Li0552A5oyR5oiY77yM5Zug5q2k6ZyA6KaB5byV5YWl5paw55qE5oqA5pyv5omL5q615p2l6Kej5Yaz6L+Z5Lqb6Zeu6aKY44CC5rex5bqm5a2m5Lmg5L2c5Li65Lq65bel5pm66IO96aKG5Z+f55qE6YeN6KaB5YiG5pSv77yM5Zyo5Zu+5YOP44CB6K+t6Z+z5ZKM6Ieq54S26K+t6KiA5aSE55CG562J6aKG5Z+f5Y+W5b6X5LqG5pi+6JGX55qE5oiQ5p6c77yM5bm25LiU5Zyo6LSo6YeP5o6n5Yi26aKG5Z+f5Lmf5YW35pyJ5bm/6ZiU55qE5bqU55So5YmN5pmv44CC5pys5paH5peo5Zyo6YCa6L+H5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi256CU56m277yM5o+Q5L6b5LiA56eN5paw55qE6Kej5Yaz5pa55qGI5p2l5pS55ZaE5Lyg57uf55qE6LSo6YeP5o6n5Yi25pa55rOV44CCIDEg5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE5YWz6ZSu5oqA5pyvIDEuMSDmt7HluqblrabkuaDnrpfms5Xln7rnoYAg5rex5bqm5a2m5Lmg5piv5LiA56eN5Lul5Lq65bel56We57uP572R57uc5Li65Z+656GA55qE5py65Zmo5a2m5Lmg5pa55rOV77yM5a6D6YCa6L+H5aSa5bGC5qyh55qE56We57uP572R57uc57uT5p6E5p2l5a+55pWw5o2u6L+b6KGM5a2m5Lmg5ZKM6KGo56S644CC5rex5bqm5a2m5Lmg566X5rOV5Z+656GA5YyF5ous5Lul5LiL5Yeg5Liq5YWz6ZSu6KaB57Sg44CCIOmmluWFiO+8jOelnue7j+e9kee7nOaooeWei+aYr+a3seW6puWtpuS5oOeul+azleeahOaguOW/g+OAguWug+eUseWkmuS4quelnue7j+WFg+e7hOaIkOeahOWxguasoee7k+aehO+8jOavj+S4quelnue7j+WFg+mDveS7peWKoOadg+WSjOeahOaWueW8j+aOpeaUtui+k+WFpe+8jOeEtuWQjue7j+i/h+mdnue6v+aAp+a/gOa0u+WHveaVsOi/m+ihjOi9rOaNou+8jOi+k+WHuuWIsOS4i+S4gOWxguOAgumAmuW4uO+8jOa3seW6puWtpuS5oOS4reS9v+eUqOeahOelnue7j+e9kee7nOaooeWei+WMheaLrOWNt+enr+elnue7j+e9kee7nO+8iENOTu+8ieOAgeW+queOr+elnue7j+e9kee7nO+8iFJOTu+8ieWSjOWPmOaNouWZqOe9kee7nO+8iFRyYW5zZm9ybWVy77yJ562J44CC5YW25qyh77yM5rex5bqm5a2m5Lmg566X5rOV55qE5a2m5Lmg6L+H56iL5piv6YCa6L+H5Y+N5ZCR5Lyg5pKt566X5rOV6L+b6KGM55qE44CC5Y+N5ZCR5Lyg5pKt566X5rOV6YCa6L+H6K6h566X6L6T5Ye65LiO55yf5a6e5YC85LmL6Ze055qE6K+v5beu77yM5bm25bCG6K+v5beu5LuO6L6T5Ye65bGC6YCQ5bGC5ZCR5YmN5Lyg5pKt77yM5pu05paw56We57uP572R57uc5Lit55qE5p2D6YeN5ZKM5YGP572u77yM5Lul5pyA5bCP5YyW6K+v5beuWzFd44CC5q2k5aSW77yM5rex5bqm5a2m5Lmg566X5rOV6L+Y6ZyA6KaB6YCJ5oup5ZCI6YCC55qE5o2f5aSx5Ye95pWw5p2l5bqm6YeP6L6T5Ye657uT5p6c5ZKM55yf5a6e5YC85LmL6Ze055qE5beu5byC44CC5bi455So55qE5o2f5aSx5Ye95pWw5YyF5ous5Z2H5pa56K+v5beu77yITVNF77yJ44CB5Lqk5Y+J54a15o2f5aSx5Ye95pWw562J44CC5pyA5ZCO77yM5rex5bqm5a2m5Lmg566X5rOV6L+Y6ZyA6KaB6YCJ5oup5ZCI6YCC55qE5LyY5YyW566X5rOV5p2l5pu05paw56We57uP572R57uc5Lit55qE5Y+C5pWw44CC5bi455So55qE5LyY5YyW566X5rOV5YyF5ous6ZqP5py65qKv5bqm5LiL6ZmN77yIU0dE77yJ44CBQWRhbeS8mOWMlueul+azleetie+8jOWug+S7rOiDveWkn+acieaViOWcsOiwg+aVtOWPguaVsO+8jOaPkOmrmOaooeWei+eahOaAp+iDveOAgiAxLjIg5pWw5o2u6YeH6ZuG5LiO6aKE5aSE55CG5oqA5pyvIOaVsOaNrumHh+mbhuS4jumihOWkhOeQhuaKgOacr+WcqOa3seW6puWtpuS5oOS4reaYr+mdnuW4uOmHjeimgeeahOS4gOatpe+8jOWug+S4u+imgeWMheaLrOaVsOaNruaUtumbhuOAgeaVsOaNrua4hea0l+OAgeaVsOaNrui9rOaNouWSjOaVsOaNruWinuW8uuetiei/h+eoi+OAgiDpppblhYjvvIzmlbDmja7mlLbpm4bmmK/mjIfku47liLbpgKDov4fnqIvkuK3ojrflj5bnm7jlhbPnmoTotKjph4/mjqfliLbmlbDmja7jgILov5nkupvmlbDmja7lj6/ku6XljIXmi6zkvKDmhJ/lmajph4fpm4bnmoTniannkIbkv6Hlj7fjgIHlt6Xoibrlj4LmlbDjgIHop4bop4nlm77lg4/nrYnjgILmlbDmja7mlLbpm4bnmoTotKjph4/lkozmnInmlYjmgKfnm7TmjqXlvbHlk43liLDlkI7nu63mqKHlnovnmoTorq3nu4PlkozmgKfog73jgILlhbbmrKHvvIzmlbDmja7muIXmtJfmmK/mjIflr7nph4fpm4bliLDnmoTljp/lp4vmlbDmja7ov5vooYzljrvlmarjgIHnvLrlpLHlgLzloavlhYXjgIHlvILluLjlgLzlpITnkIbnrYnmk43kvZzvvIzku6XmtojpmaTmlbDmja7kuK3nmoTlmarlo7DlkozlubLmibDvvIzkv53or4HmlbDmja7nmoTlh4bnoa7mgKflkozlrozmlbTmgKfjgILmlbDmja7ovazmjaLmmK/lsIbljp/lp4vmlbDmja7ovazmjaLkuLrmt7HluqblrabkuaDnrpfms5Xog73lpJ/lpITnkIbnmoTlvaLlvI/jgILkvovlpoLvvIzlr7nkuo7lm77lg4/mlbDmja7vvIzlj6/ku6Xov5vooYzlm77lg4/pooTlpITnkIbmk43kvZzvvIzlpoLosIPmlbTlpKflsI/jgIHoo4HliarjgIHml4vovaznrYnjgILlr7nkuo7mlbDlgLzlnovmlbDmja7vvIzlj6/ku6Xov5vooYzlvZLkuIDljJbmiJbmoIflh4bljJblpITnkIbvvIzlsIbmlbDmja7nvKnmlL7liLDkuIDlrprnmoTojIPlm7TlhoXjgILmnIDlkI7vvIzmlbDmja7lop7lvLrmmK/pgJrov4fkuIDns7vliJfnmoTmlbDmja7mianlhYXmlrnms5XvvIznlJ/miJDmm7TlpJrnmoTorq3nu4PmoLfmnKzjgILkvovlpoLvvIzlr7nkuo7lm77lg4/mlbDmja7vvIzlj6/ku6Xov5vooYzpmo/mnLrnv7vovazjgIHml4vovazjgIHnvKnmlL7nrYnmk43kvZzvvIzlop7liqDmlbDmja7nmoTlpJrmoLfmgKflkozmlbDph4/vvIzmj5Dpq5jmqKHlnovnmoTms5vljJbog73lipvjgIIgMS4zIOeJueW+geaPkOWPluS4juihqOekuuWtpuS5oCDnibnlvoHmj5Dlj5bkuI7ooajnpLrlrabkuaDmmK/mt7HluqblrabkuaDkuK3nmoTlhbPplK7njq/oioLvvIzlroPog73lpJ/ku47ljp/lp4vmlbDmja7kuK3mj5Dlj5blh7rlhbfmnInljLrliIbog73lipvnmoTnibnlvoHvvIzlubblsIblhbbooajnpLrkuLrkuIDkuKrkvY7nu7TnmoTlkJHph4/jgIIg5Zyo5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi25Lit77yM54m55b6B5o+Q5Y+W5ZKM6KGo56S65a2m5Lmg5Y+v5Lul5LuO5Y6f5aeL55qE5Lyg5oSf5Zmo5L+h5Y+35oiW5Zu+5YOP5pWw5o2u5Lit5o+Q5Y+W5Ye65Luj6KGo6LSo6YeP54m55b6B55qE5YWz6ZSu5L+h5oGv77yM55So5LqO5Yik5pat5Lqn5ZOB55qE5ZCI5qC85oCn44CCIOWvueS6juWbvuWDj+aVsOaNru+8jOWPr+S7peS9v+eUqOWNt+enr+elnue7j+e9kee7nO+8iENOTu+8iei/m+ihjOeJueW+geaPkOWPluOAgkNOTuiDveWkn+mAmui/h+S4gOezu+WIl+eahOWNt+enr+OAgeaxoOWMluWSjOmdnue6v+aAp+a/gOa0u+etieaTjeS9nO+8jOS7juWbvuWDj+S4reaPkOWPluWHuuWFt+acieWxgOmDqOWSjOWFqOWxgOS/oeaBr+eahOeJueW+geOAgui/meS6m+eJueW+geWPr+S7peihqOekuuWbvuWDj+eahOe6ueeQhuOAgeW9oueKtuWSjOi+uee8mOetieeJueW+ge+8jOeUqOS6juWIpOaWreS6p+WTgeihqOmdoueahOe8uumZt+OAgeW9oueKtuWBj+W3ruetiVsyXeOAgiDlr7nkuo7kvKDmhJ/lmajkv6Hlj7fmlbDmja7vvIzlj6/ku6Xkvb/nlKjlvqrnjq/npZ7nu4/nvZHnu5zvvIhSTk7vvInmiJblj5jmjaLlmajnvZHnu5zvvIhUcmFuc2Zvcm1lcu+8iei/m+ihjOeJueW+geaPkOWPluOAglJOTuiDveWkn+WvueaXtumXtOW6j+WIl+aVsOaNrui/m+ihjOW7uuaooe+8jOW5tuaNleaNieWIsOWFtuS4reeahOaXtuW6j+S+nei1luWFs+ezu+OAguiAjFRyYW5zZm9ybWVy5YiZ6IO95aSf5a+55LiN5ZCM5Lyg5oSf5Zmo5L+h5Y+35LmL6Ze055qE5YWz57O76L+b6KGM5bu65qih77yM5o+Q5Y+W5Ye65YWo5bGA5LiK55qE54m55b6B6KGo56S644CCIDEuNCDmqKHlnovkvJjljJbkuI7mqKHlnovorq3nu4Mg5qih5Z6L5LyY5YyW5ZKM5qih5Z6L6K6t57uD5piv5rex5bqm5a2m5Lmg5Lit6Iez5YWz6YeN6KaB55qE5LiA5q2l77yM5a6D5raJ5Y+K5Yiw6YCJ5oup5ZCI6YCC55qE5qih5Z6L5p625p6E44CB5o2f5aSx5Ye95pWw5ZKM5LyY5YyW566X5rOV77yM5Lul5Y+K5a+55qih5Z6L6L+b6KGM5pyJ5pWI55qE6K6t57uD5ZKM6LCD5LyY44CCIOmAieaLqeWQiOmAgueahOaooeWei+aetuaehOaYr+aooeWei+S8mOWMlueahOmmluimgeS7u+WKoeOAguWcqOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItuS4re+8jOWPr+S7peagueaNruWFt+S9k+S7u+WKoeeahOeJueeCuemAieaLqemAguWQiOeahOelnue7j+e9kee7nOe7k+aehO+8jOWmgkNOTuOAgVJOTuaIllRyYW5zZm9ybWVy562J44CC5ZCM5pe277yM6L+Y6ZyA6KaB6ICD6JmR5qih5Z6L55qE5rex5bqm44CB5a695bqm5ZKM6L+e5o6l5pa55byP562J6LaF5Y+C5pWw55qE6K6+572u77yM5Lul5YWF5YiG5Y+R5oyl5qih5Z6L55qE6KGo6L6+6IO95Yqb44CCIOaNn+WkseWHveaVsOeahOmAieaLqeS4juaooeWei+eahOiuree7g+ebruagh+WvhuWIh+ebuOWFs+OAguWcqOi0qOmHj+aOp+WItuS4re+8jOW4uOeUqOeahOaNn+WkseWHveaVsOWMheaLrOWdh+aWueivr+W3ru+8iE1TRe+8ieOAgeS6pOWPieeGteaNn+WkseWHveaVsOetieOAguWQiOeQhumAieaLqeaNn+WkseWHveaVsOWPr+S7peacieaViOWcsOW8leWvvOaooeWei+WtpuS5oOebruagh+eJueW+ge+8jOW5tuaPkOmrmOaooeWei+eahOmihOa1i+aAp+iDveOAgiDkvJjljJbnrpfms5XnmoTpgInmi6nlkozlj4LmlbDosIPkvJjlr7nkuo7mqKHlnovnmoTorq3nu4PmlYjmnpzoh7PlhbPph43opoHjgILluLjnlKjnmoTkvJjljJbnrpfms5XljIXmi6zpmo/mnLrmoq/luqbkuIvpmY3vvIhTR0TvvInjgIFBZGFt5LyY5YyW566X5rOV562J44CC6L+Z5Lqb5LyY5YyW566X5rOV6IO95aSf6YCa6L+H6K6h566X5qKv5bqm5bm25pu05paw5qih5Z6L5Y+C5pWw77yM5LiN5pat5LyY5YyW5qih5Z6L55qE5oCn6IO944CC5q2k5aSW77yM6L+Y6ZyA6KaB5a+55a2m5Lmg546H44CB5q2j5YiZ5YyW57O75pWw5ZKM5om56YeP5aSn5bCP562J6LaF5Y+C5pWw6L+b6KGM6LCD5LyY77yM5Lul6I635b6X5pu05aW955qE5qih5Z6L5oCn6IO944CCIDIg5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE5Li76KaB5rWB56iLIDIuMSDmlbDmja7mlLbpm4bkuI7pooTlpITnkIYg5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE56ys5LiA5q2l5piv5pWw5o2u5pS26ZuG5LiO6aKE5aSE55CG44CC5Zyo6L+Z5LiA6Zi25q6177yM6ZyA6KaB5pS26ZuG5bm25pW055CG5LiO55Sf5Lqn6L+H56iL5ZKM5Lqn5ZOB6LSo6YeP55u45YWz55qE5pWw5o2u44CC6L+Z5Lqb5pWw5o2u5Y+v5Lul5YyF5ous5Lyg5oSf5Zmo5pWw5o2u44CB5bel6Im65Y+C5pWw44CB5Lqn5ZOB5qOA5rWL57uT5p6c562J44CCIOaVsOaNruaUtumbhueahOi/h+eoi+mcgOimgeiAg+iZkeaVsOaNrueahOWHhuehruaAp+WSjOWujOaVtOaAp+OAguWQiOmAgueahOS8oOaEn+WZqOWSjOiuvuWkh+iiq+eUqOadpeWunuaXtuaUtumbhuaVsOaNru+8jOehruS/neaVsOaNruWFt+aciemrmOi0qOmHj+WSjOmrmOeyvuW6puOAguWQjOaXtu+8jOS5n+imgeehruS/neaVsOaNruaUtumbhueahOmikeeOh+WSjOaXtumXtOeCueWFt+acieS7o+ihqOaAp++8jOS7peS+v+WFqOmdouS6huino+eUn+S6p+i/h+eoi+OAgiDlnKjmlbDmja7pooTlpITnkIbpmLbmrrXvvIzlr7nmlLbpm4bliLDnmoTmlbDmja7ov5vooYzmuIXmtJfjgIHnrZvpgInlkozkv67mraPvvIzku6XljrvpmaTlvILluLjlgLzlkozlmarlo7DvvIzlubbov5vooYzmlbDmja7op4TojIPljJblkozmoIflh4bljJbvvIzkv53or4HmlbDmja7nmoTkuIDoh7TmgKflkozlj6/mr5TmgKfjgILmraTlpJbvvIzlnKjmnInnvLrlpLHlgLznmoTmg4XlhrXkuIvvvIzlj6/ku6Xkvb/nlKjmj5LlgLznrYnmlrnms5Xov5vooYzmlbDmja7nmoTloavooaXjgIIgMi4yIOaehOW7uua3seW6puWtpuS5oOaooeWeiyDmnoTlu7rmt7HluqblrabkuaDmqKHlnovmmK/lrp7njrDmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTmoLjlv4PmraXpqqTjgILlnKjov5nkuIDpmLbmrrXvvIzpnIDopoHpgInmi6npgILlkIjnmoTmt7HluqblrabkuaDnrpfms5XlkozmnrbmnoTvvIzlubbmoLnmja7pl67popjnmoTnibnngrnov5vooYzmqKHlnovnmoTorr7orqHlkozkvJjljJbjgIIg6aaW5YWI77yM5qC55o2u6LSo6YeP5o6n5Yi255qE55uu5qCH5ZKM6ZyA5rGC77yM6YCJ5oup5ZCI6YCC55qE5rex5bqm5a2m5Lmg566X5rOV77yM5aaC5Y2356ev56We57uP572R57uc77yIQ05O77yJ44CB5b6q546v56We57uP572R57uc77yIUk5O77yJ44CB55Sf5oiQ5a+55oqX572R57uc77yIR0FO77yJ562J44CC5qC55o2u5pWw5o2u55qE54m554K55ZKM6Zeu6aKY55qE5aSN5p2C5bqm77yM6YCJ5oup5ZCI6YCC55qE572R57uc5p625p6E5ZKM5bGC5pWw44CC5YW25qyh77yM6L+b6KGM5pWw5o2u55qE5YiS5YiG77yM5bCG5pWw5o2u6ZuG5YiG5Li66K6t57uD6ZuG44CB6aqM6K+B6ZuG5ZKM5rWL6K+V6ZuG44CC6K6t57uD6ZuG55So5LqO5qih5Z6L55qE6K6t57uD5Y+C5pWw77yM6aqM6K+B6ZuG55So5LqO5qih5Z6L55qE6LCD5LyY5ZKM6YCJ5oup5pyA5L2z5qih5Z6L77yM5rWL6K+V6ZuG55So5LqO6K+E5Lyw5qih5Z6L55qE5oCn6IO95ZKM5rOb5YyW6IO95Yqb44CC5pyA5ZCO77yM6L+b6KGM5qih5Z6L55qE6K6t57uD5ZKM5LyY5YyW44CC5L2/55So6K6t57uD6ZuG5a+55qih5Z6L6L+b6KGM5Y+N5aSN6L+t5Luj5ZKM5LyY5YyW77yM6YCa6L+H5LyY5YyW566X5rOV5ZKM5o2f5aSx5Ye95pWw77yM6LCD5pW05qih5Z6L5Y+C5pWw77yM5o+Q6auY5qih5Z6L55qE6aKE5rWL5YeG56Gu5oCn5ZKM5rOb5YyW6IO95YqbWzNd44CC5Zyo6K6t57uD55qE6L+H56iL5Lit77yM5Y+v5Lul6YeH55So5pWw5o2u5aKe5by65oqA5pyv5p2l5omp5YWF6K6t57uD6ZuG77yM5aKe5Yqg5qih5Z6L55qE6bKB5qOS5oCn44CCIDIuMyDlrp7ml7bnm5HmtYvkuI7lj43ppojmnLrliLYg6YCa6L+H5a6e5pe255uR5rWL55Sf5Lqn6L+H56iL5Lit55qE5pWw5o2u5ZKM6LSo6YeP5oyH5qCH77yM5Y+K5pe25Y+R546w5byC5bi45ZKM6LSo6YeP6Zeu6aKY77yM5bm26YeH5Y+W55u45bqU55qE5Y+N6aaI5o6q5pa944CCIOWcqOWunuaXtuebkea1i+mYtuaute+8jOS9v+eUqOiuree7g+WlveeahOa3seW6puWtpuS5oOaooeWei+WvueWunuaXtuaVsOaNrui/m+ihjOmihOa1i+WSjOWIhuexu++8jOivhuWIq+WHuuW8guW4uOWSjOS4jeiJr+i2i+WKv+OAgui/memcgOimgeWcqOezu+e7n+S4rembhuaIkOWQhOmhueS8oOaEn+WZqOWSjOebkea1i+iuvuWkh++8jOmAmui/h+WunuaXtuaVsOaNrueahOmHh+mbhuWSjOS8oOi+k++8jOWunueOsOWvueeUn+S6p+i/h+eoi+eahOWunuaXtuebkea1i+OAgiDkuIDml6bmo4DmtYvliLDlvILluLjmiJbotKjph4/pl67popjvvIzlj4rml7bov5vooYzlj43ppojlkozmjqfliLbjgILns7vnu5/lj6/ku6XpgJrov4foh6rliqjljJborr7lpIfjgIHmnLrlmajkurrmiJblt6XkurrnmoTlubLpooTmnaXlrp7njrDotKjph4/pl67popjnmoTkv67mraPlkozmjqfliLbjgILlj43ppojmnLrliLbov5jlj6/ku6XlsIbpl67popjkv6Hmga/kvKDpgJLnu5nnm7jlhbPkurrlkZjvvIzku6Xkvr/ov5vooYzov5vkuIDmraXnmoTliIbmnpDlkozlhrPnrZbvvIzpgb/lhY3nsbvkvLzpl67popjnmoTlho3mrKHlj5HnlJ/jgIIgM+WfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueahOW6lOeUqOetlueVpSAzLjEg5Z+65LqO5pm66IO95Lyg5oSf5Zmo55qE5a6e5pe26LSo6YeP55uR5rWLIOWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItuWcqOWunuaXtui0qOmHj+ebkea1i+aWuemdoumHh+eUqOaZuuiDveS8oOaEn+WZqOeahOetlueVpeOAguaZuuiDveS8oOaEn+WZqOmbhuaIkOS6huWFiOi/m+eahOS8oOaEn+aKgOacr+WSjOa3seW6puWtpuS5oOeul+azle+8jOmAmui/h+WunuaXtumHh+mbhuWSjOWIhuaekOeUn+S6p+i/h+eoi+S4reeahOaVsOaNru+8jOWunueOsOWvueS6p+WTgei0qOmHj+eahOebkea1i+WSjOivhOS8sOOAgiDpppblhYjvvIzmmbrog73kvKDmhJ/lmajlj6/ku6Xlrp7ml7bph4fpm4bnlJ/kuqfov4fnqIvkuK3nmoTlkITnp43lj4LmlbDmlbDmja7vvIzlpoLmuKnluqbjgIHljovlipvjgIHmjK/liqjnrYnjgILov5nkupvmlbDmja7nu4/ov4fkvKDmhJ/lmajlhoXpg6jnmoTmt7HluqblrabkuaDnrpfms5XlpITnkIbvvIzlj6/ku6XnlKjkuo7lrp7ml7bnm5HmtYvkuqflk4HnmoTlkITpobnotKjph4/mjIfmoIfvvIzkvovlpoLlsLrlr7jnsr7luqbjgIHooajpnaLlhYnmtIHluqbnrYnjgIIg5YW25qyh77yM5Z+65LqO5rex5bqm5a2m5Lmg55qE5pm66IO95Lyg5oSf5Zmo6IO95aSf5a2m5Lmg5bm25YiG5p6Q5LiN5ZCM5bel5Ya15LiL55qE5qih5byP5ZKM6KeE5b6L44CC6YCa6L+H5a+55aSn6YeP5pWw5o2u55qE5a2m5Lmg77yM5Lyg5oSf5Zmo5Y+v5Lul5YeG56Gu5Zyw5Yik5pat5piv5ZCm5a2Y5Zyo6LSo6YeP6Zeu6aKY77yM5bm25Y+K5pe257uZ5Ye66aKE6K2m5ZKM5o+Q6YaS77yM5biu5Yqp5LyB5Lia5Y+K5pe26YeH5Y+W5o6q5pa95Lul6YG/5YWN6LSo6YeP6Zeu6aKY55qE5Y+R55Sf44CCIOatpOWklu+8jOaZuuiDveS8oOaEn+WZqOi/mOWPr+S7peS4juacuuWZqOS6uuaIluWFtuS7luiHquWKqOWMluiuvuWkh+i/m+ihjOiBlOWKqO+8jOWunueOsOWunuaXtui0qOmHj+ebkea1i+S4juaOp+WItueahOmXreeOr+OAguS4gOaXpuWPkeeOsOi0qOmHj+W8guW4uO+8jOaZuuiDveS8oOaEn+WZqOWPr+S7pemAmui/h+e9kee7nOS4jueUn+S6p+e6v+S4iueahOWFtuS7luiuvuWkh+mAmuS/oe+8jOWPiuaXtui/m+ihjOiwg+aVtOWSjOS/ruato++8jOehruS/neS6p+WTgei0qOmHj+eahOeos+WumuaAp+WSjOS4gOiHtOaAp+OAgiAzLjIg5Z+65LqO6aKE5rWL5YiG5p6Q55qE5pWF6Zqc5qOA5rWL5LiO6aKE6K2mIOWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItuWcqOaVhemanOajgOa1i+S4jumihOitpuaWuemdoumHh+eUqOmihOa1i+WIhuaekOeahOetlueVpeOAgumAmui/h+WIhuaekOWOhuWPsuaVsOaNruWSjOWunuaXtuaVsOaNru+8jOezu+e7n+WPr+S7pemihOa1i+iuvuWkh+i/kOihjOS4reWPr+iDveWPkeeUn+eahOaVhemanO+8jOW5tuaPkOWJjei/m+ihjOmihOitpu+8jOS7pemBv+WFjeeUn+S6p+S4reeahOi0qOmHj+mXrumimOOAgiDpppblhYjvvIzmt7HluqblrabkuaDmqKHlnovlj6/ku6XlrabkuaDorr7lpIfov5DooYzov4fnqIvkuK3nmoTlkITnp43mqKHlvI/lkozop4TlvovjgILpgJrov4flr7nlpKfph4/ljoblj7LmlbDmja7nmoTorq3nu4PvvIzns7vnu5/lj6/ku6Xor4bliKvlh7rkuI3lkIzmlYXpmpzmqKHlvI/nmoTnibnlvoHvvIzlu7rnq4vmlYXpmpzpooTmtYvmqKHlnovjgILlvZPlrp7ml7bmlbDmja7kuI7pooTmtYvmqKHlnovkuI3nrKbml7bvvIzns7vnu5/lj6/ku6XliKTmlq3lj6/og73lrZjlnKjmlYXpmpzvvIzlubblj5Hlh7rpooTorabkv6Hlj7fjgIIg5YW25qyh77yM6aKE5rWL5YiG5p6Q5Y+v5Lul5Z+65LqO5aSa56eN5pWw5o2u5rqQ77yM5YyF5ous6K6+5aSH5pWw5o2u44CB546v5aKD5pWw5o2u44CB5L6b5bqU6ZO+5pWw5o2u562J44CC6YCa6L+H57u85ZCI5YiG5p6Q6L+Z5Lqb5pWw5o2u77yM57O757uf5Y+v5Lul5pu05YeG56Gu5Zyw6aKE5rWL5pWF6Zqc55qE5Y+R55Sf77yM5bm25Y+K5pe26YeH5Y+W55u45bqU55qE5o6q5pa977yM5L6L5aaC5YGc5py657u05L+u44CB5pu05o2i6Zu26YOo5Lu2562J77yM5Lul6YG/5YWNLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgd3JpdGUgYW4gYWJzdHJhY3QgZm9yIGEgcGFwZXIgb24gY29udGFpbmVyIHRlY2hub2xvZ3kuIFRoZSBvdGhlciBwYXJ0cyBvZiB0aGUgcGFwZXIgYXJlIGFzIGZvbGxvd3M6ICoqUmVzZWFyY2ggb24gQ2xvdWQgUGxhdGZvcm0gTmV0d29yayBBcmNoaXRlY3R1cmUgQmFzZWQgb24gQ29udGFpbmVyIFRlY2hub2xvZ3kqKgoKMCBJbnRyb2R1Y3Rpb24gIApJbiBjbG91ZCBjb21wdXRpbmcgZW52aXJvbm1lbnRzLCBvcHRpbWl6aW5nIG5ldHdvcmsgYXJjaGl0ZWN0dXJlIGlzIGNydWNpYWwgZm9yIGVuaGFuY2luZyB0aGUgcGVyZm9ybWFuY2Ugb2YgY2xvdWQgc2VydmljZXNbMV0uIENvbnRhaW5lciB0ZWNobm9sb2d5LCB3aXRoIGl0cyBsaWdodHdlaWdodCBhbmQgZWZmaWNpZW50IGNoYXJhY3RlcmlzdGljcywgb2ZmZXJzIG5ldyBwZXJzcGVjdGl2ZXMgZm9yIHRoZSBuZXR3b3JrIGFyY2hpdGVjdHVyZSBvZiBjbG91ZCBwbGF0Zm9ybXNbMi00XS4gVGhpcyBzdHVkeSBmb2N1c2VzIG9uIHRoZSBhcHBsaWNhdGlvbiBvZiBjb250YWluZXIgdGVjaG5vbG9neSBpbiBjbG91ZCBwbGF0Zm9ybSBuZXR3b3JrIGFyY2hpdGVjdHVyZSwgYWltaW5nIHRvIHNvbHZlIGlzc3VlcyBzdWNoIGFzIG5ldHdvcmsgaXNvbGF0aW9uLCBzY2FsYWJpbGl0eSwgYW5kIHNlY3VyaXR5IHByb2JsZW1zIHByZXNlbnQgaW4gdHJhZGl0aW9uYWwgdmlydHVhbGl6YXRpb24gZW52aXJvbm1lbnRzLiBUaGUgZGVzaWduIG9mIGNvbnRhaW5lciBuZXR3b3JrIGFyY2hpdGVjdHVyZSBtdXN0IG1lZXQgdGhlIGR5bmFtaWMgYW5kIGVsYXN0aWMgcmVxdWlyZW1lbnRzIG9mIGNsb3VkIHNlcnZpY2VzIHdoaWxlIGVuc3VyaW5nIHRoZSBlZmZpY2llbmN5IGFuZCBzZWN1cml0eSBvZiBuZXR3b3JrIGNvbW11bmljYXRpb24uIFRoaXMgcmVzZWFyY2ggZXhwbG9yZXMgdGhlIGtleSB0ZWNobm9sb2dpZXMgb2YgY29udGFpbmVyIG5ldHdvcmtzLCBpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIG5ldHdvcmsgaXNvbGF0aW9uIG1lY2hhbmlzbXMsIGxvYWQgYmFsYW5jaW5nIHN0cmF0ZWdpZXMsIHNlcnZpY2UgZGlzY292ZXJ5LCBhbmQgc2VjdXJpdHkgaGFyZGVuaW5nIG1lYXN1cmVzLiAgCgoxIENvbnRhaW5lciBOZXR3b3JrIEFyY2hpdGVjdHVyZSBEZXNpZ24gIAoxLjEgRGVzaWduIENvbmNlcHQgIApUaGUgY29yZSBvZiBjb250YWluZXIgbmV0d29yayBhcmNoaXRlY3R1cmUgZGVzaWduIGlzIHRvIGFjaGlldmUgZWZmaWNpZW50LCBmbGV4aWJsZSwgYW5kIHNlY3VyZSBuZXR3b3JrIGNvbW11bmljYXRpb24uIEluIGNsb3VkIHBsYXRmb3JtcywgY29udGFpbmVycywgYXMgYSBsaWdodHdlaWdodCB2aXJ0dWFsaXphdGlvbiB0ZWNobm9sb2d5LCByZXF1aXJlIGEgbmV0d29yayBkZXNpZ24gdGhhdCBzYXRpc2ZpZXMgdGhlIG5lZWRzIG9mIHJhcGlkIGRlcGxveW1lbnQgYW5kIGR5bmFtaWMgc2NhbGFiaWxpdHkgaW4gYSBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZS4gVGhpcyBzZWN0aW9uIHdpbGwgZGVsdmUgaW50byB0aGUgZGVzaWduIGNvbmNlcHQgb2YgY29udGFpbmVyIG5ldHdvcmsgYXJjaGl0ZWN0dXJlLCBpbmNsdWRpbmcgbmV0d29yayBpc29sYXRpb24sIHNlcnZpY2UgZGlzY292ZXJ5LCBsb2FkIGJhbGFuY2luZywgYW5kIHNlY3VyaXR5IHN0cmF0ZWdpZXMuICAKTmV0d29yayBpc29sYXRpb24gaXMgZXNzZW50aWFsIGZvciBlbnN1cmluZyBzZWN1cmUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGNvbnRhaW5lcnMuIFR1bm5lbCB0ZWNobm9sb2dpZXMgc3VjaCBhcyBWWExBTiBvciBTVFQgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IG5ldHdvcmsgaXNvbGF0aW9uIGJldHdlZW4gZGlmZmVyZW50IHRlbmFudHMuIE1lYW53aGlsZSwgRG9ja2Vy4oCZcyBuZXR3b3JrIHBsdWdpbnMgKGUuZy4sIENhbGljbyBvciBGbGFubmVsKSBjYW4gcHJvdmlkZSBlYWNoIGNvbnRhaW5lciB3aXRoIGFuIGluZGVwZW5kZW50IG5ldHdvcmsgc3RhY2suIFNlcnZpY2UgZGlzY292ZXJ5IGlzIGFuIGludGVncmFsIHBhcnQgb2YgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUuICAKCjEuMiBOZXR3b3JrIENvbXBvbmVudHMgYW5kIEZ1bmN0aW9ucyAgClRoZSBkZXNpZ24gb2YgY29udGFpbmVyIG5ldHdvcmsgYXJjaGl0ZWN0dXJlIGZvY3VzZXMgb24gYnVpbGRpbmcgYW4gZWZmaWNpZW50LCBzY2FsYWJsZSwgYW5kIHNlY3VyZSBuZXR3b3JrIGVudmlyb25tZW50IHRvIHN1cHBvcnQgY29udGFpbmVyaXplZCBkZXBsb3ltZW50IG9uIGNsb3VkIHBsYXRmb3Jtcy4gVGhlIGNvcmUgY29tcG9uZW50cyBpbmNsdWRlIG5ldHdvcmsgaW50ZXJmYWNlIGNvbnRyb2xsZXJzLCBzZXJ2aWNlIGRpc2NvdmVyeSBtZWNoYW5pc21zLCBsb2FkIGJhbGFuY2VycywgYW5kIHNlY3VyaXR5IHBvbGljaWVzLiBUaGUgbmV0d29yayBpbnRlcmZhY2UgY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIG1hbmFnaW5nIGNvbnRhaW5lciBuZXR3b3JrcywgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgY29udGFpbmVyIHJ1bnRpbWUgdmlhIHRoZSBBcHBsaWNhdGlvbiBQcm9ncmFtbWluZyBJbnRlcmZhY2UgKEFQSSkgdG8gZW5hYmxlIGR5bmFtaWMgbmV0d29yayBjb25maWd1cmF0aW9uLiBUaGUgc2VydmljZSBkaXNjb3ZlcnkgbWVjaGFuaXNtIGFsbG93cyBjb250YWluZXJzIHRvIGNvbW11bmljYXRlIHZpYSBzZXJ2aWNlIG5hbWVzIHJhdGhlciB0aGFuIElQIGFkZHJlc3NlcyBieSByZWdpc3RlcmluZyBzZXJ2aWNlIGluc3RhbmNlcyBhbmQgaW5zdGFuY2UgaW5mb3JtYXRpb24sIGVuYWJsaW5nIGR5bmFtaWMgc2VydmljZSByZWdpc3RyYXRpb24gYW5kIGRpc2NvdmVyeS4gIApMb2FkIGJhbGFuY2VycyBhcmUgZGlzdHJpYnV0ZWQgYWNyb3NzIHRoZSBuZXR3b3JrIGFuZCBhbGxvY2F0ZSByZXF1ZXN0cyB0byBhcHByb3ByaWF0ZSBjb250YWluZXIgaW5zdGFuY2VzIGJhc2VkIG9uIHJlYWwtdGltZSB0cmFmZmljIGFuZCBoZWFsdGggY2hlY2sgcmVzdWx0cywgZW5zdXJpbmcgaGlnaCBhdmFpbGFiaWxpdHkgYW5kIHJlc3BvbnNpdmVuZXNzIG9mIHNlcnZpY2VzLiBTZWN1cml0eSBwb2xpY2llcyBwcm90ZWN0IGRhdGEgdHJhbnNtaXNzaW9uIGJldHdlZW4gY29udGFpbmVycyBieSBpbXBsZW1lbnRpbmcgbmV0d29yayBpc29sYXRpb24sIGFjY2VzcyBjb250cm9sLCBhbmQgZW5jcnlwdGVkIGNvbW11bmljYXRpb24uIFRhYmxlIDEgbGlzdHMgdGhlIHBlcmZvcm1hbmNlIG1ldHJpY3Mgb2YgZGlmZmVyZW50IGxvYWQgYmFsYW5jaW5nIGFsZ29yaXRobXMsIGRlbW9uc3RyYXRpbmcgdGhlIHBlcmZvcm1hbmNlIG9mIFJvdW5kIFJvYmluLCBSYW5kb20sIGFuZCBMZWFzdCBDb25uZWN0aW9ucyBhbGdvcml0aG1zIGluIHZhcmlvdXMgc2NlbmFyaW9zLiAgCgpUYWJsZSAxOiBQZXJmb3JtYW5jZSBNZXRyaWNzIG9mIERpZmZlcmVudCBMb2FkIEJhbGFuY2luZyBBbGdvcml0aG1zICAKCnwgQWxnb3JpdGhtIFR5cGUgfCBBdmVyYWdlIFJlc3BvbnNlIFRpbWUgKG1zKSB8IFJlc291cmNlIFV0aWxpemF0aW9uICglKSB8ICAKfC0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwgIAp8IFJvdW5kIFJvYmluICAgIHwgNTAgICAgICAgICAgICAgICAgICAgICAgICAgfCA4MCAgICAgICAgICAgICAgICAgICAgICAgfCAgCnwgUmFuZG9tICAgICAgICAgfCA3NSAgICAgICAgICAgICAgICAgICAgICAgICB8IDc1ICAgICAgICAgICAgICAgICAgICAgICB8ICAKfCBMZWFzdCBDb25uZWN0aW9ucyB8IDQ1ICAgICAgICAgICAgICAgICAgICAgfCA4NSAgICAgICAgICAgICAgICAgICAgICAgfCAgCgoxLjMgSXNvbGF0aW9uIGFuZCBTZWN1cml0eSBvZiBDb250YWluZXIgTmV0d29ya3MgIApUaGUgaXNvbGF0aW9uIGFuZCBzZWN1cml0eSBvZiBjb250YWluZXIgbmV0d29ya3MgYXJlIGNydWNpYWwgZm9yIGVuc3VyaW5nIHRoZSBzdGFibGUgb3BlcmF0aW9uIG9mIGNsb3VkIHBsYXRmb3Jtcy4gQ29udGFpbmVyIHRlY2hub2xvZ3kgYWNoaWV2ZXMgbmV0d29yayBpc29sYXRpb24gdGhyb3VnaCBuYW1lc3BhY2VzIGFuZCBuZXR3b3JrIHBvbGljaWVzLCBwcmV2ZW50aW5nIHVubmVjZXNzYXJ5IGNvbW11bmljYXRpb24gYmV0d2VlbiBjb250YWluZXJzLCB0aGVyZWJ5IHJlZHVjaW5nIHNlY3VyaXR5IHJpc2tzLiBOZXR3b3JrIHBvbGljaWVzIGNvbnRyb2wgaW5jb21pbmcgYW5kIG91dGdvaW5nIHRyYWZmaWMgdG8gY29udGFpbmVycyB0aHJvdWdoIGlwdGFibGVzIHJ1bGVzIG9yIHRoaXJkLXBhcnR5IHNvbHV0aW9ucyAoc3VjaCBhcyBDYWxpY28pLCBlbmFibGluZyBmaW5lLWdyYWluZWQgYWNjZXNzIGNvbnRyb2wuICAKQWRkaXRpb25hbGx5LCBlbmNyeXB0aW9uIHRlY2hub2xvZ3kgaW4gY29udGFpbmVyIG5ldHdvcmtzIGVuc3VyZXMgdGhlIHNlY3VyaXR5IG9mIGRhdGEgdHJhbnNtaXNzaW9uLiBUaGUgVHJhbnNwb3J0IExheWVyIFNlY3VyaXR5IChUTFMpIHByb3RvY29sIGlzIHdpZGVseSB1c2VkIHRvIGVzdGFibGlzaCBzZWN1cmUgY29tbXVuaWNhdGlvbiBjaGFubmVscyBiZXR3ZWVuIGNvbnRhaW5lcnMsIGVuc3VyaW5nIHRoZSBpbnRlZ3JpdHkgYW5kIHByaXZhY3kgb2YgZGF0YSBkdXJpbmcgdHJhbnNtaXNzaW9uLiAgClRvIHF1YW50aWZ5IHRoZSBlZmZlY3Qgb2YgbmV0d29yayBpc29sYXRpb24sIHRoaXMgcGFwZXIgdXNlcyBhbiBpc29sYXRpb24gZWZmaWNpZW5jeSBmb3JtdWxhLCBhcyBzaG93biBpbiBlcXVhdGlvbiAoMSkuICAK8J2cgj3wnZGZ8J2Qv8OXMTAwJSDigIMoMSkgIAp3aGVyZSDOtyBpcyB0aGUgaXNvbGF0aW9uIGVmZmljaWVuY3ksIGwgaXMgdGhlIGlsbGVnYWwgdHJhZmZpYyBzdWNjZXNzZnVsbHkgYmxvY2tlZCwgYW5kIEwgaXMgdGhlIHRvdGFsIGlsbGVnYWwgdHJhZmZpYy4gIAoKMiBDbG91ZCBQbGF0Zm9ybSBOZXR3b3JrIEFyY2hpdGVjdHVyZSBJbXBsZW1lbnRhdGlvbiAgCjIuMSBOZXR3b3JrIENvbXBvbmVudCBJbXBsZW1lbnRhdGlvbiBUZWNobm9sb2dpZXMgIApLZXkgdGVjaG5vbG9naWVzIGZvciBpbXBsZW1lbnRpbmcgY2xvdWQgcGxhdGZvcm0gbmV0d29yayBhcmNoaXRlY3R1cmUgaW5jbHUuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2UgaGVscCBtZSB3cml0ZSBhbiBpbnRyb2R1Y3Rpb24gZm9yIGEgcGFwZXIgb24gY2xvdWQtbmF0aXZlIGFyY2hpdGVjdHVyZS4gVGhlIG90aGVyIHBhcnRzIG9mIHRoZSBwYXBlciBhcmUgYXMgZm9sbG93cyBBcHBsaWNhdGlvbiBSZXNlYXJjaCBvZiBDbG91ZC1OYXRpdmUgQXJjaGl0ZWN0dXJlIENvbXB1dGluZyBQbGF0Zm9ybSBpbiBNZWRpY2FsIEltYWdpbmcgRWR1Y2F0aW9uCgoxIENsb3VkLU5hdGl2ZSBBcmNoaXRlY3R1cmUgQ29tcHV0aW5nIFBsYXRmb3JtICAKMS4xIENsb3VkLU5hdGl2ZSBDb25jZXB0ICAKVGhlIGNvbmNlcHQgb2YgY2xvdWQtbmF0aXZlIHJlcHJlc2VudHMgYSBuZXcgcGFyYWRpZ20gaW4gbW9kZXJuIHNvZnR3YXJlIGRldmVsb3BtZW50LCBkZXBsb3ltZW50LCBhbmQgbWFpbnRlbmFuY2UsIGZvY3VzaW5nIG9uIGJ1aWxkaW5nIGFwcGxpY2F0aW9ucyB0aGF0IGNhbiBydW4gZWZmaWNpZW50bHkgaW4gY2xvdWQgZW52aXJvbm1lbnRzLiBUaGUgY29yZSBvZiB0aGlzIGFwcHJvYWNoIGlzIGVuc3VyaW5nIHRoYXQgYXBwbGljYXRpb25zIGZ1bGx5IGxldmVyYWdlIHRoZSBlbGFzdGljaXR5LCBzY2FsYWJpbGl0eSwgYW5kIGF1dG9tYXRpb24gYWR2YW50YWdlcyBwcm92aWRlZCBieSBjbG91ZCBjb21wdXRpbmcuIEJ5IGFkb3B0aW5nIGFkdmFuY2VkIHRlY2hub2xvZ2llcyBzdWNoIGFzIGNvbnRhaW5lcml6YXRpb24sIG1pY3Jvc2VydmljZXMgYXJjaGl0ZWN0dXJlLCBEZXZPcHMgcHJhY3RpY2VzLCBhbmQgY29udGludW91cyBpbnRlZ3JhdGlvbi9jb250aW51b3VzIGRlcGxveW1lbnQgKENJL0NEKSwgY2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBjYW4gYmUgcmFwaWRseSBkZXBsb3llZCwgZmxleGlibHkgc2NhbGVkIGFjY29yZGluZyB0byBkZW1hbmQsIGFjaGlldmUgZWZmaWNpZW50IG9wZXJhdGlvbnMgbWFuYWdlbWVudCwgYW5kIGFjY2VsZXJhdGUgcHJvZHVjdCBpdGVyYXRpb24gYW5kIHVwZ3JhZGVzLiBUaGUgcHJvbW90aW9uIG9mIHRoaXMgcGFyYWRpZ20gaGFzIG1hZGUgc29mdHdhcmUgZGV2ZWxvcG1lbnQgYW5kIG9wZXJhdGlvbnMgbW9yZSBmbGV4aWJsZSBhbmQgZWZmaWNpZW50LCBhZGFwdGluZyB0byB0aGUgcmFwaWRseSBjaGFuZ2luZyBkZW1hbmRzIG9mIHRoZSBjbG91ZCBjb21wdXRpbmcgZXJhLiAgCgoxLjIgQ2xvdWQtTmF0aXZlIEFyY2hpdGVjdHVyZSAgCjEuMi4xIENvbXBvbmVudHMgb2YgQ2xvdWQtTmF0aXZlIEFyY2hpdGVjdHVyZSAgCkNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUgY29uc2lzdHMgb2Ygc2V2ZXJhbCBrZXkgY29tcG9uZW50cyB0aGF0IGNvbGxhYm9yYXRlIHRvIHByb3ZpZGUgYW4gZWZmaWNpZW50LCByZWxpYWJsZSwgYW5kIHNjYWxhYmxlIHJ1bnRpbWUgZW52aXJvbm1lbnQgZm9yIGFwcGxpY2F0aW9ucy4gVGhlc2UgaW5jbHVkZSBtaWNyb3NlcnZpY2VzLCBjb250YWluZXJpemF0aW9uLCBjb250aW51b3VzIGludGVncmF0aW9uL2NvbnRpbnVvdXMgZGVwbG95bWVudCAoQ0kvQ0QpLCBhbmQgRGV2T3BzLCBhbW9uZyBvdGhlcnMuICAKMSkgTWljcm9zZXJ2aWNlczogVGhlIG1pY3Jvc2VydmljZXMgYXJjaGl0ZWN0dXJlIGJyZWFrcyBkb3duIGxhcmdlIGFwcGxpY2F0aW9ucyBpbnRvIHNtYWxsZXIgdGFza3MgYW5kIGluZGl2aWR1YWwgc2VydmljZXMuIFZhcmlvdXMgYnVzaW5lc3Mgb3BlcmF0aW9ucyBydW4gaW4gdGhlaXIgb3duIHByb2Nlc3NlcyBhbmQgaW50ZXJhY3QgdGhyb3VnaCBsaWdodHdlaWdodCBjb21tdW5pY2F0aW9uIHByb3RvY29scy4gIAoyKSBDb250YWluZXJpemF0aW9uOiBUaGlzIGlzIHRoZSBjb3JuZXJzdG9uZSBvZiBjbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlLiBCeSBkZXBsb3lpbmcgdGhlIHN5c3RlbSBlbnZpcm9ubWVudCwgYXBwbGljYXRpb25zLCBhbmQgcmVsYXRlZCBkZXBlbmRlbmNpZXMgaW4gY29udGFpbmVycywgaXQgZW5zdXJlcyB0aGF0IGFwcGxpY2F0aW9ucyBhcmUgZnVsbHkgcG9ydGFibGUgYWNyb3NzIGRpZmZlcmVudCBkZXBsb3ltZW50IGVudmlyb25tZW50cy4gIAozKSBDb250aW51b3VzIEludGVncmF0aW9uL0NvbnRpbnVvdXMgRGVwbG95bWVudCAoQ0kvQ0QpOiBJbiBjbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlLCBDSS9DRCBlbmFibGVzIHJhcGlkIHJlc3BvbnNlIHRvIGNoYW5nZXMgaW4gZGVtYW5kLCBpbXByb3ZpbmcgZGV2ZWxvcG1lbnQgZWZmaWNpZW5jeSBhbmQgcHJvZHVjdCBxdWFsaXR5IHRocm91Z2ggYXV0b21hdGVkIGJ1aWxkaW5nLCB0ZXN0aW5nLCBhbmQgZGVwbG95bWVudCBwcm9jZXNzZXMuICAKNCkgRGV2T3BzOiBEZXZPcHMgaXMgcHJpbWFyaWx5IHJlc3BvbnNpYmxlIGZvciB0aGUgY29vcmRpbmF0aW9uIGFuZCBjb2xsYWJvcmF0aW9uIGJldHdlZW4gb3BlcmF0aW9ucyBhbmQgZGV2ZWxvcG1lbnQgd2l0aGluIHRoZSBwbGF0Zm9ybSwgc2V0dGluZyB1cCBzdGFuZGFyZGl6ZWQgYW5kIGF1dG9tYXRlZCBwcm9jZXNzZXMgdG8gYWNoaWV2ZSBlZmZpY2llbnQgaXRlcmF0aW9uLCByYXBpZCBvcGVyYXRpb25zLCBhbmQgY29udGludW91cyBpbXByb3ZlbWVudC4gIAoKMS4yLjIgQWR2YW50YWdlcyBvZiBDbG91ZC1OYXRpdmUgQXJjaGl0ZWN0dXJlICAKQ29tcGFyZWQgdG8gdHJhZGl0aW9uYWwgYXJjaGl0ZWN0dXJlLCBjbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlIGhhcyB0aGUgZm9sbG93aW5nIGNoYXJhY3RlcmlzdGljczogZWxhc3RpYyBzY2FsaW5nLCBoaWdoIGF2YWlsYWJpbGl0eSwgZWZmaWNpZW50IG9wZXJhdGlvbnMsIHJhcGlkIGl0ZXJhdGlvbiwgYW5kIGNvc3QgcmVkdWN0aW9uLCBhcyBvdXRsaW5lZCBiZWxvdzogIAoxKSBFbGFzdGljIFNjYWxpbmc6IENsb3VkLW5hdGl2ZSBhcHBsaWNhdGlvbnMgY2FuIHJhcGlkbHkgYW5kIGZsZXhpYmx5IHNjYWxlIHRvIGFjY29tbW9kYXRlIGNoYW5nZXMgaW4gYnVzaW5lc3MgZGVtYW5kIHRocm91Z2ggY29udGFpbmVyaXphdGlvbiBhbmQgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUuICAKMikgSGlnaCBBdmFpbGFiaWxpdHk6IENsb3VkLW5hdGl2ZSBhcHBsaWNhdGlvbnMgYXJlIGhpZ2hseSBhdmFpbGFibGUgYW5kIHJlc2lsaWVudCwgY2FwYWJsZSBvZiByYXBpZCByZWNvdmVyeSBpbiB0aGUgZXZlbnQgb2YgZmFpbHVyZS4gIAozKSBFZmZpY2llbnQgT3BlcmF0aW9uczogQ2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBjYW4gYXV0b21hdGUgb3BlcmF0aW9ucywgaW5jbHVkaW5nIGF1dG9tYXRlZCBidWlsZGluZywgZGVwbG95bWVudCwgbW9uaXRvcmluZywgYW5kIGFsZXJ0cy4gIAo0KSBSYXBpZCBJdGVyYXRpb246IENsb3VkLW5hdGl2ZSBhcHBsaWNhdGlvbnMgcHJpbWFyaWx5IHVzZSBEZXZPcHMgYW5kIGFnaWxlIGRldmVsb3BtZW50IG1ldGhvZHMsIGVuYWJsaW5nIHJhcGlkIGl0ZXJhdGlvbiBhbmQgdXBkYXRlcy4gIAo1KSBDb3N0IFJlZHVjdGlvbjogQ2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBtYWtlIGZ1bGwgdXNlIG9mIGNsb3VkIHBsYXRmb3JtIHJlc291cmNlcywgZWZmZWN0aXZlbHkgcmVkdWNpbmcgY29zdHMuICAKCjEuMyBDbG91ZC1OYXRpdmUgUmVzZWFyY2ggYW5kIFRlYWNoaW5nIFBsYXRmb3JtIEZyYW1ld29yayAgClRoaXMgcGFwZXIgcHJvcG9zZXMgYSBkZXNpZ24gc2NoZW1lIGZvciBhIHRlYWNoaW5nIGFuZCByZXNlYXJjaCBjb21wdXRpbmcgcGxhdGZvcm0gYmFzZWQgb24gY2xvdWQtbmF0aXZlIGFyY2hpdGVjdHVyZSwgYXMgc2hvd24gaW4gRmlndXJlIDEuIEl0IGluY2x1ZGVzIEt1YmVybmV0ZXMgKEs4UykgY29tcGF0aWJpbGl0eSwgZGlzdHJpYnV0ZWQgc3RvcmFnZSwgdGFzayBxdWV1ZXMsIGF1dG9tYXRlZCBvcGVyYXRpb25zLCBhbmQgcmVzb3VyY2Ugc2NoZWR1bGluZy4gIAoKRmlndXJlIDE6IENsb3VkLU5hdGl2ZSBBcmNoaXRlY3R1cmUgVGVhY2hpbmcgYW5kIFJlc2VhcmNoIENvbXB1dGluZyBQbGF0Zm9ybSAgClRoZSBwcm9wb3NlZCBjbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlIHRlYWNoaW5nIGFuZCByZXNlYXJjaCBjb21wdXRpbmcgcGxhdGZvcm0gaXMgYSBtdWx0aS11c2VyIHBhcmFsbGVsIGNvbXB1dGluZyBwbGF0Zm9ybSBjZW50ZXJlZCBvbiBzdHVkZW50IHJlc2VhcmNoIGFuZCB0ZWFjaGluZyBzY2VuYXJpb3MuIEl0IHByb3ZpZGVzIGZ1bGwtc3RhY2sgSVQgYXV0b21hdGlvbiBvcGVyYXRpb25zIGNhcGFiaWxpdGllcywgc2ltcGxpZnlpbmcgdGhlIHdvcmtmbG93IG9mIHRlYWNoaW5nIGFuZCByZXNlYXJjaCwgYW5kIHByb3ZpZGVzIGEgdXNlci1mcmllbmRseSBndWlkZWQgaW50ZXJmYWNlIHRoYXQgZW1wb3dlcnMgaW5zdHJ1Y3RvcnMgdG8gcXVpY2tseSBidWlsZCBhIHBvd2VyZnVsIGFuZCBmZWF0dXJlLXJpY2ggY29udGFpbmVyIGNsb3VkIHBsYXRmb3JtIGZvciBzdHVkZW50cy4gIAoKRmlndXJlIDI6IENsb3VkLU5hdGl2ZSBUZWFjaGluZyBhbmQgUmVzZWFyY2ggUGxhdGZvcm0gRnJhbWV3b3JrICAKRnJvbSBGaWd1cmUgMiwgd2UgY2FuIHNlZSB0aGF0IHRoaXMgcGxhdGZvcm0gaW50ZWdyYXRlcyBhIHBvd2VyZnVsIEdQVSBjbHVzdGVyIHRvIHByb3ZpZGUgZWZmaWNpZW50IGRhdGEgcHJvY2Vzc2luZyBhbmQgdmlzdWFsaXphdGlvbiBjYXBhYmlsaXRpZXMsIHN1cHBvcnRpbmcgaW4tZGVwdGggcmVzZWFyY2ggYW5kIHRlYWNoaW5nIG9mIG1lZGljYWwgaW1hZ2luZy4gVGhlIG1pY3Jvc2VydmljZXMgYXJjaGl0ZWN0dXJlIGVuc3VyZXMgdGhhdCB0aGUgcGxhdGZvcm0gaGFzIHN0cm9uZyBvcGVubmVzcyBhbmQgc2NhbGFiaWxpdHkuIFRoZSB1c2VyIGNlbnRlciBlbnN1cmVzIHRoZSBzZWN1cmUgYW5kIG9yZGVybHkgdXNlIG9mIHJlc291cmNlcy4gQWRkaXRpb25hbGx5LCB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgR1BVIHBoeXNpY2FsIG1hY2hpbmVzIGFuZCBXaW5kb3dzIHZpcnR1YWwgbWFjaGluZXMsIG1lZXRpbmcgZGl2ZXJzZSBzb2Z0d2FyZSBuZWVkcy4gT3ZlcmFsbCwgdGhlIHBsYXRmb3JtIHByb3ZpZGVzIHNvbGlkIHRlY2huaWNhbCBzdXBwb3J0IGZvciB0ZWFjaGluZyBhbmQgcmVzZWFyY2ggaW4gdGhlIGZpZWxkIG9mIG1lZGljYWwgaW1hZ2luZywgcHJvbW90aW5nIHRoZSBjb250aW51b3VzIGRldmVsb3BtZW50IG9mIHRoZSBmaWVsZC4gIAoKMi4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6ClBsZWFzZSBoZWxwIG1lIHJldmlzZSB0aGUgaW50cm9kdWN0aW9uIG9mIHRoaXMgcGFwZXIgb24gc21hcnQgY2l0aWVzIGFuZCBleHBhbmQgaXQgYSBiaXQgbW9yZSwgc3VjaCBhcyBhZGRpbmcgdGhlIHJlc2VhcmNoIGJhY2tncm91bmQsIHJlc2VhcmNoIHNpZ25pZmljYW5jZSwgZXRjLiBUaGUgb3JpZ2luYWwgZnVsbCB0ZXh0IG9mIHRoZSBwYXBlciBpcyBhcyBmb2xsb3dzOiAqKlJlc2VhcmNoIG9uIHRoZSBDb25zdHJ1Y3Rpb24gUGxhbiBvZiBOZXcgU21hcnQgQ2l0aWVzKiogIApBYnN0cmFjdDogVGhlIGNvbnN0cnVjdGlvbiBvZiBzbWFydCBjaXRpZXMgbm90IG9ubHkgY29uY2VybnMgdGhlIGFjY3VyYWN5IG9mIHVyYmFuIHBsYW5uaW5nIGFuZCBkZWNpc2lvbi1tYWtpbmcgYnV0IGFsc28gZGlyZWN0bHkgaW1wYWN0cyByZXNpZGVudHMnIGhhcHBpbmVzcyBhbmQgc2F0aXNmYWN0aW9uLCBzZXJ2aW5nIGFzIGEga2V5IGluZGljYXRvciBmb3IgbWVhc3VyaW5nIHRoZSBxdWFsaXR5IG9mIHVyYmFuIGRldmVsb3BtZW50LiBUaGlzIHBhcGVyIGFpbXMgdG8gY29tYmluZSB0aGUgaW5ub3ZhdGl2ZSBwcmFjdGljZXMgaW4gZGF0YSBzaGFyaW5nLCBnb3Zlcm5tZW50IHNlcnZpY2VzLCB1cmJhbiBtYW5hZ2VtZW50LCBhbmQgb3RoZXIgYXJlYXMgZnJvbSBhZHZhbmNlZCBjaXRpZXMgc3VjaCBhcyBTaGFuZ2hhaSBhbmQgSGFuZ3pob3UsIHByb3Bvc2luZyBhIGZyYW1ld29yayBhbmQgY29uc3RydWN0aW9uIGlkZWFzIGZvciBzbWFydCBjaXR5IGRldmVsb3BtZW50LCB3aXRoIHRoZSBnb2FsIG9mIHByb21vdGluZyBzY2llbnRpZmljIGFuZCBwcmVjaXNlIHNvY2lhbCBnb3Zlcm5hbmNlIGFuZCBlbmhhbmNpbmcgdGhlIGludGVsbGlnZW5jZSBhbmQgY29udmVuaWVuY2Ugb2YgZ292ZXJubWVudCBzZXJ2aWNlcy4gIApLZXl3b3Jkczogc21hcnQgY2l0eTsgdXJiYW4gb3BlcmF0aW9uOyBkYXRhIHNoYXJpbmc7IGNvbGxhYm9yYXRpdmUgYXBwbGljYXRpb25zICAKClRoZSBjb25zdHJ1Y3Rpb24gb2Ygc21hcnQgY2l0aWVzIGVtcGhhc2l6ZXMgdGhlIGNyaXRpY2FsIHJvbGUgb2YgY29tbXVuaWNhdGlvbiB0ZWNobm9sb2d5IGluZnJhc3RydWN0dXJlIGludmVzdG1lbnQgYW5kIHRoZSBhcHBsaWNhdGlvbiBvZiBuZXcgdGVjaG5vbG9naWVzIGluIHRoZSB1cmJhbiBkZXZlbG9wbWVudCBwcm9jZXNzIFsxXS4gSW4gcmVjZW50IHllYXJzLCB0aGUgbmF0aW9uYWwgYW5kIGxvY2FsIGdvdmVybm1lbnRzIGhhdmUgaW50cm9kdWNlZCBhIHNlcmllcyBvZiBwb2xpY3kgZG9jdW1lbnRzIGFpbWVkIGF0IHByb21vdGluZyBzdXN0YWluYWJsZSB1cmJhbiBkZXZlbG9wbWVudCB0aHJvdWdoIGRpZ2l0YWwgdHJhbnNmb3JtYXRpb24uIEJhc2VkIG9uIHRoZSBzdWNjZXNzZnVsIGV4cGVyaWVuY2VzIG9mIGFkdmFuY2VkIGNpdGllcywgdGhpcyBwYXBlciBmb2N1c2VzIG9uIHRoZSB0aHJlZSBjb3JlIG9wZXJhdGlvbnMgb2Yg4oCcdW5pZmllZCBtYW5hZ2VtZW50LCB1bmlmaWVkIHNlcnZpY2UsIGFuZCB1bmlmaWVkIGNvbGxhYm9yYXRpb27igJ0gYW5kIHByb3Bvc2VzIGNvcnJlc3BvbmRpbmcgaW5zdGl0dXRpb25hbCBhbmQgbWVjaGFuaXNtIHN1cHBvcnQgbWVhc3VyZXMuIFRoZSBhaW0gaXMgdG8gcHJvdmlkZSBlZmZlY3RpdmUgcGF0aHdheXMgZm9yIHNvbHZpbmcgY29tbW9uIHByb2JsZW1zIGluIGN1cnJlbnQgc21hcnQgY2l0eSBjb25zdHJ1Y3Rpb24sIHN1Y2ggYXMgZGF0YSBzaWxvcywgaW50ZXItZGVwYXJ0bWVudGFsIGNvbGxhYm9yYXRpb24gZGlmZmljdWx0aWVzLCBhbmQgaW5zdWZmaWNpZW50IGRlY2lzaW9uLW1ha2luZyBzdXBwb3J0LiBJdCBzZWVrcyB0byBwcm9tb3RlIHRoZSBpbnRlZ3JhdGlvbiBvZiBnb3Zlcm5tZW50IHBsYXRmb3JtcywgdGhlIHJlbGVhc2Ugb2YgZGF0YSByZXNvdXJjZSB2YWx1ZSwgYWdpbGUgY2FwYWJpbGl0aWVzLCBlZmZpY2llbnQgY29vcmRpbmF0aW9uIGluIGRpZ2l0YWwgZ292ZXJuYW5jZSwgYW5kIGltcHJvdmVkIHF1YWxpdHkgYW5kIGNvbnRyb2xsYWJpbGl0eSBpbiBzZWN1cml0eSBhbmQgb3BlcmF0aW9uYWwgbWFuYWdlbWVudCBbMl0uICAKCjEuIFByb2JsZW1zICAKQ2hpbmHigJlzIHNtYXJ0IGNpdHkgY29uc3RydWN0aW9uIGhhcyBnb25lIHRocm91Z2ggc2V2ZXJhbCBzdGFnZXM6IHRoZSBpbmR1c3RyeSBhcHBsaWNhdGlvbi1kcml2ZW4gZGlnaXRhbCBjaXR5LCBlbWVyZ2luZyB0ZWNobm9sb2d5LWRyaXZlbiBzbWFydCBjaXR5IGRldmVsb3BtZW50IFszXSwgYW5kIHRoZSBkaWdpdGFsIGdvdmVybm1lbnQgdHJhbnNpdGlvbiBmcm9tIGUtZ292ZXJubWVudCBhbmQgZGlnaXRhbCBnb3Zlcm5hbmNlIHRvIGEgbmV3IHN0YWdlIG9mIGNvb3JkaW5hdGVkIGFuZCBpbm5vdmF0aXZlIG1hbmFnZW1lbnQgWzRdLiBMb2NhbCBkaWdpdGFsIGNvbnN0cnVjdGlvbiBpcyBpbiBhIHJhcGlkIGRldmVsb3BtZW50IHBoYXNlLCBidXQgZHVlIHRvIGRpZmZlcmVuY2VzIGluIGVjb25vbWljIGZvdW5kYXRpb24sIHRlY2hub2xvZ2ljYWwgbGV2ZWxzLCBhbmQgcmVzb3VyY2UgZW5kb3dtZW50LCBjb25zdHJ1Y3Rpb24gcHJvZ3Jlc3MgYW5kIHJlc3VsdHMgdmFyeS4gRGVzcGl0ZSBzb21lIGFjaGlldmVtZW50cywgY29tbW9uIHByb2JsZW1zIHN0aWxsIHBlcnNpc3QuICAKClRoZSBwaGVub21lbm9uIG9mIGRhdGEgc2lsb3MgaXMgc2V2ZXJlLiBBbHRob3VnaCB2YXJpb3VzIHJlZ2lvbnMgaGF2ZSBidWlsdCBkYXRhLXNoYXJpbmcgb3BlbiBwbGF0Zm9ybXMgYW5kIHByb3ZpZGVkIHNvbWUgZ292ZXJubWVudCBkYXRhIHNoYXJpbmcgd2luZG93cywgdGhlIHdpbGxpbmduZXNzIHRvIHNoYXJlIGRhdGEgaXMgd2VhayBpbiBtYW55IGRlcGFydG1lbnRzIG9yIHRoZXkgaGF2ZSBhIHN0cm9uZyBzZW5zZSBvZiBkYXRhIG93bmVyc2hpcC4gVGhpcyBsZWFkcyB0byBpbnN1ZmZpY2llbnQgZGF0YSBzaGFyaW5nIGluIHRlcm1zIG9mIHZvbHVtZSwgcmVhbC10aW1lIGF2YWlsYWJpbGl0eSwgYW5kIGFjY3VyYWN5LCBhbmQgZmFpbHMgdG8gdHVybiB0aGUgYnVzaW5lc3MgZGF0YSBhY2N1bXVsYXRlZCBieSBkZXBhcnRtZW50cyBpbnRvIGNpdHkgZGF0YSBhc3NldHMuIE9uIHRoZSBvdGhlciBoYW5kLCBkdWUgdG8gdGhlIGxhY2sgb2YgZGVlcCBsZWFybmluZywga25vd2xlZGdlIGdyYXBocywgZGVjaXNpb24gc3VwcG9ydCwgYW5kIG90aGVyIGZvdW5kYXRpb25hbCBkYXRhIHZhbHVlLWFkZGVkIHByb2R1Y3RzLCB0aGUgYXBwbGljYXRpb24gdmFsdWUgYW5kIHBvdGVudGlhbCBlbmVyZ3kgb2YgZGF0YSBoYXZlIG5vdCBiZWVuIGZ1bGx5IHJlbGVhc2VkLCBsaW1pdGluZyBpdHMgcm9sZSBpbiBpbXByb3ZpbmcgdXJiYW4gZ292ZXJuYW5jZSBlZmZlY3RpdmVuZXNzLCBvcHRpbWl6aW5nIHB1YmxpYyBzZXJ2aWNlcywgYW5kIHByb21vdGluZyBlY29ub21pYyBhbmQgc29jaWFsIGRldmVsb3BtZW50LiAgCgpDcm9zcy1kZXBhcnRtZW50YWwgY29sbGFib3JhdGlvbiBpcyBkaWZmaWN1bHQuIFRoZXJlIGlzIGFuIG92ZXJhbGwgdGVuZGVuY3kgdG8gZm9jdXMgb24gYnVzaW5lc3MgcmF0aGVyIHRoYW4gY29sbGFib3JhdGlvbiwgYW5kIGEgbGFjayBvZiBldmVudC1jZW50ZXJlZCwgc2VydmljZS1vcmllbnRlZCB1cmJhbiBvcGVyYXRpb25hbCBjb29yZGluYXRpb24gbWVjaGFuaXNtcy4gVGhpcyByZXN1bHRzIGluIGRlcGFydG1lbnRzIHN0aWNraW5nIHRvIHRoZWlyIG93biB3b3JrIGFuZCBmYWlsaW5nIHRvIGNyZWF0ZSBhbiBlZmZlY3RpdmUgdW5pZmllZCBnb2FsLW9yaWVudGVkIGFuZCBjb2xsYWJvcmF0aXZlIGNvbnNlbnN1cywgbWFraW5nIGl0IGRpZmZpY3VsdCB0byBmb3JtIGEgcmFwaWQtcmVzcG9uc2UgYW5kIGVmZmljaWVudCB1cmJhbiBnb3Zlcm5hbmNlIGFuZCBwdWJsaWMgc2VydmljZSBzeXN0ZW0uIFRoaXMgaXMgZXNwZWNpYWxseSB0cnVlIGluIHNvY2lhbCBnb3Zlcm5hbmNlLCB3aGVyZSBicmVha3Rocm91Z2ggYWNoaWV2ZW1lbnRzIGFyZSBsYWNraW5nLiAgCgpTdXBlcnZpc2lvbiBhbmQgYXNzZXNzbWVudCBtZWNoYW5pc21zIGFyZSBpbmFkZXF1YXRlLiBJbiB0ZXJtcyBvZiBidXNpbmVzcyBwZXJmb3JtYW5jZSwgdGhlcmUgaXMgYSBsYWNrIG9mIGVmZmljaWVudCBpbmZvcm1hdGlvbi1iYXNlZCBtb25pdG9yaW5nIG1ldGhvZHMgYW5kIGxvbmctdGVybSBhc3Nlc3NtZW50IG1lY2hhbmlzbXMuIEl0IGlzIGRpZmZpY3VsdCB0byB0cmFjayBhbmQgYW5hbHl6ZSBzb2NpYWwgZ292ZXJuYW5jZSBhbmQgcHVibGljIHNlcnZpY2UgcHJvY2Vzc2VzIGFuZCByZXN1bHRzIGNvbXByZWhlbnNpdmVseSwgY29udGludW91c2x5LCBhbmQgZGVlcGx5LCBoaW5kZXJpbmcgdGhlIGRpc2NvdmVyeSBvZiBwb3RlbnRpYWwgaXNzdWVzIGFuZCB0aGUgYWRqdXN0bWVudCBvZiBtZWFzdXJlcywgd2hpY2ggaXMgbm90IGNvbmR1Y2l2ZSB0byB0aGUgc3RhYmxlIGltcHJvdmVtZW50IGFuZCBjb250aW51b3VzIG9wdGltaXphdGlvbiBvZiBidXNpbmVzcyBwZXJmb3JtYW5jZSBxdWFsaXR5LiAgCgpUaHJvdWdoIHRvcC1sZXZlbCBkZXNpZ24sIGNsYXJpZnlpbmcgdGhlIGJvdW5kYXJpZXMgb2YgcmlnaHRzIGFuZCByZXNwb25zaWJpbGl0aWVzLCBzdHJlbmd0aGVuaW5nIHRoZSByZS1lbmdpbmVlcmluZyBvZiBnb3Zlcm5hbmNlIGJ1c2luZXNzIHByb2Nlc3NlcyBiYXNlZCBvbiBpbmZvcm1hdGlvbiBzaGFyaW5nLCBhbmQgc3RhbmRhcmRpemluZyB1cmJhbiBldmVudCBjbGFzc2lmaWNhdGlvbiBhbmQgcmVzcG9uc2UgcGxhbnMsIHdlIGNhbiBidWlsZCB0aGUgZm91bmRhdGlvbiBmb3IgdXJiYW4gZ292ZXJuYW5jZSBidXNpbmVzcyBjb2xsYWJvcmF0aW9uLCBmdXJ0aGVyIGVuaGFuY2UgcmVzcG9uc2Ugc3BlZWQgYW5kIGRpc3Bvc2FsIGNhcGFiaWxpdGllcywgYW5kIHByb21vdGUgdGhlIGRldmVsb3BtZW50IGFuZCBpbm5vdmF0aW9uIG9mIGdvdmVybmFuY2UgYW5kIHNlcnZpY2Ugc3lzdGVtcy4gIAoKMi4gQ29uc3RydWN0aW9uIFBsYW4gIAoyLjEgQ29uc3RydWN0aW9uIElkZWFzICAKU3RyZW5ndGhlbiB0b3AtbGV2ZWwgZGVzaWduIGFuZCBjb29yZGluYXRlZCBjb25zdHJ1Y3Rpb24uIEZyb20gYSBtYWNybyBwZXJzcGVjdGl2ZSwgLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUmVzZWFyY2ggb24gdGhlIERldmVsb3BtZW50IG9mIFNtYXJ0IEFncmljdWx0dXJlIGluIFN1cWlhbiBDaXR5IGluIHRoZSBOZXcgRXJhIOKAkyBBIENhc2UgU3R1ZHkgb2YgVGlhbndhIFNtYXJ0IEluZHVzdHJpYWwgUGFyawoKQWJzdHJhY3Q6IFdpdGggdGhlIGFycml2YWwgb2YgdGhlIGRpZ2l0YWwgZXJhLCBzbWFydCBhZ3JpY3VsdHVyZSBoYXMgZ3JhZHVhbGx5IGJlY29tZSBhIGhvdCB0b3BpYy4gSXQgcGxheXMgYW4gaW1wb3J0YW50IHJvbGUgaW4gaW1wcm92aW5nIGxhYm9yIGVmZmljaWVuY3ksIGVuaGFuY2luZyBwcm9kdWN0aXZpdHkgcXVhbGl0eSwgb3B0aW1pemluZyByZXNvdXJjZSBhbGxvY2F0aW9uLCBhbmQgcHJvbW90aW5nIGVudmlyb25tZW50YWwgcHJvdGVjdGlvbi4gSXQgaGFzIGJlY29tZSBhbiBpbXBvcnRhbnQgZGV2ZWxvcG1lbnQgY29uY2VwdCBmb3IgaW1wbGVtZW50aW5nIHRoZSBydXJhbCByZXZpdGFsaXphdGlvbiBzdHJhdGVneSBhbmQgYSBwb3dlcmZ1bCB0b29sIGZvciBidWlsZGluZyDigJxuZXcgYWdyaWN1bHR1cmUsIG5ldyBjb3VudHJ5c2lkZSwgbmV3IGZhcm1lcnPigJ0gaW4gdGhlIG5ldyBlcmEuIEluIHRoaXMgcmVnYXJkLCBob3cgdG8gdXNlICJJbnRlcm5ldCArIiB0ZWNobm9sb2d5IHRvIGluamVjdCBzbWFydCAiZ2VuZXMiIGludG8gYWdyaWN1bHR1cmFsIG1vZGVybml6YXRpb24gaGFzIGJlY29tZSB0aGUgZm9jdXMgb2YgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IHdvcmsgaW4gdmFyaW91cyByZWdpb25zLiBUYWtpbmcgdGhlIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBvZiBUaWFud2EgU21hcnQgSW5kdXN0cmlhbCBQYXJrIGluIFN1cWlhbiBDaXR5LCBKaWFuZ3N1IFByb3ZpbmNlLCBhcyBhbiBleGFtcGxlLCB0aGlzIHBhcGVyIGV4cGxvcmVzIHRoZSBwb3NpdGl2ZSBzaWduaWZpY2FuY2UgYW5kIHZhbHVhYmxlIGV4cGVyaWVuY2UgcHJvdmlkZWQgYnkgdGhlIGRldmVsb3BtZW50IG9mIHNtYXJ0IGFncmljdWx0dXJlIGluIFN1cWlhbiBDaXR5IGZvciB0aGUgZW50aXJlIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBpbiBOb3J0aGVybiBKaWFuZ3N1IFByb3ZpbmNlIHRocm91Z2ggZmllbGQgc3VydmV5cyBhbmQgcmVzZWFyY2guCgpLZXl3b3JkczogU21hcnQgQWdyaWN1bHR1cmU7IFJ1cmFsIFJldml0YWxpemF0aW9uOyBUaWFud2EgU21hcnQgSW5kdXN0cmlhbCBQYXJrCgpUaGUgcmVwb3J0IG9mIHRoZSAyMHRoIE5hdGlvbmFsIENvbmdyZXNzIG9mIHRoZSBDb21tdW5pc3QgUGFydHkgb2YgQ2hpbmEgZW1waGFzaXplczogV2UgbXVzdCBhZGhlcmUgdG8gcHJpb3JpdGl6aW5nIGFncmljdWx0dXJhbCBhbmQgcnVyYWwgZGV2ZWxvcG1lbnQsIGFuZCBtYWtlIGltcG9ydGFudCBkZXBsb3ltZW50cyBmb3IgY29tcHJlaGVuc2l2ZWx5IHByb21vdGluZyBydXJhbCByZXZpdGFsaXphdGlvbiwgYWNjZWxlcmF0aW5nIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSBzdHJvbmcgYWdyaWN1bHR1cmFsIGNvdW50cnksIGFuZCBjbGFyaWZ5aW5nIHRoZSBncmVhdCBnb2FscyBmb3IgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IGluIHRoZSBuZXcgZXJhIGFuZCBuZXcgam91cm5leSwgcG9pbnRpbmcgb3V0IHRoZSBkaXJlY3Rpb24gZm9yIHRoZSBtb2Rlcm5pemF0aW9uIG9mIHJ1cmFsIGRldmVsb3BtZW50IGluIENoaW5hIGFuZCB0aGUgZnVuZGFtZW50YWwgd29yayB0byBmb2xsb3cuIEluIHRoZSBuZXcgZXJhLCBvbmx5IGJ5IGNvbWJpbmluZyAidGVjaG5vbG9neSIgd2l0aCAiYWdyaWN1bHR1cmUsIiBlbXBvd2VyaW5nIGFncmljdWx0dXJlIHdpdGggdGVjaG5vbG9neSwgYW5kIHByb21vdGluZyB0aGUgZGV2ZWxvcG1lbnQgYW5kIGNvbnN0cnVjdGlvbiBvZiBzbWFydCBhZ3JpY3VsdHVyZSBjYW4gd2UgdWx0aW1hdGVseSBhY2hpZXZlIHRoZSBlZmZlY3Qgb2YgIjErMT4yLiIKCjEuIFRoZSBDb25jZXB0IGFuZCBDb25ub3RhdGlvbiBvZiBTbWFydCBBZ3JpY3VsdHVyZSAgClNpbmNlIGFuY2llbnQgdGltZXMsIENoaW5hIGhhcyBiZWVuIGEgbGFyZ2UgYWdyaWN1bHR1cmFsIGNvdW50cnksIHdpdGggYSBsYXJnZSBwcm9wb3J0aW9uIG9mIHJ1cmFsIHBvcHVsYXRpb24sIGFuZCBhZ3JpY3VsdHVyZSBoYXMgcGxheWVkIGEgc2lnbmlmaWNhbnQgcm9sZSBpbiB0aGUgbmF0aW9uYWwgZWNvbm9teS4gV2l0aCB0aGUgZXN0YWJsaXNobWVudCBvZiB0aGUgUGVvcGxlJ3MgUmVwdWJsaWMgb2YgQ2hpbmEgYW5kIHRoZSBkZXZlbG9wbWVudCBvZiB0aGUgcmVmb3JtIGFuZCBvcGVuaW5nLXVwIHBvbGljeSwgdGhlIENoaW5lc2UgZWNvbm9teSBoYXMgcmFwaWRseSBzb2FyZWQsIHRoZSB0ZXJ0aWFyeSBpbmR1c3RyeSBoYXMgcmlzZW4sIGFuZCBoYXMgY29uc3RhbnRseSBpbXBhY3RlZCB0aGUgb2xkIGVjb25vbWljIHN0cnVjdHVyZS4gVGhlIHByb3BvcnRpb24gb2YgYWdyaWN1bHR1cmFsIGVjb25vbXkgaGFzIGNvbnRpbnVlZCB0byBkZWNsaW5lLCBhbmQgdGhlIG1haW4gc29jaWFsIGNvbnRyYWRpY3Rpb24gaGFzIHNoaWZ0ZWQgdG8gdGhlIGNvbnRyYWRpY3Rpb24gYmV0d2VlbiB0aGUgcGVvcGxlJ3MgZ3Jvd2luZyBkZW1hbmQgZm9yIGEgYmV0dGVyIGxpZmUgYW5kIHVuYmFsYW5jZWQgYW5kIGluc3VmZmljaWVudCBkZXZlbG9wbWVudC4gSW4gcmVzcG9uc2UsIG9ubHkgYnkgY29uc3RhbnRseSBpbXByb3ZpbmcgcHJvZHVjdGl2aXR5IGFuZCBsYWJvciBlZmZpY2llbmN5IGNhbiB3ZSBmdXJ0aGVyIG1lZXQgdGhlIGxpdmluZyBuZWVkcyBvZiB0aGUgcGVvcGxlIGFuZCBhY2hpZXZlIHRoZSAiVHdvIENlbnRlbmFyeSBHb2Fscy4iICAKU21hcnQgYWdyaWN1bHR1cmUgcmVmZXJzIHRvIGludGVsbGlnZW50IGFncmljdWx0dXJhbCB0ZWNobm9sb2d5LCB3aGljaCBpbnZvbHZlcyBhIHNlcmllcyBvZiBhZ3JpY3VsdHVyYWwgcHJvZHVjdGlvbiBhY3Rpdml0aWVzIGNhcnJpZWQgb3V0IGJ5IGFncmljdWx0dXJhbCBwcm9kdWNlcnMgdXNpbmcgSW50ZXJuZXQgb2YgVGhpbmdzIChJb1QpIHRlY2hub2xvZ2llcy4gVGhyb3VnaCBtb2JpbGUgcGhvbmVzLCBjb21wdXRlcnMsIGFuZCBvdGhlciBkZXZpY2VzLCBhZ3JpY3VsdHVyYWwgcHJvZHVjdGlvbiBwcm9jZXNzZXMgYXJlIGNvbnRyb2xsZWQgYW5kIG1vbml0b3JlZCwgYWxsb3dpbmcgZm9yIHByZWNpc2lvbiBtYW5hZ2VtZW50IG9mIGFncmljdWx0dXJhbCBwcm9kdWN0aW9uIGFuZCB1bHRpbWF0ZWx5IG9idGFpbmluZyBjb3JyZXNwb25kaW5nIHByb2R1Y3Rpb24gZGF0YS4gQXMgYW4gZW1lcmdpbmcgYWdyaWN1bHR1cmFsIHByb2R1Y3Rpb24gY29uY2VwdCBpbnRlZ3JhdGVkIHdpdGggSW9UIHRlY2hub2xvZ3ksIHRoZSBkZXZlbG9wbWVudCBvZiBzbWFydCBhZ3JpY3VsdHVyZSBvZnRlbiBzZXJ2ZXMgYXMgYW4gaW1wb3J0YW50IHJlZmVyZW5jZSBmb3IgdGhlIGxldmVsIG9mIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBpbiBhIHJlZ2lvbi4gVGhlIGRlZ3JlZSBvZiBpbnRlbGxpZ2VuY2UgYW5kIG1lY2hhbml6YXRpb24gaW4gYSByZWdpb24gaXMgb2YgZ3JlYXQgaW1wb3J0YW5jZSBpbiBhc3Nlc3NpbmcgdGhlIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBzdGF0dXMgb2YgdGhhdCBhcmVhLiAgCkFzIGFuIGltcG9ydGFudCBjb21wb25lbnQgb2YgdGhlIHNtYXJ0IGVjb25vbXksIHNtYXJ0IGFncmljdWx0dXJlIGZ1bGx5IHV0aWxpemVzIG1vZGVybiBpbmZvcm1hdGlvbiB0ZWNobm9sb2d5IHRvIHNlcnZlIHRyYWRpdGlvbmFsIGFncmljdWx0dXJlLCBwcm92aWRpbmcgcHJlY2lzZSBwbGFudGluZywgdmlzdWFsIGR5bmFtaWMgbW9uaXRvcmluZywgYW5kIGludGVsbGlnZW50IGRlY2lzaW9uLW1ha2luZyBmb3IgYWdyaWN1bHR1cmFsIHByb2R1Y3Rpb24uIFRoZSBkZXZlbG9wbWVudCBvZiBzbWFydCBhZ3JpY3VsdHVyZSBub3Qgb25seSBhZGRyZXNzZXMgcnVyYWwgZW1wbG95bWVudCBpc3N1ZXMgYnV0IGFsc28gZWZmZWN0aXZlbHkgaW1wcm92ZXMgdGhlIGFncmljdWx0dXJhbCBlY29sb2dpY2FsIGVudmlyb25tZW50LCBlbmhhbmNlcyBhZ3JpY3VsdHVyYWwgcHJvZHVjdGl2aXR5LCBhbmQgcmVzb2x2ZXMgdGhlIGlzc3VlIG9mIGEgc2hvcnRhZ2Ugb2YgZHJpdmluZyBmb3JjZSBpbiBhZ3JpY3VsdHVyZS4gUHJvbW90aW5nIGFncmljdWx0dXJhbCBhbmQgcnVyYWwgbW9kZXJuaXphdGlvbiByZXF1aXJlcyB0aGUgYXNzaXN0YW5jZSBvZiBzbWFydCBhZ3JpY3VsdHVyZSBhbmQgaXMgYSBrZXkgcGFydCBvZiBhY2NlbGVyYXRpbmcgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIHN0cm9uZyBhZ3JpY3VsdHVyYWwgY291bnRyeS4KCjIuIE92ZXJ2aWV3IG9mIFJ1cmFsIERldmVsb3BtZW50IElzc3VlcyBpbiBOb3J0aGVybiBKaWFuZ3N1IGFuZCBBbmFseXNpcyBvZiBDYXVzZXMgIApUaGUgTm9ydGhlcm4gSmlhbmdzdSByZWdpb24gaXMgbG9jYXRlZCBpbiBvbmUgb2YgQ2hpbmEncyB0aHJlZSBtYWpvciBwbGFpbnMg4oCUIHRoZSBtaWRkbGUgYW5kIGxvd2VyIFlhbmd0emUgUml2ZXIgcGxhaW4uIEl0IGJlbmVmaXRzIGZyb20gaXRzIGxvY2F0aW9uIGFsb25nIHRoZSByaXZlciwgd2l0aCBmYXZvcmFibGUgZ2VvZ3JhcGhpY2FsIGNvbmRpdGlvbnMsIGFuZCBpcyBrbm93biBhcyB0aGUgIkdyYW5hcnkgb2YgdGhlIFdvcmxkLiIgSG93ZXZlciwgd2l0aCB0aGUgYWR2YW5jZW1lbnQgb2YgdGltZSwgdGhlIGFjY2VsZXJhdGlvbiBvZiB1cmJhbml6YXRpb24gYWNyb3NzIHRoZSBzb2NpZXR5LCBhbmQgdGhlIGZ1cnRoZXIgZGV2ZWxvcG1lbnQgb2YgdGhlIHRlcnRpYXJ5IGluZHVzdHJ5LCBwYXJ0aWN1bGFybHkgaW4gdGhlIHNvdXRoZXJuIEppYW5nc3UgcmVnaW9uLCBoYXZlIGltcGFjdGVkIHRoZSBhZ3JpY3VsdHVyYWwgZGV2ZWxvcG1lbnQgaW4gTm9ydGhlcm4gSmlhbmdzdS4gIAoyLjEgQWNjZWxlcmF0ZWQgTG9zcyBvZiBQcm9kdWN0aXZpdHkgYW5kIFNldmVyZSBSdXJhbCBIb2xsb3dpbmcuICAKU2luY2UgdGhlIHJlZm9ybSBhbmQgb3BlbmluZy11cCwgZXNwZWNpYWxseSB3aXRoIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc29jaWFsaXN0IG1hcmtldCBlY29ub215LCB0aGVyZSBoYXZlIGJlZW4gbW9yZSBkZXZlbG9wbWVudCBvcHBvcnR1bml0aWVzIGFuZCBpbi4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CioqUmVzZWFyY2ggb24gdGhlIFByYWN0aWNlIG9mIEluZHVzdHJpYWwgSW50ZXJuZXQgU2VjdXJpdHkgQ2FwYWJpbGl0eSBDb25zdHJ1Y3Rpb24gaW4gUG93ZXIgUHJvZHVjdGlvbiBFbnRlcnByaXNlcyoqICAKCiMjIyAxLiBEZXNpZ24gb2YgSW5kdXN0cmlhbCBJbnRlcm5ldCBTZWN1cml0eSBGdW5jdGlvbmFsIEFyY2hpdGVjdHVyZSBmb3IgUG93ZXIgUHJvZHVjdGlvbiBFbnRlcnByaXNlcyAgCgpCYXNlZCBvbiBjeWJlcnNlY3VyaXR5IHJlZ3VsYXRpb25zLCB0aGUgb3BlcmF0aW9uYWwgY2hhcmFjdGVyaXN0aWNzIG9mIHBvd2VyIGVudGVycHJpc2VzLCBhbmQgbmF0aW9uYWwgaW5kdXN0cnkgcmVndWxhdG9yeSBwcmFjdGljZXMsIHBvd2VyIHByb2R1Y3Rpb24gZW50ZXJwcmlzZXMgaGF2ZSBlc3RhYmxpc2hlZCBhIHRhcmdldGVkIGluZHVzdHJpYWwgaW50ZXJuZXQgc2VjdXJpdHkgcHJvdGVjdGlvbiBzeXN0ZW0uIFRoaXMgc3lzdGVtIGFpbXMgdG8gcHJvbW90ZSB0aGUgaW50ZWxsaWdlbnQgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHBvd2VyIGluZHVzdHJ5IHdoaWxlIGVuc3VyaW5nIGZ1bGwgY29tcGxpYW5jZSBhbmQgZWZmaWNpZW50IHNlY3VyaXR5IHRocm91Z2ggYSB0d28tdGllciwgdGhyZWUtbGF5ZXIgYXJjaGl0ZWN0dXJlIG9mIHRoZSBpbmR1c3RyaWFsIGludGVybmV0IHNlY3VyaXR5IHNlcnZpY2UgcGxhdGZvcm0gKFVDU1ApIFsxXS4gIAoKVGhpcyBwbGF0Zm9ybSBpbnRlZ3JhdGVzIHJlc291cmNlcyBmcm9tIHVwc3RyZWFtIGFuZCBkb3duc3RyZWFtIHBvd2VyIHByb2R1Y3Rpb24gZW50ZXJwcmlzZXMsIHJlZ3VsYXRvcnkgYWdlbmNpZXMsIGFuZCBzZXJ2aWNlIHByb3ZpZGVycywgZm9ybWluZyBhIGNvbGxhYm9yYXRpdmUgc2VjdXJpdHkgb3BlcmF0aW9uIGFuZCBtYWludGVuYW5jZSBtZWNoYW5pc20uIEl0IG9mZmVycyBvbmUtc3RvcCBjeWJlcnNlY3VyaXR5IHNlcnZpY2VzIHRvIGFkZHJlc3MgdmFyaW91cyBzZWN1cml0eSBjaGFsbGVuZ2VzIGZhY2VkIGJ5IHBvd2VyIGVudGVycHJpc2VzIGR1cmluZyBkaWdpdGFsIHRyYW5zZm9ybWF0aW9uLiAgCgpVQ1NQIGlzIGEgcGxhdGZvcm0gZGVkaWNhdGVkIHRvIGluZHVzdHJpYWwgaW50ZXJuZXQgbW9uaXRvcmluZyBhbmQgcGVyY2VwdGlvbi4gSXQgc2VhbWxlc3NseSBjb25uZWN0cyB3aXRoIG5hdGlvbmFsIHN1cGVydmlzb3J5IG1hbmFnZW1lbnQgc3lzdGVtcyBhbmQgcmVsZXZhbnQgbmF0aW9uYWwgcGxhdGZvcm1zIHdoaWxlIGFjdGl2ZWx5IHBhcnRpY2lwYXRpbmcgaW4gdGhyZWF0IGludGVsbGlnZW5jZSBzaGFyaW5nIGFuZCBlbmZvcmNpbmcgaGlnaCBzdGFuZGFyZHMgb2YgcmVndWxhdG9yeSBjb21wbGlhbmNlLiBJdHMgZnVuY3Rpb25hbCBhcmNoaXRlY3R1cmUgZGVzaWduIGlzIHNob3duIGluICoqRmlndXJlIDEqKi4gVGhlIGNvcmUgZnVuY3Rpb25zIGluY2x1ZGUgYnV0IGFyZSBub3QgbGltaXRlZCB0bzogIAoKLSBBc3NldCBkZXRlY3Rpb24gIAotIFRyYWZmaWMgYW5kIHJpc2sgYW5hbHlzaXMgIAotIFNpdHVhdGlvbiBhc3Nlc3NtZW50ICAKLSBFYXJseSB3YXJuaW5nIHN5c3RlbXMgIAotIEVtZXJnZW5jeSByZXNwb25zZSAgCgpUaGVzZSBmdW5jdGlvbnMgY29sbGVjdGl2ZWx5IGNvbnRyaWJ1dGUgdG8gYSBkZWVwZXIgdW5kZXJzdGFuZGluZyBhbmQgdmlzdWFsaXphdGlvbiBvZiBpbmR1c3RyaWFsIG5ldHdvcmsgc2VjdXJpdHkgY29uZGl0aW9ucywgZW5zdXJpbmcgcmVhbC10aW1lIGlkZW50aWZpY2F0aW9uIGFuZCB3YXJuaW5nIG9mIHBvdGVudGlhbCB0aHJlYXRzLCByaXNrcywgYW5kIHZ1bG5lcmFiaWxpdGllcywgdGh1cyBwcm92aWRpbmcgc3Ryb25nIHN1cHBvcnQgZm9yIHBvd2VyIGVudGVycHJpc2VzJyBjeWJlcnNlY3VyaXR5IG1hbmFnZW1lbnQuICAKCioqRmlndXJlIDE6IE92ZXJhbGwgRnVuY3Rpb25hbCBBcmNoaXRlY3R1cmUgRGVzaWduIG9mIEluZHVzdHJpYWwgSW50ZXJuZXQgU2VjdXJpdHkgQ2FwYWJpbGl0eSBmb3IgUG93ZXIgUHJvZHVjdGlvbiBFbnRlcnByaXNlcyoqICAKCkluIHRoZSBpbmR1c3RyaWFsIG5ldHdvcmsgc2VjdXJpdHkgcmlzayBtb25pdG9yaW5nIGFuZCBhbmFseXNpcyBzeXN0ZW0sIHNlY3VyaXR5IHN0cmF0ZWdpZXMgYXJlIGRlc2lnbmVkIHRvIHN1cHBvcnQgcG93ZXIgZW50ZXJwcmlzZXMgaW4gYWxpZ25pbmcgd2l0aCBOYXRpb25hbCBTdGFuZGFyZCAyLjAuIFRoaXMgZW5zdXJlcyBzZWN1cml0eSBpbiBuZXR3b3JrIGJvdW5kYXJpZXMsIGNvbW11bmljYXRpb24sIGFwcGxpY2F0aW9ucywgYW5kIGRhdGEgbGF5ZXJzLiBUaGUgc3lzdGVtIGFkaGVyZXMgdG8gaW5kdXN0cnkgc2VjdXJpdHkgbm9ybXMsIGFpbWluZyBmb3IgcmlzayBjbGFyaXR5LCB2aXN1YWxpemF0aW9uLCBhbmQgY29udHJvbGxhYmlsaXR5IHRvIGVuaGFuY2UgdGhlIGN5YmVyc2VjdXJpdHkgbWFuYWdlbWVudCBjYXBhYmlsaXRpZXMgb2YgcG93ZXIgZW50ZXJwcmlzZXMgWzJdLiAgCgpGb3Igb2ZmaWNlIGFyZWEgc2VjdXJpdHkgZGVzaWduLCBpbmZvcm1hdGlvbiBjb2xsZWN0aW9uLCBhc3NldCBjb250cm9sLCBhbmQgYXVkaXRpbmcgdGFza3MgYXJlIGNvdmVyZWQgdG8gcHJvdmlkZSByZWFsLXRpbWUgbW9uaXRvcmluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIHVuaWZpZWQgc2VjdXJpdHkgcGxhdGZvcm0gYW5kIHN1cHBvcnQgcGxhdGZvcm0gc2VydmljZXMuIEF0IHRoZSBjcml0aWNhbCBpbmR1c3RyaWFsIGNvbnRyb2wgZWRnZSBsYXllciwgYSBsYXllcmVkIGFuZCBkb21haW4tc2VwYXJhdGVkIHN0cmF0ZWd5IGlzIGFkb3B0ZWQsIGludGVncmF0aW5nIG11bHRpcGxlIHNlY3VyaXR5IHRlY2hub2xvZ2llcyB0byByZWluZm9yY2UgbmV0d29yayBib3VuZGFyeSBwcm90ZWN0aW9uIGJldHdlZW4gZGV2aWNlcyBhbmQgY29udHJvbCBzeXN0ZW1zLiAgCgpJbiBpbmR1c3RyaWFsIGNvbnRyb2wgZXF1aXBtZW50LCBwb3dlciBlbnRlcnByaXNlcyBpbXBsZW1lbnQgc3RyaWN0IGlkZW50aXR5IHZlcmlmaWNhdGlvbiBhbmQgYWNjZXNzIGNvbnRyb2wsIHV0aWxpemluZyBoYXJkd2FyZS11bmlxdWUgaWRlbnRpZmllcnMgdG8gZW5zdXJlIGxlZ2l0aW1hdGUgbmV0d29yayBhY2Nlc3MgYW5kIHJ1bGUtYmFzZWQgZGF0YSBpbnRlcmFjdGlvbiBjb250cm9sLiAqKkZpZ3VyZSAyKiogaWxsdXN0cmF0ZXMgdGhlIGluZHVzdHJpYWwgaW50ZXJuZXQgZGF0YSBmbG93IGFuZCBjcnlwdG9ncmFwaGljIGVtcG93ZXJtZW50IGluIHBvd2VyIHByb2R1Y3Rpb24gZW50ZXJwcmlzZXMuICAKClNlY3VyaXR5IG1lYXN1cmVzIGluIHRoZSBjb250cm9sIHByb2Nlc3MgaW5jbHVkZTogIAoKLSBTdHJlbmd0aGVuaW5nIHByb3RvY29sIHNlY3VyaXR5ICAKLSBTb2Z0d2FyZSBoYXJkZW5pbmcgIAotIENvbW1hbmQgYXVkaXRpbmcgIAotIEZhdWx0IHByb3RlY3Rpb24gIAoKQWxsIHVzZXJzIG11c3QgYmUgYXV0aGVudGljYXRlZCwgYWRkaXRpb25hbCBhdXRoZW50aWNhdGlvbiBzdGVwcyBhcmUgcmVxdWlyZWQgZHVyaW5nIGNvbW11bmljYXRpb24gdG8gcHJldmVudCB1bmF1dGhvcml6ZWQgc2Vzc2lvbnMsIGVuY3J5cHRpb24gaXMgdXNlZCB0byBwcm90ZWN0IGRhdGEgdHJhbnNtaXNzaW9uLCBhbmQgc29mdHdhcmUgdnVsbmVyYWJpbGl0aWVzIGFyZSBwcm9tcHRseSBwYXRjaGVkIG9yIG1pdGlnYXRlZC4gQ29tbWFuZCBhdWRpdGluZyBwcmV2ZW50cyBzZWN1cml0eSBpbmNpZGVudHMsIGVuc3VyaW5nIGNvbXByZWhlbnNpdmUgcHJvdGVjdGlvbiBmb3IgaW5kdXN0cmlhbCBpbnRlcm5ldCBzZWN1cml0eS4gIAoKKipGaWd1cmUgMjogSW5kdXN0cmlhbCBJbnRlcm5ldCBEYXRhIEZsb3cgYW5kIENyeXB0b2dyYXBoaWMgRW1wb3dlcm1lbnQgaW4gUG93ZXIgUHJvZHVjdGlvbiBFbnRlcnByaXNlcyoqICAKCiMjIyAyLiBEZXBsb3ltZW50IFBsYW4gZm9yIEluZHVzdHJpYWwgSW50ZXJuZXQgU2VjdXJpdHkgQ2FwYWJpbGl0eSBpbiBQb3dlciBQcm9kdWN0aW9uIEVudGVycHJpc2VzICAKCkZvciBwb3dlciBwcm9kdWN0aW9uIGVudGVycHJpc2VzLCBVQ1NQIGlzIGEgY29tcHJlaGVuc2l2ZSwgbXVsdGktbGF5ZXJlZCBzZWN1cml0eSBwcm90ZWN0aW9uIHN5c3RlbS4gSXRzIGZ1bmRhbWVudGFsIGNvbXBvbmVudHMgaW5jbHVkZSBtdWx0aXBsZSBsYXllcnMgc3VjaCBhcyB0aGUgKippbmZyYXN0cnVjdHVyZSBsYXllcioqIGFuZCB0aGUgKipzeXN0ZW0gY29tcG9uZW50IGxheWVyKiosIHdoaWNoIGNvbGxhYm9yYXRlIHRvIGVuc3VyZSBuZXR3b3JrIHNlY3VyaXR5IGFjcm9zcyB0aGUgcG93ZXIgc3lzdGVtIFszXS4gIAoKLSAqKkluZnJhc3RydWN0dXJlIExheWVyKio6IEVmZmljaWVudCByZXNvdXJjZSBhbmQgZGV2aWNlIGNvbXB1dGluZyB0byBwcm92aWRlIGEgc29saWQgdGVjaG5vbG9naWNhbCBmb3VuZGF0aW9uIGZvciB0aGUgZW50aXJlIHN5c3RlbS4gIAotICoqU3lzdGVtIENvbXBvbmVudHMgYW5kIEZ1bmN0aW9uYWwgU2VydmljZSBMYXllcioqOiBVQ1NQIHNlcnZlcyBhcyB0aGUgY29yZSwgY292ZXJpbmcgbmluZSBtYWpvciBjb21wb25lbnRzLCBpbmNsdWRpbmcgc2VjdXJlIGRhdGEgc3RvcmFnZSwgZGF0YSBpbnRlZ3JhdGlvbiwgYW5kIGRhdGEgY2x1c3RlciBub2Rlcy4gVGhlc2UgY29tcG9uZW50cyBlbmFibGUgZWZmaWNpZW50IGRhdGEgcHJvY2Vzc2luZyBhbmQgcHJlY2lzZSBzZWN1cml0eSBzdHJhdGVnaWVzIHRvIHJhcGlkbHkgcmVzcG9uZCB0byBzZWN1cml0eSB0aHJlYXRzLiAgCi0gKipTaXR1YXRpb24gRGlzcGxheSBMYXllcioqOiBMYXJnZS1zY2FsZSBzaXR1YXRpb25hbCBtb25pdG9yaW5nIHNjcmVlbnMgcHJvdmlkZSByZWFsLXRpbWUgdmlzdWFsaXphdGlvbiBvZiBmaXZlIG1ham9yIHNlY3VyaXR5IHNpdHVhdGlvbnMsIGVuYWJsaW5nIHNlY3VyaXR5IHBlcnNvbm5lbCB0byBncmFzcCB0aGUgY3VycmVudCBzZWN1cml0eSBzdGF0dXMgYXQgYSBnbGFuY2UuICAKCkFkZGl0aW9uYWxseSwgVUNTUCBvZmZlcnMgdHdvIGNyaXRpY2FsIGJ1c2luZXNzIGZ1bmN0aW9uczogIAoKMS4gKipBZHZhbmNlZCBQZXJzaXN0ZW50IFRocmVhdCAoQVBUKSBEZXRlY3Rpb24qKiAgCjIuICoqQ3liZXJzZWN1cml0eSBTaXR1YXRpb24gTW9uaXRvLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgd3JpdGUgYW4gaW50cm9kdWN0aW9uIGZvciBhbiBJbnRlcm5ldCBvZiBUaGluZ3MgKElvVCkgc2VjdXJpdHkgcGFwZXIgYmFzZWQgb24gdGhlIGNvbnRlbnQgSSBwcm92aWRlLCBleHBsYWluaW5nIHRoZSBpbmNyZWFzaW5nbHkgc2VyaW91cyBzZWN1cml0eSB0aHJlYXRzIHBvc2VkIGJ5IElvVCBkZXZpY2VzLiBQcm92aWRlIGEgZGV0YWlsZWQgZXhwbGFuYXRpb24gb2YgdGhlIHRlY2huaWNhbCBmZWF0dXJlcyBvZiBjdXJyZW50IG1haW5zdHJlYW0gcHJvdGVjdGlvbiBzb2x1dGlvbnMgKHN1Y2ggYXMgZmlybXdhcmUgaGFyZGVuaW5nLCBhY2Nlc3MgY29udHJvbCwgZXRjLikgYW5kIHRoZSBsaW1pdGF0aW9ucyBlbmNvdW50ZXJlZCBpbiBwcmFjdGljYWwgYXBwbGljYXRpb25zLiBOYXR1cmFsbHksIGxlYWQgaW50byB0aGUgaW5ub3ZhdGl2ZSBwb2ludHMgYW5kIGFkdmFudGFnZXMgb2YgdGhlIG5ldyBwcm90ZWN0aW9uIG1ldGhvZCBJIHByb3Bvc2UuICAKQXMgYSBmcm9udGxpbmUgcmVzZWFyY2hlciBhbmQgZGV2ZWxvcG1lbnQgZW5naW5lZXIgaW4gSW9UIHNlY3VyaXR5LCBJIGFtIGRlZXBseSBhd2FyZSBvZiB0aGUgaW5jcmVhc2luZyBzZWN1cml0eSBjaGFsbGVuZ2VzIGluIHRoZSBJbmR1c3RyaWFsIEludGVybmV0IG9mIFRoaW5ncyAoSUlvVCkgZW52aXJvbm1lbnQuIEluIGFjdHVhbCBwcm9qZWN0cywgSSBoYXZlIGJlZW4gaW52b2x2ZWQgaW4gdGhlIHNlY3VyaXR5IGFzc2Vzc21lbnQgYW5kIHByb3RlY3Rpb24gZGV2ZWxvcG1lbnQgb2Ygc2V2ZXJhbCBpbmR1c3RyaWFsIGNvbnRyb2wgc3lzdGVtcywgYW5kIGhhdmUgZW5jb3VudGVyZWQgc29tZSBjaGFsbGVuZ2luZyBzZWN1cml0eSBpbmNpZGVudHMuIEZvciBleGFtcGxlLCBpbiBhIHR5cGljYWwgaW5kdXN0cmlhbCBtb25pdG9yaW5nIHN5c3RlbSwgd2UgZGlzY292ZXJlZCBhbiBhdHRhY2sgbWV0aG9kIHdoZXJlIGFuIGF0dGFja2VyIGV4cGxvaXRlZCBhIGRldmljZSBmaXJtd2FyZSB2dWxuZXJhYmlsaXR5IHRvIGludGVyZmVyZSB3aXRoIHRoZSBpbmR1c3RyaWFsIHByb2R1Y3Rpb24gcHJvY2VzcywgY2F1c2luZyBwcm9kdWN0aW9uIGRvd250aW1lIGFuZCBkYXRhIGxlYWthZ2UuIFN1Y2ggY2FzZXMgaGlnaGxpZ2h0IHRoZSBpbXBvcnRhbmNlIG9mIHNlY3VyaXR5IHByb3RlY3Rpb24gZm9yIElvVCBkZXZpY2VzIGFuZCBoYXZlIG1hZGUgbWUgcmVhbGl6ZSB0aGUgbGltaXRhdGlvbnMgb2YgdHJhZGl0aW9uYWwgc2VjdXJpdHkgbWVhc3VyZXMgaW4gZGVhbGluZyB3aXRoIHRoZXNlIHNwZWNpZmljIGF0dGFjayBzY2VuYXJpb3MuCgpUaHJvdWdoIHllYXJzIG9mIHByYWN0aWNhbCBleHBlcmllbmNlLCBJIGhhdmUgZm91bmQgdGhhdCBhbHRob3VnaCB0aGVyZSBhcmUgc29tZSBwcm90ZWN0aW9uIHNvbHV0aW9ucyBvbiB0aGUgbWFya2V0LCBzdWNoIGFzIGZpcm13YXJlIGhhcmRlbmluZywgYWNjZXNzIGNvbnRyb2wsIGFuZCBlbmNyeXB0ZWQgdHJhbnNtaXNzaW9uLCB0aGV5IGZhY2UgbWFueSBjaGFsbGVuZ2VzIGluIHByYWN0aWNhbCBhcHBsaWNhdGlvbnMuIEZvciBpbnN0YW5jZSwgd2hpbGUgZmlybXdhcmUgaGFyZGVuaW5nIGVmZmVjdGl2ZWx5IGltcHJvdmVzIGRldmljZSBzZWN1cml0eSwgaXQgb2Z0ZW4gaW5jcmVhc2VzIHRoZSBjb3N0IGFuZCBjb21wbGV4aXR5IG9mIHRoZSBkZXZpY2UsIGFuZCB0aGUgaGFyZGVuZWQgZGV2aWNlcyBoYXZlIHNsb3cgcmVzcG9uc2UgdGltZXMgd2hlbiBmYWNpbmcgbmV3IHR5cGVzIG9mIGF0dGFja3M7IGFjY2VzcyBjb250cm9sIHNvbHV0aW9ucywgd2hpbGUgZWZmZWN0aXZlbHkgcmVzdHJpY3RpbmcgdW5hdXRob3JpemVkIGFjY2VzcywgYXJlIGNvc3RseSB0byBpbXBsZW1lbnQsIGNvbXBsZXggdG8gY29uZmlndXJlLCBhbmQgZGlmZmljdWx0IHRvIGFkYXB0IHRvIHRoZSBkeW5hbWljIGluZHVzdHJpYWwgZW52aXJvbm1lbnQuIFRocm91Z2ggdGhlc2UgcGVyc29uYWwgZXhwZXJpZW5jZXMsIEkgZGVlcGx5IHJlYWxpemUgdGhhdCBjdXJyZW50IHByb3RlY3RpdmUgbWVhc3VyZXMgYXJlIGZhciBmcm9tIG1lZXRpbmcgdGhlIGhpZ2ggc2VjdXJpdHkgcmVxdWlyZW1lbnRzIGluIHRoZSBpbmR1c3RyaWFsIElvVCBmaWVsZC4KCkJhc2VkIG9uIG15IGFjY3VtdWxhdGVkIGV4cGVyaWVuY2UgaW4gSUlvVCBzZWN1cml0eSwgdGhpcyBwYXBlciBwcm9wb3NlcyBhIG5ldyBwcm90ZWN0aXZlIG1ldGhvZCBhaW1lZCBhdCBvdmVyY29taW5nIHRoZSBsaW1pdGF0aW9ucyBvZiBleGlzdGluZyB0ZWNobm9sb2dpZXMgYW5kIGltcHJvdmluZyB0aGUgc2VjdXJpdHkgYW5kIGFkYXB0YWJpbGl0eSBvZiBJb1QgZGV2aWNlcy4gT3VyIGFwcHJvYWNoIGNvbWJpbmVzICoqbXVsdGktbGF5ZXIgZHluYW1pYyBtb25pdG9yaW5nKiogd2l0aCBhbiAqKmFkYXB0aXZlIHJlc3BvbnNlIG1lY2hhbmlzbSoqLCBhbmFseXppbmcgZGV2aWNlIGJlaGF2aW9yIGFuZCBuZXR3b3JrIHRyYWZmaWMgaW4gcmVhbCB0aW1lIHRvIGF1dG9tYXRpY2FsbHkgaWRlbnRpZnkgYW5kIGJsb2NrIHBvdGVudGlhbCBzZWN1cml0eSB0aHJlYXRzLiBVbmxpa2UgdHJhZGl0aW9uYWwgc3RhdGljIHByb3RlY3Rpb24gbWVhc3VyZXMsIHRoaXMgYXBwcm9hY2ggY2FuIGZsZXhpYmx5IGFkanVzdCBwcm90ZWN0aW9uIHN0cmF0ZWdpZXMgYmFzZWQgb24gYWN0dWFsIGNvbmRpdGlvbnMsIHNpZ25pZmljYW50bHkgcmVkdWNpbmcgZmFsc2UgcG9zaXRpdmUgcmF0ZXMgYW5kIGltcHJvdmluZyBwcm90ZWN0aW9uIGVmZmljaWVuY3kuIEFkZGl0aW9uYWxseSwgd2UgaGF2ZSBpbnRyb2R1Y2VkIGEgKipibG9ja2NoYWluLWJhc2VkKiogZGV2aWNlIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSB0byBlbnN1cmUgdGhlIHJlbGlhYmlsaXR5IG9mIGRldmljZSBpZGVudGl0aWVzIGFuZCB0aGUgdHJhbnNwYXJlbmN5IG9mIGNvbW11bmljYXRpb24gcHJvY2Vzc2VzLCBhZGRyZXNzaW5nIHRoZSBjb21tb24gc2VjdXJpdHkgcmlza3MgYXNzb2NpYXRlZCB3aXRoIGRldmljZSBpZGVudGl0eSBhdXRoZW50aWNhdGlvbi4gCgpUaGVzZSBpbm5vdmF0aW9ucyBtYWtlIG91ciBwcm90ZWN0aW9uIG1ldGhvZCBub3Qgb25seSBwZXJmb3JtIGV4Y2VsbGVudGx5IGluIHJlc3BvbmRpbmcgdG8ga25vd24gdGhyZWF0cyBidXQgYWxzbyBlZmZlY3RpdmVseSBkZWFsIHdpdGggZW1lcmdpbmcgdHlwZXMgb2YgYXR0YWNrcywgZmlsbGluZyB0aGUgZ2FwIGluIGZsZXhpYmlsaXR5IGFuZCBhZGFwdGFiaWxpdHkgaW4gY3VycmVudCB0ZWNobm9sb2dpY2FsIHNvbHV0aW9ucy4KdXNlcjoKUGxlYXNlIGhlbHAgbWUgY2hlY2sgYW5kIGltcHJvdmUgdGhlIGludHJvZHVjdGlvbiBvZiB0aGlzIHBhcGVyIG9uIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5LCBleHBhbmRpbmcgdGhlIHJlc2VhcmNoIGJhY2tncm91bmQgYW5kIHByb3ZpZGluZyBhIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoZSBwYWluIHBvaW50cyBhbmQgc29sdXRpb25zLCAqKklubm92YXRpb24gb2YgVHJ1bmsgTG9naXN0aWNzIEF1dG9ub21vdXMgRHJpdmluZyBUZWNobm9sb2d5IGFuZCBFdm9sdXRpb24gb2YgQnVzaW5lc3MgTW9kZWxzKioKCkFic3RyYWN0OiBBdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBoYXMgZmlyc3QgYmVlbiBpbXBsZW1lbnRlZCBpbiB0aGUgdHJ1bmsgbG9naXN0aWNzIGZpZWxkLiBUaGUgcmlzZSBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBicmluZ3MgbmV3IGRldmVsb3BtZW50IG9wcG9ydHVuaXRpZXMgdG8gdGhlIHRydW5rIGxvZ2lzdGljcyBpbmR1c3RyeS4gVHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGlzIGJlY29taW5nIG1hdHVyZSBhbmQgaGFzIGJlZ3VuIHRvIGV4cGxvcmUgY29tbWVyY2lhbGl6YXRpb24gbW9kZWxzLiBCeSBhbmFseXppbmcgdGhlIHNwZWNpZmljIHNjZW5hcmlvcyBhbmQgY2hhcmFjdGVyaXN0aWNzIG9mIHRydW5rIGxvZ2lzdGljcywgdGhlIGtleSB0ZWNobm9sb2dpZXMgb2YgYXV0b25vbW91cyBkcml2aW5nIGluIHRydW5rIGxvZ2lzdGljcyBhcmUgaWRlbnRpZmllZCwgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmdW5jdGlvbiBhbmQgc3lzdGVtIGRlc2lnbiBvZiB0cnVuayB2ZWhpY2xlcy4gQmFzZWQgb24gdGhlIG1hcmtldCBkZW1hbmQgb2YgdHJ1bmsgbG9naXN0aWNzLCB0aGlzIGFydGljbGUgcHJvbW90ZXMgdGhlIGNvbW1lcmNpYWxpemF0aW9uIGV2b2x1dGlvbiBvZiB0cnVuayBsb2dpc3RpY3MgYmFzZWQgb24gdGhlIGlubm92YXRpb24gb2YgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3kuCgpLZXl3b3JkczogdHJ1bmsgbG9naXN0aWNzOyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neTsgYnVzaW5lc3MgbW9kZWxzOyB0ZWNobm9sb2dpY2FsIHJvdXRlcwoKVGhlIHRyYWRpdGlvbmFsIGxvZ2lzdGljcyBvcGVyYXRpb24gbW9kZWwgaGFzIHByb2JsZW1zIHN1Y2ggYXMgaGlnaCBsYWJvciBjb3N0LCBoaWdoIGNvc3RzLCBsb3cgZWZmaWNpZW5jeSwgbG9uZyBkZWxpdmVyeSB0aW1lLCBhbmQgaGlkZGVuIHNhZmV0eSBoYXphcmRzLiBUaHJvdWdoIHRoZSBpbXByb3ZlbWVudCBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSwgdGhlIGRlZmVjdHMgb2YgdGhlIHRyYWRpdGlvbmFsIGxvZ2lzdGljcyBvcGVyYXRpb24gbW9kZWwgY2FuIGJlIGJldHRlciBhZGRyZXNzZWQuIFRoZXJlZm9yZSwgdGhlIGNvbnRpbnVvdXMgZGV2ZWxvcG1lbnQgb2YgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3kgYnJpbmdzIG5ldyBkZXZlbG9wbWVudCBvcHBvcnR1bml0aWVzIHRvIHRoZSBsb2dpc3RpY3MgaW5kdXN0cnkuIEF0IHByZXNlbnQsIGRvbWVzdGljIGFuZCBmb3JlaWduIHJlc2VhcmNoIGlzIG1vc3RseSBsaW1pdGVkIHRvIHRoZSBhbmFseXNpcyBvZiBzcGVjaWZpYyBzY2VuYXJpb3Mgb24gdHJ1bmsgcm9hZHMsIGxhY2tpbmcgYSBzeXN0ZW1hdGljIGFuYWx5c2lzIG9mIHZhcmlvdXMgYXBwbGljYXRpb24gc2NlbmFyaW9zIHRoYXQgdHJ1bmsgYXV0b25vbW91cyBsb2dpc3RpY3MgdmVoaWNsZXMgbWF5IGZhY2UuIFRoaXMgYXJ0aWNsZSBhaW1zIHRvIGFkZHJlc3Mga2V5IGlzc3VlcyBpbiB2aXN1YWwgcGVyY2VwdGlvbiwgcG9zaXRpb25pbmcsIGFuZCBvdGhlciBjcml0aWNhbCB0ZWNobm9sb2dpZXMgZm9yIHRydW5rIGF1dG9ub21vdXMgbG9naXN0aWNzIHZlaGljbGVzIHRocm91Z2ggaW4tZGVwdGggcmVzZWFyY2ggYW5kIGlubm92YXRpb24gb24gdGhlaXIgdW5pcXVlIHNjZW5hcmlvcyBhbmQgdGVjaG5vbG9naWVzLCBhbmQgcHJvdmlkZSBuZXcgaWRlYXMgZm9yIHRoZSBwcmFjdGljYWwgYXBwbGljYXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGJ1c2luZXNzIG1vZGVscy4KCjEuICoqSW5ub3ZhdGlvbiBvZiBUcnVuayBMb2dpc3RpY3MgQXV0b25vbW91cyBEcml2aW5nIFRlY2hub2xvZ3kgYW5kIEJ1c2luZXNzIE1vZGVsIEFyY2hpdGVjdHVyZSoqCgpUaGUgcmVzZWFyY2ggb24gdGhlIGlubm92YXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGFuZCB0aGUgZXZvbHV0aW9uIG9mIGJ1c2luZXNzIG1vZGVscyBjb25zaXN0cyBvZiB0aHJlZSBwYXJ0czogY29uc3RydWN0aW5nIGEgZmxleGlibGUgYXV0b25vbW91cyBkcml2aW5nIG1vZGUsIHRydW5rIGxvZ2lzdGljcyBjbG91ZCBkYXRhIGludGVsbGlnZW5jZSBhbmQgYXV0b25vbW91cyBkcml2aW5nIGludGVncmF0aW9uLCBhbmQgdGhlIHRlY2huaWNhbCByb3V0ZSBvZiB0aGUgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyBidXNpbmVzcyBtb2RlbCwgYXMgc2hvd24gaW4gRmlndXJlIDEuCgoqKkZpZ3VyZSAxKio6IFRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBpbm5vdmF0aW9uIGFuZCBidXNpbmVzcyBtb2RlbCBhcmNoaXRlY3R1cmUKCkJhc2VkIG9uIGV4aXN0aW5nIHRlY2hub2xvZ2llcywgdGhlIGxhdGVzdCB0ZWNobm9sb2dpZXMgYXJlIGludGVncmF0ZWQgdG8gdXBncmFkZSB0aGUgdGVjaG5vbG9neS4gVGhlIGV4cGxvcmF0aW9uIG9mIHRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBpbm5vdmF0aW9uIGFuZCBidXNpbmVzcyBtb2RlbHMgd2lsbCBwcm9jZWVkIGZyb20gdGhyZWUgYXNwZWN0czogZmlyc3RseSwgY29uc3RydWN0aW5nIGEgZmxleGlibGUgYXV0b25vbW91cyBkcml2aW5nIG1vZGUsIHdoaWNoIGluY2x1ZGVzIHRoZSBkZXNpZ24gb2YgbXVsdGlwbGUgZHJpdmluZyBtb2RlcywgZGV2ZWxvcG1lbnQgb2YgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nIG1vZHVsZXMsIGltcHJvdmVtZW50IG9mIHZlaGljbGUgcGVyY2VwdGlvbiB0ZWNobm9sb2dpZXMsIGFuZCBvcHRpbWl6YXRpb24gb2YgYXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2UgYWxnb3JpdGhtcywgY29udGludW91c2x5IGltcHJvdmluZyB0aGUgZXhpc3RpbmcgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5LCBlbmhhbmNpbmcgaXRzIGFwcGxpY2FiaWxpdHkgYW5kIHVuaXZlcnNhbGl0eTsgc2Vjb25kbHksIGFjaGlldmluZyB0aGUgaW50ZWdyYXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGNsb3VkIGRhdGEgaW50ZWxsaWdlbmNlIGFuZCBhdXRvbm9tb3VzIGRyaXZpbmcsIHdoaWNoIGluY2x1ZGVzIGNsb3VkIGRhdGEgb3B0aW1pemF0aW9uIGFuZCB0aGUgaXRlcmF0aW9uIG9mIGNsb3VkIGNvbXB1dGluZyBkYXRhIGludGVsbGlnZW5jZSDigJxzdXBwb3J04oCdIHRlY2hub2xvZ3ksIGltcHJvdmluZyB2ZWhpY2xlIHZhbHVlIHRocm91Z2ggY29tcHV0aW5nIHBvd2VyIHNlcnZpY2VzLCBhbmQgZm9ybWluZyBpbnRlbGxpZ2VudCBkcml2aW5nOyB0aGlyZGx5LCBzdHVkeWluZyB0aGUgdGVjaG5pY2FsIHJvdXRlIG9mIHRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgYnVzaW5lc3MgbW9kZWxzLCBpbmNsdWRpbmcgdGhlIHVwZ3JhZGluZyBvZiBpbnRlbGxpZ2VudCBtb25pdG9yaW5nIGFuZCBtYW5hZ2VtZW50IHN5c3RlbXMsIHRoZSBpbnRlZ3JhdGlvbiBvZiB2ZWhpY2xlIG5ldHdvcmtzIGFuZCBWMlgsIGFuZCB0aGUgaXRlcmF0aW9uIG9mIGNsb3VkIGNvbXB1dGluZyBkYXRhIGludGVsbGlnZW5jZSAic3VwcG9ydCIgdGVjaG5vbG9neS4gQnkgaW50ZWdyYXRpbmcgYW5kIHJlZm9ybWluZyB0aGUgdGVjaG5vbG9neSBvZiB0cnVuayBsb2dpc3RpY3MgYXV0b25vbW91cyBkcml2aW5nIGJ1c2luZXNzIG1vZGVscywgdGhlIGRldmVsb3BtZW50IG9mIHRoZSBpbmR1c3RyeSBjYW4gYmUgYWNjZWxlcmF0ZWQsIHJlc291cmNlIHV0aWxpemF0aW9uIGVmZmljaWVuY3kgaW1wcm92ZWQsIGFuZCBlY29ub21pYyBiZW5lZml0cyBwcm9tb3RlZC4KCjIuICoqRGVzaWduIG9mIFRydW5rIExvZ2lzdGljcyBBdXRvbm9tb3VzIERyaXZpbmcgVGVjaG5vbG9neSBJbm5vdmF0aW9uIE1vZGVsKioKCjIuMSAqKkNvbnN0cnVjdGluZyBhIEZsZXhpYmxlIEF1dG9ub21vdXMgRHJpdmluZyBNb2RlKioKCjIuMS4xICoqRGVzaWduIG9mIE11bHRpcGxlIERyaXZpbmcgTW9kZXMqKgoKVHJ1bmsgbG9naXN0aWNzIHZlaGljbGVzIGFyZSBkZXNpZ25lZCB3aXRoIHZhcmlvdXMgZHJpdmluZyBtb2RlcyBiYXNlZCBvbiBkaWZmZXJlbnQgZGVsaXZlcnkgbG9jYXRpb25zIGFuZCByb2FkIGNvbXBsZXhpdGllcywgYXMgd2VsbCBhcyBkaWZmZXJlbnQgZHJpdmluZyBzY2VuYXJpb3MgYW5kIHJlcXVpcmVtZW50cyB0byByZWR1Y2UgY29zdHMgYW5kIGltcHJvdmUgZWZmaWNpZW5jeS4gVGhlIGF1dG9ub21vdXMgZHJpdmluZyBtb2RlIGNhbiBjaG9vc2UgdGhlIG9wdGltYWwgZHJpdmluZyByb3V0ZSBiYXNlZCBvbiBkaWZmZXJlbnQgc2l0dWF0aW9ucy4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlIG9mIHRyYWZmaWMgY29uZ2VzdGlvbiBvbiB1cmJhbiByb2FkcywgYSBsb3ctc3BlZWQgZGVjZWxlcmF0aW9uIHRyYW5zcG9ydCBtb2RlIGNhbiBiZSB1c2VkIHRvIHJlZHVjZSB2ZWhpY2xlIGVuZXJneSBjb25zdW1wdGlvbiBhbmQgZHJpdmluZyBub2lzZTsgb24gaGlnaHdheXMgb3Igb3BlbiByb2FkcyBpbiBzdWJ1cmJhbiBhcmVhcywgYSBoaWdoLXNwZWVkIHRyYW5zcG9ydCBtb2RlIGlzIHJlcXVpcmVkIHRvIGltcHJvdmUgdHJhbnNwb3J0YXRpb24gZWZmaWNpZW5jeS4KCjIuMS4yICoqRGV2ZWxvcG1lbnQgb2YgSW50ZWxsaWdlbnQgRGVjaXNpb24tTWFraW5nIE1vZHVsZXMqKgoKSW4gb3JkZXIgdG8gZGVsaXZlciBnb29kcyBvbiB0aW1lIGFuZCBpbXByb3ZlIGN1c3RvbWVyIHNhdGlzZmFjdGlvbiwgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nIG1vZHVsZXMgYXJlIHJlcXVpcmVkLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKKipTaW11bGF0aW9uIE1vZGVsIERlc2lnbiBhbmQgQ29ubmVjdGl2aXR5IFJlYWxpemF0aW9uIG9mIERpZ2l0YWwgVHdpbiBpbiBTbWFydCBGYWN0b3J5KioKCkFic3RyYWN0OiBCYXNlZCBvbiB0aGUgZGlzY3JldGUgbWFudWZhY3R1cmluZyBzbWFydCBmYWN0b3J5IGV4cGVyaW1lbnRhbCBwbGF0Zm9ybSwgdGhpcyBwYXBlciBkZWVwbHkgYW5hbHl6ZXMgaXRzIHN5c3RlbSBhcmNoaXRlY3R1cmUuIEl0IHVzZXMgRmxleFNpbSAzRCBtb2RlbGluZyB0ZWNobm9sb2d5IHRvIGJ1aWxkIGEgdmlydHVhbCBpbWFnZSBvZiB0aGUgc21hcnQgZmFjdG9yeSwgYW5kIGFjaGlldmVzIHJlYWwtdGltZSBpbmZvcm1hdGlvbiBmbG93IGFuZCBiaWRpcmVjdGlvbmFsIGludGVyYWN0aW9uIGJldHdlZW4gdGhlIHBoeXNpY2FsIGVudGl0eSBhbmQgdGhlIHZpcnR1YWwgbW9kZWwgdGhyb3VnaCBhIFNvY2tldCBjb21tdW5pY2F0aW9uIG1lY2hhbmlzbS4gVGhlIGRpZ2l0YWwgdHdpbiBzeXN0ZW0gb2YgdGhlIHNtYXJ0IGZhY3RvcnkgaXMgc3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkLCBwcm92aWRpbmcgaW5ub3ZhdGl2ZSBpZGVhcyBhbmQgZW1waXJpY2FsIHJlZmVyZW5jZXMgZm9yIGRpZ2l0YWwgdHdpbiBwcmFjdGljZXMuCgpGdW5kOiBOaW5nYm8gQ2l0eSAiU2NpZW5jZSBhbmQgVGVjaG5vbG9neSBJbm5vdmF0aW9uIFlvbmdqaWFuZyAyMDM1IiBNYWpvciBBcHBsaWNhdGlvbiBEZW1vbnN0cmF0aW9uIFBsYW4g4oCUIFJlc2VhcmNoIGFuZCBBcHBsaWNhdGlvbiBvZiB0aGUgQ29tbWFuZCBhbmQgRGlzcGF0Y2ggRGVjaXNpb24tTWFraW5nIFN5c3RlbSBCYXNlZCBvbiBEaWdpdGFsIFR3aW4gUGxhdGZvcm0gZm9yIE1vbGQgSW5kdXN0cmlhbCBQYXJrIChQcm9qZWN0IE5vOiAyMDI0WjAwNykKCktleXdvcmRzOiBTbWFydCBmYWN0b3J5OyBkaWdpdGFsIHR3aW4gc2ltdWxhdGlvbiB0ZWNobm9sb2d5CgpJbnRyb2R1Y3Rpb246IEluIHJlY2VudCB5ZWFycywgd2l0aCB0aGUgY29udGludW91cyBkZXZlbG9wbWVudCBvZiBwcm9kdWN0aXZpdHksIENoaW5h4oCZcyBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5IGhhcyBncmFkdWFsbHkgdHJhbnNmb3JtZWQgZnJvbSB0cmFkaXRpb25hbCBtYW51ZmFjdHVyaW5nIHRvIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcuIEludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgaGFzIGJlY29tZSBhbiBpbXBvcnRhbnQgcGF0aCB0byBsZWFkIHRoZSB1cGdyYWRpbmcgYW5kIGRldmVsb3BtZW50IG9mIHRoZSBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5LiBJbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIGlzIG5vdCBvbmx5IHRoZSBlbmdpbmUgZm9yIHRoZSB0cmFuc2Zvcm1hdGlvbiBhbmQgdXBncmFkaW5nIG9mIHRoZSBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5IGJ1dCBhbHNvIHRoZSBrZXkgdG8gcHJvbW90aW5nIGhpZ2gtcXVhbGl0eSBlY29ub21pYyBkZXZlbG9wbWVudC4gQnkgaW50cm9kdWNpbmcgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyB0ZWNobm9sb2d5LCBDaGluYeKAmXMgbWFudWZhY3R1cmluZyBpbmR1c3RyeSBjYW4gYWNoaWV2ZSBhIGZ1bmRhbWVudGFsIGNoYW5nZSBpbiB0aGUgbW9kZSBvZiBwcm9kdWN0aW9uLCB0cmFuc2Zvcm1pbmcgZnJvbSBsYWJvci1pbnRlbnNpdmUgdG8gdGVjaG5vbG9neS1pbnRlbnNpdmUsIGltcHJvdmluZyB0aGUgY29yZSBjb21wZXRpdGl2ZW5lc3MgYW5kIGludGVybmF0aW9uYWwgc3RhdHVzIG9mIHRoZSBpbmR1c3RyeS4gQXQgdGhlIHNhbWUgdGltZSwgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBwcm9tb3RlcyB0aGUgZGVlcCBpbnRlZ3JhdGlvbiBvZiBtYW51ZmFjdHVyaW5nIGFuZCBpbmZvcm1hdGlvbiB0ZWNobm9sb2d5LCBkcml2aW5nIHRoZSBlbWVyZ2VuY2Ugb2YgbmV3IGJ1c2luZXNzIGZvcm1zIGFuZCBtb2RlbHMsIGluamVjdGluZyBuZXcgdml0YWxpdHkgaW50byBlY29ub21pYyBkZXZlbG9wbWVudC4gSW4gc21hcnQgbWFudWZhY3R1cmluZywgdGhlIGRpZ2l0YWwgdHdpbiBzaW11bGF0aW9uIHRlY2hub2xvZ3kgb2Ygc21hcnQgZmFjdG9yaWVzIGlzIHBsYXlpbmcgYW4gaW5jcmVhc2luZ2x5IGltcG9ydGFudCByb2xlLiBUaGUgZGlnaXRhbCB0d2luIHNpbXVsYXRpb24gdGVjaG5vbG9neSBvZiB0aGUgc21hcnQgZmFjdG9yeSBjYW4gYWNoaWV2ZSBkZWVwIGludGVncmF0aW9uIGFuZCBhY2N1cmF0ZSBtYXBwaW5nIGJldHdlZW4gdGhlIHBoeXNpY2FsIHdvcmxkIGFuZCB0aGUgdmlydHVhbCB3b3JsZC4gSXQgbm90IG9ubHkgc2ltdWxhdGVzIHByb2R1Y3Rpb24gcHJvY2Vzc2VzLCBlcXVpcG1lbnQgb3BlcmF0aW9uLCBhbmQgcHJvZHVjdGlvbiBsaW5lIG9wdGltaXphdGlvbiBpbiBhZHZhbmNlIHRvIGVmZmVjdGl2ZWx5IGF2b2lkIHJpc2tzIGFuZCBjb3N0IHdhc3RlIGluIGFjdHVhbCBvcGVyYXRpb25zIGJ1dCBhbHNvIGNvbmR1Y3RzIGNvdW50bGVzcyBpdGVyYXRpb25zIGluIHRoZSB2aXJ0dWFsIGVudmlyb25tZW50LCBhY2NlbGVyYXRpbmcgcHJvZHVjdCBpbm5vdmF0aW9uIGN5Y2xlcywgcHJvdmlkaW5nIGRlY2lzaW9uIHN1cHBvcnQgZm9yIG1hbmFnZXJzLCBvcHRpbWl6aW5nIHJlc291cmNlIGFsbG9jYXRpb24sIGFuZCBpbXByb3ZpbmcgcHJvZHVjdGlvbiBlZmZpY2llbmN5IGFuZCBmbGV4aWJpbGl0eS4gSW4gY29uY2x1c2lvbiwgdGhlIGRpZ2l0YWwgdHdpbiBzaW11bGF0aW9uIHRlY2hub2xvZ3kgb2Ygc21hcnQgZmFjdG9yaWVzIGlzIGEga2V5IGZvcmNlIGluIGRyaXZpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIG9mIG1hbnVmYWN0dXJpbmcgdG8gaW50ZWxsaWdlbnQgYW5kIGVmZmljaWVudCBzeXN0ZW1zLgoKMS4gQ29yZSBDb21wb25lbnRzIG9mIERpZ2l0YWwgVHdpbiAgCkluIHRoZSBjdXJyZW50IHdhdmUgb2YgaW5kdXN0cmlhbCB0cmFuc2Zvcm1hdGlvbiBhbmQgdXBncmFkaW5nLCBzbWFydCBmYWN0b3JpZXMgYW5kIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgYXJlIGxlYWRpbmcgcHJvZm91bmQgY2hhbmdlcyBpbiB0aGUgaW5kdXN0cmlhbCBzZWN0b3IuIEFzIGEgbW9kZWwgb2YgdGhlIGZ1c2lvbiBvZiBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5IG1hbmFnZW1lbnQgd2lzZG9tIGFuZCBhZHZhbmNlZCB0ZWNobm9sb2d5LCBzbWFydCBmYWN0b3JpZXMgcmVseSBvbiBmcm9udGllciB0ZWNobm9sb2dpZXMgc3VjaCBhcyB0aGUgSW50ZXJuZXQgb2YgVGhpbmdzLCBhdXRvbWF0aW9uLCBuZXR3b3JrIGNvbW11bmljYXRpb24sIGFuZCBhcnRpZmljaWFsIGludGVsbGlnZW5jZSB0byBidWlsZCBhIGhpZ2hseSBpbnRlZ3JhdGVkIGVjb3N5c3RlbSBvZiBwZW9wbGUsIG1hY2hpbmVzLCBtYXRlcmlhbHMsIGFuZCB0aGUgZW52aXJvbm1lbnQuIFRoaXMgc3lzdGVtIG5vdCBvbmx5IGFjaGlldmVzIGludGVncmF0aW9uIG9mIHByb2R1Y3Rpb24gYW5kIG1hbmFnZW1lbnQgYnV0IGFsc28gbGF5cyBhIHNvbGlkIGZvdW5kYXRpb24gZm9yIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSBzbWFydCBzdXBwbHkgY2hhaW4uIEhvd2V2ZXIsIHRoZSBlZmZpY2llbnQgb3BlcmF0aW9uIGFuZCBtYW5hZ2VtZW50IG9mIHNtYXJ0IGZhY3RvcmllcyByZWx5IG9uIHRoZSBkZWVwIGludm9sdmVtZW50IG9mIHNpbXVsYXRpb24gdGVjaG5vbG9neSB0byBldmFsdWF0ZSBhbmQgb3B0aW1pemUgdGhlaXIgY29tcGxleCBzeXN0ZW1zLiBUaGUgbGltaXRhdGlvbiBvZiB0cmFkaXRpb25hbCBzaW11bGF0aW9uIHRlY2hub2xvZ3kgbGllcyBpbiBpdHMgIm9mZmxpbmUiIG5hdHVyZSwgd2hpY2ggbWFrZXMgaXQgZGlmZmljdWx0IHRvIHJlZmxlY3QgdGhlIGR5bmFtaWMgY2hhbmdlcyBvZiB0aGUgcGh5c2ljYWwgc3lzdGVtIGluIHJlYWwtdGltZSBhbmQgZmFpbHMgdG8gbWVldCB0aGUgcmVhbC10aW1lIG1vbml0b3JpbmcgYW5kIHByZWNpc2UgZGVjaXNpb24tbWFraW5nIG5lZWRzIG9mIHNtYXJ0IGZhY3Rvcmllcy4KCkFnYWluc3QgdGhpcyBiYWNrZ3JvdW5kLCBkaWdpdGFsIHR3aW4gdGVjaG5vbG9neSBlbWVyZ2VkIGFzIGEga2V5IGZvcmNlIGRyaXZpbmcgdGhlIGRldmVsb3BtZW50IG9mIHNtYXJ0IGZhY3RvcmllcyBhbmQgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZy4gRGlnaXRhbCB0d2lucyBjcmVhdGUgYW4gYWNjdXJhdGUgdmlydHVhbCBpbWFnZSBvZiB0aGUgcGh5c2ljYWwgZW50aXR5LCBlbmFibGluZyBzZWFtbGVzcyBpbnRlZ3JhdGlvbiBhbmQgcmVhbC10aW1lIGludGVyYWN0aW9uIGJldHdlZW4gdGhlIHBoeXNpY2FsIHdvcmxkIGFuZCB0aGUgZGlnaXRhbCB3b3JsZC4gQSBkaWdpdGFsIHR3aW4gY29uc2lzdHMgb2YgdGhyZWUgbWFpbiBwYXJ0czogdGhlIHBoeXNpY2FsIGVudGl0eSBpbiB0aGUgcGh5c2ljYWwgc3BhY2UsIHRoZSB2aXJ0dWFsIGVudGl0eSBpbiB0aGUgdmlydHVhbCBzcGFjZSwgYW5kIHRoZSBkYXRhIGFuZCBpbmZvcm1hdGlvbiBleGNoYW5nZSBpbnRlcmZhY2UgYmV0d2VlbiB0aGUgcGh5c2ljYWwgYW5kIHZpcnR1YWwgc3BhY2VzLiBEaWdpdGFsIHR3aW5zIGNhbiBub3Qgb25seSByZWNlaXZlIHJlYWwtdGltZSBkYXRhIGZyb20gcGh5c2ljYWwgZW50aXRpZXMgdG8gZHJpdmUgc2ltdWxhdGlvbiBhbmQgZHluYW1pYyBhZGp1c3RtZW50cyBvZiB2aXJ0dWFsIG1vZGVscyBidXQgYWxzbyBmZWVkIGJhY2sgb3B0aW1pemF0aW9uIHN0cmF0ZWdpZXMgZnJvbSB0aGUgdmlydHVhbCB3b3JsZCB0byB0aGUgcGh5c2ljYWwgd29ybGQsIGd1aWRpbmcgdGhlIHByZWNpc2UgZXhlY3V0aW9uIG9mIGFjdHVhbCBwcm9kdWN0aW9uIHByb2Nlc3Nlcy4gVGhlIGNvcmUgb2YgZGlnaXRhbCB0d2lucyBsaWVzIGluIHRoZWlyIGJpZGlyZWN0aW9uYWwgZHluYW1pYyBtYXBwaW5nIGFuZCBpbnRlcmFjdGlvbiBtZWNoYW5pc21zLCB3aGljaCBicmVhayBkb3duIHRoZSBib3VuZGFyaWVzIGJldHdlZW4gdGhlIHBoeXNpY2FsIGFuZCBkaWdpdGFsIHdvcmxkcywgY3JlYXRpbmcgYSBjbG9zZWQtbG9vcCBjb250cm9sIHN5c3RlbSBmb3IgY29tcHJlaGVuc2l2ZSBwZXJjZXB0aW9uLCByZWFsLXRpbWUgYW5hbHlzaXMsIGludGVsbGlnZW50IGRlY2lzaW9uLW1ha2luZywgYW5kIHByZWNpc2UgZXhlY3V0aW9uLiBUaHJvdWdoIHRoZSBkZWVwIGludGVncmF0aW9uIG9mIHBoeXMuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2Ugd3JpdGUgYW4gaW50cm9kdWN0aW9uIGNoYXB0ZXIgZm9yIGEgbWVkaWNhbCBpbWFnaW5nIGFuYWx5c2lzIHRoZXNpcywgd2l0aCBhIHdvcmQgY291bnQgcmVxdWlyZW1lbnQgb2YgMjAwMC0yNTAwIHdvcmRzLiBUaGUgZm9sbG93aW5nIGlzIHRoZSBtYWluIHRleHQgb2YgbXkgdGhlc2lzOiAqKlJlc2VhcmNoIFByb2dyZXNzIG9mIE1lZGljYWwgSW1hZ2UgQW5hbHlzaXMgQmFzZWQgb24gRGVlcCBDb252b2x1dGlvbmFsIE5ldHdvcmtzKioKCjEuIE92ZXJ2aWV3IG9mIERlZXAgQ29udm9sdXRpb25hbCBOZXVyYWwgTmV0d29ya3MgIApUaGUgaHVtYW4gYnJhaW4gaXMgdGhlIGluZm9ybWF0aW9uIHByb2Nlc3NpbmcgY2VudGVyLCBjb250cm9sbGluZyBodW1hbiBiZWhhdmlvciBhbmQgdGhvdWdodC4gVG8gc3R1ZHkgdGhlIHN0cnVjdHVyZSBhbmQgZnVuY3Rpb24gb2YgdGhlIGh1bWFuIGJyYWluJ3MgbmVydm91cyBzeXN0ZW0sIGJpb2xvZ2ljYWwgbmV1cmFsIG5ldHdvcmtzIHdlcmUgcHJvcG9zZWQuIEluc3BpcmVkIGJ5IHRoaXMsIGNvbXB1dGVyIHJlc2VhcmNoZXJzIGludHJvZHVjZWQgYXJ0aWZpY2lhbCBuZXVyYWwgbmV0d29ya3MgdG8gc2ltdWxhdGUgdGhlIHN0cnVjdHVyZSBhbmQgZnVuY3Rpb25pbmcgb2YgdGhlIGh1bWFuIGJyYWlu4oCZcyBuZXJ2b3VzIHN5c3RlbS4gIApGcm9tIGFuIGluZm9ybWF0aW9uIHByb2Nlc3NpbmcgcGVyc3BlY3RpdmUsIGFuIGFydGlmaWNpYWwgbmV1cmFsIG5ldHdvcmsgaXMgYSBjb21wbGV4IG1hdGhlbWF0aWNhbCBtb2RlbCB0aGF0IGNvbm5lY3RzIGEgbGFyZ2UgbnVtYmVyIG9mIG1hdGhlbWF0aWNhbCBmdW5jdGlvbnMgaW4gdGhlIGZvcm0gb2YgbmV1cm9ucy4gVGhlIHRyYW5zbWlzc2lvbiBvZiBpbmZvcm1hdGlvbiBiZXR3ZWVuIG5ldXJvbnMgaXMgc2ltaWxhciB0byB0aGUgdHJhbnNmZXIgb2YgaG9ybW9uZXMgYmV0d2VlbiBhZGphY2VudCBuZXJ2ZSBjZWxscyBpbiB0aGUgYnJhaW4uIFRoZSBudW1iZXIgb2YgbmV1cm9ucywgdGhlIGNvbm5lY3Rpb24gbWV0aG9kLCBpbnRlcm5hbCBwYXJhbWV0ZXJzLCBhbmQgYWN0aXZhdGlvbiBmdW5jdGlvbnMgZGlmZmVyIHRvIGZvcm0gdmFyaW91cyBuZXVyYWwgbmV0d29yayBzdHJ1Y3R1cmVzLiBUaGUgc2ltcGxlc3QgdHlwZSBvZiBhcnRpZmljaWFsIG5ldXJhbCBuZXR3b3JrIGlzIGNhbGxlZCBhIHNpbmdsZS1sYXllciBwZXJjZXB0cm9uLCBjb25zaXN0aW5nIG9mIG9uZSBpbnB1dCBsYXllciwgb25lIGhpZGRlbiBsYXllciwgYW5kIG9uZSBvdXRwdXQgbGF5ZXIsIGFzIHNob3duIGluIEZpZ3VyZSAxLiBCZWNhdXNlIHRoaXMgc3RydWN0dXJlIGlzIHRvbyBzaW1wbGUgdG8gaGFuZGxlIGNvbXBsZXggY29tcHV0YXRpb25zLCBpdHMgYXBwbGljYXRpb24gaXMgbGltaXRlZC4gIApNdWx0aWxheWVyIG5ldXJhbCBuZXR3b3JrcywgYWxzbyBrbm93biBhcyBtdWx0aS1sYXllciBwZXJjZXB0cm9ucyAoTUxQKSwgaGF2ZSBtdWx0aXBsZSBoaWRkZW4gbGF5ZXJzIGFuZCBhcmUgdmFsdWFibGUgYXJ0aWZpY2lhbCBuZXVyYWwgbmV0d29ya3MgZm9yIHByYWN0aWNhbCBhcHBsaWNhdGlvbnMuIFRoZSBtb3N0IHR5cGljYWwgbXVsdGlsYXllciBuZXVyYWwgbmV0d29yayBtb2RlbCBpcyB0aGUgYmFja3Byb3BhZ2F0aW9uIChCUCkgbmV1cmFsIG5ldHdvcmsgaW52ZW50ZWQgYnkgUnVtZWxoYXJ0IGV0IGFsLiAgCgpGaWd1cmUgMTogU2luZ2xlLUxheWVyIE5ldXJvbiBTdHJ1Y3R1cmUgIAoKV2l0aCB0aGUgYWR2YW5jZW1lbnQgb2YgY29tcHV0ZXIgcG93ZXIgYW5kIG1hdGhlbWF0aWNhbCBsb2dpYywgbXVsdGlsYXllciBuZXVyYWwgbmV0d29yayBzdHJ1Y3R1cmVzIGhhdmUgYmVjb21lIGluY3JlYXNpbmdseSBjb21wbGV4IGFuZCBkaXZlcnNlLiBEZWVwIGxlYXJuaW5nIGFsZ29yaXRobXMgcmVwcmVzZW50ZWQgYnkgQ05OcyBmdXJ0aGVyIGV4cGFuZCB0aGUgZGVwdGggYW5kIGJyZWFkdGggb2YgY29tcHV0ZXIgYWxnb3JpdGhtcyBzaW11bGF0aW5nIGh1bWFuIGNvZ25pdGl2ZSBkb21haW5zLiBBcyBzaG93biBpbiBGaWd1cmUgMiwgYSB0eXBpY2FsIENOTiBzdHJ1Y3R1cmUgY29uc2lzdHMgb2Ygb25lIGlucHV0IGxheWVyLCBvbmUgb3V0cHV0IGxheWVyLCBzZXZlcmFsIGNvbnZvbHV0aW9uYWwgbGF5ZXJzLCBwb29saW5nIGxheWVycywgYW5kIGZ1bGx5IGNvbm5lY3RlZCBsYXllcnMuIFRoaXMgbmV0d29yayBzdHJ1Y3R1cmUgcGVyZm9ybXMgYmV0dGVyIHRoYW4gdHJhZGl0aW9uYWwgbXVsdGlsYXllciBuZXVyYWwgbmV0d29ya3MgaW4gY29tcHV0ZXIgdmlzaW9uIHRhc2tzIGJlY2F1c2UgY29udm9sdXRpb25hbCBsYXllcnMgYW5kIHBvb2xpbmcgbGF5ZXJzIGNhbiByZWR1Y2UgdGhlIG51bWJlciBvZiB3ZWlnaHQgcGFyYW1ldGVycyB0aGF0IG5lZWQgdG8gYmUgdHJhaW5lZCBieSB1c2luZyBwYXJhbWV0ZXIgc2hhcmluZyBhbmQgcGFydGlhbCBkaXNjYXJkaW5nIG1ldGhvZHMuIFRoaXMgcmVkdWNlcyBuZXR3b3JrIGNvbXBsZXhpdHksIGVhc2VzIHRoZSBjb21wdXRhdGlvbmFsIGxvYWQsIGFuZCBlbmFibGVzIENOTnMgd2l0aCB0aGUgc2FtZSBkZXB0aCB0byBoYXZlIHN0cm9uZ2VyIGRhdGEgcHJvY2Vzc2luZyBhbmQgZmVhdHVyZSBleHRyYWN0aW9uIGNhcGFiaWxpdGllcyB0aGFuIG11bHRpLWxheWVyIHBlcmNlcHRyb25zLiAgCkdlbmVyYXRpdmUgQWR2ZXJzYXJpYWwgTmV0d29ya3MgKEdBTnMpIGFyZSB0aGUgbW9zdCB3aWRlbHkgYXBwbGllZCBjb252b2x1dGlvbmFsIG5ldXJhbCBuZXR3b3JrcyBpbiByZWNlbnQgeWVhcnMuIFVubGlrZSBjbGFzc2ljIENOTiBtb2RlbHMgc3VjaCBhcyBBbGV4TmV0LCBWR0csIGFuZCBSZXNOZXQsIEdBTiBjb25zaXN0cyBvZiB0d28gaW5kZXBlbmRlbnQgbmV0d29yayBtb2RlbHM6IGEgZ2VuZXJhdG9yIGFuZCBhIGRpc2NyaW1pbmF0b3IsIGFzIHNob3duIGluIEZpZ3VyZSAzLiBJbiBtb3N0IGNhc2VzLCBib3RoIHRoZSBnZW5lcmF0b3IgYW5kIGRpc2NyaW1pbmF0b3IgYXJlIGltcGxlbWVudGVkIHdpdGggQ05Ocy4gVGhleSBhY3QgbGlrZSBhZHZlcnNhcmllczogYm90aCBpbmRlcGVuZGVudCBhbmQgY29tcGxlbWVudGFyeSwgY29tcGV0aW5nIHdpdGggZWFjaCBvdGhlciBhbmQgZW5oYW5jaW5nIGVhY2ggb3RoZXIncyBwZXJmb3JtYW5jZS4gIApUaGUgR0FOLCBjb25zaXN0aW5nIG9mIHR3byBtb2RlbHMsIGluaGVyZW50bHkgaGFzIHNlbGYtZGlzY3JpbWluYXRpb24sIHNlbGYtb3B0aW1pemF0aW9uLCBhbmQgc3Ryb25nIGdlbmVyYWxpemF0aW9uIGFiaWxpdGllcywgYWNoaWV2aW5nIGdvb2QgcmVzdWx0cyBpbiBpbWFnZSByZWNvbnN0cnVjdGlvbiBhbmQgZ2VuZXJhdGlvbi4gRnVydGhlcm1vcmUsIGltcHJvdmVkIEdBTiBtb2RlbHMgc3VjaCBhcyBDb25kaXRpb25hbCBHZW5lcmF0aXZlIEFkdmVyc2FyaWFsIE5ldHdvcmtzIChDR0FOKSBhbmQgQ3ljbGUgR2VuZXJhdGl2ZSBBZHZlcnNhcmlhbCBOZXR3b3JrcyAoQ3ljbGUgR0FOKSBwcm92aWRlIG5ldyBzb2x1dGlvbnMgZm9yIGNvbXBsZXggY29tcHV0ZXIgdmlzaW9uIHRhc2tzLgoKMi4gQXBwbGljYXRpb25zIG9mIENOTnMgaW4gTWVkaWNhbCBJbWFnZSBQcm9jZXNzaW5nICAKMi4xIEltYWdlIFNlZ21lbnRhdGlvbiAgCkltYWdlIHNlZ21lbnRhdGlvbiBpbnZvbHZlcyBkaXZpZGluZyB0aGUgdGFyZ2V0IGltYWdlIGludG8gcmVnaW9ucyBvZiBpbnRlcmVzdCwgc3VjaCBhcyBkaXNlYXNlZCBvcmdhbnMsIHRpc3N1ZXMsIGFuZCB0dW1vcnMuIE1vc3QgbWVkaWNhbCBpbWFnZXMgYXJlIGdyYXlzY2FsZSwgYW5kIHRoZXkgb2Z0ZW4gc3VmZmVyIGZyb20gdW5ldmVuIGdyYXlzY2FsZSBkaXN0cmlidXRpb24sIHNpZ25pZmljYW50IG5vaXNlLCBhbmQgdW5jbGVhciBvciBjaGFuZ2luZyBib3VuZGFyaWVzIG9mIHRpc3N1ZXMgYW5kIG9yZ2FucywgbWFraW5nIHRoZW0gZGlmZmljdWx0IHRvIGludGVycHJldCBhbmQgdW5kZXJzdGFuZCBmb3Igbm9uLXByb2Zlc3Npb25hbHMuIFRyYWRpdGlvbmFsIGltYWdlIHNlZ21lbnRhdGlvbiBtZXRob2RzIHByaW1hcmlseSB1c2UgbG9jYWwgcGh5c2ljYWwgZmVhdHVyZXMgc3VjaCBhcyBjb2xvciwgdGV4dHVyZSwgYW5kIG1vcnBob2xvZ3kgZm9yIHJlZ2lvbi1iYXNlZCBhbmQgYm91bmRhcnktYmFzZWQgc2VnbWVudGF0aW9uLiBDb21tb24gbWV0aG9kcyBpbmNsdWRlIGNsdXN0ZXJpbmcgYWxnb3JpdGhtcyBpbiB0cmFkaXRpb25hbCBtYWNoaW5lIGxlYXJuaW5nLCBzdWNoIGFzIGZ1enp5IEMtbWVhbnMgKEZDTSkgZm9yIG1hZ25ldGljIHJlc29uYW5jZSBpbWFnZSAoTVJJKSBzZWdtZW50YXRpb24sIEstbWVhbnMgY2x1c3RlcmluZyBhbmQgV2F0ZXJzaGVkIGFsZ29yaXRobXMgZm9yIGltYWdlIHNlZ21lbnRhdGlvbiwgYW5kIFN1cHBvcnQgVmVjdG9yIE1hY2hpbmUgKFNWTSktYmFzZWQgaW1hZ2Ugc2VnbWVudGF0aW9uLCBhbW9uZyBvdGhlcnMuIFRoZXNlIG1ldGhvZHMgbWFpbmx5IHV0aWxpemUgbG9jYWwgcGh5c2ljYWwgaW5mb3JtYXRpb24gYW5kIGRvIG5vdCBmdWxseSB1dGlsaXplIHRoZSBzZW1hbnRpYyBpbmZvcm1hdGlvbiBjb250YWluZWQgaW4gdGhlIGltYWdlIGl0c2VsZi4KCkZpZ3VyZSAyOiBUeXBpY2FsIENvbnZvbHV0aW9uYWwgTmV1cmFsIE5ldHdvcmsgU3RydWN0dXJlICAKRmlndXJlIDM6IEJhc2ljIEZyYW1ld29yayBvZiBHZW5lcmF0aXZlIEFkdmVyc2FyaWFsIE5ldHdvcmtzICAKCkNOTnMsIHdpdGggdGhlaXIgbXVsdGktbm9kZSBhbmQgbXVsdGktbGF5ZXJlZCBzdHJ1Y3R1cmUsIGhhdmUgdGhlIGFiaWxpdHkgdG8gYXV0b21hdGljYWxseSBleHRyYWN0IGRlZXAgZmVhdHVyZXMgZnJvbSBpbnB1dCBkYXRhLCBtYWtpbmcgdGhlbSBtb3JlIHN1aXRhYmxlIGZvciBpbWFnZSBjbGFzc2lmaWNhdGlvbiBvciByZWdyZXNzaW9uIHRhc2tzLiBUaGFua3MgdG8gdGhlIGFkdmVudCBvZiBGdWxseSBDb252b2x1dGlvbmFsIE5ldHdvcmtzIChGQ05zKSwgaW1hZ2Ugc2VnbWVudGF0aW9uIHRhc2tzIGhhdmUgZm91bmQgbmV3IHNvbHV0aW9ucy4gRkNOcyByZXBsYWNlIHRoZSBmaW5hbCBmdWxseSBjb25uZWN0ZWQgbGF5ZXJzIG9mIHRoZSBjbGFzc2ljYWwgQ05OIG1vLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgd3JpdGUgYSB0ZWNobmljYWwgcG9kY2FzdCAoMTAwMOKAkzIwMDAgd29yZHMpIGludHJvZHVjaW5nIHRoZSBtYWluIGNvbnRyaWJ1dGlvbnMgb2YgdGhlIEFwYWNoZSBQT0kgb3Blbi1zb3VyY2UgdGVjaG5vbG9neSBsaWJyYXJ5Lgp1c2VyOgrmiJHopoHlhpnkuIDnr4fjgIrmlbDlrZflrarnlJ/mioDmnK/lnKjmmbrog73liLbpgKDkuK3nmoTlupTnlKjnoJTnqbbjgIvvvIzor7fmoLnmja7miYDmj5DkvpvnmoTlj4LogIPorrrmlofnm7jlhbPotYTmlpnnu5PlkIjku6XkuIvor6bnu4bopoHmsYLluK7miJHlhpnnm7jlhbPlt6XkvZzpg6jliIbjgIIKIOWGheWuuee7k+aehOimgeaxgu+8mgotIOamgui/sOaVsOWtl+WtqueUn+aKgOacr+eahOWPkeWxleWOhueoi+WSjOWfuuacrOamguW/tQotIOezu+e7n+ais+eQhuaZuuiDveWItumAoOmihuWfn+aVsOWtl+WtqueUn+eahOS4u+imgeW6lOeUqOWcuuaZrwotIOmHjeeCueWIhuaekOW3peeoi+Wunui3teS4reeahOWFs+mUruaKgOacr+mavueCuQotIOivpue7huiuqOiuuuebruWJjeW3peeoi+iQveWcsOmdouS4tOeahOS4u+imgeaMkeaImO+8iOaKgOacr+OAgeaIkOacrOOAgeagh+WHhuWMluetieaWuemdou+8iQotIOWvueacquadpeWPkeWxlei2i+WKv+i/m+ihjOWxleacmwoK5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6L5LiO5YWz6ZSu5oqA5pyv56CU56m2ICDpvZDlpKnms5Mg77yMIOm7hOa1t+WzsCDvvIwg5pu55LmQIO+8jCDlvKDnrJHnq7kgICDljJfkuqznp5HmioDlpKflraYgIO+8jCAg5Lit5Zu955S156eR5aSn5pWw5o2u56CU56m26Zmi5pyJ6ZmQ5YWs5Y+4ICDvvIwgIOWkquaegeiuoeeul+acuuiCoeS7veaciemZkOWFrOWPuCAgIOaRmOimge+8muS4uuaOqOWKqOWItumAoOS4muaVsOWtl+WMluOAgeaZuuiDveWMlui9rOWei+WNh+e6p++8jOaPkOWHuuaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWei++8jOWMheWQq+amguW/teaooeWei+imgeaxguOAgeamguW/teaooeWei+aetuaehOOAgeamguW/teaooeWei+WHhuehruaAp+WSjOWPr+mdoOaAp+S/nemanOaWueazlTTkuKrnu7TluqbvvIzlnKjor6XmpoLlv7XmqKHlnovln7rnoYDkuIrku4vnu43kuobmmbrog73liLbpgKDmlbDlrZflrarnlJ/mioDmnK/mnrbmnoTvvIzliIbmnpDkuobmlbDlrZflrarnlJ/lu7rmqKHjgIHku7/nnJ/lkozmlbDmja7liIbmnpDnrYnlhbPplK7mioDmnK/vvIzlubblr7nmnKrmnaXmioDmnK/lj5HlsZXov5vooYzkuoblsZXmnJvjgIIgIOWFs+mUruivje+8muaZuuiDveWItumAoDvmpoLlv7XmqKHlnos75pWw5a2X5a2q55Sf5a6e5L2TICDmlLbnqL/ml6XmnJ/vvJoyMDI0LTAzLTI5ICBSZXNlYXJjaCBvbiBJbnRlbGxpZ2VudCBNYW51ZmFjdHVyaW5nIERpZ2l0YWwgVHdpbiBDb25jZXB0dWFsIE1vZGVsIGFuZCBLZXkgVGVjaG5vbG9naWVzICBBYnN0cmFjdO+8mlRvIHByb21vdGUgdGhlIGRpZ2l0YWwgdHJhbnNmb3JtYXRpb24gYW5kIHVwZ3JhZGluZyBvZiBzbWFydCBtYW51ZmFjdHVyaW5nLGEgY29uY2VwdHVhbCBtb2RlbCBvZiB0aGUgZGlnaXRhbCB0d2luIGZvciBzbWFydCBtYW51ZmFjdHVyaW5nIGlzIHByb3Bvc2VkLkl0IGluY2x1ZGVzIGZvdXIgZGltZW5zaW9uczpyZXF1aXJlbWVudHMgb2YgdGhlIGNvbmNlcHR1YWwgbW9kZWwsYXJjaGl0ZWN0dXJlIG9mIHRoZSBjb25jZXB0dWFsIG1vZGVsLGFuZCBtZXRob2RzIHRvIGVuc3VyZSB0aGUgYWNjdXJhY3kgYW5kIHJlbGlhYmlsaXR5IG9mIHRoZSBjb25jZXB0dWFsIG1vZGVsLkJhc2VkIG9uIHRoaXMgY29uY2VwdHVhbCBtb2RlbCx0aGUgdGVjaG5pY2FsIGZyYW1ld29yayBvZiB0aGUgZGlnaXRhbCB0d2luIGZvciBzbWFydCBtYW51ZmFjdHVyaW5nIGlzIGludHJvZHVjZWQuS2V5IHRlY2hub2xvZ2llcyBzdWNoIGFzIGRpZ2l0YWwgdHdpbiBtb2RlbGluZyxzaW11bGF0aW9uLGFuZCBkYXRhIGFuYWx5c2lzIGFyZSBhbmFseXplZCxhbmQgZnV0dXJlIHRlY2hub2xvZ2ljYWwgZGV2ZWxvcG1lbnRzIGFyZSBwcm9zcGVjdGVkLiBLZXkgd29yZHPvvJppbnRlbGxpZ2VuY2UgbWFudWZhY3R1cmluZyA7IGNvbmNlcHR1YWwgbW9kZWwgOyBkaWdpdGFsIHR3aW4gZW50aXR5IFJlY2VpdmVk77yaMjAyNC0wMy0yOSAgMCDlvJXoqIAg5pm66IO95Yi26YCg5piv5paw6LSo55Sf5Lqn5Yqb5b2i5oiQ5ZKM5Y+R5bGV55qE6YeN6KaB6amx5Yqo5Yqb77yM5piv5bel5LiaNC4wLzUuMOeahOaguOW/g++8jOS7peWPiuaOqOWKqOWunueOsOmrmOaViOOAgeeBtea0u+OAgee7v+iJsuOAgeaZuuiDveeahOeUn+S6p+aWueW8j1sxXeOAguaVsOWtl+WtqueUn+aKgOacr+S9nOS4uuaZuuiDveWItumAoOeahOWFs+mUruaKgOacr+S5i+S4gO+8jOmAmui/h+aehOW7uueJqeeQhuiuvuWkh+S4juiZmuaLn+aooeWei+S5i+mXtOeahOWunuaXtuaYoOWwhOWSjOWQjOatpe+8jOS4uuWItumAoOS4mueahOaZuuiDveWMluOAgemrmOaViOWMluaPkOS+m+acieWKm+aUr+aMge+8jOaOqOWKqOWItumAoOS4mueahOi9rOWei+WNh+e6p+OAgiDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mmK/lnKjnjrDku6PkvKDmhJ/mioDmnK/jgIHnvZHnu5zmioDmnK/jgIHoh6rliqjljJbmioDmnK/jgIHmi5/kurrljJbmmbrog73mioDmnK/nrYnmioDmnK/nmoTln7rnoYDkuIrvvIzpgJrov4fmmbrog73ljJbnmoTmhJ/nn6XjgIHkurrmnLrkuqTkupLjgIHlhrPnrZblkozmiafooYzmioDmnK/vvIzlr7nkuqflk4HjgIHliLbpgKDov4fnqIvmiJbmlbTkuKrlt6XljoLov5vooYzomZrmi5/ku7/nnJ/vvIzlrp7njrDorr7orqHov4fnqIvjgIHliLbpgKDov4fnqIvjgIHnrqHnkIbov4fnqIvlkozliLbpgKDoo4XlpIfmmbrog73ljJbvvIzmj5Dpq5jliLbpgKDkvIHkuJrkuqflk4HnoJTlj5HjgIHliLbpgKDlkoznrqHnkIbmlYjnjofvvIzmmK/kv6Hmga/mioDmnK/jgIHmmbrog73mioDmnK/kuI7oo4XlpIfliLbpgKDmioDmnK/nmoTmt7Hluqbono3lkIjkuI7pm4bmiJBbMi00XeOAguS+i+Wmgu+8jOWcqOS6p+WTgeiuvuiuoeaWuemdou+8jOmAmui/h+aVsOWtl+WtqueUn+aehOW7uuS6p+WTgeiZmuaLn+aooeWei++8jOi/m+ihjOS6p+WTgeaAp+iDveS7v+ecn+WSjOS8mOWMluiuvuiuoe+8jOaPkOmrmOS6p+WTgeiuvuiuoei0qOmHj+WSjOaViOeOh++8m+WcqOeUn+S6p+WItumAoOaWuemdou+8jOWunuaXtuebkeaOp+eUn+S6p+i/h+eoi++8jOmihOa1i+iuvuWkh+aVhemanO+8jOS8mOWMlueUn+S6p+a1geeoi++8jOmZjeS9jueUn+S6p+aIkOacrO+8m+WcqOS+m+W6lOmTvueuoeeQhuaWuemdou+8jOWfuuS6juaVsOWtl+WtqueUn+WunueOsOS+m+W6lOmTvuaVsOaNrueahOmbhuaIkOWSjOWFseS6q++8jOS8mOWMlui1hOa6kOmFjee9ru+8jOaPkOmrmOS+m+W6lOmTvuWNj+WQjOaViOeOh+OAgiDmnKzmlofpppblhYjku4vnu43kuobmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnovlkozmioDmnK/moYbmnrbvvJvlhbbmrKHvvIzpmJDov7Dkuobmmbrog73liLbpgKDmlbDlrZflrarnlJ/lhbPplK7mioDmnK/vvIzmnIDlkI7vvIzlr7nmnKrmnaXmioDmnK/lj5HlsZXov5vooYzlsZXmnJvjgIIgMSDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnosgMS4xIOamguW/teaooeWei+imgeaxgiDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnoso5Lul5LiL566A56ew4oCc5qaC5b+15qih5Z6L4oCdKeaYr+WcqOaVsOWtl+epuumXtOWunueOsOeJqeeQhuWunuS9k+WPiui/h+eoi+eahOWxnuaAp+OAgeaWueazleOAgeihjOS4uuetieeJueaAp+eahOaVsOWtl+WMluW7uuaooe+8jOaYr+WvueWunuS9k+WvueixoeWklumDqOW9ouaAgeOAgeWGhemDqOacuueQhuWSjOi/kOihjOWFs+ezu+etieeahOaVtOS9k+aKveixoeaPj+i/sOOAguamguW/teaooeWei+S4u+imgeW6lOa7oei2s+WmguS4i+imgeaxgu+8miAoMSnmjIHnu63ov63ku6Pmm7TmlrBbNV3jgIIg5Zyo55Sf5Lqn6L+H56iL5Lit77yM5ZCE57G755Sf5Lqn5pWw5o2u5a6e5pe25Y+Y5YyW77yM5qaC5b+15qih5Z6L5bqU6IO95qC55o2u54mp55CG5a6e5L2T55qE6L+Q6KGM54q25oCB5ZKM5Y+N6aaI5L+h5oGv5oyB57ut5pu05paw6L+t5Luj77yM5L+d5oyB5LiO54mp55CG5a6e5L2T55qE5ZCM5q2l44CCICgyKeiZmuWunuS6pOS6kuaYoOWwhOOAgiDmlK/mjIHomZrmi5/nqbrpl7TkuI7niannkIbnqbrpl7TnmoTkuqTkupLvvIzomZrmi5/nqbrpl7Tml6Log73lrp7ml7blj43mmKDliLbpgKDov4fnqIvniannkIbnqbrpl7TnirbmgIHvvIzmm7TlupTog73pgJrov4fmlbDmja7ono3lkIjjgIHliIbmnpDjgIHkvJjljJbjgIHmjqfliLbniannkIbnqbrpl7TnmoTov5DooYzjgIIgKDMp5aSa5rqQ5pWw5o2u6amx5Yqo44CCIOWItumAoOi/h+eoi+a2ieWPiuaVsOaNruexu+Wei+S8l+Wkmu+8jOW6lOiDveiejeWQiOWkmua6kOW8guaehOaVsOaNru+8jOWMheaLrOWunuaXtuS8oOaEn+WZqOaVsOaNruWSjOWOhuWPsuaVsOaNru+8jOS7peaPkOmrmOamguW/teaooeWei+eahOWHhuehruaAp+OAgiAoNCnoh6rpgILlupTlj4LmlbDosIPmlbTjgIIg5qaC5b+15qih5Z6L6IO95qC55o2u5LiN5ZCM5bqU55So5Zy65pmv5pSv5oyB6Ieq6YCC5bqU6LCD5pW05Y+C5pWw6K6+572u77yM5Lul5o+Q6auY5qaC5b+15qih5Z6L5Zyo5LiN5ZCM546v5aKD5LiL55qE6YCC55So5oCn44CCICg1Kei/reS7o+S8mOWMluWGs+etlls2XeOAgiDnu5PlkIjomZrmi5/ku7/nnJ/kuI7mlbDmja7liIbmnpDvvIzmlK/mjIHov63ku6PkvJjljJblhrPnrZbvvIzovoXliqnlrp7njrDnlJ/kuqfns7vnu5/nmoTmmbrog73ljJbjgIIgMS4yIOamguW/teaooeWei+aetuaehCDmnKzmlofmj5Dlh7rnlLHniannkIblrp7kvZPjgIHmnI3liqHlrp7kvZPjgIHmlbDlrZflrarnlJ/lrp7kvZPjgIHmlbDmja7lrp7kvZPlkozlkITpg6jliIbpl7TnmoTov57mjqXlrp7kvZPnu4TmiJDnmoTkupTnu7TmlbDlrZflrarnlJ/mqKHlnovjgILln7rkuo7mlofnjK5bN13vvIzpkojlr7nmmbrog73liLbpgKDpoobln5/nibnngrnvvIzmj5Dlh7rlpoLlm74x5omA56S65qaC5b+15qih5Z6L5p625p6E44CCICgxKeeJqeeQhuWunuS9kyDlm74xIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWei+aetuaehCAg54mp55CG5a6e5L2T5piv5Z+656GA77yM5a+55pm66IO95Yi26YCg55qE5q+P5LiA5Liq5pWw5a2X5a2q55Sf5bqU55So5Zy65pmv77yM5Y+v5Lul6L+b5LiA5q2l5YiS5YiG5Y2V5YWD57qn44CB57O757uf57qn5ZKM5aSN5p2C57O757uf57qn562J5LiN5ZCM57KS5bqm5bGC5qyhWzhd44CC5L6L5aaC77yM5pW05Liq5pm66IO95bel5Y6C55qE5pWw5a2X5a2q55Sf77yM6L2m6Ze055Sf5Lqn57q/5Y+v5L2c5Li65Y2V5YWD57qn77yM55Sf5Lqn57q/5omA5Zyo6L2m6Ze05Y+v5L2c5Li657O757uf57qn77yM6ICM5pW05Liq5bel5Y6C5YiZ5L2c5Li65aSN5p2C57O757uf57qn44CC5aaC5p6c5Lul6L2m6Ze05Li65pWw5a2X5a2q55Sf5a+56LGh77yM5YiZ5Y+v5bCG5p6E5oiQ55Sf5Lqn57q/55qE6K6+5aSH5L2c5Li65Y2V5YWD57qn77yM5a6e546w5Y2V5Liq6K6+5aSH55qE55uR5rWL44CB5pWF6Zqc6aKE5rWL5ZKM6aKE6K2m5Lul5Y+K57u05oqkWzld77yb55Sf5Lqn57q/5L2c5Li657O757uf57qn77yM5a+555Sf5Lqn6L+b6KGM6LCD5bqm44CB6L+b5bqm5o6n5Yi25ZKM5Lqn5ZOB6LSo6YeP5o6n5Yi277yb5pW05Liq6L2m6Ze05YiZ5L2c5Li65aSN5p2C57O757uf57qn77yM5a+55pW05Liq6L2m6Ze055Sf5Lqn6L+Q6KGM6L+b6KGM55uR5rWL5LiO6LCD5bqm5LyY5YyW44CCICgyKeaVsOWtl+WtqueUn+WunuS9kyDmlbDlrZflrarnlJ/lrp7kvZPmoLnmja7niannkIblrp7kvZPnmoTkuI3lkIzlsYLmrKHlkoznibnngrnvvIzku47kuI3lkIzml7bpl7Tlkoznqbrpl7TlsLrluqblr7nniannkIblrp7kvZPov5vooYzmj4/ov7DvvIzljIXmi6zlh6DkvZXmqKHlnovjgIHniannkIbmqKHlnovjgIHop4TliJnmqKHlnovlkozooYzkuLrmqKHlnovnrYlbMTBd77yM5pSv5oyB5Lqn5ZOB5pWw5a2X5a2q55Sf44CB55Sf5Lqn5pWw5a2X5a2q55Sf44CB6K6+5aSH5pWw5a2X5a2q55Sf77yM6LSv56m/5pW05Liq5pm66IO95Yi26YCg5Lqn5ZOB55Sf5ZG95ZGo5pyf566h55CG5Lu35YC86ZO+44CCIOWHoOS9leaooeWei+aPj+i/sOeJqeeQhuWunuS9k+WmguW3peWOguOAgei9pumXtOOAgeeUn+S6p+e6v+OAgeiuvuWkh+aIluiuvuWkh+WFg+WZqOS7tuetieeahOW9oueKtuOAgeWwuuWvuOOAgeS9jee9ruOAgeepuumXtOW4g+WxgOaIluijhemFjeWFs+ezu+etie+8jOS4gOiIrOWFt+acieaXtuepuuS4gOiHtOaAp++8jOW4uOeUqOi9r+S7tuW3peWFt+mAmui/h+S4iee7tOW7uuaooeaWueW8j+WIm+W7uuOAgiDniannkIbmqKHlnovlnKjlh6DkvZXmqKHlnovln7rnoYDkuIrlop7liqDniannkIblrp7kvZPnmoTniannkIblsZ7mgKfjgIHnuqbmnZ/lkoznibnlvoHnrYnvvIzlpoLnu5PmnoTjgIHmtYHkvZPjgIHnlLXlnLrjgIHno4HlnLrlu7rmqKHku7/nnJ/nrYnvvIzlj6/ku47lvq7op4Llkozlro/op4LnrYnkuI3lkIzlsLrluqbpgJrov4fkuIDkupvlt6Xlhbfova/ku7bov5vooYzmlbDlrabov5HkvLzmqKHmi5/lkozliLvnlLvjgIIg6KGM5Li65qih5Z6L5o+P6L+w5LiN5ZCM5bGC5qyh44CB5LiN5ZCM5pe256m65LiL54mp55CG5a6e5L2T5Zyo5YaF5aSW6YOo5LiN5ZCM5L2c55So5Zug57Sg5ZKM5L2c55So5py65Yi25LiL55qE6KGM5Li65ZKM6KGM5Li65ryU5YyW77yM5piv5LiA5Liq5aSN5p2C55qE6L+H56iL77yM5Y+v6YeH55So6ams5bCU5Y+v5aSr6ZO+44CB5pyJ6ZmQ54q25oCB5py6562J6L+b6KGM5o+P6L+w44CCIOinhOWImeaooeWei+aPj+i/sOmihuWfn+OAgeWHhuWImeOAgeefpeivhuWSjOe7j+mqjO+8jOS+i+WmguiuvuWkh+aTjeS9nOinhOeoi+OAgeiuvuWkh+iwg+S8mOWPguaVsOOAgeeUn+S6p+e6v+i/kOihjOeuoeeQhuinhOWImeOAgeeJqeaWmeaKleaUvuagh+WHhuetie+8jOmaj+edgOinhOWImeeahOWinuWKoOWSjOa8lOWMlu+8jOS9v+aVsOWtl+WtqueUn+WunuS9k+mAkOa4kOW9ouaIkOWunuaXtuWIpOaWreOAgeiHquS8mOWMluOAgeiHquagoeato+WSjOmihOa1i+etieiDveWKm++8jOWvueeJqeeQhuWunuS9k+i/m+ihjOaOp+WItuWSjOi/kOihjOaMh+WvvOOAguinhOWImeaooeWei+WPr+S7pemAmui/h+aVtOWQiOeOsOacieefpeivhuW6k++8jOW5tue7k+WQiOacuuWZqOWtpuS5oOaKgOacr+adpeWPkeaOmOaWsOeahOinhOWIme+8jOS7juiAjOaehOW7uuWSjOWujOWWhOOAgumAmui/h+iZmuaLn+eOsOWunihWUinlkozlop7lvLrnjrDlrp4oQVIp562J5oqA5pyv5a+55Yeg5L2V5qih5Z6L44CB54mp55CG5qih5Z6L44CB6KGM5Li65qih5Z6L5ZKM6KeE5YiZ5qih5Z6L562J6L+b6KGM6ZuG5oiQ44CB6J6N5ZCI5ZKM5LiA6Ie05oCn5qCh5qC477yM5bm25LiO54mp55CG5a6e5L2T6Jma5a6e5Y+g5Yqg5Y+K6J6N5ZCI5pi+56S677yM5o+Q6auY5pWw5a2X5a2q55Sf5L2T55qE55yf5a6e5oCn44CB5rKJ5rW45oCn5ZKM5Lqk5LqS5oCn44CCICgzKeacjeWKoeWunuS9kyDmnI3liqHlrp7kvZPlr7nmlbDmja7jgIHmqKHlnovjgIHnrpfms5XnrYnov5vooYzmnI3liqHljJblsIHoo4XvvIzkuLrmlbDlrZflrarnlJ/lrp7njrDmj5DkvpvmnI3liqHmlK/mjIHjgILmoLnmja7mnI3liqHnsbvlnovvvIzlj6/liIbkuLrmlbDmja7mnI3liqHjgIHku7/nnJ/mnI3liqHjgIHkuJrliqHmnI3liqHnrYnjgILmlbDmja7mnI3liqHljIXmi6zmlbDmja7ph4fpm4bjgIHlrZjlgqjjgIHmuIXmtJfjgIHlhbPogZTjgIHono3lkIjjgIHmjJbmjpjjgIHmjqXlhaXjgIHorr/pl67nrYnlkITnsbvmlbDmja7nrqHnkIbjgIHlpITnkIbkuI7orr/pl67mnI3liqHvvJvku7/nnJ/mnI3liqHljIXmi6zlu7rmqKHku7/nnJ/jgIHku7/nnJ/mqKHlnovnu4Too4XjgIHku7/nnJ/mqKHlnovono3lkIjjgIHku7/nnJ/mqKHlnovnrqHnkIbnrYnjgILkuJrliqHmnI3liqHlr7nmlbDlrZflrarnlJ/lupTnlKjov4fnqIvkuK3pnaLlkJHkuI3lkIzliLbpgKDpoobln5/jgIHkuI3lkIzlsYLmrKHnlKjmiLfmu6HotrPlkITnsbvliLbpgKDkuJrliqHpnIDmsYLnmoTmnI3liqHov5vooYzlsIHoo4XvvIzku6XlkITnsbvova/ku7blvaLlvI/lrZjlnKjvvIzljIXmi6zpnaLlkJHnjrDlnLrmk43kvZzkurrlkZjnmoTmnI3liqHjgIHpnaLlkJHnrqHnkIblhrPnrZbkurrlkZjnmoTmnI3liqHnrYnvvIzmjInpnIDkvb/nlKjjgIHngbXmtLvnu4TlkIjvvIzlrp7njrDlkITnsbvliLbpgKDkuJrliqHog73lipvjgIIgKDQp5pWw5o2u5a6e5L2TIOaVsOaNruWunuS9k+mbhuaIkOiejeWQiOS/oeaBr+aVsOaNruOAgeeJqeeQhuaVsOaNru+8jOa7oei2s+S/oeaBr+epuumXtOS4jueJqeeQhuepuumXtOeahOS4gOiHtOaAp+mcgOaxgu+8jOS4uuaZuuiDveWItumAoOaVsOWtl+WtqueUn+aPkOS+m+WFqOimgee0oOOAgeWFqOa1geeoi+WSjOWFqOS4muWKoeeahOaVsOaNruaUr+aMgeOAgiDniannkIbmlbDmja7ljIXmi6zlj43mmKDlkITnsbvniannkIblrp7kvZPop4TmoLzjgIHlip/og73jgIHmgKfog73jgIHlhbPns7vnrYnnmoTpnZnmgIHlsZ7mgKfmlbDmja7kuI7lj43mmKDniannkIblrp7kvZPov5DooYznirblhrXjgIHmgKfog73jgIHnjq/looPlj4LmlbDnrYnnmoTliqjmgIHov4fnqIvmlbDmja7vvIzov5nkupvmlbDmja7pgJrov4fpooTorr7nmoTmoIflh4blgLzlkozlkITnsbvkvKDmhJ/lmajph4fpm4bnmoTmlbDmja7ov5vooYzorr7lrprlkozojrflj5bjgIIg5L+h5oGv5pWw5o2u5YyF5ous5pWw5a2X5a2q55Sf5qih5Z6L5pWw5o2u44CB55+l6K+G5pWw5o2u44CB55Sf5Lqn5Yi26YCg5Lia5Yqh5pWw5o2u562J44CC5qih5Z6L5pWw5o2u5Y+N5pig5pWw5a2X5a2q55Sf5a6e5L2T5Yeg5L2V5qih5Z6L44CB54mp55CG5qih5Z6L44CB6KGM5Li65qih5Z6L5ZKM6KeE5YiZ5qih5Z6L562J5a2q55Sf5qih5Z6L5pWw77yb55+l6K+G5pWw5o2u5YyF5ous5ZCE57G75Yi26YCg5Lia5Yqh5qCH5YeG5LiO6KeE5YiZ44CB55Sf5Lqn55+l6K+G44CB5LiT5a6255+l6K+G562J77yb55Sf5Lqn5Yi26YCg5Lia5Yqh5pWw5o2u5YyF5ous55Sf5Lqn566h55CG44CB5Lqn5ZOB566h55CG44CB54mp5paZ566h55CG44CB6LCD5bqm566h55CG44CB5LyB5Lia566h55CG562J5pWw5o2u44CCICg1Kei/nuaOpeWunuS9kyDov57mjqXlrp7kvZPlrp7njrDniannkIblrp7kvZPjgIHmlbDlrZflrarnlJ/lrp7kvZPjgIHmnI3liqHlrp7kvZPku6Xlj4rmlbDmja7lrp7kvZPkuYvpl7TnmoTmma7pgILljJblt6XkuJrkupLogZTvvIzmlK/mjIHomZrlrp7lrp7ml7bkupLogZTkuI7ono3lkIhbMTFd44CC6YCa6L+H5ZCE56eN5Lyg5oSf5Zmo44CB5bWM5YWl5byP57O757uf562J5a+554mp55CG5a6e5L2T5pWw5o2u6L+b6KGM5a6e5pe26YeH6ZuG5bm25Lyg6L6T5Yiw5a2q55Sf5pWw5o2u5a6e5L2T77yM57uP6L+H5a2q55Sf5pWw5o2u5a6e5L2T5aSE55CG5ZCO55qE6YCa6L+H55u45bqU55qE5Y2P6K6u5Lyg6L6T5Y+N6aaI57uZ54mp55CG5a6e5L2T77yM5a6e546w54mp55CG5a6e5L2T55qE6L+Q6KGM5LyY5YyW44CC54mp55CG5a6e5L2T5a6e5pe25pWw5o2u6YCa6L+H5Y2P6K6u5Lyg6L6T5Yiw5pWw5a2X5a2q55Sf5a6e5L2T77yM6L+b6KGM5pWw5a2X5a2q55Sf5qih5Z6L55qE6Jma5a6e5LiA6Ie05oCn5qCh5q2j77yM5pWw5a2X5a2q55Sf5a6e5L2T5Lu/55yf5YiG5p6Q562J5pWw5o2u6L2s5YyW5Li65o6n5Yi25oyH5Luk5Lyg6L6T5Yiw54mp55CG5a6e5L2T77yM5a+554mp55CG5a6e5L2T6L+b6KGM5a6e5pe25Lqk5LqS5o6n5Yi244CC54mp55CG5a6e5L2T44CB5pWw5a2X5a2q55Sf5a6e5L2T5ZKM5pWw5o2u5a6e5L2T5LiO5pyN5Yqh5a6e5L2T5a6e5pe26L+e5o6l77yM6L+b6KGM5pWw5o2u44CB5qih5Z6L44CB5Lia5Yqh5pyN5Yqh55qE5a6e5pe26K6/6Zeu5LiO5LyY5YyW44CCIDEuMyDmpoLlv7XmqKHlnovlh4bnoa7mgKflkozlj6/pnaDmgKcg5qaC5b+15qih5Z6L55qE5YeG56Gu5oCn5ZKM5Y+v6Z2g5oCn5piv5pWw5a2X5a2q55Sf5oqA5pyv5bqU55So5LqO5pm66IO95Yi26YCg55qE5YWz6ZSu44CC5Y+v6YCa6L+H5aaC5LiL5omL5q615L+d6Zqc5qaC5b+15qih5Z6L55qE5YeG56Gu5oCn5ZKM5Y+v6Z2g5oCn44CCICgxKeaVsOaNruiejeWQiOOAgiDpm4bmiJDkuI3lkIzmnaXmupDmlbDmja7vvIzpgJrov4fml7bnqbrlr7npvZDjgIHmoLzlvI/lr7npvZDnrYnmlbDmja7ono3lkIjnmoTmlrnlvI/vvIzmj5Dpq5jmlbDmja7nmoTlh4bnoa7mgKflkozkuIDoh7TmgKfjgIIgKDIp57K+56Gu5bu65qih44CCIOmHh+eUqOeyvuehruaVsOWtpuaooeWei+WSjOeul+azle+8jOaooeaLn+eJqeeQhuWunuS9k+eahOihjOS4uu+8jOS9v+amguW/teaooeWei+iDveWkn+WHhuehruWPjeaYoOeJqeeQhuWunuS9k+eahOeJueaAp+OAgiAoMynmpoLlv7XmqKHlnovmoKHlh4bjgIIg5a+55pWw5a2X5a2q55Sf5a6e5L2T5ZKM54mp55CG5a6e5L2T6L+b6KGM5pWw5o2u5ZCM5q2l5oCn5ZKM5LiA6Ie05oCn5qOA5p+l77yM56Gu5L+d5pWw5o2u5ZCM5q2l5ZKM5LiA6Ie044CCICg0KemXreeOr+WPjemmiOOAgiDmr5TovoPmlbDlrZflrarnlJ/mqKHlnovnmoTovpPlh7rkuI7niannkIblrp7kvZPnmoTlrp7pmYXmgKfog73lt67lvILvvIzlkJHmqKHlnovkvp3mja7lt67lvILmg4XlhrXov5vooYzmqKHlnovosIPmlbTvvIzlu7rnq4vmqKHlnovkuI7niannkIblrp7kvZPnmoTpl63njq/lj43ppojmnLrliLbjgIIgKDUp5qaC5b+15qih5Z6L5oyB57ut6Ieq5a2m5Lmg5ZKM5LyY5YyW44CCIOmAmui/h+S6uuW3peaZuuiDveetieaKgOacr++8jOi/m+ihjOamguW/teaooeWei+aMgee7reiHquiwg+aVtOWSjOiHquS8mOWMlu+8jOaMgee7reaPkOmrmOaooeWei+mihOa1i+WSjOWIhuaekOiDveWKm+OAgiAoNinmpoLlv7XmqKHlnovmtYvor5Xlkozpqozor4HjgIIg6L+b6KGM5LiN5ZCM5Zy65pmv5LiL5qaC5b+15qih5Z6L5YeG56Gu5oCn5ZKM5Y+v6Z2g5oCn5rWL6K+V5ZKM6aqM6K+B44CCICg3KeWuieWFqOaAp+S/neaKpOOAgiDnoa7kv53mpoLlv7XmqKHlnovmlbDmja7lronlhajvvIzpmLLmraLmlbDmja7ms4TpnLLlkoznr6HmlLnjgIIgMiDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mioDmnK/mnrbmnoQg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5oqA5pyv5p625p6E5o+P6L+w5LqG5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6L5LiN5ZCM5a6e5L2T5LmL6Ze05Lqk5LqS55qE5oqA5pyv5a6e546w57uT5p6E44CCIOWmguWbvjLmiYDnpLrvvIzniannkIblsYLmtonlj4rliLbpgKDpoobln5/kurrlkZjjgIHorr7lpIfjgIHnianmlpnjgIHlt6XoibrjgIHnjq/looPnrYnnlJ/kuqfopoHntKDjgILkuI3lkIzliLbpgKDpoobln5/nmoTniannkIblrp7kvZPmnInmiYDkuI3lkIzjgILkvovlpoLvvIzpkqLpk4HlhrbngrzliqDlt6XkvIHkuJrvvIzniannkIblrp7kvZPmnInlhrbngrzpq5jngonjgIHnn7/nn7PjgIHpk7jku7bjgIHlhrbngrzmjqfliLbns7vnu5/nrYnvvJvoiLnoiLbliLbpgKDkvIHkuJrvvIzniannkIblrp7kvZPmnInoiLnoiLbljp/lnovjgIHoiLnoiLbpg6jku7bjgIHlvoXkv67oiLnoiLbnrYnjgIIg5Zu+MiDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mioDmnK/mnrbmnoQgIOaEn+efpeS8oOi+k+WxguaPkOS+m+eJqeeQhuWxguS4jeWQjOWxguasoeS5i+mXtOeahOS6kumAmuOAgiDmlbDmja7lsYLljIXmi6zniannkIblrp7kvZPnmoTlkITnsbvpnZnmgIHlkozliqjmgIHmlbDlrZfljJbkv6Hmga/jgIIg5qih5Z6L5bGC5ZKM5pyN5Yqh5bGC5Li65bqU55So5bGC5o+Q5L6b5ZCE57G75pyN5Yqh77yM5YyF5ous5qih5Z6L5pyN5Yqh44CB5pWw5o2u5pyN5Yqh44CB5Lu/55yf5pyN5Yqh5ZKM5Lia5Yqh5pyN5Yqh562J44CCIOW6lOeUqOWxguWIqeeUqOS4iui/sOWQhOWxguiDveWKm++8jOeBtea0u+aehOW7uuaZuuiDveWItumAoOS4jeWQjOmihuWfn+OAgeS4jeWQjOeykuW6pueahOaVsOWtl+WtqueUn+WunuS9k++8jOS+i+WmgueUn+S6p+i/h+eoi+aVsOWtl+WtqueUn+OAgeiuvuWkh+aVsOWtl+WtqueUn+OAgeW3peiJuuS8mOWMluaVsOWtl+WtqueUn+etie+8jOimhuebluS6p+WTgeeUn+WRveWRqOacn+euoeeQhuWFqOS7t+WAvOmTvuWSjOWItumAoOWFqOa1geeoi+mTvuOAgiAzIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+WFs+mUruaKgOacryAzLjEg5pWw5a2X5a2q55Sf5bu65qih5oqA5pyvIOW7uuaooeagueaNruiiq+S7v+ecn+WvueixoeaIluezu+e7n+eahOaehOaIkOimgee0oOOAgei/kOWKqOinhOW+i+OAgee6puadn+adoeS7tuWSjOeJqeeQhueJueaAp+etie+8jOW7uueri+W9ouW8j+WMlueahOS4jueJqeeQhuWunuS9k+ebuOWvueW6lOeahOiZmuaLn+aVsOWtl+WtqueUn+WunuS9k+aooeWei++8jOWPjeaYoOeJqeeQhuWunuS9k+eahOWkluinguOAgeWGhemDqOeahOeJueaAp+OAgee7k+aehOWSjOihjOS4uuOAguWFt+S9k+WcqOaZuuiDveWItumAoOmihuWfn++8jOW7uuaooeaKgOacr+aYr+mSiOWvueWItumAoOS4reeahOi9veS9kyjlpoLmlbDmjqfmnLrluoop44CB5Yi26YCg6L+H56iLKOWmguWKoOW3pei/h+eoi+S4reeahOeDreOAgeWKm+etiSnlkozooqvliqDlt6Xlr7nosaEo5aaC6KKr5Yi26YCg55qE6aOe5py6Keetie+8jOW6lOeUqOacuuaisOOAgeeJqeeQhuOAgeWKm+WtpuOAgeiuoeeul+acuuWSjOaVsOWtpuetieefpeivhu+8jOWvueW7uuaooeWvueixoeeahOS4gOenjei/keS8vOihqOi+vuOAgiDmlbDlrZflrarnlJ/lrp7kvZPmqKHlnovlnKjojIPlm7TkuIrvvIzmnInlhajlsYDnu5PmnoTmqKHlnoso5L6L5aaC5bel5Y6C5YWo55Sf5Lqn57q/KeOAgeWxgOmDqOe7k+aehOaooeWeiyjlpoLmn5DkuIDovabpl7TnlJ/kuqfoo4Xnva4p44CB5Lqn5ZOB57uT5p6E5qih5Z6L5ZKM55Sf5Lqn6K6h5YiS6LCD5bqm5qih5Z6L562J77yb5Zyo5pa55rOV5LiK77yM5pyJ5pWw5a2m6Kej5p6Q5qih5Z6LKOWmgueKtuaAgeepuumXtOaooeWeiynjgIHlm77npLrigJTop6PlkIjmqKHlnoso5aaCUGV0cmnnvZHmqKHlnosp562J77yb5Zyo5Yqf6IO95LiK77yM5pyJ57uT5p6E5o+P6L+w5qih5Z6L44CB57O757uf5YiG5p6Q5qih5Z6L44CB57O757uf6K6+6K6h5a6e5pa95qih5Z6L5ZKM57O757uf6L+Q6KGM566h55CG5qih5Z6L562J44CCIOW7uuaooeeahOS4u+imgei/h+eoi+WMheaLrOWItumAoOaVsOaNrumHh+mbhuS4jumbhuaIkOOAgeaooeWei+WIm+W7uuOAgeWunuaXtuaVsOaNruWQjOatpeOAgemXreeOry4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CkkgYW0gd3JpdGluZyBhIHJlcG9ydCBvbiBhbiBvcHRpY2FsIGZpYmVyIGNvbW11bmljYXRpb24gZXhwZXJpbWVudC4gQ291bGQgeW91IHBsZWFzZSBoZWxwIG1lIHdyaXRlIHRoZSB0aGVvcnkgc2VjdGlvbj8gVXNlIHNpbXBsZSBsYW5ndWFnZSB0byBleHBsYWluIHRoZSB0aGVvcnkgb2Ygb3B0aWNhbCBmaWJlciBjb21tdW5pY2F0aW9uLiBUaGUgbGVuZ3RoIHNob3VsZCBiZSBiZXR3ZWVuIDEwMDAgYW5kIDE1MDAgd29yZHMuIFRoZSBrZXkgdG9waWNzIHRvIGJlIGNvdmVyZWQgaW5jbHVkZTogdGhlIGJhc2ljIHByaW5jaXBsZXMgb2Ygb3B0aWNhbCBmaWJlciBjb21tdW5pY2F0aW9uLCB0aGUgdHJhbnNtaXNzaW9uIGNoYXJhY3RlcmlzdGljcyBvZiBvcHRpY2FsIGZpYmVycywgc2lnbmFsIG1vZHVsYXRpb24gYW5kIGRlbW9kdWxhdGlvbiBtZXRob2RzLCBhbmQgY29yZSBjb25jZXB0cyBzdWNoIGFzIGZpYmVyIGxvc3MgYW5kIGRpc3BlcnNpb24uCnVzZXI6CkkgYW0gYSBncmFkdWF0ZSBzdHVkZW50IGluIHRoZSBmaWVsZCBvZiBjcnlwdG9ncmFwaHkgYW5kIG5lZWQgdG8gd3JpdGUgYSBwYXBlciBvbiB0aGUgYXBwbGljYXRpb24gb2YgcXVhbnR1bSBjb21wdXRpbmcgaW4gY3J5cHRvZ3JhcGh5LiBQbGVhc2UgcHJvdmlkZSB0aGUgY29udGVudCBmb3IgdGhlIHJlbGF0ZWQgd29yayBzZWN0aW9uIG9mIHRoZSBwYXBlciwgd2l0aCBhIGZvY3VzIG9uOgotIFRocmVhdCBhbmFseXNpcyBvZiBTaG9yJ3MgYWxnb3JpdGhtIG9uIGV4aXN0aW5nIGNyeXB0b2dyYXBoaWMgc3lzdGVtcwotIExhdGVzdCByZXNlYXJjaCBwcm9ncmVzcyBvbiBtYWluc3RyZWFtIHBvc3QtcXVhbnR1bSBjcnlwdG9ncmFwaHkgdGVjaG5pcXVlcyAobGF0dGljZS1iYXNlZCBjcnlwdG9ncmFwaHksIG11bHRpdmFyaWF0ZSBjcnlwdG9ncmFwaHksIGhhc2gtYmFzZWQgc2lnbmF0dXJlcywgZXRjLikKLSBEZXRhaWxlZCBkaXNjdXNzaW9uIG9mIHRoZSBsYXRlc3QgcHJvZ3Jlc3MgaW4gdGhlIE5JU1QgcG9zdC1xdWFudHVtIGNyeXB0b2dyYXBoeSBzdGFuZGFyZGl6YXRpb24gcHJvamVjdCwgZXNwZWNpYWxseSB0aGUgdGVjaG5pY2FsIGRldGFpbHMgb2YgdGhlIGZpcnN0IGJhdGNoIG9mIHNlbGVjdGVkIGFsZ29yaXRobXMgaW4gMjAyMgotIFNwZWNpZmljIGV4YW1wbGVzIG9mIHRoZSBjb21tZXJjaWFsaXphdGlvbiBvZiBwb3N0LXF1YW50dW0gY3J5cHRvZ3JhcGh5IGJ5IG1ham9yIHRlY2hub2xvZ3kgY29tcGFuaWVzIChHb29nbGUsIElCTSwgZXRjLikKdXNlcjoK5YW35L2T5Luq5Zmo5Z6L5Y+355qE5oqA5pyv5omL5YaM5oiW6K+05piO5Lmm77yaCuaXpeeri1NVODAxMOWei+WPt1NFTQoxIOW8gOacugrlvIDlvaLosoznlLXohJHvvJrmiZPlvIDlvqrnjq/msLTigJTigJRkaXNwbGF55oyJ6ZKu5Yiw4puU77iP4oCU4oCUIOS8muiHquWKqOW8gOacuuKAlOKAlOeCueWHu+eUqOaItyBzdTgwMTAg5rKh5pyJ5a+G56CBIO+8iOWmguaenOWcqOW8gOacuuS5i+WQjuS4jeWwj+W/g+aKiui9r+S7tuWFs+aOieS6hueCueWHu+eUteiEkeW3puS4i+inkuW8gOWni++8jOeCueWHu3BjLXNlbeWwseWPr+S7peaJk+W8gOi9r+S7tu+8iQoK5byA6IO96LCx55S16ISR77ya54K55Ye76IO96LCx55S16ISR5Li75py66IOM5ZCO55qE6buR6Imy5oyJ6ZKu5Yiw4puU77iP4oCU4oCU5omT5byA5Li75py64oCU4oCU5omT5byA5pi+56S65bGP5byA5YWz4oCU4oCU5omT5byA6L2v5Lu277yIIOeUqOaIt1NVODAxMC1FRFMg5rKh5pyJ5a+G56CB77yJQVp0ZWMKCuavj+asoeW8gOacuuWQjumcgOimgeajgOafpe+8mgoK6auY5YCN5LiL5p+l55yL5piv5ZCm5oqK56OB5oCn5qih5byP5YWz5LqG77ya54K55Ye7c2V0dXDigJTigJTli77pgInkuIrno4HmgKfmqKHlvI8K5qOA5p+l55S15Y6L5piv5LiN5pivM2t277ya54K55Ye76L2v5Lu25bem5LiK6KeS6buR6Imy5pyJ55S15Y6L55qE6YOo5YiGCmZsYXNoaW5n5LiA5LiL77ya54K55Ye75bem5LiK6KeS6buR6Imy5qGG4oCU4oCU54K55Ye7Zmxhc2hpbmfigJTigJTngrnlh7tleGVjdXRl4oCU4oCU5Zyo5Lik5Y+w55S16ISR5Lit6Ze055qE5pys5a2Q5LiK6K6w5b2V55S15rWB5pWw5YC85ZKM5b2T5pel5byA5aeL5pe26Ze0CuiusOW9lUlQ5pWw5YC877ya54K55Ye75Y+z5LiL6KeSbWFpbnRl4oCU4oCU5Zyo5LiK6Z2i55qE5pys5a2Q5LiK6K6w5b2V5LiJ5LiqSVDmlbDlgLwK5q2k5pe25Y+v5Lul6aG65L6/5omT5byA5bCP6KeG6aKR55qE5oyJ6ZKuCu+8iOazqO+8mjMsNOS4pOmhueavj+WkqTXngrnkuZ/pnIDopoHmk43kvZzkuIDmrKHvvIkKCjIg5Yi25qC3CuehruWumueUqOaIt+a1i+eahOaYr+aWremdoui/mOaYr+ihqOmdou+8muW5s+mdouWPsCDmn7Hplb8g77yb5pat6Z2i5Y+wIOafseefreOAggoK5qC35ZOB5Y+w5pyJ5Lik5Liq77yM5LiA5Liq5aSn55qE77yM5LiA5Liq5bCP55qE77yM6K6p55So5oi36Ieq5bex6YCJ5oup6ZyA6KaB55qE44CCCgrlhbPkuo7lr7znlLXog7bvvJrnuqLoibLlr7znlLXog7bpgILlkIjnsonmnKvoja/lk4HnlKjvvIzku7fmoLzotLXvvJvok53oibLlr7znlLXog7bpgILlkIjpmaTnsonmnKvlpJblhbbku5bmoLflk4HvvIzku7fmoLzkvr/lrpzvvIzog73nnIvliLDlrZTjgIIKCuagt+WTgeWPsOS4iui0tOWlveWvvOeUteiDtuWQju+8jOWGjei0tOWlveeUqOaIt+aJgOacieeahOW+hea1i+agt+WTgeOAggoKMyDplYDph5EK5byA5py677yaIHN3aXRjaCBvbuKAlOKAlCBGRkIgb27igJTigJRwb3dlciBvbuKblO+4j+KAlOKAlEJMbG9r77yMIG9wZW4g77yI5q+P5aSp5LiA5p2l5Y+v5Lul5YWI57uZ6ZWA6YeR5Luq5omT5byA77yJCgrlhbPmnLrvvJrngrnlh7tTdGFydOaKveecn+epuuKAlOKAlOaKveWIsEUwIFBh4oCU4oCUQkxsb2vovazliqjliLBjbG9zZeKAlOKAlOeCueWHu+aYvuekuuWxj3N0b3DigJTigJRwb3dlcm9mZuKAlOKAlCBGRkIgb2Zm4oCU4oCUc3dpdGNoIG9mZgoK5YWz5LqO5Za36YeRCgrllrfnmoTlhbblrp7mmK/piZEKCuWWt+mHkSDomb3nhLborr7nva7nmoTmmK80MHPjgIE2MHPvvIzkvYbmmK/lrp7pmYXkuIropoE4LjnliIbpkp/vvIzlm6DkuLropoFhaXLvvIxldmFj77ybCgrllrfph5Hms6jmhI/ngrnvvJrkuIDkuKrmmK/mlbDlrZfopoHlr7nlh4bvvJvkuozmmK/pk77mnaHkuI3opoHljaHliLDph4zpnaLljrvvvJsKCuWWt+mHkeWujOaIkOeahOagh+W/l+aYr+mVgOmHkeS7queahOmch+WKqOWjsOWBnOatouOAggoKNCDnoazku7bov5vmoLcK5Y+v5Lul5Zyo5qC35ZOB5Y+w5LiK55So6K6w5Y+356yU5qCH6K6w5LiA5LiL56ys5LiA5Liq5qC35ZOB55qE5L2N572u44CCCgrmi6fntKfljp/niYfvvIzorqnljp/niYflkozplIHlrprlmajmiJDkuLrmlbTkvZPigJTigJTmiormoLflk4Hlj7DmlL7liLDlubPpnaLlj7DmiJbogIXmlq3pnaLlj7DplIHlrprlmajkuIrigJTigJTpobrml7bpkojmi6fntKfmoLflk4Hlj7DigJTigJTmnInkuKTkuKrlsI/lrZTnmoTmnJ3lkJHoh6rlt7HigJTigJTlsIbkuK3pl7TnmoTljp/niYfpgIbml7bpkojmlrnlkJHnqI3lvq7mi6fmnb7kuIDngrnngrnvvIjpobrlhbPpgIblvIDvvInigJTigJQg5peL6L2s5qC35ZOB5Y+w77yM6LCD5pW06ZSB5a6a5Zmo6J665q+N55qE6auY5bqm77yI6aG65pe26ZKI6ZmN5L2O77yM6YCG5pe26ZKI5Y2H6auY77yJ77yM5L2/5b6X5qC35ZOB5Y+w55qE6YeP6auY5q+U5rWL6auY5Luq56iN5b6u5L2OMS0ybW3vvIjms6jvvJrlpoLmnpzmmK/no4HmgKfmoLflk4HvvIzpnIDopoHnm7jlt64zLTRtbe+8ieKAlOKAlOWQjOaXtuS5n+mcgOimgeehruS/neeUqOaIt+eahOesrOS4gOS4quagt+WTgeWcqOW3puS4iuinkuaWueWQkeKAlOKAlOmhuuaXtumSiOaLp+e0p+S4remXtOWOn+eJh+KAlOKAlOeUqOa0l+iAs+eQg+WQueS4gOWQueagt+WTgeihqOmdoueahOiEj+S4nOilv++8jOi2heWbm+WRqOWQue+8jOS4jeimgeS6kuebuOaxoeafk+agt+WTge+8jOacneWcsOmdouWQue+8jOS4jeimgeWvueedgOahjOmdouWQueaxoeafk+ahjOmdouOAggoK6LW35aeL54q25oCB77yaY2xvc2UgZXZlYwoK54K55Ye7YWly5Zyo5Lqk5o2i5LuT6YeM5rOo5YWl56m65rCU4oCU4oCU5omL5Yqo5oqK5Lqk5o2i5LuT5ouJ5Ye65p2l4oCU4oCU5pS+5LiK5Yi25aSH5aW955qE5qC35ZOB5Y+w5ZCM5pe2bG9ja+S4gOS4i+KAlOKAlOaKiuS6pOaNouS7k+mAgei/m+WOu+KAlOKAlOeCueWHu2V2YWPmir3nnJ/nqbrigJTigJTngrnlh7tvcGVu5omT5byA6Iix6Zeo4oCU4oCU5o6o6L+b5Y675qC35ZOB5p2G5Yiw5pyA6YeM6Z2i55u05YiweGPok53nga/kuq7otbfigJTigJR1bmxvY2vmoLflk4Hmi4nlh7rmoLflk4HmnYbliLDmnIDov5znq6/lkKzliLDnoLDnmoTkuIDlo7DkuI3mlL7miYvigJTigJTngrnlh7tjbG9zZeWFs+mXreS7k+mXqOKAlOKAlOadvuW8gOaLieedgOagt+WTgeadhueahOaJiwoKNSDova/ku7bosIPmlbQK5aaC5p6c5b6F5rWL5qC35ZOB5piv56OB5oCn5qC35ZOB77yM6L2v5Lu2c2V0dXDno4HmgKfmqKHlvI/li77pgInkuIrvvIzlkIzkuIDkuKrkurrnmoTmoLflk4HnlKjlrozkuoborrDlvpfopoHlj5bmtojli77pgInvvIHvvIEKCuWmguaenOaYr+aAleawp+WMlueahOagt+WTgSDkuIDlrpropoHlv6vpgJ/mk43kvZzvvIHvvIEKCueCueWHu+i9r+S7tuW3puS4iuinkm9u5omT5byA55S15Y6L77yI5q2k5pe26ZyA6KaB56iN5b6u562J5LiA5Lya5YS/77yJ4oCU4oCU6LCD5pW05Yiw5L2O5YCN5qih5byPTE3igJTigJTmib7liLDnrKzkuIDkuKrmoLflk4Hotbflp4vkvY3nva4o5aSn5qC35ZOB5Y+wOuacgOW3pui+ue+8iC0xNyww77yJIOW3puS4iuinku+8iC0xNyw177yJ77yb5bCP5qC35ZOB5Y+w77yIIC0xMiww77yJKeKAlOKAlOWIh+aNouWIsOmrmOWAjeS4i+KAlOKAlOiwg+WIsAoKMTBr5bem5Y+z77yI5bel5L2c6Led56a75Li6OOW3puWPs++8ieKAlOKAlOi+ueaUvuWkp+i+ueeyl+iwg+eEtuWQjuWGjee7huiwg+WIsOWwveWPr+iDvea4healmuKAlOKAlOWGjUJBbGlnbuKAlOKAlOKRoCDvuI94eeiwg+eUteWtkOadn+WxheS4reKAlOKAlOKRoXh56LCD5YWJ6ZiR5bGF5Lit77yM5Yiw5LiN5bem5Y+z5pmD77yM6YeM5aSW6ZyH5Yqo5Li65q2i4oCU4oCU4pGi4pGjIO+4j++4j+iwg+eahOaYr+WDj+aVo++8jOiwg+WIsOS4jeW3puWPs+aZg++8jOWPmOaIkOmHjOWklumch+WKqOS4uuatouKAlOKAlOeCueWHu3JlZDHlsI/nqpflj6PvvIxmaW5l57uG6LCD77yM5YaNIHh56LCD5pW05Yiw55S76Z2i5riF5pmw77yM5YaNZmluZee7huiwg+KAlOKAlOS6pOe7meeUqOaIt+a1i+ivlQoK5YWz5LqO5peL6L2s5Zu+5YOP77yM5Yu+6YCJcm90YXRpb24g5Y2z5Y+v6L+b6KGM6LCD5pW044CCCgo2IOiDveiwsQrms6jvvJrmiZPog73osLHlsI/op4bpopHlv4XpobvopoHlhbPmjonvvIEKCui+k+WFpei+k+WHuuiuoeaVsOeOh+mDveimgSAyMDAw5Lul5LiK77yM5YW25a6eMTUwMOS5n+ihjO+8jOWmguaenOWPquacieWHoOeZvuWwseaciemXrumimOS6hu+8jOWZqumfs+S8muW+iOWkmu+8gQoK5aaC5p6c55So5oi36ZyA6KaB5omT6IO96LCx77yM6K6p55So5oi36Ieq5bex55So56yU6K6w5b2V5LiL5oOz6KaB5omT6IO96LCx55qE5L2N572u77ybCgrlt6bovrnnlLXohJHvvJrngrnlh7vova/ku7blt6bkuIrop5Lpu5HoibLpg6jliIbvvIznlLXljovosIPmlbTliLAxNS4wa1bigJTigJTosIPmlbTlt6XkvZzot53nprvvvJrog73osLHpnIDopoHnmoTlt6XkvZzot53nprvkuLoxNW1t77yM5aaC5p6c5q2k5pe25b2i6LKM5Zu+5pi+56S65bel5L2c6Led56a75Li6eO+8jOWPs+S+p3rkuIvmlrnmmL7npLrlt6XkvZzot53nprvkuLp577yM5YiZ6ZyA6KaB5omL5Yqo5Zyo6L2v5Lu25Y+z5L6neuS4i+aWuei+k+WFpeW3peS9nOi3neemu++8iDE1LXgree+8ieKAlOKAlOWcqHjjgIF555qE5L2N572u5omL5Yqo6L6T5YWl55So5oi36K6w5b2V55qE5b6F5omT6IO96LCx55qE5L2N572u77yM56Gu5a6a4oCU4oCU6LCD5pW05aW95Yiw5ZCI6YCC55qE5pS+5aSn5YCN5pWw77ybCgrlj7PovrnnlLXohJHvvJrmiZPlvIDog73osLHova/ku7bvvIzlpoLmnpzmnInkuIrkuIDkuKrkurrpgZfnlZnnmoTmlbDmja7vvIzngrnlh7vlj5bmtojvvIzkuI3opoHngrnigJzmmK/igJ3miJbigJzlkKbigJ3vvIzkvJropobnm5bmjonkuIrkuIDkuKrkurrnmoTmlbDmja7igJTigJTpobnnm67lj6blrZjkuLrvvIzmib7liLDnlKjmiLfnmoTkuKrkurrmlofku7blpLnigJTigJTkvp3mrKHngrnlh7vikaDpnaLliIbluIPlm77ikaHmiavmj4/lm77lg48t5byA5aeL4pGi6YeH6ZuG5YiG5biD5Zu+5pWw5o2uLeW8gOWni+KRo+aehOW7uuWIhuW4g+WbvuaVsOaNruKRpOehruiupOWFg+e0oOKRpee8lui+keWIl+KAlOKAlOmdouenr+iuoeaVsOWIsOi+vjI1dyvml7blsLHlj6/ku6Xli77pgInlj7PkvqfljLox55qE5pa55qGG5Y+v5Lul5YGc5LqG4oCU4oCU5re75Yqg5oiW6ICF5Yig6Zmk5YWD57Sg77ya54K55Ye74oCc6K6h566X5oiQ5YiG4oCdIO+8jOeCueWHu+KAnOe8lui+keWIlyDigJ3vvIzlj6rli77pgIl3dCXjgIF3dCVzaWdtYeOAgeWOn+WtkOeZvuWIhuavlOi/meS4ieS4quWwseihjOKAlOKAlOmdouWIhuW4g+WbvuaooeW8j+S4i++8jOWPs+mUruaKpeWRiu+8jOi/veWKoOKAlOKAlHBvaW50SUTmqKHlvI/kuIvvvIzlj7PplK7miqXlkYrvvIzngrnlh7vov73liqDigJTigJTkv53lrZjlpb3mlofku7bigJTigJTmib7kuIvkuIDkuKrkvY3nva7miZPog73osLHmiJbogIXnu5PmnZ/igJTigJTlnKh1cGxvYWQgZGF0YeaWh+S7tuWkueS4i++8jOaWsOW7uueUqOaIt+mihOe6pue8luWPt+WRveWQjeeahOaWh+S7tuWkue+8jOWmgjI0MjQyMu+8iOatpOaWh+S7tuWkuemHjOmdouWPquiDveaUvuWNleS4quaWh+S7tuaIluiAheWOi+e8qeWMhe+8ie+8jOaKiuaWh+S7tuaUvuWIsOivpeaWh+S7tuWkueS4i+OAguazqO+8muaJk+WujOiDveiwse+8jOiDveiwseWIh+aNouWIsOW9ouiyjO+8jOS4gOWumuaKiueUteWOi+iwg+WbnuWIsDNrViEKNyDmjaLmoLflk4EK54K55Ye76L2v5Lu255qEaG9tZei/m+ihjOWkjeS9jeKAlOKAlOeCueWHu29mZuWFs+mXreeUteWOi+KAlOKAlOeCueWHu29wZW7miZPlvIDkuqTmjaLku5Ppl6jigJTigJTmjqjov5vmoLflk4HmnYbliLDmnIDph4zpnaLnm7TliLB4Y+etieS6rui1t+KAlOKAlGxvY2vplIHkvY/moLflk4Hlj7DigJTigJTmi4nlh7rmoLflk4HmnYbliLDmnIDlpJbpnaLkuI3opoHmnb7miYvvvIzmi4nliLDkvY3kvJrlkKzliLDlo7Dpn7PigJTigJTngrnlh7tjbG9zZeWFs+mXreS6pOaNouS7k+mXqO+8jOmXqOWFs+S4iuS6huWGjeadvuaJi+KAlOKAlOeCueWHu2FpcuiuqeS6pOaNouS7k+i/m+epuuawlO+8jOWujOaIkOWQjmFpcueBr+S4jemXqu+8jOWPmOaIkOm7hOiJsu+8jOW5tuS4lOacieWjsOmfs+aPkOekuuKAlOKAlOaLieW8gOS6pOaNouS7k+KAlOKAlOW3puaJi+aJtuS9j+agt+WTgeWPsO+8jOWPs+aJi3VubG9ja+agt+WTgeadhu+8jOW3puaJi+WPluS4i+agt+WTgeWPsO+8jOaKiuS6pOaNouS7k+aOqOi/m+WOu+KAlOKAlOaKiuS4i+S4gOS4quS6uueahOagt+WTgeWPsOaUvuWIsOmUgeWumuWZqOS4iuOAggoKOCDkuIrkvKDmlbDmja4K5YWz5o6J5b2i6LKM5oiW6ICF6IO96LCx77yI5YWzU0VN6L2v5Lu277yaZmlsZS1leGl0LW9rIO+8ieeahOi9r+S7tuKAlOKAlOWcqOS4u+acuuS4iuaPkuWFpee9keWNoeKAlOKAlOetieW+hXdpZmnov57mjqXliLAyLjRHSHrigJTigJTlj4zlh7vpu4ToibLnmoR1cGxvYWTova/ku7bigJTigJTngrnlh7vkuIrkvKDvvIjkuI3pnIDopoHlhajpgInvvInigJTigJTnrYnlvoXkuIrkvKDlrozmr5XigJTigJTlhbPmjol1cGxvYWTova/ku7bjgIIKCjkg5YWz5py6CuWFs+iDveiwseeUteiEke+8muWFs+aYvuekuuWxj+KAlOKAlOWFs+S4u+acuuWQjumdoueahOm7keiJsuaMiemSruWIsDDnmoTkvY3nva7vvJsK5YWz5b2i6LKM55S16ISR77ya5YWz5pi+56S65bGP4oCU4oCU5YWzZGlzcGxheeKAlOKAlOWFs+W+queOr+awtOOAggoxMCDlhbbku5bvvIjlhbPkuo7lj7DlvI/vvIkK5qC35ZOB5Y+w77ya56qE55qE5LiA5L6n5pyd5ZCR6Ieq5bex77yM6ZyA6KaB55So55m96Imy5p2/6YeP6auY77yM55S16ISR6L6T5YWl5pWw5o2u5q+U5a6e6ZmF5qC35ZOB5Y+w6auY5bqm6auYMW1t77ybCgrova/ku7bvvJrikaDliKDpmaTmjonkuIrkuIDkuKrkurrnmoTlm77niYfvvIzngrlyZW1vdmXvvIzkuI3opoHngrlkZWxldGXvvIzlnLrlj5HlsITlj6/ku6XngrlkZWxldGXvvJvikaHlhbPkuo7ml4vovazlm77lg4/vvIzlj7DlvI/li77pgIlvbu+8jOWcuuWPkeWwhOWLvumAiXJvdGF0aW9u77ybCgrnvZHljaHvvJrlj7DlvI/nmoTlvaLosozlkozlnLrlj5HlsITnmoTlvaLosozjgIHog73osLHlhbHnlKjkuIDkuKrnvZHljaHvvIzlj7DlvI/nmoTog73osLHljZXni6zkuIDkuKrnvZHljaHvvJsKCuiDveiwse+8muWPsOW8j+mcgOimgeWcqOiDveiwseeUteiEkeWPs+S4i+inkuaJi+WKqOi+k+WFpeaUvuWkp+WAjeeOh+OAgeW3peS9nOi3neemu+OAgeeUteWOi++8jOWcuuWPkeWwhOS4jemcgOimgeOAggrluIPpsoHlhYtEOCBYUkQKMS7lvIDmnLrlh4blpIfvvJrpppblhYjmj5LlhaXnlLXmupDnur/vvIzmj5LkuIrpkqXljJnlubbmi6jliLBPTuS9jee9ru+8jOetieW+heWxj+W5leS6rui1t+W5tuWHuueOsOiPnOWNleeVjOmdouOAguWQjOaXtu+8jOivt+ehruS/nVXnm5jvvIjnlKjkuo7nlJ/miJDlsYDln5/nvZHvvInlt7Lmj5LlhaXkuJTkuI3pnIDopoHmi5TkuIvvvIznhLblkI7ov57mjqXmoLflk4HmjK/ojaHlmajjgIIKMi7moLflk4HlpITnkIbvvJrku47moLflk4HkuIrliK7lj5bpgILph4/nsonmnKvvvIjnuqY1MG1n77yJ5bm26L+H562b44CC5L2/55So5Yiu5Yu65bCG57KJ5pyr6YCB5YWl5qC35ZOB5rGg77yM5LmL5ZCO56uW55u05oyv6I2h5Zmo6K6p57KJ5pyr6Ieq54S26JC95YWl6YCa6YGT5YaF44CCCjMu6ZyH6I2h6YCB5qC377ya6KOF5aW95oyv6I2h5Zmo5ZCO77yM5Zyo5Li76I+c5Y2V55WM6Z2i6YCJ5oup4oCcU0hBS0XigJ3lvIDlp4vpnIfojaHvvIzlsIbmoLflk4HpgIHlhaXmoLflk4HmsaDlhoXjgILmoLnmja7pnIDopoHpgInmi6nmjK/ojaHlipvluqbvvIzlvZPmoLflk4Hln7rmnKzlrozlhajov5vlhaXmoLflk4HmsaDlkI7vvIzlgZzmraLpnIfojaHjgIIKNC7ova/ku7blronoo4XkuI7mlbDmja7liIbmnpDvvJpYUkTmlbDmja7liIbmnpDova/ku7blkI3kuLrigJxYUG93ZGVy4oCd77yM5a6J6KOF56iL5bqP5L2N5LqO5Luq5Zmo6Ieq5bim55qEVeebmOS4reOAguWwhuWuieijheeoi+W6j+aLt+i0neiHs+iHquW3seeahOiuvuWkh+W5tui/m+ihjOWuieijhe+8jOWuieijheWujOaIkOWQjumcgOimgea/gOa0u+i9r+S7tuOAguS5i+WQjuWuieijheaVsOaNruW6k++8jOW5tuWwhuWQhOexu+aVsOaNruW6k+aLt+i0neiHs+i9r+S7tuWuieijheebruW9leeahOaMh+WumuaWh+S7tuWkueOAguaJk+W8gOi9r+S7tuWQju+8jOmAieaLqeWImuWImuWuieijheeahOaVsOaNruW6k++8jOW8gOWni+WIhuaekOaVsOaNruOAggo1LuWFs+acuuS4jua4heeQhu+8muS9v+eUqOaMr+iNoeWZqOmch+iNoeWKn+iDveWwhuagt+WTgeeyieacq+aMr+WHuu+8jOW/heimgeaXtueUqOWOi+e8qeawlOaequaIluieuuS4neWIgOa4heeQhuagt+WTgeaxoOOAguWcqOS7quWZqOiPnOWNleagj+S4remAieaLqeKAnHNodXQgZG93buKAneWFs+mXreacuuWZqO+8jOeEtuWQjuaLp+WKqOmSpeWMmeiHs09GRuS9jee9ru+8jOacgOWQjuaLlOWHuuaMr+iNoeWZqOe6v+WPiueUtea6kOe6v+OAggror7fnoa7kv53mjInnhafkuIrov7DmraXpqqTmraPnoa7mk43kvZzku6rlmajvvIzku6Xojrflvpflh4bnoa7nmoTliIbmnpDnu5PmnpzjgIIKCgrnsbvkvLzku6rlmajnmoTmoIflh4bmk43kvZzop4TnqIsoU09QKeaooeadv++8mgrmoIflh4YKCkEu5qC55o2u546v5aKD55qE5rSB5YeA56iL5bqm77yM5Y+v5a6a5pyf77yI5LiA6IisMu+9njPkuKrmnIjvvInlsIbnspfmu6TluIPmi4bkuIvmuIXmtJfkuojku6Xmm7TmjaLvvJsKCkIu5a6a5pyf77yI5LiA6Iis5Li65LiA5ZGo77yJ5a+56LaF5YeA5bel5L2c5Y+w546v5aKD6L+b6KGM54Gt6I+M77yM5ZCM5pe277yM57uP5bi455So57qx5biD5rK+5LiK6YWS57K+5oiW5LiZ6YWu5pyJ5py65rq25YmC5bCG57Sr5aSW5p2A6I+M54Gv5aSW6KGo6Z2i5o+p5pOm5bmy5YeA77yM5L+d5oyB6KGo6Z2i5riF5rSB77yM5ZCm5YiZ5Lya5b2x5ZON5p2A6I+M5pWI5p6c77ybCgpDLuW9k+WKoOWkp+mjjuacuueUteWOi+S4jeiDveS9v+aTjeS9nOmjjumAn+i+vuWIsDAuMzJtL3Pml7bvvIzlv4Xpobvmm7TmjaLpq5jmlYjnqbrmsJTov4fmu6TlmajvvJsKCkQu5pu05o2i6auY5pWI56m65rCU6L+H5ruk5Zmo5pe25Y+v5omT5byA6aG255uW77yM5pu05o2i5pe25bqU5rOo5oSP6L+H5ruk5Zmo5LiK55qE566t5aS05qCH5b+X77yM566t5aS05oyH5ZCR5Y2z5Li65bGC5rCU5rWB5rWB5ZCR77ybCgpFLuabtOaNoumrmOaViOepuuawlOi/h+a7pOawlOWQju+8jOW6lOeUqOWwmOWfg+eykuWtkOiuoeaVsOWZqOajgOafpeWbm+WRqOi+ueahhuWvhuWwgeaYr+WQpuiJr+Wlve+8jOiwg+iKgumjjuacuueUteWOi++8jOS9v+aTjeS9nOW5s+Wdh+mjjumAn+S/neaMgeWcqDAuMzLvvZ4wLjQ4bS9z6IyD5Zu05YaF77yM5YaN5pyJ55SoWTA5LTTlnovlsJjln4PnspLlrZDorqHmlbDlmajmo4Dmn6XmtIHlh4DluqbjgIIKCuaTjeS9nOinhOeoi++8mgoKQS7kvb/nlKjlt6XkvZzlj7Dml7bvvIzlupTmj5DliY0x5bCP5pe25byA5py677yM5ZCM5pe25byA5ZCv57Sr5aSW54Gt6I+M54Gv77yM5aSE55CG5pON5L2c5Yy65YaF6KGo6Z2i56ev57Sv55qE5b6u55Sf54mp77yM5LiJ5Y2B5YiG6ZKf5ZCO5YWz6Zet5p2A6I+M54Gv77ybCgpCLuaWsOWuieijheeahOaIlumVv+acn+acquS9v+eUqOeahOW3peS9nOWPsO+8jOS9v+eUqOWJjeW/hemhu+WvueW3peS9nOWPsOWSjOWRqOWbtOeOr+Wig+WFiOeUqOi2heWHgOecn+epuuWQuOWwmOWZqOaIlueUqOS4jeS6p+eUn+e6pOe7tOeahOW3peWFt+i/m+ihjOa4hea0geW3peS9nOWPsO+8jOWGjemHh+eUqOiNr+eJqeeBreiPjOazleWSjOe0q+Wklue6v+eBreiPjOazlei/m+ihjOeBreiPjOWkhOeQhu+8mwoKQy7mk43kvZzljLrlhoXkuI3lhYHorrjlrZjmlL7kuI3lv4XopoHnmoTnianlk4HvvIzku6Xkv53mjIHmk43kvZzljLrnmoTmtIHlh4DmsJTmtYHmtYHlnovkuI3lj5flubLmibDvvJsKCkQu5pON5L2c5Yy65YaF5bqU5bC96YeP6YG/5YWN5L2c5piO5pi+5omw5Lmx5rCU5rWB5rWB5Z6L55qE5Yqo5L2c77ybRS7mk43kvZzljLrlhoXnmoTkvb/nlKjmuKnluqbkuI3lvpflpKfkuo42MOKEg+OAggoKCn3lrp7pqozlrqTlt7LmnInnmoTmk43kvZzop4TojIPmlofmoaPvvJoKCgrkuIDjgIHlrp7pqozlrqTlrojliJkKCjHjgIHov5vlhaXlrp7pqozlrqTlt6XkvZzml7bvvIzlv4Xpobvnqb/lt6XkvZzmnI3vvIznprvlvIDlrp7pqozlrqTml7blupTohLHkuIvjgILlt6XkvZzmnI3lupTnu4/luLjkv53mjIHmlbTmtIHvvIznpoHmraLnqb/lt6XkvZzmnI3ov5vlhaXlhazlhbHlnLrmiYDjgILlnKjov5vooYzku7vkvZXmnInlj6/og73norDkvKTjgIHliLrmv4DmiJbng6fkvKTnnLznnZvnmoTlt6XkvZzml7bvvIzlv4XpobvmiLTpmLLmiqTnnLzplZzjgILnu4/luLjmjqXop6bmtZPphbjjgIHmtZPnorHnmoTlt6XkvZzkurrlkZjvvIzlupTmiLTog7bluIPmiYvlpZflj4rlt6XkvZzluL3vvIzor5XmoLfliqDlt6Xmk43kvZzml7bkuI3lvpfmiLTmiYvlpZfjgIIKCjLjgIHnpoHmraLlnKjlrp7pqozlrqTlhoXlkLjng5/lj4rlkIPkuJzopb/jgILkuI3lh4bkvb/nlKjor5Xpqozlmajnmr/kvZzojLbmna/miJbppJDlhbfvvIzkuI3lvpfnlKjlmLTlt7Tlk4HlsJ3lkbPpgZPnmoTmlrnms5XmnaXpibTliKvmnKrnn6XnianjgIIKCjPjgIHlt6XkvZzlrozmr5XlkI7nprvlvIDlrp7pqozlrqTml7blupTnlKjogqXnmoLmtJfmiYvjgIIKCjTjgIHlrp7pqozlrqTlgZzmraLkvpvnlLXjgIHkvpvmsLTml7blupTlsIbmsLTmupDjgIHnlLXmupDlvIDlhbPlhajpg6jlhbPkuIrvvIzku6XpmLLmgaLlpI3kvpvnlLXjgIHkvpvmsLTml7bnlLHkuo7lvIDlhbPmnKrlhbPogIzlj5HnlJ/kuovmlYXjgILnprvlvIDlrp7pqozlrqTml7blupTmo4Dmn6Xpl6jjgIHnqpfjgIHmsLTjgIHnlLXjgIHmsJTmmK/lkKblronlhajlj4rlhbPpl63jgIIKCjXjgIHlrp7pqozlrqTlhoXnmoTmr4/nk7bor5XliYLlv4XpobvotLTmnInmmI7mmL7nmoTkuI7or5XliYLnm7jnrKbnmoTmoIfnrb7jgIHlubbmoIfmmI7or5XliYLlkI3np7DjgIHmtZPluqblj4rphY3liLbml6XmnJ/miJbmoIflrprml6XmnJ/jgIIKCjbjgIHpq5jmuKnniankvZPvvIjkvovlpoLliJrnlLHpq5jmuKnngonkuK3lj5blh7rnmoTlnanln5rlkoznk7foiJ/opoHmlL7lnKjlubLlh4DnmoTogJDngavnn7Pmo4nmnb/vvInkuIrmiJbnk7fnm5jkuK3pmYTov5HkuI3lvpfmnInmmJPnh4PnianjgILpnIDnp7Dph4/nmoTlnanln5rlvoXnqI3lhrflkI7mlrnlj6/np7voh7PlubLnh6XlmajkuK3lhrfljbTjgIIKCjfjgIHmk43kvZzml7bkvJrkuqfnlJ/mnInlrrPmsJTkvZPjgIHng5/pm77miJbnsonlsJjml7bvvIzlv4XpobvlnKjoia/lpb3nmoTpgJrpo47mn5zlhoXov5vooYzjgIIKCjjjgIHlrp7pqozlrqTnmoTku6rlmajlnKjmnKrmjozmj6Hlronlhajmk43kvZzop4TnqIvliY3kuI3lvpfpmo/mhI/liqjnlKjjgIIKCuS6jOOAgeeUteWZqOOAgeaYk+eHg+OAgeaYk+eIhgoK77yI5LiA77yJ55S15Zmo5a6J5YWo5pON5L2c6KeE56iLCgox44CB5a6e6aqM5a6k5YaF5LiN5b6X5pyJ6KO46Zyy55qE55S157q/44CB6Ze45YiA5byA5YWz5bqU5a6M5YWo5ZCI5LiK5oiW5pat5byA77yM5Lul6Ziy5q2i5o6l6Kem5LiN5aW95Lqn55Sf54Gr6Iqx6L+b6ICM5byV6LW35piT54eD54mp55qE54iG54K477yM5ouU5LiL5o+S5aS05pe25bqU55So5omL5o2P5L2P5o+S5aS05YaN5ouU77yM5LiN5b6X5omv5ouJ55S157q/44CCCgoy44CB5ZCE56eN55S15Zmo6K6+5aSH5Y+K55S157q/5bqU5aeL57uI5L+d5oyB5bmy54el77yM5LiN5b6X5rW45rm/77yM5Lul6Ziy55+t6Lev5byV6LW354Gr54G+5oiW54On5Z2P55S15Zmo6K6+5aSH44CCCgoz44CBIOWQhOexu+eUteWZqOiuvuWkh+WPkeeUn+W8guW4uOaIluaVhemanOaXtu+8jOW6lOWPiuaXtuaWreeUte+8jOeUseS4k+S4muS6uuWRmOajgOS/ruOAggoKNOOAgSDkv53pmankuJ3nhpTmlq3ml7bvvIzlupTmn6XmuIXljp/lm6DvvIzkuI3lvpfku7vmhI/lop7liqDmiJbliqDnspfkv53pmankuJ3vvIzmm7TkuI3lvpfku6Xpk5zkuJ3ku6Pmm7/jgIIKCu+8iOS6jO+8ieawp+awlOOAgea2suWMluawlOeTtueahOWuieWFqOS9v+eUqOinhOeoiwoKMeOAgeawp+awlOOAgea2suWMluawlOaYr+W8uueDiOeahOWKqeeHg+awlOS9k++8jOawp+awlOOAgea2suWMluawlOeTtuS4gOWumuimgeS4pemYsuS4juayueiEguaOpeinpuOAguW8gOWQr+awp+awlOOAgea2suWMluawlOeTtueahOaJs+aJi+S4jeW+l+ayvuacieayueiEguOAggoKMuOAgeaQrOi/kOawp+awlOOAgea2suWMluawlOeTtuaXtu+8jOW6lOWFiOijheS4iuWuieWFqOW4ve+8jOS4jeWPr+S9v+awlOS9k+WPl+WIsOmch+WKqOaIluaSnuWHu++8jOS7pemYsuatoueIhueCuOOAggoKM+OAgeW9k+awp+awlOOAgea2suWMluawlOeTtuS4uuerluebtOaUvue9ruaXtu+8jOW/hemhu+WbuuWumuaLtOeJouOAggoKNOOAgeawp+awlOOAgea2suWMluawlOeTtuS4jeW+l+S4jueUtee6v+aOpeinpu+8jOS5n+S4jeW+l+aUvuWcqOmdoOi/keWKoOeDreWZqOOAgeaYjueBq+aIluaaluawlOmZhOi/ke+8jOS7peWPiumYs+WFieebtOWwhOeahOWcsOaWue+8jOS7pemYsuatouawlOS9k+WPl+eDreiGqOiDgOW8lei1t+eIhueCuOOAggoKNeOAgeW8gOWQr+WOi+WKm+ihqOmYgOmXqOaXtuimgee8k+aFou+8jOawlOa1geS4jeWPr+WkquW/q++8jOS7pemYsuWGsuWdj+S7quWZqOaIluW8lei1t+edgOeBq++8jOeIhueCuOOAggoK5LiJ44CB54Gt54Gr5LiO5oCl5pWRCgrvvIjkuIDvvInnga3ngasKCjHjgIHlrp7pqozlrqTlpLHngavlkI7vvIzkuIDlrpropoHmsonnnYDjgIHkuI3opoHmg4rmhYzvvIzopoHmoLnmja7otbfngavljp/lm6DkuI7ngavlir/lpKflsI/vvIzlj4rml7bph4flj5bku6XkuIvmjqrmlr3vvJoKCjLjgIHnq4vljbPlhbPmjonnlLXmupDjgIHmsJTmupDlj4rpgJrpo47mnLoKCjPjgIHlsIblrqTlhoXmmJPnh4PjgIHmmJPniIbnianvvIjkvovlpoLljovnvKnmsJTnk7bvvInlsI/lv4PmkKznprvngavmupDvvIzms6jmhI/mkKzliqjml7bliIfkuI3lj6/norDmkp7vvIzku6XlhY3lvJXotbfmm7TlpKfngavngb7jgIIKCjTjgIHov4XpgJ/pgInnlKjpgILlvZPnmoTnga3ngavlmajvvIzlsIbliJrotbfnmoTngavmiZHnga3jgILms6jmhI/kuI3opoHnlKjmsLTmnaXmiZHnga3kuI3murbkuo7msLTnmoTmsrnnsbvku6Xlj4rlhbbku5bmnInmnLrmurbliYLnrYnlj6/nh4PnianjgIIKCjXjgIHlj4rml7bmiqXorabvvJrlronlhajkv53ljavnlLXor53vvJowODcxLTY1OTM3MTEwIOeBq+itpueUteivnTExOeOAggoKNuOAgei6q+S4iuiho+acjeedgOeBq+aXtu+8jOWIh+S4jeWPr+S7u+aEj+i3keWKqOOAguW6lOeUqOefs+ajieavr+ijueWcqOi6q++8jOS7pemalOe7neepuuawlOiAjOeBreeBq+OAguWmguaXoOefs+ajieavr+aIluiWhOavr+aXtu+8jOWPr+WwseWcsOi6uuS4i+aJk+a7muS7peeBreeBq+OAggoKN+OAgeWunumqjOWupOW6lOijheWkh+W/heimgeeahOeBreeBq+iuvuWkh+OAggoKLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKVGhpcyBpcyBhIHJlcG9ydCBvbiB0aGUgdGVuc2lsZSBleHBlcmltZW50IG9mIG1hdGVyaWFsIG1lY2hhbmljcywgKipNYXRlcmlhbCoqCgoxLiBTYW1wbGUgSW5mb3JtYXRpb24KCiAgICBNYXRlcmlhbCBOYW1lOiBMb3cgQ2FyYm9uIFN0ZWVsICAKICAgIFNhbXBsZSBTaGFwZTogUm91bmQgQmFyICAKICAgIFNhbXBsZSBEaWFtZXRlcjogMTAgbW0gIAogICAgU2FtcGxlIExlbmd0aDogMTAwIG1tICAKICAgIFNhbXBsZSBJRDogQS0wMSAgCgoyLiBUZXN0aW5nIEVxdWlwbWVudAoKICAgIFRlc3RpbmcgTWFjaGluZSBOYW1lOiBJTlNUUk9OIDU1NjkgVGVuc2lsZSBUZXN0aW5nIE1hY2hpbmUgIAogICAgICAgIE1heGltdW0gTG9hZDogMTAwIGtOICAKICAgICAgICBUZW5zaWxlIFNwZWVkOiAyIG1tL21pbiAgCiAgICAgICAgRGlzcGxhY2VtZW50IFJlc29sdXRpb246IDAuMDAxIG1tICAKICAgICAgICBTdHJhaW4gTWVhc3VyZW1lbnQgU3lzdGVtOiBIaWdoLVByZWNpc2lvbiBEaXNwbGFjZW1lbnQgU2Vuc29yICAKICAgICAgICBDb250cm9sIFN5c3RlbTogRGlnaXRhbCBDb250cm9sIFN5c3RlbSwgc3VwcG9ydHMgcmVhbC10aW1lIGRpc3BsYXkgb2YgZm9yY2UtZGlzcGxhY2VtZW50IGN1cnZlIGFuZCBkYXRhIHJlY29yZGluZyAgCgozLiBFeHBlcmltZW50IFByb2Nlc3MKCiAgICBTYW1wbGUgUHJlcGFyYXRpb246ICAKICAgICAgICBJbnNwZWN0IHRoZSBzYW1wbGUgc3VyZmFjZSBmb3IgY3JhY2tzIG9yIGRlZmVjdHMsIGVuc3VyaW5nIHRoZSBzdXJmYWNlIGlzIHNtb290aC4gIAogICAgICAgIE1lYXN1cmUgdGhlIGluaXRpYWwgZGlhbWV0ZXIgb2YgdGhlIHNhbXBsZSB0byBiZSAxMC4wIG1tIGFuZCB0aGUgbGVuZ3RoIHRvIGJlIDEwMCBtbSB1c2luZyBjYWxpcGVycy4gIAoKICAgIFRlc3RpbmcgUHJvY2VzczogIAogICAgICAgIEluc3RhbGwgdGhlIHNhbXBsZSBpbiB0aGUgdGVzdGluZyBtYWNoaW5lIGdyaXBzLCBlbnN1cmluZyBzeW1tZXRyaWMgbG9hZGluZy4gIAogICAgICAgIFN0YXJ0IHRoZSB0ZW5zaWxlIHRlc3RpbmcgbWFjaGluZSwgc2V0IHRoZSB0ZW5zaWxlIHNwZWVkIHRvIDIgbW0vbWluLCBhbmQgYmVnaW4gbG9hZGluZy4gIAoKNC4gRXhwZXJpbWVudGFsIFJhdyBEYXRhCgogICAgU3RyZXNzIChNUGEpICAgU3RyYWluIChtbS9tbSkgICBMb2FkIChrTikgICBEZWZvcm1hdGlvbiAobW0pICAKICAgIDAgICAgICAgICAgICAgMCAgICAgICAgICAgICAgICAwICAgICAgICAgICAwICAKICAgIDUwICAgICAgICAgICAgMC4wMDIgICAgICAgICAgICAwLjUgICAgICAgICAwLjIgIAogICAgMTAwICAgICAgICAgICAwLjAwNCAgICAgICAgICAgIDEuMCAgICAgICAgIDAuNCAgCiAgICAxNTAgICAgICAgICAgIDAuMDA2ICAgICAgICAgICAgMS41ICAgICAgICAgMC42ICAKICAgIDIwMCAgICAgICAgICAgMC4wMDggICAgICAgICAgICAyLjAgICAgICAgICAwLjggIAogICAgMjUwICAgICAgICAgICAwLjAxMCAgICAgICAgICAgIDIuNSAgICAgICAgIDEuMCAgCiAgICAzMDAgICAgICAgICAgIDAuMDEyICAgICAgICAgICAgMy4wICAgICAgICAgMS4yICAKICAgIDM1MCAgICAgICAgICAgMC4wMTUgICAgICAgICAgICAzLjUgICAgICAgICAxLjQgIAogICAgNDAwICAgICAgICAgICAwLjAxOCAgICAgICAgICAgIDQuMCAgICAgICAgIDEuNiAgCiAgICA0NTAgICAgICAgICAgIDAuMDIwICAgICAgICAgICAgNC41ICAgICAgICAgMS44ICAKICAgIDUwMCAgICAgICAgICAgMC4wMjIgICAgICAgICAgICA1LjAgICAgICAgICAyLjAgIAogICAgNTEwICAgICAgICAgICAwLjAyMyAgICAgICAgICAgIDUuMSAgICAgICAgIDIuMSAgCgo1LiBUaGVvcmV0aWNhbCBDYWxjdWxhdGlvbgoKICAgIFlpZWxkIFN0cmVuZ3RoICjPg195KSAgCiAgICBUaGUgeWllbGQgc3RyZW5ndGggb2YgdGhlIHN0cmVzcy1zdHJhaW4gY3VydmUgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZSBleHBlcmltZW50YWwgZGF0YSwgYXNzdW1pbmcgdGhlIHlpZWxkIHBvaW50IGFzIHRoZSBwb2ludCBiZWZvcmUgdGhlIHN0cmVzcyByZWFjaGVzIGl0cyBtYXhpbXVtIHZhbHVlLiAgCiAgICAgICAgTWF4aW11bSBTdHJlc3Mgz4NfbWF4ID0gNTEwIE1QYSAgCiAgICAgICAgWWllbGQgU3RyZW5ndGggz4NfeSA9IDI1MCBNUGEgKFRoZW9yZXRpY2FsIFZhbHVlKSAgCgogICAgVGVuc2lsZSBTdHJlbmd0aCAoz4NfYikgIAogICAgVGhlIHRlbnNpbGUgc3RyZW5ndGggaXMgdGhlIHN0cmVzcyBhdCB0aGUgbWF4aW11bSBsb2FkIHBvaW50IGR1cmluZyBzdHJldGNoaW5nLiAgCiAgICAgICAgVGhlb3JldGljYWwgVmFsdWUgz4NfYiA9IDUxMCBNUGEgIAoKICAgIEVsb25nYXRpb24gQWZ0ZXIgRnJhY3R1cmUgKEEpICAKICAgIEFjY29yZGluZyB0byB0aGUgZm9ybXVsYTogIAogICAgQSA9IChsX2YgLSBsXzApIC8gbF8wIMOXIDEwMCUgIAogICAgV2hlcmUsIGxfZiBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBzYW1wbGUgYWZ0ZXIgZnJhY3R1cmUsIGFuZCBsXzAgaXMgdGhlIG9yaWdpbmFsIGxlbmd0aC4gIAogICAgQXNzdW1lIHRoZSBsZW5ndGggYWZ0ZXIgZnJhY3R1cmUgaXMgbF9mID0gMTAyIG1tLCAgCiAgICBBID0gKDEwMiAtIDEwMCkgLyAxMDAgw5cgMTAwJSA9IDIlICAKICAgICAgICBFbG9uZ2F0aW9uIEFmdGVyIEZyYWN0dXJlOiAyJSAgCgogICAgRWxhc3RpYyBNb2R1bHVzIChFKSAgCiAgICBUaGUgZWxhc3RpYyBtb2R1bHVzIGNhbiBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIHNsb3BlIG9mIHRoZSBpbml0aWFsIGxpbmVhciBzZWN0aW9uIG9mIHRoZSBzdHJlc3Mtc3RyYWluIGN1cnZlOiAgCiAgICBFID0gz4MgLyDOtSAgCiAgICBUYWtpbmcgc3RyZXNzIGFzIDEwMCBNUGEgYW5kIHN0cmFpbiBhcyAwLjAwNDogIAogICAgRSA9IDEwMCBNUGEgLyAwLjAwNCA9IDI1LDAwMCBNUGEgPSAyNSBHUGEgIAogICAgICAgIEVsYXN0aWMgTW9kdWx1cyBFID0gMjUgR1BhIChUaGVvcmV0aWNhbCBWYWx1ZSkgIAoKNi4gQW5hbHlzaXMgb2YgRXhwZXJpbWVudGFsIFJlc3VsdHMKCiAgICBZaWVsZCBTdHJlbmd0aCBvZiB0aGUgTWF0ZXJpYWw6IFRoZSBleHBlcmltZW50YWwgcmVzdWx0IHNob3dzIHRoYXQgdGhlIHlpZWxkIHN0cmVuZ3RoIG9mIHRoZSBzYW1wbGUgaXMgMjUwIE1QYSwgd2hpY2ggaXMgY2xvc2UgdG8gdGhlIHRoZW9yZXRpY2FsIHZhbHVlIGFuZCBtZWV0cyBleHBlY3RhdGlvbnMuICAKICAgIFRlbnNpbGUgU3RyZW5ndGg6IFRoZSBtYXhpbXVtIHN0cmVzcyByZWFjaGVzIDUxMCBNUGEsIG11Y2ggaGlnaGVyIHRoYW4gdGhlIHlpZWxkIHN0cmVuZ3RoLCBpbmRpY2F0aW5nIHN0cm9uZyB0ZW5zaWxlIGNhcGFiaWxpdHkgb2YgdGhlIG1hdGVyaWFsLiAgCiAgICBFbG9uZ2F0aW9uIEFmdGVyIEZyYWN0dXJlOiBUaGUgMiUgZWxvbmdhdGlvbiBhZnRlciBmcmFjdHVyZSBzaG93cyB0aGF0IHRoZSBtYXRlcmlhbCBoYXMgYSBjZXJ0YWluIGRlZ3JlZSBvZiBkdWN0aWxpdHksIG1ha2luZyBpdCBzdWl0YWJsZSBmb3IgYXBwbGljYXRpb25zIHRoYXQgcmVxdWlyZSBzdWJzdGFudGlhbCBwbGFzdGljIGRlZm9ybWF0aW9uLiAgCiAgICBFbGFzdGljIE1vZHVsdXM6IFRoZSBlbGFzdGljIG1vZHVsdXMgaXMgMjUgR1BhLCBpbmRpY2F0aW5nIGhpZ2ggcmlnaWRpdHksIGNvbnNpc3RlbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWNzIG9mIGxvdyBjYXJib24gc3RlZWwuICAKCjcuIENvbmNsdXNpb24KCiAgICBUaGlzIHRlbnNpbGUgdGVzdCB2ZXJpZmllZCB0aGUgeWllbGQgc3RyZW5ndGgsIHRlbnNpbGUgc3RyZW5ndGgsIGFuZCBkdWN0aWxpdHkgb2YgbG93IGNhcmJvbiBzdGVlbC4gQ29tcGFyaW5nIHdpdGggdGhlIHRoZW9yZXRpY2FsIHZhbHVlcywgdGhlIGV4cGVyaW1lbnRhbCByZXN1bHRzIGFyZSBpbiBsaW5lIHdpdGggdGhlIGJhc2ljIHByaW5jaXBsZXMgb2YgbWF0ZXJpYWwgbWVjaGFuaWNzLCBwcm92aW5nIHRoYXQgdGhpcyBtYXRlcmlhbCBoYXMgZ29vZCBtZWNoYW5pY2FsIHByb3BlcnRpZXMgYW5kIGlzIHN1aXRhYmxlIGZvciB1c2UgaW4gc3RydWN0dXJhbCBjb21wb25lbnRzIHRoYXQgYmVhciBsYXJnZSBsb2Fkcy4uIFBsZWFzZSB3cml0ZSBhIGRpc2N1c3Npb24gc2VjdGlvbiBvZiBhcHByb3hpbWF0ZWx5IDMwMDAgd29yZHMgYmFzZWQgb24gdGhpcyByZXBvcnQuIEZyb20gdGhlIHRocmVlIGRpbWVuc2lvbnMgb2YgdGhlb3JldGljYWwgZm91bmRhdGlvbiwgZXhwZXJpbWVudGFsIHByb2Nlc3MsIGFuZCBkYXRhIGFuYWx5c2lzLCBlbGFib3JhdGUgb24gdGhlIHJlYXNvbnMgZm9yIHRoZSBkZXZpYXRpb24gYmV0d2VlbiB0aGUgZXhwZXJpbWVudGFsIHJlc3VsdHMgYW5kIHRoZSB0aGVvcmV0aWNhbCB2YWx1ZXMuIEZvciBlYWNoIGRldmlhdGlvbiByZWFzb24sIHByb3Bvc2Ugc3BlY2lmaWMgYW5kIGZlYXNpYmxlIGltcHJvdmVtZW50IG1lYXN1cmVzLCBpbmNsdWRpbmcgaW5zdHJ1bWVudCBzZWxlY3Rpb24sIG9wdGltaXphdGlvbiBvZiBleHBlcmltZW50YWwgc3RlcHMsIGRhdGEgcHJvY2Vzc2luZyBtZXRob2RzLCBldGMuCnVzZXI6CldyaXRlIGFuIGFic3RyYWN0IGZvciB0aGlzIHBhcGVyIG9uIHRoZSBkZXNpZ24gb2YgYSBzb2Z0d2FyZSB0ZXN0aW5nIGF1dG9tYXRpb24gZnJhbWV3b3JrIGZvciAqKjEuIEludHJvZHVjdGlvbioqCgpTbyBmYXIsIHRoZSByYXBpZCBkZXZlbG9wbWVudCBvZiBpbmZvcm1hdGlvbiB0ZWNobm9sb2d5IGhhcyBsZWQgdG8gdGhlIGFwcGxpY2F0aW9uIG9mIHNvZnR3YXJlIHByb2R1Y3RzIGluIHZhcmlvdXMgc2VjdG9ycyBvZiBzb2NpZXR5LiBOYXR1cmFsbHksIHRoZSBxdWFsaXR5IG9mIHNvZnR3YXJlIHByb2R1Y3RzIGhhcyBiZWNvbWUgYSBjb21tb24gZm9jdXMgb2YgYXR0ZW50aW9uLiBUbyBlbnN1cmUgcHJvZHVjdCBxdWFsaXR5LCBzb2Z0d2FyZSB0ZXN0aW5nIHdpbGwgcmVtYWluIGFuIGVmZmVjdGl2ZSBtZXRob2QgZm9yIHNvZnR3YXJlIHByb2R1Y3QgcXVhbGl0eSBhc3N1cmFuY2UgZm9yIGEgbG9uZyB0aW1lIGluIHRoZSBmdXR1cmUuIEF1dG9tYXRlZCB0ZXN0aW5nIGlzIGEgd2lkZWx5IGRpc2N1c3NlZCBkaXJlY3Rpb24gaW4gdG9kYXkncyBzb2Z0d2FyZSB0ZXN0aW5nIGluZHVzdHJ5LiBDdXJyZW50bHksIHBlcmZvcm1hbmNlIHRlc3RpbmcgYXV0b21hdGlvbiBpcyB0aGUgbW9zdCBtYXR1cmUgaW1wbGVtZW50YXRpb24gaW4gdGhlIGluZHVzdHJ5LiBBcyBmb3Igc3lzdGVtIHRlc3RpbmcgYXV0b21hdGlvbiwgaW5jbHVkaW5nIFVJIHRlc3RpbmcgYXV0b21hdGlvbiwgdW5pdCB0ZXN0aW5nIGF1dG9tYXRpb24sIGFuZCBmdW5jdGlvbmFsIHRlc3RpbmcgYXV0b21hdGlvbiwgYWx0aG91Z2ggcG93ZXJmdWwgdGhpcmQtcGFydHkgc29mdHdhcmUgdGVzdGluZyB0b29scyBzdWNoIGFzIFFUUCwgV0lOUlVOTkVSLCBhbmQgU0VMRU5JVU0gY2FuIGJlIHVzZWQgYXMgc29sdXRpb25zLCBpbiBwcmFjdGljZSwgY29tcGFuaWVzIGZpbmQgaXQgZGlmZmljdWx0IHRvIHN1Y2Nlc3NmdWxseSBpbXBsZW1lbnQgdGVzdCBhdXRvbWF0aW9uIHJlbHlpbmcgb24gYSBzaW5nbGUgdG9vbC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGUgbGFjayBvZiBhIGNvbXBsZXRlIHNldCBvZiB0ZXN0IGF1dG9tYXRpb24gc29sdXRpb25zLCBpLmUuLCB0aGUgYWJzZW5jZSBvZiBhIHRlc3RpbmcgZnJhbWV3b3JrLiBUaGVyZWZvcmUsIG1vcmUgbWFucG93ZXIgaXMgb2Z0ZW4gcmVxdWlyZWQgdG8gbGVhcm4gaG93IHRvIHVzZSB0aGUgdG9vbHMsIHdyaXRlIGNvbXBsZXggdGVzdCBzY3JpcHRzLCBtYW51YWxseSBvYnRhaW4gdGVzdCByZXN1bHRzIGFuZCBhbmFseXplIHRoZW0sIGFuZCBkZWFsIHdpdGggdGhlIGRhbWFnZSBjYXVzZWQgYnkgY2hhbmdlcyBpbiBwcm9qZWN0IHBlcnNvbm5lbC4gSGVuY2UsIGJ1aWxkaW5nIGEgY29tcGxldGUgdGVzdCBhdXRvbWF0aW9uIGZyYW1ld29yayBpcyBhbiBpbmV2aXRhYmxlIHRyZW5kLiAKCkFuIGF1dG9tYXRlZCB0ZXN0aW5nIGZyYW1ld29yayBpcyBhIGNvbXByZWhlbnNpdmUgc29sdXRpb24gZm9yIHRlc3QgYXV0b21hdGlvbiwgcGxheWluZyBhIGtleSByb2xlIGluIHRoZSBzcGVjaWZpYyB3b3JrIG9mIHNvZnR3YXJlIHRlc3QgYXV0b21hdGlvbi4gVGhlIGluZHVzdHJ5IGlzIGFjdGl2ZWx5IGNvbnN0cnVjdGluZyBhdXRvbWF0ZWQgdGVzdGluZyBmcmFtZXdvcmtzIHRhaWxvcmVkIHRvIHRoZSBuZWVkcyBvZiB0aGVpciByZXNwZWN0aXZlIGNvbXBhbmllcy4gQ29tbW9ubHkgbWVudGlvbmVkIGF1dG9tYXRlZCB0ZXN0aW5nIGZyYW1ld29ya3MgaW4gdGhlIGluZHVzdHJ5IGluY2x1ZGUgZGF0YS1kcml2ZW4gYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3Jrcywga2V5d29yZC1kcml2ZW4gdGVzdGluZyBmcmFtZXdvcmtzLCBhbmQgdGFibGUtZHJpdmVuIGF1dG9tYXRlZCB0ZXN0aW5nIGZyYW1ld29ya3MuIFRoZXNlIHRlc3RpbmcgZnJhbWV3b3JrcyBpbXByb3ZlIHRlc3RpbmcgZWZmaWNpZW5jeSBpbiBjZXJ0YWluIHN0YWdlcyBvZiBzb2Z0d2FyZSB0ZXN0aW5nLCBidXQgYWxzbyBpbnRyb2R1Y2Ugb3RoZXIgaXNzdWVzLiBUaGlzIGFydGljbGUgYXJndWVzIHRoYXQgdGVzdGluZyBmcmFtZXdvcmtzIHNob3VsZCBub3QgYmUgZGVzaWduZWQgZm9yIHNwZWNpZmljIHRlc3RpbmcgYWN0aXZpdGllcyBidXQgc2hvdWxkIGJlIGNhdGVnb3JpemVkIGFjY29yZGluZyB0byBkZXZlbG9wbWVudCB0eXBlcywgd2hpY2ggaXMgYSBtb3JlIHJlYXNvbmFibGUgYXBwcm9hY2guIFRoaXMgcGFwZXIgcHJvcG9zZXMgYSB0ZXN0IGZyYW1ld29yayBzdWl0YWJsZSBmb3IgaXRlcmF0aXZlIGRldmVsb3BtZW50LgoKKioyLiBEZXNpZ24gb2YgdGhlIFNvZnR3YXJlIFRlc3RpbmcgQXV0b21hdGlvbiBGcmFtZXdvcmsgQmFzZWQgb24gSXRlcmF0aXZlIFNvZnR3YXJlIERldmVsb3BtZW50KioKCioqMi4xIFNvZnR3YXJlIFRlc3QgQXV0b21hdGlvbioqCgpDdXJyZW50bHksIHNvZnR3YXJlIHRlc3QgYXV0b21hdGlvbiByZWZlcnMgdG8gdGhlIHVzZSBvZiBwcm9ncmFtIGV4ZWN1dGlvbiB0byByZXBsYWNlIG1hbnVhbCB0ZXN0aW5nLCB0aHVzIHJlZHVjaW5nIG1hbnVhbCB3b3JrbG9hZCBhbmQgaW1wcm92aW5nIHRlc3RpbmcgZWZmaWNpZW5jeS4gQXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3JrcyBhcmUgY29tcHJlaGVuc2l2ZSBzb2x1dGlvbnMgdGhhdCBhY2hpZXZlIGhpZ2gtZWZmaWNpZW5jeSwgaGlnaC1xdWFsaXR5IGF1dG9tYXRlZCB0ZXN0aW5nLiBJdGVyYXRpdmUgZGV2ZWxvcG1lbnQgaXMgYSBncmFkdWFsIGRldmVsb3BtZW50IG1ldGhvZCB0aGF0IGRpdmlkZXMgdGhlIGVudGlyZSBkZXZlbG9wbWVudCBwcm9jZXNzIGludG8gc2V2ZXJhbCBpdGVyYXRpdmUgY3ljbGVzLCB3aXRoIGVhY2ggY3ljbGUgcHJvZHVjaW5nIGEgcnVubmFibGUgc29mdHdhcmUuIEl0ZXJhdGl2ZSBkZXZlbG9wbWVudCBpcyB0aGUgbW9zdCBzdWl0YWJsZSBkZXZlbG9wbWVudCBhY3Rpdml0eSBmb3IgdGVzdCBhdXRvbWF0aW9uIGFuZCBjYW4gbWF4aW1pemUgdGhlIGJlbmVmaXRzIG9mIGF1dG9tYXRlZCB0ZXN0aW5nLiAKCkluIGl0ZXJhdGl2ZSBkZXZlbG9wbWVudCwgZWFjaCBzb2Z0d2FyZSBkZXZlbG9wbWVudCBjeWNsZSBhZGRzIG5ldyBmZWF0dXJlcywgd2hlcmUgdGVzdGVycyBkZXNpZ24gdGVzdHMgZm9yIHRoZSBuZXcgZmVhdHVyZXMsIHRyYW5zaXRpb24gdG8gZnVuY3Rpb25hbCB2ZXJpZmljYXRpb24sIGV4ZWN1dGUgdGVzdHMgZm9yIG5ldyBmZWF0dXJlcywgYW5kIHBlcmZvcm0gcmVncmVzc2lvbiB0ZXN0aW5nIGZvciBpc3N1ZXMgZGlzY292ZXJlZCBpbiB0aGUgcHJldmlvdXMgcm91bmQgb2YgdGVzdGluZy4gSW4gdGhlc2UgdGVzdGluZyBhY3Rpdml0aWVzLCBhY3Rpdml0aWVzIHN1Y2ggYXMgdGVzdCB2ZXJpZmljYXRpb24sIG5ldyBmZWF0dXJlIHRlc3RpbmcsIGFuZCByZWdyZXNzaW9uIHRlc3RpbmcgYXJlIGVhc3kgdG8gYXV0b21hdGUgYW5kIHN1aXRhYmxlIGZvciBhdXRvbWF0aW9uLiAKCkluIHRoZSB0ZXN0aW5nIHByb2Nlc3MgKGFzIHNob3duIGluIEZpZ3VyZSAxKToKCjEuIEFmdGVyIHZlcnNpb24gdHJhbnNpdGlvbiB0ZXN0aW5nLCBmdW5jdGlvbmFsIHZlcmlmaWNhdGlvbiBpcyBjb25kdWN0ZWQgZmlyc3QgdG8gcHJvdmUgdGhhdCBubyBuZXcgc2VyaW91cyBpc3N1ZXMgaGF2ZSBiZWVuIGludHJvZHVjZWQgaW4gdGhlIHRyYW5zaXRpb25lZCB2ZXJzaW9uLiBBcHByb3ByaWF0ZSB0ZXN0IGNhc2VzIGFyZSBzZWxlY3RlZCBmcm9tIHRoZSBzY3JpcHQgbGlicmFyeSBmb3IgdGVzdGluZy4KMi4gUmVncmVzc2lvbiB0ZXN0aW5nIGlzIHBlcmZvcm1lZCBmb3IgZGVmZWN0cyBmb3VuZCBpbiB0aGUgcHJldmlvdXMgc3RhZ2UuIFRoZSB1c2Ugb2YgcHJldmlvdXMgc2NyaXB0cyBjYW4gcHJldmVudCB0aGUgYXJiaXRyYXJpbmVzcyBvZiBtYW51YWwgdGVzdGluZyBhbmQgYWNoaWV2ZSBhIGNvbXBsZXRlbHkgcmVzdG9yZWQgb24tc2l0ZSBzY2VuYXJpby4KMy4gTmV3IGZ1bmN0aW9uYWxpdHkgaXMgdGVzdGVkIHVzaW5nIG5ldyB0ZXN0IHNjcmlwdHMuIEFmdGVyIHRlc3RpbmcsIHRoZSBuZXcgZmVhdHVyZSBzY3JpcHRzIGFyZSBpbmNvcnBvcmF0ZWQgaW50byB0aGUgc2NyaXB0IGxpYnJhcnkgZm9yIHRoZSBuZXh0IHJvdW5kIG9mIHRyYW5zaXRpb24gdGVzdGluZyBhbmQgcmVncmVzc2lvbiB0ZXN0aW5nLgoKKipGaWd1cmUgMSoqCgpDbGVhcmx5LCB0ZXN0IHNjcmlwdHMgYXJlIHJ1biBtdWx0aXBsZSB0aW1lcyB0aHJvdWdob3V0IHRoZSBlbnRpcmUgaXRlcmF0aXZlIHByb2Nlc3MsIG1ha2luZyB0aGVpciB1c2FnZSBoaWdobHkgZWZmaWNpZW50LCB3aGljaCBkaXJlY3RseSBpbXByb3ZlcyB0aGUgb3V0cHV0LXRvLWlucHV0IHJhdGlvIG9mIGF1dG9tYXRlZCB0ZXN0aW5nLgoKKioyLjIgRGVzaWduIG9mIFNvZnR3YXJlIFRlc3RpbmcgQXV0b21hdGlvbiBGcmFtZXdvcmsqKgoKVGhlIHNvZnR3YXJlIHRlc3RpbmcgYXV0b21hdGlvbiBmcmFtZXdvcmsgaXMgYSBjb21wcmVoZW5zaXZlIHNvbHV0aW9uIGZvciB0ZXN0IGF1dG9tYXRpb24sIHByb3ZpZGluZyBhIGNvbXBsZXRlIHNldCBvZiB0ZXN0aW5nIGFjdGl2aXRpZXMuIEl0IGNlbnRyYWxpemVzLCBzcGVjaWFsaXplcywgYW5kIGFic3RyYWN0cyB0aGUgd29yayBvZiB0ZXN0ZXJzLiBJbiB0aGUgdGVzdGluZyBmcmFtZXdvcmssIHRoZSB3b3JrIG9mIHRlc3RlcnMgaXMgYXMgc2hvd24gaW4gRmlndXJlIDI6CgoxLiAqKlRlc3QgRGVzaWduKio6IFRlc3RlcnMgdXNlIHZhcmlvdXMgdGVzdCBkZXNpZ24gbWV0aG9kcyBzdWNoIGFzIGVxdWl2YWxlbmNlIGNsYXNzIHBhcnRpdGlvbmluZywgYm91bmRhcnkgdmFsdWUgYW5hbHlzaXMsIGFuZCBjYXVzZS1lZmZlY3QgZ3JhcGhpbmcgdG8gY3JlYXRlIGRlc2lnbiBwbGFucyBhbmQgdGVzdCBjYXNlcywgYW5kIHVwbG9hZCB0aGUgdGVzdCBjYXNlcyB0byB0aGUgdGVzdGluZyBmcmFtZXdvcmsuCjIuICoqUmVzdWx0IEFuYWx5c2lzKio6IEFuYWx5emUgdGhlIHRlc3QgcmVzdWx0cyBmZWVkYmFjayBmcm9tIGV4ZWN1dGluZyB0aGUgdGVzdCBjYXNlcyBpbiB0aGUgdGVzdGluZyBmcmFtZXdvcmsuCgpUbyByZWxpZXZlIHRlc3RlcnMgZnJvbSB0aGUgY29tcGxleGl0eSBvZiB2YXJpb3VzIHRlc3RpbmcgYWN0aXZpLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoK6K+35Li65LiA56+H5o6i6K6o5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit5bqU55So55qE5a2m5pyv6K665paH5pKw5YaZ5Lit5paH5pGY6KaB77yM6K665paH5YW25LuW6YOo5YiG5aaC5LiLOuS4gOOAgeW8leiogCDoh6oyMDA45bm05Lit5pys6IGq5Zyo5q+U54m55biB6K665Z2b5LiK5Y+R6KGo5ZCN5Li64oCcQml0Y29pbjpBIFBlZXItdG8tUGVlciBFbGVjdHJvbmljIENhc2ggU3lzdGVt4oCdWzFd55qE6K665paH5Lul5p2l77yM5Yy65Z2X6ZO+55qE5qaC5b+16ZqP552A5q+U54m55biB55qE54Gr54iG5Y+X5Yiw5LqG5ZCE5Zu95pS/5bqc5ZKM5a2m6ICF55qE6auY5bqm5YWz5rOo44CC5ZCE5Liq5Zu95a6255u457un5o6o5Ye65raJ5Y+K5Yy65Z2X6ZO+5oqA5pyv55qE57O75YiX5pS/562W5paH5Lu277yM5Yqg6YCf5Yy65Z2X6ZO+55qE5bqU55So6JC95Zyw77yM5L2/5YW25oiQ5Li65byV6aKG5paw5LiA5Luj5L+h5oGv5oqA5pyv55qE5Li76KeS44CC5oiR5Zu95pep5ZyoMjAxNuW5tOWwseWPkeihqOS6hummluS7veOAiuS4reWbveWMuuWdl+mTvuaKgOacr+WSjOW6lOeUqOWPkeWxleeZveearuS5puOAi+OAguOAiueZveearuS5puOAi+ivpue7huS7i+e7jeS6huWMuuWdl+mTvuWcqOWbveWGheWklueahOWPkeWxleeOsOeKtuOAgeW6lOeUqOWcuuaZr+S4juacquadpeWPkeWxleaWueWQkVsyXeOAguWQjOW5tO+8jOWbveWKoemZouWNsOWPkeeahOOAiuKAnOWNgeS4ieS6lOKAneWbveWutuS/oeaBr+WMluinhOWIkuOAi+S4reaYjuehruWwhuWMuuWdl+mTvuaKgOacr+WIl+S4uuaImOeVpeaAp+WJjeayv+aKgOacr1szXeOAgjIwMTnlubQxMOaciDI05pel77yM5Lmg6L+R5bmz5oC75Lmm6K6w5Zyo5Lit5aSu5pS/5rK75bGA56ys5Y2B5YWr5qyh6ZuG5L2T5a2m5Lmg5pe25by66LCD77yM4oCc5oqK5Yy65Z2X6ZO+5L2c5Li65qC45b+D5oqA5pyv6Ieq5Li75Yib5paw6YeN6KaB56qB56C05Y+j77yM5Yqg5b+r5o6o5Yqo5Yy65Z2X6ZO+5oqA5pyv5ZKM5Lqn5Lia5Yib5paw5Y+R5bGV4oCdWzRd77yM6L+b5LiA5q2l5Ye45pi+5LqG5Yy65Z2X6ZO+55qE6YeN6KaB5L2c55So44CCIOWMuuWdl+mTvuaKgOacr+e7meWQhOihjOWQhOS4muW4puadpeS6huaWsOeahOWPkeWxleacuumBh++8jOWFtuW6lOeUqOmAkOa4kOS7jumHkeiejemihuWfn+aJqeWxleWIsOWFtuS7lumihuWfn++8jOS+m+W6lOmTvuWwseaYr+WFtuS4reS5i+S4gOOAgumaj+edgOWMuuWdl+mTvuaKgOacr+eahOS4jeaWreWPkeWxle+8jOS8oOe7n+eahOS+m+W6lOmTvueuoeeQhuaooeW8j+S6n+mhu+WcqOiejeWFpeaWsOaKgOacr+eahOWfuuehgOS4iui/m+ihjOWFqOaWsOeahOWPmOmdqeOAguWboOatpO+8jOenkeWtpuWcsOais+eQhuW5tuaAu+e7k+KAnOWMuuWdl+mTvivkvpvlupTpk77igJ3poobln5/nmoTnoJTnqbbng63ngrnkuI7liY3msr/otovlir/vvIzlhbfmnInph43opoHnmoTnkIborrrlkozlrp7ot7XmhI/kuYnjgILmnKzmlofku6VDaXRlIFNwYWNl5paH54yu6K6h6YeP5YiG5p6Q5Li65oyH5byV77yM5a+55Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So56CU56m26L+b6KGM6L+w6K+E77yM6YCa6L+H5qKz55CG546w5pyJ5paH54yu77yM5Zyo5piO5pmw5Yy65Z2X6ZO+5oqA5pyv57uZ5L6b5bqU6ZO+5bim5p2l55qE5rex5Yi75Y+Y6Z2p5Y+K5bqU55So546w54q255qE5Z+656GA5LiK77yM5a+55pyq5p2l56CU56m25pa55ZCR6L+b6KGM5bGV5pyb44CCIOS6jOOAgeWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOeglOeptuaWh+eMruiuoemHj+WIhuaekCDkuLrlhajpnaLkuobop6PljLrlnZfpk77mioDmnK/lnKjkvpvlupTpk77kuK3nmoTlupTnlKjnoJTnqbbnjrDnirbvvIzlgJ/liqlDaXRlIFNwYWNl5Y+v6KeG5YyW5YiG5p6Q6L2v5Lu26L+b6KGM5paH54yu5YWx6KKr5byV5YiG5p6Q44CB5YWz6ZSu6K+N5YWx546w5YiG5p6Q44CB5YWz6ZSu6K+N6IGa57G75YiG5p6QWzVd44CC5Lul4oCcYmxvY2tjaGFpbuKAneWSjOKAnHN1cHBseSBjaGFpbuKAneS4uuajgOe0ouS4u+mimOivjeWcqFdlYiBvZiBTY2llbmNl5pWw5o2u5bqT5Lit6L+b6KGM5paH54yu5qOA57Si77yM6K+t56eN6K6+5a6a5Li66Iux6K+t77yM5paH54yu57G75Z6L6YCJ5oup4oCcQXJ0aWNsZeKAneaIluKAnFJldmlld+KAne+8jOajgOe0ouaXtumXtOS4ujIwMjDlubQxMuaciO+8jOaXtumXtOi3qOW6puiuvuS4ujIwMDjigJQyMDIw77yM5YWx5qOA57Si5Yiw6Iux5paH5paH54yuNDU156+H44CCIOmAmui/h+aWh+eMruWFseiiq+W8leWIhuaekO+8jOWPkeeOsOacieS4gOS6m+WvueWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOeglOeptuW9seWTjei+g+Wkp+eahOaWh+eMruOAguWmglN3YW5bNl3lnKgyMDE15bm05Ye654mI5LqG6JGX5L2cQmxvY2tjaGFpbjpCbHVlcHJpbnQgZm9yIGEgTmV3IEVjb25vbXnvvIzorqjorrrkuobmr5TnibnluIHlkozljLrlnZfpk77mioDmnK/nmoTkuInkuKrkuI3lkIzpmLbmrrU65Yy65Z2X6ZO+MS4w44CB5Yy65Z2X6ZO+Mi4w5ZKM5Yy65Z2X6ZO+My4w77yM5bm25o+Q5Ye65Yy65Z2X6ZO+My4w5Zyo6LSn5biB44CB6YeR6J6N44CB56eR5oqA44CB5Z+65Zug57uE5a2m44CB5YGl5bq344CB5a2m5Lmg44CB5a2m5pyv5Ye654mI44CB5byA5Y+R44CB5pWR5o+05ZKM5paH5YyW562J6aKG5Z+f55qE6K+45aSa5bqU55So5YmN5pmv77yM5Li65ZCO57ut56CU56m25aWg5a6a5LqG5Z+656GA44CCS3NoZXRyaVs3XeWcqDIwMTjlubTlj5HooajkuoborrrmlofigJxCbG9ja2NoYWluJ3MgUm9sZXMgaW4gTWVldGluZyBLZXkgU3VwcGx5IENoYWluIE1hbmFnZW1lbnQgT2JqZWN0aXZlc+KAne+8jOS7pemprOWjq+WfuuOAgemYv+mHjOW3tOW3tOOAgeayg+WwlOeOm+etiTEx5a625oiQ5Yqf6L+Q55So5Yy65Z2X6ZO+55qE5Luj6KGo5oCn5LyB5Lia5Li65L6L77yM56CU56m25LqG5Yy65Z2X6ZO+5a+55YWz6ZSu5L6b5bqU6ZO+566h55CG55uu5qCH77yM5aaC5oiQ5pys44CB6LSo6YeP44CB6YCf5bqm44CB5Y+v6Z2g5oCn44CB6aOO6Zmp6ZmN5L2O44CB5Y+v5oyB57ut5oCn5ZKM54G15rS75oCn55qE5b2x5ZON77yM5oyH5Ye65LqG5Yy65Z2X6ZO+5Zyo6aOf5ZOB5L6b5bqU6ZO+44CB5Zu96ZmF54mp5rWB44CB572R57uc5a6J5YWo562J6K+45aSa6aKG5Z+f55qE5bqU55So44CCU2FiZXJpIGV0IGFsLls4XeWcqDIwMTnlubTlj5HooajnmoTorrrmlofigJxCbG9ja2NoYWluIFRlY2hub2xvZ3kgYW5kIEl0cyBSZWxhdGlvbnNoaXBzIHRvIFN1c3RhaW5hYmxlIFN1cHBseSBDaGFpbiBNYW5hZ2VtZW504oCd57O757uf5LuL57uN5LqG5Yy65Z2X6ZO+5Zyo5L6b5bqU6ZO+566h55CG5Lit55qE5bqU55So77yM5bm25LuO57uP5rWO44CB56S+5Lya5ZKM546v5aKD5LiJ5Liq57u05bqm6ZiQ6YeK5LqG5Yy65Z2X6ZO+5Zyo5Y+v5oyB57ut5L6b5bqU6ZO+572R57uc5Lit55qE5LyY5Yq/O+WfuuS6juWvueaWh+eMrueahOWbnumhvu+8jOWwhuWMuuWdl+mTvuaKgOacr+W6lOeUqOmdouS4tOeahOmanOeijeWIhuS4uuWbm+S4quaWuemdojrnu4Tnu4fpl7TjgIHnu4Tnu4flhoXjgIHmioDmnK/lkozlpJbpg6jpmpznoo075pyA5ZCO5o+Q5Ye65LqG5pyq5p2l55qE56CU56m25pa55ZCR5Lul5pyJ5pWI6Kej5Yaz5Yy65Z2X6ZO+55qE5oqA5pyv6Zqc56KN77yM5L2/5Yy65Z2X6ZO+5pu05aW95Zyw5bqU55So5Yiw5L6b5bqU6ZO+566h55CG5Lit44CC6L+Z5Lqb5paH54yu5byV6aKG5LqG5Yy65Z2X6ZO+5Zyo5L6b5bqU6ZO+6aKG5Z+f55qE5bqU55So56CU56m277yM5bm25L2/55u45YWz56CU56m25b6X5Lul5LiN5pat5rex5YyW44CCIOWFs+mUruivjeWFseeOsOWIhuaekOaYvuekuijlpoLooagx5omA56S6Ke+8jOWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOS4u+mimOi+g+Wkmu+8jOS7juWMuuWdl+mTvuOAgeS+m+W6lOmTvuOAgeaZuuiDveWQiOe6puWIsOmjn+WTgeS+m+W6lOmTvuOAgeS+m+W6lOmTvue7qeaViOOAgeW9seWTjeOAgeaMkeaImOOAgeWPr+aMgee7reaAp+etieOAgui/m+S4gOatpemAmui/h+WFs+mUruivjeiBmuexu+WIhuaekCjlpoLooagy5omA56S6KeWPkeeOsO+8jOeglOeptueahOeDreeCueS4u+mimOS4u+imgea2ieWPiuWMuuWdl+mTvuaKgOacr+OAgeWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOmihuWfn+OAgeWvueS+m+W6lOmTvueahOW9seWTjeOAgeacquadpeaMkeaImOetieaWuemdouOAguWfuuS6juatpO+8jOS4i+mdouWwhuWbtOe7leS7peS4i+S6lOS4quaWuemdoumXrumimOWvueeOsOacieaWh+eMrui/m+ihjOi/sOivhDooMSnku4DkuYjmmK/ljLrlnZfpk77mioDmnK8/KDIp5Li65LuA5LmI6KaB5Zyo5L6b5bqU6ZO+5Lit6J6N5YWl5Yy65Z2X6ZO+5oqA5pyvPygzKeWMuuWdl+mTvuaKgOacr+S4u+imgeW6lOeUqOWcqOS+m+W6lOmTvueahOWTquS6m+mihuWfnz8oNCnov5nkupvlupTnlKjnu5nkvpvlupTpk77luKbmnaXku4DkuYjlvbHlk40/KDUp5pyq5p2l6Z2i5Li05ZOq5Lqb5oyR5oiYPyDooagxIOWFs+mUruivjeWFseeOsOWIhuaekCAg6KGoMiDlhbPplK7or43ogZrnsbvnu5PmnpwgIOS4ieOAgeWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOeglOeptuS4u+mimOeOsOeKtui/sOivhCAo5LiAKeWMuuWdl+mTvuaKgOacrzrmpoLlv7XjgIHkvZznlKjkuI7nsbvlnosg5Yy65Z2X6ZO+5pyA5Yid5L2c5Li65LiA56eN5pSv5oyB5Yqg5a+G6LSn5biB6aKG5Z+f5Lqk5piT55qE5oqA5pyv6ICM5Ye6546wWzFd44CCQ2hyaXN0aWRpcyBhbmQgRGV2ZXRzaW9raW90aXNbOV3lsIbljLrlnZfpk77lrprkuYnkuLrigJzlnKjnvZHnu5zmiJDlkZjkuYvpl7TlpI3liLblkozlhbHkuqvnmoTliIbluIPlvI/mlbDmja7nu5PmnoTigJ3jgIJBbC1TYXFhZiBhbmQgU2VpZGxlclsxMF3liJnlsIbljLrlnZfpk77lrprkuYnkuLrigJzliIbluIPlvI/mlbDlrZfliIbnsbvotKbmiJbkvJrorqHotKbnsL/igJ3jgILlnKjmraTln7rnoYDkuIrvvIxSaXNpdXMgYW5kIFNwb2hyZXJbMTFd5a+55Yy65Z2X6ZO+5oqA5pyv57uZ5Ye65LqG5LiA5Liq6L6D5q2j5byP55qE5a6a5LmJ77yM5Y2z4oCc5Yy65Z2X6ZO+5oqA5pyv5piv5oyH5LiA56eN55So5LqO5Lul5Yqg5a+G5pa55byP5o2V6I635ZKM5a2Y5YKo572R57uc5Y+C5LiO6ICF5LmL6Ze05LiA6Ie055qE44CB5LiN5Y+Y55qE44CB57q/5oCn55qE5LqL5Yqh5pel5b+X55qE5a6M5YWo5YiG5biD5byP57O757uf44CC5Zyo5Yqf6IO95LiK57G75Ly85LqO5YiG5biD5byP5YiG57G76LSm77yM55Sx572R57uc5YaF5omA5pyJ5Y+C5LiO5Lqk5piT55qE5ZCE5pa55LiA6Ie05L+d5a2Y44CB5pu05paw5ZKM6aqM6K+B44CC6K+l5oqA5pyv5Yqg5by65LqG572R57uc6YCP5piO5bqm77yM5bm256Gu5L+d5pyA57uI5Zyo57O757uf6IyD5Zu05YaF5bCx5pW05Liq5Lqk5piT5Y6G5Y+y55qE5pyJ5pWI5oCn6L6+5oiQ5YWx6K+G4oCd44CC5bC9566h57uZ5Ye65LqG6L+Z5Liq5q2j5byP5a6a5LmJ77yM5L2G5pi+54S25Yy65Z2X6ZO+6L+Y5pyJ5LiA5Lqb5YW25LuW54m55b6B77yM5aaC5Y675Lit5b+D44CB5Y675Lit5LuL44CB6Ziy56+h5pS5562J44CC5Zu95YaF5a2m6ICF546L5YWD5Zyw562JWzEyXee7vOi/sOS6huacieWFs+WMuuWdl+mTvuaKgOacr+eahOWGhea2te+8jOWwhuWFtuWIhuS4uuS6lOexuzrkuIDmmK/ln7rkuo7mlbDmja7nmoTop4bop5LlsIbljLrlnZfpk77lrprkuYnkuLrkuIDnp43mlbDmja7nu5PmnoTmiJbmlbDmja7lupM75LqM5piv5Z+65LqO6K6w6LSm55qE6KeG6KeS5bCG5Yy65Z2X6ZO+5a6a5LmJ5Li65LiA56eN5YiG5biD5byP6K6w6LSm55qE5bqV5bGC5oqA5pyvO+S4ieaYr+WfuuS6juWNj+iurueahOinhuinkuWwhuWMuuWdl+mTvuWumuS5ieS4uuS4gOenjeS6kuiBlOe9keWNj+iurjvlm5vmmK/ln7rkuo7mioDmnK/nmoTop4bop5LlsIbljLrlnZfpk77lrprkuYnkuLrkuIDnp43nlLHlpJrnp43mioDmnK/mnoTmiJDnmoTmlrDmioDmnK/mlrnmoYg75LqU5piv5Z+65LqO57uP5rWO55qE6KeG6KeS5bCG5Yy65Z2X6ZO+5a6a5LmJ5Li65LiA56eN5Lu35YC85LqS6IGU572R57uc44CC5LuO5L6b5bqU6ZO+6KeG6KeS5p2l55yL77yM5Yy65Z2X6ZO+5oqA5pyv5Y+v5Lul55CG6Kej5Li65LiO5Lqk5piT55qE5Y675Lit5LuL5YyW55u45YWz77yM5Y2z5peg6aG75Lit5LuL5py65p6E5p2l6aqM6K+B5Lqk5piT5bm25Li65Lqk5piT5o+Q5L6b5Y+v5L+h5bqm55qE5oqA5pyvWzEzXeOAgiDljLrlnZfpk77mioDmnK/kuLvopoHop6PlhrPkuqTmmJPnmoTkv6Hku7vlkozlronlhajpl67popjvvIzpkojlr7nov5nkuKrpl67popjvvIzkuLvopoHmnInlm5vpobnmoLjlv4PmioDmnK/vvIzljIXmi6zliIbluIPlvI/lrZjlgqjjgIHpnZ7lr7nnp7DliqDlr4bjgIHlhbHor4bmnLrliLbjgIHmmbrog73lkIjnuqZbMTQtMTdd44CC5Yy65Z2X6ZO+5oqA5pyv5YW35pyJ5Y675Lit5b+D5YyW44CB5Y675L+h5Lu744CB5YWs5byA6YCP5piO44CB5byA5pS+5oCn44CB6Ziy56+h5pS544CB5Y+v6L+95rqv5oCn44CB5a6J5YWo5Y+v6Z2g562J54m554K5WzE4LTE5XeOAguWMuuWdl+mTvuaKgOacr+eahOi/meS6m+eJueaAp+aEj+WRs+edgOWFtuWwhuWvueS+m+W6lOmTvueuoeeQhuivuOWmguaIkOWRmOWFs+ezu+OAgeWNj+S9nOOAgeS/oeS7u+WSjOWfuuS6juinkuiJsueahOS6keaVj+aNt+aAp+aTjeS9nOaooeWei+eahOWPmOWMluetieaWuemdouS6p+eUn+W9seWTjVsxM13jgILlroPog73mnInmlYjop6PlhrPnvZHnu5zkv6Hmga/kuI3lr7nnp7DvvIzlhbbmnIDkuLrmoLjlv4PnmoTku7flgLzlnKjkuo7lr7nnvZHnu5zkuK3nmoTmr4/kuIDkuKroioLngrnlhYXliIbotYvog73vvIzop6PlhrPkuqTmmJPnmoTkv6Hku7vmnLrliLblkozmv4DlirHmnLrliLbpl67pophbMjBd44CCIOagueaNruivu+WPluWMuuWdl+mTvuOAgeWQkeWMuuWdl+mTvuaPkOS6pOS6pOaYk+W5tuWPguS4juWFseivhua1geeoi+aOp+WItuetieaWuemdoueahOiuv+mXruadg+mZkO+8jOWPr+S7peWwhuWMuuWdl+mTvuWMuuWIhuS4uuS4ieenjeS4u+imgeexu+WeizrlhazmnInpk74ocHVibGljIGJsb2NrY2hhaW4p44CB56eB5pyJ6ZO+KHByaXZhdGUgYmxvY2tjaGFpbinlkozogZTnm5/pk74oY29uc29ydGl1bSBibG9ja2NoYWluKVsxOV3jgILlnKjlhazmnInpk77kuK3vvIzmr4/kuKrkuqTmmJPpg73mmK/lhazlvIDnmoTvvIznlKjmiLflj6/ku6Xkv53mjIHljL/lkI3jgILnvZHnu5zpgJrluLjmnInkuIDkuKrmv4DlirHmnLrliLbmnaXpvJPlirHlj4LkuI7ogIXliqDlhaXnvZHnu5zjgILmr5TnibnluIHlkozku6XlpKrlnYrlsLHmmK/lhazmnInpk77nmoTkvovlrZDjgILlnKjmnInmnYPpmZDorrjlj6/nmoTljLrlnZfpk77kuK3vvIzlj4LkuI7ogIXpnIDopoHojrflvpfliqDlhaXnmoTpgoDor7fmiJborrjlj6/vvIzorr/pl67mnYPpmZDnlLHmiJDlkZjogZTnm58o6IGU55uf6ZO+KeaIluWNleS4que7hOe7hyjnp4HmnInpk74p5o6n5Yi244CC5L6b5bqU6ZO+5bCx5piv5LiA56eN6IGU55uf6ZO+77yM5oiQ5ZGY6YCa6L+H5o6I5p2D5ZCO5omN6IO95Yqg5YWl5LiO6YCA5Ye6572R57uc44CC5Zyo6IGU55uf6ZO+5LiK77yM5L6b5bqU6ZO+5ZCE5Y+C5LiO5pa55YWx5Lqr5LiA5Liq6YCP5piO5Y+v6Z2g55qE5L+h5oGv5bmz5Y+w5ZKM6L+95rqv5rWB56iL77yM5ZCM5pe277yM5ZCE5Y+C5LiO5pa55Lmf5Y+v5Lul5Z+65LqO5Yy65Z2X6ZO+5pWw5o2u5byA5bGV5aaC5L6b5bqU6ZO+6YeR6J6N44CB57K+5YeG6JCl6ZSA562J5pyN5YqhWzIxXeOAgiAo5LqMKeS+m+W6lOmTvuW6lOeUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oCDlhbPkuo7kuLrku4DkuYjopoHlnKjkvpvlupTpk77kuK3lupTnlKjljLrlnZfpk77mioDmnK/vvIzlm73lpJblrabogIXov5DnlKjmioDmnK/mjqXlj5flkozph4fnlKjnkIborrrku6Xlj4rooYzkuLrnkIborrrvvIzku47nu6nmlYjpooTmnJ/jgIHnpL7kvJrlvbHlk43jgIHmnInliKnmnaHku7bjgIHlr7nmioDmnK/nmoTkv6Hku7vjgIHnu4Tnu4fpl7TnmoTkv6Hku7vnrYnmlrnpnaLliIbmnpDkuobkvpvlupTpk77ph4fnlKjljLrlnZfpk77mioDmnK/nmoTpqbHliqjlm6DntKBbMjJd77yM5bm25a+55q+U5YiG5p6Q5LqG5Y2w5bqm5ZKM576O5Zu95oOF5pmv5LiL55qE5beu5byCWzIzXeOAguS+m+W6lOmTvumHh+eUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oOWmguWbvjHmiYDnpLrjgIIg5Zu+MSDkvpvlupTpk77ph4fnlKjljLrlnZfpk77mioDmnK/nmoTpqbHliqjlm6DntKAgIOi1hOaWmeadpea6kDrnrJTogIXmoLnmja5GcmFuY2lzY28gYW5kIFN3YW5zb24gKDIwMTgpWzIyXeWPilF1ZWlyb3ogYW5kIFdhbWJhICgyMDE4KVsyM13nmoTnm7jlhbPmlofnjK7mlbTnkIbjgIIgIOmmluWFiO+8jOe7qeaViOmihOacn+aYr+S+m+W6lOmTvuW6lOeUqOWMuuWdl+mTvuaKgOacr+eahOacgOmHjeimgeeahOmpseWKqOWKm+OAguW3suacieeglOeptuihqOaYju+8jOS4quS9k+mHh+e6s+WSjOS9v+eUqOaKgOacr+eahOaEj+aEv+WcqOW+iOWkp+eoi+W6puS4iuWPluWGs+S6jue7qeaViOmihOacn1syNC0yNl3vvIzogIzljLrlnZfpk77mioDmnK/lupTnlKjlr7nkvpvlupTpk77ku47mlYjnjoflkozkuqflk4HotKjph4/liLDlhbPplK7mtYHnqIvnmoTmlLnov5vmlrnpnaLpg73kuqfnlJ/kuoblvojpq5jnmoTpooTmnJ9bN13jgILlhbbmrKHmmK/npL7kvJrlvbHlk43lm6DntKDjgILnpL7kvJrlvbHlk43mmK/mjIfkuKrkvZPlr7nlhbbku5bkurrorqTkuLrlupTor6Xkvb/nlKjmlrDmioDmnK/nmoTph43opoHnqIvluqbnmoTorqTnn6VbMjdd44CC5Yy65Z2X6ZO+5bqU55So5piv5LiA56eN4oCc56S+5Lya5oCn4oCd5oqA5pyv77yM5aaC5p6c6ZqP552A6KeE6IyD5oCn5Y6L5Yqb5ZKM55So5oi34oCc5Li055WM5pWw6YeP4oCd55qE5aKe5Yqg77yM6L+b6ICM5a6e546w572R57uc5pWI5bqU55qE5aKe5Yqg77yM6L+Z56eN5oOF5Ya15LiL5Y+v6IO95Lya5a+86Ie05pu06auY55qE5L2/55So5oSP5oS/WzIyXeOAguWboOatpOS+m+W6lOmTvuaIkOWRmOmXtOeOsOacieWFs+ezu+WvueaYr+WQpumHh+eUqOi3qOe9kee7nOeahOWMuuWdl+mTvuaKgOacr+S8muS6p+eUn+mHjeWkp+W9seWTjeOAguWGjeasoeaYr+S+v+WIqeadoeS7tuWboOe0oOOAguS+v+WIqeadoeS7tuaYr+aMh+KAnOS4quS9k+iupOS4uue7hOe7h+aKgOacr+WfuuehgOiuvuaWvei1luS7peaUr+aMgeezu+e7n+S9v+eUqOeahOeoi+W6puKAnVsyN13jgILlsLHljLrlnZfpk77ogIzoqIDvvIzlsLHmmK/mjIfkuKrkvZPlr7nnu4Tnu4fkuK3lj6/nlKjkuo7mlK/mjIHljLrlnZfpk77kvb/nlKjnmoTotYTmupDnmoTnkIbop6PjgILlt7LmnInnoJTnqbbooajmmI7vvIzljIXmi6zorqHnrpfmnLrjgIHnvZHpgJ/jgIHkuI7lhbbku5bns7vnu5/nmoTpm4bmiJDnrYnlnKjlhoXnmoTkvr/liKnmnaHku7bpg73kvJrlvbHlk43nm7jlhbPmioDmnK/nmoTph4fnurPlkozkvb/nlKhbMjgtMzBd44CC5pyA5ZCO5piv5L+h5Lu75Zug57Sg77yM5YyF5ous5a+55oqA5pyv55qE5L+h5Lu75Lul5Y+K5L6b5bqU6ZO+5Yip55uK55u45YWz6ICF5LmL6Ze055qE5L+h5Lu744CC5oqA5pyv5YWs5L+h5Yqb5Lya5b2x5ZON5Lq65Lus5a+55oqA5pyv55qE5oCB5bqm77yM6L+b6ICM5b2x5ZON5Lq65Lus5L2/55So5oqA5pyv55qE5oSP5oS/44CCVGhhdGNoZXIgZXQgYWwuWzMxXeaMh+WHuu+8jOe8uuS5j+WvuUlU55qE5L+h5Lu75Y+v6IO95a+86Ie055So5oi35Ye65LqO5a+55Y+v6Z2g5oCn5oiW5oCn6IO957y65LmP5L+h5b+D6ICM5YGc5q2i5L2/55So6K+l5oqA5pyv44CC5aaC5p6c55So5oi35oSP6K+G5Yiw5Yy65Z2X6ZO+5oqA5pyv5LiN5a6J5YWo77yM5LuW5Lus5bCG5LiN5Lya5L2/55So6K+l5oqA5pyv44CC5b2T54S277yM6ZqP552A55So5oi35a+55oqA5pyv55qE5LqG6Kej5ZKM5a2m5Lmg6LaK5aSa77yM5LuW5Lus5oul5pyJ55qE57uP6aqM5ZKM55+l6K+G5bCx6LaK5aSa77yM5oqA5pyv5Zyo5LuW5Lus55yL5p2l5bCx6LaK5Y+v5L+h44CC5Zug5q2k77yM5a+55oqA5pyv55qE5L+h5Lu75oiQ5Li65LqG6Kej55So5oi35L2/55So5oSP5oS/55qE5LiA5Liq6YeN6KaB5Zug57Sg44CC5L6b5bqU6ZO+5Yip55uK55u45YWz6ICF5LmL6Ze055qE5L+h5Lu75piv5oyH5L6b5bqU6ZO+572R57uc5Lit5Lik5Liq5oiW5Lik5Liq5Lul5LiK55qE5oiQ5ZGY5LmL6Ze055u45LqS5L6d6LWW5bm257u05oqk5b285q2k5pyf5pyb55qE5oSP5oS/WzIzXeOAguS+m+W6lOmTvuWIqeebiuebuOWFs+iAheS5i+mXtOeahOS/oeS7u+aYr+WwhuWMuuWdl+mTvuaKgOacr+W6lOeUqOS6juS+m+W6lOmTvue9kee7nOS4reeahOWfuuacrOWJjeaPkOOAgiDmraTlpJbvvIzov5jmnInlrabogIXku47kvpvlupTpk77nrqHnkIbnm67moIfop5LluqbliIbmnpDlupTnlKjljLrlnZfpk77mioDmnK/nmoTpqbHliqjlm6DntKDvvIzmr5TlpoLlhYvmnI3kvpvlupTpk77kuK3mlq3kuI7lpI3mnYLmgKdbMzItMzNd77yM56Gu5L+d5Lqn5ZOB55qE5a6J5YWo44CB55yf5a6e44CB5ZCI5rOVWzM0LTM1Xe+8jOS7peWPiuWFrOWFseWuieWFqOS4juWPjeiFkOi0pVszNi0zN13nrYnjgIIgKOS4iSnljLrlnZfpk77lnKjkvpvlupTpk77kuK3nmoTkuLvopoHlupTnlKjpoobln58g5Yy65Z2X6ZO+5oqA5pyv6LW35Yid5Li76KaB5bqU55So5LqO6YeR6J6N6KGM5Lia77yM5LmL5ZCO6YCQ5riQ5ouT5bGV5Yiw5Yac5Lia44CB6Zu25ZSu44CB5Yy755aX44CB5Yi26YCg5Lia5Lul5Y+K6IO95rqQ562J5aSa6KGM5Lia77yM5Zu95YaF5aSW56CU56m25pmu6YGN6K6k5Li654mp5rWB5ZKM5L6b5bqU6ZO+6aKG5Z+f5piv6L+Z6aG55oqA5pyv6IO95aSf5bim5p2l5b275bqV5Y+Y6Z2p55qE5Li76KaB6aKG5Z+f5LmL5LiAWzM4LTQyXeOAgiDpppblhYjvvIzigJzljLrlnZfpk74r5L6b5bqU6ZO+6YeR6J6N4oCd5piv5Zu95YaF5aSW56CU56m255qE54Ot6Zeo6aKG5Z+f44CC5Yy65Z2X6ZO+5oqA5pyv55qE6L+Q55So6IO96Kej5Yaz5Lyg57uf5L6b5bqU6ZO+6YeR6J6N5Lit5L6b5bqU5ZWG5L+h55So5L+h5oGv6K6w5b2V5LiN5YWo44CB5LqM57qn5Lul5LiK55qE5L6b5bqU5ZWG5LiO57uP6ZSA5ZWG6Zq+6I636LS35qy+44CB5Lit5bCP5b6u5LyB5Lia6Zq+6I635o6I5L+h44CB5o6I5L+h6aKd5bqm6Zq+5Lul56Gu6K6k44CB6J6N6LWE5ZCO5bGl57qm44CB5riF566X5rue5ZCO562J6Zeu6aKYWzIxXeOAguWMuuWdl+mTvuWcqOaPkOmrmOS+m+W6lOmTvumHkeiejeihjOS4mueahOmAj+aYjuW6puOAgeaJqeWkp+acjeWKoeWvueixoeOAgeaPkOmrmOaViOeOh+OAgemZjeS9jumjjumZqeOAgeWKoOW8uui1hOmHkea1geeuoeeQhuS4reWFt+acieaYjuaYvuS8mOWKv1s0M13jgILljLrlnZfpk77lnKjlm73lhoXkvpvlupTpk77ph5Hono3lupTnlKjmoYjkvovooajnjrDkuLrku6XmoLjlv4PkvIHkuJrkuLrkuLvlr7znmoTigJxDaGFpbmVkIEZpbmFuY2XigJ3ljLrlnZfpk77ph5Hono3lubPlj7DjgIHku6XmioDmnK/mj5DkvpvmlrnkuLrkuLvlr7znmoTohb7orq/igJzljLrlnZfpk74r5L6b5bqU6ZO+6YeR6J6N6Kej5Yaz5pa55qGI4oCd44CB5Lul6YeR6J6N5py65p6E5Li65Li75a+855qE5bmz5a6J6ZO26KGM5L6b5bqU6ZO+5bqU5pS26LSm5qy+5pyN5Yqh5bmz5Y+w562J5LiJ5Liq5Li76KaB57G75Z6LWzQ0XeOAguWcqOWbveWklu+8jOmHkeiejeenkeaKgOWFrOWPuE9HWURvY3PmnoTlu7rljLrlnZfpk77otLjmmJPph5Hono3lubPlj7BXYXZl77yM5Yip55So5YiG5biD5byP6LSm5pys5a+55paH5Lu25ZKM5ZWG5ZOB5Zyo6L+Q6L6T6L+H56iL5Lit55qE5omA5pyJ5p2D6L+b6KGM566h55CG77yM5pu/5Luj5Lyg57uf55qE5ZCE6aG557q46LSo5Y2V6K+B77yM5Lul5o+Q6auY5Zu96ZmF6LS45piT55qE5Lqk5piT5pWI546H5ZKM5a6J5YWo5oCn77yM5Y676Zmk57qg57q344CB5Lyq6YCg5ZOB5ZKM5LiN5b+F6KaB55qE6aOO6ZmpWzQ0XeOAgiDlhbbmrKHvvIznianmtYHkvpvlupTpk77poobln5/mmK/ljLrlnZfpk77mnIDmnInlupTnlKjliY3mma/nmoTpoobln5/kuYvkuIBbNDVd44CC5Yy65Z2X6ZO+5oqA5pyv55qE5YiG5biD5byP6K6w6LSm54m55oCn6IO95L2/5L6b5bqU6ZO+5LiK55qE5L+h5oGv5L+d5oyB5LiA6Ie077yM5ZCE6IqC54K55oiQ5ZGY5YWx5Lqr5YWs5byA55qE5L+h5oGv6LWE5rqQ77yM5pyJ5Yip5LqO6Kej5Yaz5L+h5oGv5LiN5a+556ew6Zeu6aKYO+aZuuiDveWQiOe6puacuuWItuWPr+WcqOaXoOmcgOesrOS4ieaWueS7i+WFpeeahOaDheWGteS4i+aMieinhOWImeiHquWKqOeUn+aIkOWQiOe6pu+8jOW5tuWcqOa7oei2s+S6pOaYk+adoeS7tuaXtuiHquWKqOaJp+ihjOWQiOe6puadoeasvu+8jOiDveaPkOmrmOWQhOeOr+iKguaUr+S7mOWSjOS6pOaYk+aViOeOh++8jOmBv+WFjei1hOmHkeW7tui/n+mjjumZqTvml7bpl7TmiLPlkozmuq/mupDpmLLkvKrmioDmnK/lj6/lr7nnianmtYHkvpvlupTpk77kuIrnmoTkuqflk4Hov5vooYzlhajpk77ot5/ouKrvvIzlrp7njrDlronlhajjgIHpq5jmlYjjgIHlj6/pnaDnmoTkv6Hmga/kvKDovpM76Z2e5a+556ew5Yqg5a+G5oqA5pyv5Y+v5Lul5L+d6K+B5pWw5o2u5LiN6KKr56+h5pS577yM5pyJ5Yqp5LqO5Lqk5piT5Li76aKY5LmL6Ze05L+h5Lu75YWz57O755qE5bu656uLWzQ2XeOAguWcqOWQhOWbveaUv+W6nOWSjOebuOWFs+S8geS4mueahOaUr+aMgeS4i++8jOS4gOS6m+KAnOWMuuWdl+mTvivnianmtYHkvpvlupTpk77igJ3pobnnm67lvpfku6Xlrp7ot7XvvIzlpoLkuLnpuqboiKrov5Dlhazlj7jpqazlo6vln7rkuI5JQk3nmoTlhajnkIPot6jlooPnianmtYHns7vnu59bNDdd44CB5paw5Yqg5Z2h5YWs5Y+4WW9qZWXnmoTov5DovpPkvJjljJbns7vnu59bNDhd44CB55Ge5aOr5YWs5Y+4TW9kdW3kuI7oi4/pu47kuJblpKflrablkIjkvZzorr7orqHnmoTljLvoja/ov5DovpPns7vnu59bN13jgIHoi7Hlm73lhazlj7hFdmVybGVkZ2Vy5Z+65LqO5Yy65Z2X6ZO+55qE5Lqn5ZOB5p2l5rqQ6aqM6K+B57O757ufWzQ5XeetieOAgui/meS6m+mhueebrueahOaIkOWKn+WunuaWveS4uuWMuuWdl+mTvuW6lOeUqOenr+e0r+S6huWunei0tee7j+mqjOOAgiDmnIDlkI7vvIzljLrlnZfpk77lnKjlhbbku5bpoobln5/kvpvlupTpk77kuIrnmoTlupTnlKjkvZPnjrDkuobljLrlnZfpk77mioDmnK/lupTnlKjnmoTlpJrmoLfmgKfvvIzlhbfkvZPooajnjrDkuLrlnKjlhpzkuqflk4HjgIHpo5/lk4HjgIHljLvoja/jgIHnlLXlipvjgIHlhpvkuovkvpvlupTpk77nrYnkvJflpJrpoobln5/nmoTlhbfkvZPov5DnlKjjgILljLrlnZfpk77lnKjlhpzkuqflk4FbNTBd5ZKM6aOf5ZOBWzUxXeS+m+W6lC4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CioqRGVzaWduIGFuZCBPcHRpbWl6YXRpb24gb2YgSW50ZWxsaWdlbnQgTWFudWZhY3R1cmluZyBTeXN0ZW1zIEJhc2VkIG9uIEFydGlmaWNpYWwgSW50ZWxsaWdlbmNlIFRlY2hub2xvZ3kqKiAgCgojIyMgMSBBbmFseXNpcyBvZiBBSSBBcHBsaWNhdGlvbnMgaW4gTWFudWZhY3R1cmluZyAgCgojIyMjIDEuMSBWaXN1YWwgSW5zcGVjdGlvbiBhbmQgRGVmZWN0IFJlY29nbml0aW9uICAKSW4gdGhlIGZpZWxkIG9mIG1hbnVmYWN0dXJpbmcsIHZpc3VhbCBpbnNwZWN0aW9uIGFuZCBkZWZlY3QgcmVjb2duaXRpb24gdGVjaG5vbG9naWVzIGhhdmUgYmVlbiBkZXZlbG9waW5nIHJhcGlkbHkuIFRoZXNlIHRlY2hub2xvZ2llcyBsZXZlcmFnZSBpbWFnZSBwcm9jZXNzaW5nIGFuZCBtYWNoaW5lIHZpc2lvbiBwcmluY2lwbGVzIHRvIGVmZmljaWVudGx5IGFuZCBhY2N1cmF0ZWx5IGlkZW50aWZ5IGRlZmVjdHMgb24gdGhlIHN1cmZhY2Ugb3IgaW5zaWRlIG9mIHByb2R1Y3RzIHdpdGhvdXQgaHVtYW4gaW50ZXJ2ZW50aW9uLCBlbnN1cmluZyBwcm9kdWN0IHF1YWxpdHkuIFdpdGggdGhlIGFwcGxpY2F0aW9uIG9mIGRlZXAgbGVhcm5pbmcgdGVjaG5vbG9neSwgdGhlIHJlY29nbml0aW9uIGNhcGFiaWxpdGllcyBvZiB2aXN1YWwgaW5zcGVjdGlvbiBzeXN0ZW1zIGhhdmUgZ3JlYXRseSBpbXByb3ZlZC4gVGhleSBjYW4gZGV0ZWN0IGV2ZW4gdGhlIHNtYWxsZXN0IGZsYXdzIGFuZCBvcGVyYXRlIHJlbGlhYmx5IGluIGNvbXBsZXggaW5kdXN0cmlhbCBlbnZpcm9ubWVudHMuICAKCkZvciBleGFtcGxlLCBpbiB0aGUgZWxlY3Ryb25pY3MgbWFudWZhY3R1cmluZyBpbmR1c3RyeSwgdmlzdWFsIGluc3BlY3Rpb24gc3lzdGVtcyBjYW4gaWRlbnRpZnkgdGlueSBjcmFja3MgYW5kIHNvbGRlcmluZyBpc3N1ZXMgb24gcHJpbnRlZCBjaXJjdWl0IGJvYXJkcywgZW5zdXJpbmcgdGhlIGZ1bmN0aW9uYWxpdHkgYW5kIHNhZmV0eSBvZiBlbGVjdHJvbmljIHByb2R1Y3RzLiBXaXRoIGluY3JlYXNlZCBjb21wdXRpbmcgcG93ZXIgYW5kIG9wdGltaXplZCBhbGdvcml0aG1zLCB2aXN1YWwgaW5zcGVjdGlvbiB0ZWNobm9sb2d5IGhhcyBhbHNvIG1hZGUgc2lnbmlmaWNhbnQgcHJvZ3Jlc3MgaW4gaW1wcm92aW5nIGRldGVjdGlvbiBzcGVlZCBhbmQgYWNjdXJhY3kuIEJ5IHByb2Nlc3NpbmcgbGFyZ2UgYW1vdW50cyBvZiBpbWFnZSBkYXRhIGluIHJlYWwgdGltZSwgdGhlc2Ugc3lzdGVtcyBjYW4gcXVpY2tseSBwcm92aWRlIGRldGVjdGlvbiByZXN1bHRzLCBncmVhdGx5IGVuaGFuY2luZyBwcm9kdWN0aW9uIGxpbmUgZWZmaWNpZW5jeS4gIAoKSW4gdGhlIGF1dG9tb3RpdmUgbWFudWZhY3R1cmluZyBpbmR1c3RyeSwgdmlzdWFsIGluc3BlY3Rpb24gdGVjaG5vbG9neSBpcyB3aWRlbHkgdXNlZCBmb3IgY2hlY2tpbmcgdGhlIHF1YWxpdHkgb2YgY2FyIGJvZHkgY29hdGluZ3MsIGFjY3VyYXRlbHkgaWRlbnRpZnlpbmcgaXNzdWVzIHN1Y2ggYXMgdW5ldmVuIGNvYXRpbmcgdGhpY2tuZXNzIGFuZCBjb2xvciBpbmNvbnNpc3RlbmNpZXMuICAKCiMjIyMgMS4yIFByZWRpY3RpdmUgTWFpbnRlbmFuY2UgYW5kIEZhdWx0IERpYWdub3NpcyAgClByZWRpY3RpdmUgbWFpbnRlbmFuY2UgYW5kIGZhdWx0IGRpYWdub3NpcyBwbGF5IGEgY3J1Y2lhbCByb2xlIGluIG1vZGVybiBtYW51ZmFjdHVyaW5nLiBCeSBsZXZlcmFnaW5nIGJpZyBkYXRhIGFuYWx5c2lzIGFuZCBtYWNoaW5lIGxlYXJuaW5nIGFsZ29yaXRobXMsIHRoZXNlIHRlY2hub2xvZ2llcyBjYW4gYWNjdXJhdGVseSBwcmVkaWN0IHBvdGVudGlhbCBlcXVpcG1lbnQgZmFpbHVyZXMsIGVuYWJsaW5nIHByb2FjdGl2ZSBtYWludGVuYW5jZSB0byBwcmV2ZW50IHByb2R1Y3Rpb24gZGlzcnVwdGlvbnMgYW5kIGVjb25vbWljIGxvc3Nlcy4gVGhpcyBhcHByb2FjaCBzaGlmdHMgZnJvbSB0cmFkaXRpb25hbCByZWFjdGl2ZSBtYWludGVuYW5jZSB0byBhIG1vcmUgcHJvYWN0aXZlIG1haW50ZW5hbmNlIHN0cmF0ZWd5LCBlZmZlY3RpdmVseSBleHRlbmRpbmcgZXF1aXBtZW50IGxpZmVzcGFuIGFuZCBpbXByb3ZpbmcgcHJvZHVjdGlvbiBlZmZpY2llbmN5LiAgCgpGb3IgZXhhbXBsZSwgaW4gaGVhdnkgaW5kdXN0cmllcywgcHJlZGljdGl2ZSBtYWludGVuYW5jZSBzeXN0ZW1zIGNhbiBtb25pdG9yIHBhcmFtZXRlcnMgc3VjaCBhcyBlcXVpcG1lbnQgdmlicmF0aW9uLCB0ZW1wZXJhdHVyZSwgYW5kIHNvdW5kIHRvIGRldGVjdCBhbm9tYWxpZXMgaW4gcmVhbCB0aW1lIGFuZCBpbnRlcnZlbmUgYmVmb3JlIHByb2JsZW1zIGVzY2FsYXRlLiBXaXRoIGNvbnRpbnVvdXMgYWR2YW5jZW1lbnRzIGluIHRlY2hub2xvZ3ksIGZhdWx0IGRpYWdub3NpcyBzeXN0ZW1zIGhhdmUgc2lnbmlmaWNhbnRseSBpbXByb3ZlZCBpbiBwcmVkaWN0aW9uIGFjY3VyYWN5IGFuZCByZXNwb25zZSBzcGVlZC4gVGhlc2Ugc3lzdGVtcyBhbmFseXplIGhpc3RvcmljYWwgYW5kIHJlYWwtdGltZSBkYXRhLCB1dGlsaXppbmcgY29tcGxleCBhbGdvcml0aG0gbW9kZWxzIHRvIHByZWRpY3QgZXF1aXBtZW50IGZhaWx1cmVzLiBUaGV5IGNhbiBldmVuIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHByb2R1Y3Rpb24gcGFyYW1ldGVycyBiYXNlZCBvbiBlcXVpcG1lbnQgc3RhdHVzIHRvIGVuc3VyZSB1bmludGVycnVwdGVkIHByb2R1Y3Rpb24uICAKCkluIHRoZSBhdXRvbW90aXZlIGluZHVzdHJ5LCBwcmVkaWN0aXZlIG1haW50ZW5hbmNlIGFuZCBmYXVsdCBkaWFnbm9zaXMgdGVjaG5vbG9naWVzIGFyZSB1c2VkIHRvIG1vbml0b3IgdGhlIHBlcmZvcm1hbmNlIG9mIGtleSBjb21wb25lbnRzIHN1Y2ggYXMgZW5naW5lcyBhbmQgdHJhbnNtaXNzaW9ucywgcHJldmVudGluZyBmYWlsdXJlcyBhbmQgZW5zdXJpbmcgZHJpdmluZyBzYWZldHkuICAKCiMjIyAyIERlc2lnbiBvZiBBSS1CYXNlZCBJbnRlbGxpZ2VudCBNYW51ZmFjdHVyaW5nIFN5c3RlbXMgIAoKIyMjIyAyLjEgU3lzdGVtIEFyY2hpdGVjdHVyZSBEZXNpZ24gIApTeXN0ZW0gYXJjaGl0ZWN0dXJlIGRlc2lnbiBpcyB0aGUgZm91bmRhdGlvbiBvZiBBSS1iYXNlZCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHN5c3RlbXMuIEl0IGludm9sdmVzIHBsYW5uaW5nIHRoZSBlbnRpcmUgcHJvZHVjdGlvbiBzeXN0ZW0sIGZyb20gZGF0YSBmbG93IHRvIGNvbnRyb2wgbG9naWMsIGVuc3VyaW5nIGVmZmljaWVudCBjb2xsYWJvcmF0aW9uIGJldHdlZW4gY29tcG9uZW50cyBhbmQgdGhlIHN5c3RlbSdzIGFkYXB0YWJpbGl0eSBhbmQgc2NhbGFiaWxpdHkuIFRoZSBoaWVyYXJjaGljYWwgZGVzaWduIGNvbmNlcHQgaW50ZWdyYXRlcyBhbmQgb3B0aW1pemVzIG1hbnVmYWN0dXJpbmcgcmVzb3VyY2VzIGVmZmVjdGl2ZWx5LiAgCgpGb3IgZXhhbXBsZSwgcGh5c2ljYWwgZGV2aWNlcyBhdCB0aGUgYm90dG9tIGxheWVyIGNvbW11bmljYXRlIGluIHJlYWwgdGltZSB3aXRoIHVwcGVyLWxheWVyIGRlY2lzaW9uLW1ha2luZyBtb2R1bGVzIHZpYSBzZW5zb3JzLiBUaGUgZGF0YSBwcm9jZXNzaW5nIGxheWVyIGFuYWx5emVzIHRoZSBjb2xsZWN0ZWQgaW5mb3JtYXRpb24sIHByb3ZpZGluZyBhIGJhc2lzIGZvciBpbnRlbGxpZ2VudCBkZWNpc2lvbi1tYWtpbmcuIEZpZ3VyZSAxIGlsbHVzdHJhdGVzIHRoZSBzeXN0ZW0gYXJjaGl0ZWN0dXJlIGRlc2lnbi4gVGhpcyBzdHJ1Y3R1cmVkIGFwcHJvYWNoIGVuaGFuY2VzIHN5c3RlbSBzdGFiaWxpdHkgYW5kIGVmZmljaWVuY3kgd2hpbGUgZmFjaWxpdGF0aW5nIG1haW50ZW5hbmNlIGFuZCB1cGdyYWRlcy4gIAoKKipGaWd1cmUgMTogU3lzdGVtIEFyY2hpdGVjdHVyZSBEZXNpZ24qKiAgCgpTeXN0ZW0gYXJjaGl0ZWN0dXJlIGRlc2lnbiBtdXN0IGFsc28gaW5jb3Jwb3JhdGUgQUkgdGVjaG5vbG9naWVzLCByZXF1aXJpbmcgZGVzaWduZXJzIHRvIGhhdmUgaW50ZXJkaXNjaXBsaW5hcnkga25vd2xlZGdlLCBpbmNsdWRpbmcgbWFudWZhY3R1cmluZyBwcm9jZXNzZXMsIGRhdGEgc2NpZW5jZSwgYW5kIG1hY2hpbmUgbGVhcm5pbmcuIEluIHByYWN0aWNlLCB0aGUgc3lzdGVtIGFyY2hpdGVjdHVyZSBzaG91bGQgc3VwcG9ydCBjb21wbGV4IGFsZ29yaXRobSBvcGVyYXRpb25zLCBzdWNoIGFzIG5ldXJhbCBuZXR3b3JrcyBhbmQgZGVlcCBsZWFybmluZyBtb2RlbHMsIGVuYWJsaW5nIHNlbGYtbGVhcm5pbmcgYW5kIHNlbGYtb3B0aW1pemF0aW9uIGR1cmluZyBwcm9kdWN0aW9uLiBUaGlzIGFsbG93cyBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHN5c3RlbXMgdG8gYWRhcHQgZmxleGlibHkgdG8gdmFyaW91cyBwcm9kdWN0aW9uIHRhc2tzIGFuZCBtYXJrZXQgY2hhbmdlcyB3aGlsZSBjb250aW51b3VzbHkgaW1wcm92aW5nIHRoZWlyIGludGVsbGlnZW5jZSBieSBsZWFybmluZyBmcm9tIHByb2R1Y3Rpb24gZGF0YS4gIAoKIyMjIyAyLjIgSHVtYW4tTWFjaGluZSBJbnRlcmZhY2UgKEhNSSkgRGVzaWduICAKVGhlIGh1bWFuLW1hY2hpbmUgaW50ZXJmYWNlIChITUkpIHNlcnZlcyBhcyBhIGJyaWRnZSBiZXR3ZWVuIGh1bWFuIG9wZXJhdGlvbiBhbmQgbWFjaGluZSBleGVjdXRpb24gaW4gaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBzeXN0ZW1zLiBJdHMgaW50dWl0aXZlbmVzcyBhbmQgZWFzZSBvZiB1c2UgZGlyZWN0bHkgYWZmZWN0IHN5c3RlbSBlZmZpY2llbmN5LiBBIHdlbGwtZGVzaWduZWQgSE1JIHNpbXBsaWZpZXMgY29tcGxleCBvcGVyYXRpb25zLCBlZmZlY3RpdmVseSB0cmFuc2xhdGluZyBodW1hbiBpbnRlbnRpb25zIGludG8gcHJlY2lzZSBtYWNoaW5lIHJlc3BvbnNlcy4gIAoKVXNlciBleHBlcmllbmNlIGlzIGEgdG9wIHByaW9yaXR5IGluIEhNSSBkZXNpZ24sIGVuc3VyaW5nIGludHVpdGl2ZSBvcGVyYXRpb24gYW5kIHJlZHVjaW5nIGVycm9ycyB0aHJvdWdoIHByb3BlciB1c2Ugb2YgZ3JhcGhpY3MsIGljb25zLCBhbmQgY29sb3JzLiBGb3IgZXhhbXBsZSwgaW50dWl0aXZlIGdyYXBoaWNhbCBpbnRlcmZhY2VzIG9uIHRvdWNoIHNjcmVlbnMgaGVscCBvcGVyYXRvcnMgcXVpY2tseSBpZGVudGlmeSBzeXN0ZW0gc3RhdHVzZXMgYW5kIHJlc3BvbmQgdG8gYWxlcnRzLCBpbXByb3ZpbmcgZWZmaWNpZW5jeSBhbmQgc2FmZXR5LiAgCgpXaXRoLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKSSBuZWVkIHRvIHdyaXRlIGEgcmVzZWFyY2ggcGFwZXIgb24gYW4gQUktYmFzZWQgbWVkaWNhbCBpbWFnaW5nLWFzc2lzdGVkIGRpYWdub3NpcyBzeXN0ZW0uIFBsZWFzZSBoZWxwIG1lIGRyYWZ0IGEgcGFwZXIgb3V0bGluZS4KdXNlcjoKUGxlYXNlIGhlbHAgbWUgZHJhZnQgYW4gb3V0bGluZSBmb3IgYSByZXZpZXcgcGFwZXIgb24gdGhlIGFwcGxpY2F0aW9uIG9mIGF1Z21lbnRlZCByZWFsaXR5IHRlY2hub2xvZ3kgaW4gaW5kdXN0cmlhbCBtYWludGVuYW5jZSwgdGFyZ2V0aW5nIGluZHVzdHJ5IHByb2Zlc3Npb25hbHMuCnVzZXI6CioqRGVzaWduIG9mIERpc3RyaWJ1dGVkIEhpZ2gtQ29uY3VycmVuY3kgU3lzdGVtIEFyY2hpdGVjdHVyZSBCYXNlZCBvbiBQb2xhckRCKioKCjAgSW50cm9kdWN0aW9uCgpUaGUgZGVtYW5kIGZvciBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMgaGFzIGJlZW4gZ3Jvd2luZyB3aXRoIHRoZSBjb250aW51b3VzIGRldmVsb3BtZW50IG9mIGludGVybmV0IGFwcGxpY2F0aW9ucy4gQW4gaW1wb3J0YW50IGNoYWxsZW5nZSBpbiB0aGlzIGNvbnRleHQgaXMgaG93IHRvIGRlc2lnbiBhIHBvd2VyZnVsLCByZWxpYWJsZSwgYW5kIHN0YWJsZSBzeXN0ZW0gZnJhbWV3b3JrLiBBcyBhIGhpZ2gtcGVyZm9ybWFuY2UgYW5kIHNjYWxhYmxlIGNsb3VkLW5hdGl2ZSBkaXN0cmlidXRlZCBkYXRhYmFzZSwgUG9sYXJEQiBwcm92aWRlcyBhIG5ldyBwb3NzaWJpbGl0eSBmb3IgYnVpbGRpbmcgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW1zLiBUaGlzIGFydGljbGUgYWltcyB0byBleHBsb3JlIHRoZSBkaXN0cmlidXRlZCBzeXN0ZW0gYXJjaGl0ZWN0dXJlIGRlc2lnbiBiYXNlZCBvbiBQb2xhckRCLCBmb2N1c2luZyBvbiBrZXkgaXNzdWVzIHN1Y2ggYXMgcGVyZm9ybWFuY2UsIGF2YWlsYWJpbGl0eSwgYW5kIGNvbnNpc3RlbmN5LiBJdCBkZWx2ZXMgaW50byB0aGUgUG9sYXJEQiBhcmNoaXRlY3R1cmUsIHN1bW1hcml6ZXMgcHJhY3RpY2FsIGV4cGVyaWVuY2UsIHByb3ZpZGVzIHRlY2huaWNhbCBzdXBwb3J0IGFuZCByZWZlcmVuY2UgZm9yIGFkZHJlc3NpbmcgdGhlIGluY3JlYXNpbmcgYnVzaW5lc3MgZGVtYW5kcywgYW5kIG9mZmVycyBuZXcgaWRlYXMgYW5kIG1ldGhvZHMgZm9yIGRpc3RyaWJ1dGVkIHN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduLgoKMSBJbnRyb2R1Y3Rpb24gdG8gUG9sYXJEQgoKMS4xIEFyY2hpdGVjdHVyZSBPdmVydmlldwoKVGhlIGRpc3RyaWJ1dGVkIHN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduIGJhc2VkIG9uIFBvbGFyREIgaXMgYW4gaW5ub3ZhdGl2ZSBzb2x1dGlvbiB0byBhZGRyZXNzIGxhcmdlLXNjYWxlIGRhdGEgc3RvcmFnZSBhbmQgaGlnaC1jb25jdXJyZW5jeSBhY2Nlc3MgY2hhbGxlbmdlcyBpbiBjbG91ZCBjb21wdXRpbmcgZW52aXJvbm1lbnRzLiBUaGUgY29yZSBmZWF0dXJlIG9mIHRoZSBQb2xhckRCIGFyY2hpdGVjdHVyZSBpcyB0aGUgc2VwYXJhdGlvbiBvZiBzdG9yYWdlIGFuZCBjb21wdXRhdGlvbiwgd2hlcmUgZGlzdHJpYnV0ZWQgZGF0YWJhc2UgY2x1c3RlcnMgYXJlIGJ1aWx0IHVzaW5nIGluZGVwZW5kZW50IGNvbXB1dGUgbm9kZXMgYW5kIHN0b3JhZ2Ugbm9kZXMsIHRodXMgYWNoaWV2aW5nIGhvcml6b250YWwgc2NhbGFiaWxpdHkgYW5kIGVsYXN0aWMgZXhwYW5zaW9uLiBJbiB0aGUgUG9sYXJEQiBhcmNoaXRlY3R1cmUsIHN0b3JhZ2Ugbm9kZXMgYXJlIHJlc3BvbnNpYmxlIGZvciBkYXRhIHBlcnNpc3RlbmNlIHN0b3JhZ2UgYW5kIG1hbmFnZW1lbnQsIHdoaWxlIGNvbXB1dGUgbm9kZXMgaGFuZGxlIFNRTCByZXF1ZXN0cyBhbmQgY29tcHV0YXRpb25hbCBsb2dpYy4gVGhpcyBkaXN0cmlidXRlZCBhcmNoaXRlY3R1cmUgbW9kZWwgYWxsb3dzIFBvbGFyREIgdG8gcHJvdmlkZSBoaWdoLXBlcmZvcm1hbmNlLCBoaWdoLWF2YWlsYWJpbGl0eSwgYW5kIGhpZ2hseSBzY2FsYWJsZSBkYXRhYmFzZSBzZXJ2aWNlcy4gUG9sYXJEQiBhbHNvIGFkb3B0cyBhIHNoYXJlZCBhcmNoaXRlY3R1cmUsIGVuYWJsaW5nIGRhdGEgc2hhcmluZyBhbmQgcmV1c2UgdGhyb3VnaCBhIHNoYXJlZCBzdG9yYWdlIGxheWVyLCB0aGVyZWJ5IHJlZHVjaW5nIHRoZSBzeXN0ZW0ncyBjb3N0IGFuZCBjb21wbGV4aXR5LiBJbiB0ZXJtcyBvZiBhcmNoaXRlY3R1cmFsIGRlc2lnbiwgUG9sYXJEQiBmdWxseSBjb25zaWRlcnMgc3lzdGVtIHNlY3VyaXR5IGFuZCByZWxpYWJpbGl0eSwgb2ZmZXJpbmcgZmVhdHVyZXMgc3VjaCBhcyBkYXRhIGVuY3J5cHRpb24sIGFjY2VzcyBjb250cm9sLCBhbmQgZmF1bHQgcmVjb3ZlcnkgdG8gcHJvdGVjdCB1c2VyIGRhdGEgc2VjdXJpdHkgYW5kIHByaXZhY3kuIFRoZSBQb2xhckRCIGFyY2hpdGVjdHVyZSBvdXRsaW5lcyBhbiBpbm5vdmF0aXZlIGRpc3RyaWJ1dGVkIGRhdGFiYXNlIG1vZGVsLCBwcm92aWRpbmcgbmV3IGlkZWFzIGFuZCBtZXRob2RzIGZvciBidWlsZGluZyBoaWdoLXBlcmZvcm1hbmNlLCBoaWdoLWF2YWlsYWJpbGl0eSBkaXN0cmlidXRlZCBzeXN0ZW1zLgoKMS4yIEZlYXR1cmVzIGFuZCBBZHZhbnRhZ2VzCgpQb2xhckRCIGhhcyBtYW55IG91dHN0YW5kaW5nIGZlYXR1cmVzIGFuZCBhZHZhbnRhZ2VzIHRoYXQgbWFrZSBpdCB0aGUgcHJlZmVycmVkIGRhdGFiYXNlIHNvbHV0aW9uIGZvciBlbnRlcnByaXNlcyBidWlsZGluZyBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMuIFBvbGFyREIgYWRvcHRzIGEgc2hhcmVkIGFyY2hpdGVjdHVyZSwgc2VwYXJhdGluZyBjb21wdXRhdGlvbiBhbmQgc3RvcmFnZSB0byBhY2hpZXZlIGVsYXN0aWMgc2NhbGluZyBhbmQgaGlnaCBwZXJmb3JtYW5jZSwgZWZmZWN0aXZlbHkgc29sdmluZyB0aGUgYm90dGxlbmVjayBpc3N1ZXMgb2YgdHJhZGl0aW9uYWwgZGF0YWJhc2VzLiBQb2xhckRCIHN1cHBvcnRzIG9ubGluZSBob3Jpem9udGFsIHNjYWxpbmcsIGVuYWJsaW5nIG5vZGVzIHRvIGJlIGR5bmFtaWNhbGx5IGFkZGVkIGJhc2VkIG9uIGJ1c2luZXNzIHJlcXVpcmVtZW50cyB3aXRob3V0IGRvd250aW1lIG9yIGRhdGEgbWlncmF0aW9uLCBlbnN1cmluZyBoaWdoIGF2YWlsYWJpbGl0eSBhbmQgc3RhYmlsaXR5LiBQb2xhckRCIGFsc28gZmVhdHVyZXMgaW50ZWxsaWdlbnQgb3B0aW1pemF0aW9uIGFuZCBhdXRvbWF0ZWQgbWFuYWdlbWVudCwgbWFraW5nIGFkYXB0aXZlIGFkanVzdG1lbnRzIGJhc2VkIG9uIHJlYWwtdGltZSBsb2FkIGFuZCBkYXRhIGFjY2VzcyBwYXR0ZXJucyB0byBpbXByb3ZlIHN5c3RlbSBlZmZpY2llbmN5IGFuZCByZXNvdXJjZSB1dGlsaXphdGlvbi4gUG9sYXJEQiBpcyBoaWdobHkgY29tcGF0aWJsZSwgZWFzeSB0byB1c2UsIHN1cHBvcnRzIHN0YW5kYXJkIFNRTCBzeW50YXggYW5kIHByb3RvY29scywgYW5kIGZhY2lsaXRhdGVzIHRoZSBtaWdyYXRpb24gYW5kIGludGVncmF0aW9uIG9mIGV4aXN0aW5nIGFwcGxpY2F0aW9ucywgcmVkdWNpbmcgc3lzdGVtIG1haW50ZW5hbmNlIGFuZCBkZXZlbG9wbWVudCBjb3N0cywgd2hpbGUgaW1wcm92aW5nIGRldmVsb3BtZW50IGVmZmljaWVuY3kgYW5kIHVzZXIgZXhwZXJpZW5jZS4gUG9sYXJEQiBpcyBhbiBpZGVhbCBjaG9pY2UgZm9yIGJ1aWxkaW5nIGRpc3RyaWJ1dGVkIGhpZ2gtY29uY3VycmVuY3kgc3lzdGVtcywgd2l0aCBpdHMgcGVyZm9ybWFuY2UsIHN0YWJpbGl0eSwgYW5kIGVhc2Ugb2YgdXNlIHN0YW5kaW5nIG91dC4KCjIgUmVxdWlyZW1lbnRzIGZvciBEaXN0cmlidXRlZCBIaWdoLUNvbmN1cnJlbmN5IFN5c3RlbSBEZXNpZ24KCjIuMSBQZXJmb3JtYW5jZSBSZXF1aXJlbWVudHMgQW5hbHlzaXMKCldoZW4gZGVzaWduaW5nIGEgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW0sIHBlcmZvcm1hbmNlIGlzIG9uZSBvZiB0aGUgbW9zdCBpbXBvcnRhbnQgY29uc2lkZXJhdGlvbnMuIFBlcmZvcm1hbmNlIHJlcXVpcmVtZW50cyBhbmFseXNpcyBpcyB0aGUga2V5IHByb2Nlc3MgZm9yIGRldGVybWluaW5nIHRoZSBwZXJmb3JtYW5jZSBtZXRyaWNzIGFuZCByZXF1aXJlbWVudHMgdGhhdCB0aGUgc3lzdGVtIG11c3QgbWVldCB3aGVuIHByb2Nlc3NpbmcgbGFyZ2Utc2NhbGUgY29uY3VycmVudCByZXF1ZXN0cy4gVG8gYWNjb21tb2RhdGUgdGhlIGdyb3dpbmcgbnVtYmVyIG9mIHVzZXJzLCB0aGUgc3lzdGVtJ3MgdGhyb3VnaHB1dCBtdXN0IGJlIGR5bmFtaWNhbGx5IHNjYWxhYmxlIHRvIG1lZXQgcGVhayBhY2Nlc3MgcHJlc3N1cmUuIEFub3RoZXIgY3JpdGljYWwgZmFjdG9yIGFmZmVjdGluZyBzeXN0ZW0gcGVyZm9ybWFuY2UgaXMgbGF0ZW5jeSwgd2hpY2ggcmVmZXJzIHRvIHRoZSByZXNwb25zZSB0aW1lIG9mIHRoZSBzeXN0ZW0gaW4gcHJvY2Vzc2luZyByZXF1ZXN0cy4gRm9yIGRpc3RyaWJ1dGVkIHN5c3RlbXMsIHRvIG1pbmltaXplIHRoZSBpbXBhY3Qgb2YgbmV0d29yayBsYXRlbmN5IGFuZCBkYXRhIHRyYW5zbWlzc2lvbiBsYXRlbmN5IG9uIHRoZSBzeXN0ZW0ncyByZXNwb25zZSB0aW1lLCBpdCBpcyBuZWNlc3NhcnkgdG8gYWRvcHQgYXBwcm9wcmlhdGUgbmV0d29yayBhcmNoaXRlY3R1cmVzIGFuZCBkYXRhIGRpc3RyaWJ1dGlvbiBzdHJhdGVnaWVzIHRvIG9wdGltaXplIHN5c3RlbSBwZXJmb3JtYW5jZS4gV2hlbiBkZXNpZ25pbmcgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW1zLCBwZXJmb3JtYW5jZSBtZXRyaWNzIGFuZCByZXF1aXJlbWVudHMgbXVzdCBiZSBjb21wcmVoZW5zaXZlbHkgY29uc2lkZXJlZC4gSW4gYWRkaXRpb24sIHRoZSBzeXN0ZW0ncyBjb25jdXJyZW5jeSBjYXBhYmlsaXR5IGFuZCBsb2FkIGJhbGFuY2luZyBtZWNoYW5pc21zIG11c3QgYmUgY29uc2lkZXJlZCB0byBlbnN1cmUgdGhhdCB0aGUgc3lzdGVtIGNhbiBlZmZlY3RpdmVseSBoYW5kbGUgbGFyZ2Ugdm9sdW1lcyBvZiBjb25jdXJyZW50IHJlcXVlc3RzIGFuZCBtYWludGFpbiBzdGFibGUgb3BlcmF0aW9uIGluIHRoZSBldmVudCBvZiBub2RlIGZhaWx1cmVzIG9yIG5ldHdvcmsgYWJub3JtYWxpdGllcy4gUGVyZm9ybWFuY2UgcmVxdWlyZW1lbnRzIGFuYWx5c2lzIGlzIGEgY3J1Y2lhbCBwYXJ0IG9mIGRlc2lnbmluZyBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMuIEl0IGlzIGVzc2VudGlhbCB0byBmdWxseSBjb25zaWRlciB2YXJpb3VzIHBlcmZvcm1hbmNlIHJlcXVpcmVtZW50cywgc3VjaCBhcyB0aHJvdWdocHV0IHNjYWxhYmlsaXR5LCBsYXRlbmN5IHN0YWJpbGl0eSwgY29uY3VycmVuY3kgY2FwYWJpbGl0eSwgYW5kIGxvYWQgYmFsYW5jaW5nLCB0byBlbnN1cmUgZXhjZWxsZW50IHN5c3RlbSBwZXJmb3JtYW5jZS4KCjIuMiBBdmFpbGFiaWxpdHkgUmVxdWlyZW1lbnRzIEFuYWx5c2lzCgpBbm90aGVyIGNyaXRpY2FsIGRlc2lnbiByZXF1Li4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKSSBhbSBhIHRyYWZmaWMgY29udHJvbCBzeXN0ZW0gZW5naW5lZXIgYW5kIHdvdWxkIGxpa2UgdG8gd3JpdGUgYSBwYXBlciBvbiB0aGUgdG9waWMgb2YgdXJiYW4gdHJhZmZpYyBzaWduYWwgb3B0aW1pemF0aW9uIGNvbnRyb2wgc3lzdGVtcy4gUGxlYXNlIGhlbHAgbWUgY29tcGxldGUgYW4gb3V0bGluZSBmb3IgdGhlIHBhcGVyLCByZXR1cm5pbmcgaXQgaW4gaGllcmFyY2hpY2FsIGZvcm0uIFRoZSBwYXBlciBzaG91bGQgYmUgYWltZWQgYXQgcHJvZmVzc2lvbmFsIHJlYWRlcnMgaW4gdGhlIGZpZWxkIG9mIHRyYWZmaWMgZW5naW5lZXJpbmcsIHdpdGggYSByaWdvcm91cyBhbmQgcHJvZmVzc2lvbmFsIHdyaXRpbmcgc3R5bGUgdGhhdCBlbXBoYXNpemVzIGVuZ2luZWVyaW5nIHByYWN0aWNlLiBUaGUgZm9sbG93aW5nIHBvaW50cyBuZWVkIHRvIGJlIGhpZ2hsaWdodGVkOiAxKSBJbnRlZ3JhdGluZyBhY3R1YWwgZGVwbG95bWVudCBwcm9qZWN0IGNhc2VzIGFuZCBkYXRhIHRoYXQgSSBhbSByZXNwb25zaWJsZSBmb3I7IDIpIEhpZ2hsaWdodGluZyB0ZWNobmljYWwgaW5ub3ZhdGlvbiwgZXNwZWNpYWxseSBpbXByb3ZlbWVudHMgaW4gYWxnb3JpdGhtIG9wdGltaXphdGlvbiBhbmQgcmVhbC10aW1lIGNvbnRyb2w7IDMpIFRoZSB3cml0aW5nIHN0eWxlIHNob3VsZCBtZWV0IHRoZSBzdWJtaXNzaW9uIHJlcXVpcmVtZW50cyBmb3IgY29yZSBqb3VybmFscy4gIApNeSBwcm9jZXNzIGRvY3VtZW50YXRpb24gYW5kIGZvcm1hdHRpbmcgcmVxdWlyZW1lbnRzIGZvciB0aGUgcGFwZXIgY2FuIGJlIHJlZmVyZW5jZWQgaW46ICoqMS4gRGV0YWlsZWQgVGVjaG5pY2FsIERvY3VtZW50YXRpb24gb2YgdGhlIEFjdHVhbCBEZXBsb3ltZW50IFByb2plY3QsIEluY2x1ZGluZyBTeXN0ZW0gQXJjaGl0ZWN0dXJlLCBBbGdvcml0aG0gRGVzaWduLCBhbmQgSW50ZXJmYWNlIFNwZWNpZmljYXRpb25zOioqICAKClRoZSBzeXN0ZW0gYWRvcHRzIGEgY29udHJvbCBzY2hlbWUgY2VudGVyZWQgYXJvdW5kIHRoZSBBVDg5QzUxIG1pY3JvY29udHJvbGxlci4gSXQgY2FsY3VsYXRlcyB0aGUgZ3JlZW4gYW5kIHJlZCBsaWdodCBkdXJhdGlvbnMgZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zIHVzaW5nIGFuIGFsZ29yaXRobSBhbmQgZGlzcGxheXMgdGhlIGNvdW50ZG93biBvbiBhIGRpZ2l0YWwgZGlzcGxheS4gQXQgdGhlIHNhbWUgdGltZSwgdGhlIHN5c3RlbSBjb250cm9scyB2ZWhpY2xlIHBhc3NhZ2UgYW5kIHN0b3BwaW5nIGJ5IHR1cm5pbmcgdGhlIHRyYWZmaWMgbGlnaHRzIGF0IHRoZSBpbnRlcnNlY3Rpb24gb24gYW5kIG9mZi4gQWRkaXRpb25hbGx5LCB0aGUgc2NoZW1lIGluY2x1ZGVzIGFuIGVtZXJnZW5jeSB2ZWhpY2xlIHBhc3NhZ2UgYnV0dG9uLiBXaGVuZXZlciBhbiBlbWVyZ2VuY3kgdmVoaWNsZSBuZWVkcyB0byBwYXNzLCB0aGUgb3BlcmF0b3IgcHJlc3NlcyB0aGUgYnV0dG9uLCB0dXJuaW5nIGFsbCB0cmFmZmljIGxpZ2h0cyBpbiBib3RoIGVhc3Qtd2VzdCBhbmQgbm9ydGgtc291dGggZGlyZWN0aW9ucyByZWQgd2hpbGUgc291bmRpbmcgYW4gYWxhcm0gdG8gcHJvaGliaXQgcmVndWxhciB2ZWhpY2xlcyBmcm9tIHBhc3NpbmcsIGFsbG93aW5nIHRoZSBlbWVyZ2VuY3kgdmVoaWNsZSB0byBnbyBmaXJzdC4gIAoKVGhlIGludGVyc2VjdGlvbiBjb25zaXN0cyBvZiB0d28gbWFpbiByb2FkcyBjcm9zc2luZyBlYWNoIG90aGVyLCB3aXRoIGVhY2ggcm9hZCBoYXZpbmcgYSBzZXQgb2YgcmVkLCB5ZWxsb3csIGFuZCBncmVlbiB0cmFmZmljIGxpZ2h0cywgYXMgd2VsbCBhcyBhIGxlZnQtdHVybiBpbmRpY2F0b3IuIFRoZXNlIGxpZ2h0cyBkaXJlY3QgdmVoaWNsZXMgZm9yIHNhZmUgcGFzc2FnZTogcmVkIG1lYW5zIHN0b3AsIGdyZWVuIG1lYW5zIGdvLCBhbmQgeWVsbG93IHNlcnZlcyBhcyBhIHdhcm5pbmcgaW5kaWNhdGluZyBhbiBpbW1pbmVudCBjaGFuZ2UgYmV0d2VlbiByZWQgYW5kIGdyZWVuLiBUaGUgZHVyYXRpb24gb2YgdGhlIHllbGxvdyBsaWdodCBpcyBzZXQgYXMgdGhlIHNoYXJlZCBzdG9wcGluZyB0aW1lIGZvciBib3RoIHRoZSBlYXN0LXdlc3QgYW5kIG5vcnRoLXNvdXRoIHJvYWRzLiBUaGUgbGVmdC10dXJuIGluZGljYXRvciBhbGxvd3MgdmVoaWNsZXMgb24gdGhlIG1haW4gcm9hZCB0byBtYWtlIGEgbGVmdCB0dXJuLiAgCgpUaGlzIHN5c3RlbSB1dGlsaXplcyB0aGUgQVQ4OUM1MSBtaWNyb2NvbnRyb2xsZXIgYXMgaXRzIGNvcmUgY29udHJvbCBjb21wb25lbnQuIEl0IGVtcGxveXMgdGltZXJzIHRvIGNvbnRyb2wgdGhlIG9uL29mZiBzdGF0ZXMgb2YgdGhlIHRyYWZmaWMgbGlnaHRzIGNvbm5lY3RlZCB0byB0aGUgUDAgcG9ydCB3aGlsZSBkaXNwbGF5aW5nIHRoZSBjb3VudGRvd24gb24gYW4gOC1zZWdtZW50IGRpZ2l0YWwgZGlzcGxheSBjb25uZWN0ZWQgdG8gdGhlIFAxIGFuZCBQMiBwb3J0cy4gVGhlIGNpcmN1aXQgZGlhZ3JhbSBtYWlubHkgY29uc2lzdHMgb2YgYSBwb3dlciBzdXBwbHkgY2lyY3VpdCwgYSB0cmFmZmljIGxpZ2h0IGRpc3BsYXkgY2lyY3VpdCwgYSB0cmFmZmljIGxpZ2h0IGNvdW50ZG93biB0aW1lciBjaXJjdWl0LCBhbmQgYW4gZW1lcmdlbmN5IGJ1dHRvbiAoSzEpIGNpcmN1aXQuICAKClRoZSBwb3dlciBzdXBwbHkgYWRvcHRzIGEgcmVndWxhdGVkIHBvd2VyIGNpcmN1aXQgdGhhdCBvdXRwdXRzIGEgc3RhYmxlICs1ViBEQyB2b2x0YWdlLiBUaGUgSUMgdXNlcyB0aGUgaW50ZWdyYXRlZCB2b2x0YWdlIHJlZ3VsYXRvciA3ODA1LCBhIHN0YW5kYXJkaXplZCwgd2lkZWx5IHVzZWQgbGluZWFyIHZvbHRhZ2UgcmVndWxhdG9yIHdpdGggYWR2YW50YWdlcyBzdWNoIGFzIHNtYWxsIHNpemUsIGxvdyBjb3N0LCBnb29kIHBlcmZvcm1hbmNlLCBoaWdoIHJlbGlhYmlsaXR5LCBhbmQgZWFzZSBvZiB1c2UuIEl0IGlzIG9uZSBvZiB0aGUgbW9zdCB3aWRlbHkgYXBwbGllZCBtb25vbGl0aGljIGludGVncmF0ZWQgcmVndWxhdG9ycyBpbiByZWd1bGF0ZWQgcG93ZXIgc3VwcGxpZXMuIFdoZW4gdGhlIG91dHB1dCBjdXJyZW50IGlzIHJlbGF0aXZlbHkgaGlnaCwgdGhlIDc4MDUgc2hvdWxkIGJlIGVxdWlwcGVkIHdpdGggYSBoZWF0IHNpbmsuIENhcGFjaXRvciBDMyBzZXJ2ZXMgYXMgdGhlIGlucHV0IGZpbHRlciBjYXBhY2l0b3IsIHdoaWxlIEM1IGFjdHMgYXMgdGhlIG91dHB1dCBmaWx0ZXIgY2FwYWNpdG9yLiAgCgpUaGUgc3lzdGVtIHVzZXMgYSAyMjBWIEFDIHBvd2VyIHNvdXJjZS4gQWZ0ZXIgcGFzc2luZyB0aHJvdWdoIGEgNVYgYWRhcHRlciBhbmQgZmlsdGVyaW5nLCBpdCBmb3JtcyBhIHJlbGF0aXZlbHkgdW5zdGFibGUgREMgdm9sdGFnZSBhdCB0aGUgVmluIGFuZCBHTkQgdGVybWluYWxzIG9mIHRoZSBmaXhlZCB0aHJlZS10ZXJtaW5hbCB2b2x0YWdlIHJlZ3VsYXRvciBMTTc4MDUuIFRoaXMgdm9sdGFnZSBvZnRlbiBmbHVjdHVhdGVzIGR1ZSB0byB2YXJpYXRpb25zIGluIHRoZSBtYWlucyB2b2x0YWdlIG9yIGxvYWQgY2hhbmdlcy4gQWZ0ZXIgTE03ODA1IHJlZ3VsYXRpb24gYW5kIGNhcGFjaXRvciBmaWx0ZXJpbmcsIHRoZSBvdXRwdXQgc2lkZSBvZiB0aGUgcmVndWxhdGVkIHBvd2VyIHN1cHBseSBnZW5lcmF0ZXMgYSBoaWdobHkgYWNjdXJhdGUgYW5kIHN0YWJsZSBEQyB2b2x0YWdlLiAgCgpUaGlzIGRlc2lnbiBhZG9wdHMgQyBsYW5ndWFnZSBhcyB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UuIENvbXBhcmVkIHRvIGFzc2VtYmx5IGxhbmd1YWdlLCBDIGdlbmVyYXRlcyBtYWNoaW5lIGNvZGUgd2l0aCBzaW1pbGFyIGVmZmljaWVuY3kgd2hpbGUgb2ZmZXJpbmcgbXVjaCBiZXR0ZXIgcmVhZGFiaWxpdHkgYW5kIHBvcnRhYmlsaXR5LiBBbHRob3VnaCBhc3NlbWJseSBsYW5ndWFnZSBhbGxvd3MgZm9yIGhpZ2hseSBlZmZpY2llbnQgbWFjaGluZSBjb2RlIGdlbmVyYXRpb24sIGl0IGlzIGRpZmZpY3VsdCB0byByZWFkLCBlc3BlY2lhbGx5IGZvciBjb21wbGV4IHByb2dyYW1zLiBDIGxhbmd1YWdlLCBpbiBtb3N0IGNhc2VzLCBtYXRjaGVzIGFzc2VtYmx5IGxhbmd1YWdlIGluIG1hY2hpbmUgY29kZSBlZmZpY2llbmN5IHdoaWxlIGdyZWF0bHkgc3VycGFzc2luZyBpdCBpbiByZWFkYWJpbGl0eSBhbmQgcG9ydGFiaWxpdHkuIEFkZGl0aW9uYWxseSwgQyBhbGxvd3MgZm9yIGVtYmVkZGVkIGFzc2VtYmx5IGNvZGUgdG8gaGFuZGxlIHJlYWwtdGltZSBjcml0aWNhbCB0YXNrcy4gIAoKRm9yIGRldmVsb3BtZW50IHRpbWUsIG1lZGl1bS10by1sYXJnZSBzb2Z0d2FyZSBwcm9qZWN0cyB3cml0dGVuIGluIEMgZ2VuZXJhbGx5IGhhdmUgYSBzaWduaWZpY2FudGx5IHNob3J0ZXIgZGV2ZWxvcG1lbnQgY3ljbGUgdGhhbiB0aG9zZSB3cml0dGVuIGluIGFzc2VtYmx5LiBDb25zaWRlcmluZyB0aGVzZSBhZHZhbnRhZ2VzLCB0aGlzIGRlc2lnbiB1c2VzIEMgYXMgdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlLiAgCgpUaGUgcHJvZ3JhbW1pbmcgZW52aXJvbm1lbnQgY2hvc2VuIGZvciB0aGlzIHByb2plY3QgaXMgS2VpbCDCtVZpc2lvbiAyLjAuIFRoaXMgc29mdHdhcmUgc3VwcG9ydHMgdmFyaW91cyBNQ1MtNTEgYXJjaGl0ZWN0dXJlIG1pY3JvY29udHJvbGxlcnMgZnJvbSBkaWZmZXJlbnQgbWFudWZhY3R1cmVycywgaW50ZWdyYXRpbmcgZWRpdGluZywgY29tcGlsaW5nLCBhbmQgc2ltdWxhdGlvbiBmdW5jdGlvbmFsaXRpZXMuIEl0IGFsc28gc3VwcG9ydHMgUExNLCBhc3NlbWJseSwgYW5kIEMgcHJvZ3JhbW1pbmcsIGZlYXR1cmluZyBhIHVzZXItZnJpZW5kbHkgaW50ZXJmYWNlIHRoYXQgaXMgZWFzeSB0byBsZWFybi4gS2VpbCDCtVZpc2lvbiBwcm92aWRlcyBhIGNvbnZlbmllbnQgZGVidWdnaW5nIGVudmlyb25tZW50IGluIHRoZSBlYXJseSBzdGFnZXMgb2Ygc29mdHdhcmUgdGVzdGluZyBhbmQgb2ZmZXJzIHN0cm9uZyBzaW11bGF0aW9uIGNhcGFiaWxpdGllcy4gIAoKQ3VycmVudGx5LCB0aGUgbW9zdCBjb21tb24gcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzIGZvciBNQ1MtNTEgbWljcm9jb250cm9sbGVycyBpbmNsdWRlIFBMTSwgYXNzZW1ibHksIGFuZCBDLiBBbW9uZyB0aGVtLCBhc3NlbWJseSBhbmQgQyBhcmUgdGhlIG1vc3Qgd2lkZWx5IHVzZWQuIEFzc2VtYmx5IGxhbmd1YS4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CuaIkeaDs+aSsOWGmeS4gOevh+acuuWZqOWtpuS5oOWcqOaZuuiDveWItumAoOi0qOmHj+aOp+WItuS4reeahOW6lOeUqOeglOeptuiuuuaWh++8jOWHhuWkh+aKleeov+OAiuaZuuiDveWItumAoOOAi+acn+WIiuOAguiuuuaWh+eqgeWHuuacuuWZqOWtpuS5oOeul+azleWcqOW3peS4muWcuuaZr+S4i+eahOaUuei/m+WIm+aWsOeCueWSjOWunumZheW3peeoi+W6lOeUqOaViOaenOOAguivt+aMieeFp+OAiuaZuuiDveWItumAoOOAi+acn+WIiuagvOW8j+imgeaxgu+8jOW4ruaIkeWGmeS4gOS4quiuuuaWh+Wkp+e6suOAguWPr+S7peWPguiAg+S7peS4i+iMg+aWh+e0oOadkOOAguWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItiAg6KKB6IqsICAg5Y2X5Lqs5py655S16IGM5Lia5oqA5pyv5a2m6Zmi6Ieq5Yqo5YyW5bel56iL57O7ICAg5pGY6KaB77ya5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi25piv5b2T5YmN5bel5Lia55Sf5Lqn5Lit5YWz5rOo55qE54Ot54K56aKG5Z+f44CC5pys5paH57O757uf5Zyw5o6i6K6o5LqG5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE5YWz6ZSu5oqA5pyv5ZKM5Li76KaB5rWB56iL77yM5o+Q5Ye65LqG5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE5bqU55So562W55Wl77yM5YyF5ous5Z+65LqO5pm66IO95Lyg5oSf5Zmo55qE5a6e5pe26LSo6YeP55uR5rWL44CB5Z+65LqO6aKE5rWL5YiG5p6Q55qE5pWF6Zqc5qOA5rWL5LiO6aKE6K2m44CB5Z+65LqO6L+c56iL55uR5o6n55qE5YiG5biD5byP6LSo6YeP5o6n5Yi277yM5Lul5Y+K5Z+65LqO55+l6K+G5Zu+6LCx55qE55+l6K+G5o6o55CG5LiO5Yaz562W77yM5Lul5L6b5Y+C6ICD44CCICDln7rph5HvvJogMjAyM+W5tOW6puaxn+iLj+mrmOagoeKAnOmdkuiTneW3peeoi+KAnei1hOWKqSA7IDIwMjPlubTluqbmsZ/oi4/pq5jmoKHlk7LlrabnpL7kvJrnp5HlrabnoJTnqbbpobnnm67noJTnqbbmiJDmnpzvvIgyMDIzU0pZQjA4MjbvvIkgOyDljZfkuqzmnLrnlLXogYzkuJrmioDmnK/lrabpmaLnp43lrZDln7rph5Hpobnnm67noJTnqbbmiJDmnpzvvIhMRDIwMjMwMe+8iSAgIOWFs+mUruivje+8muacuuaisOaZuuiDveWItumAoDvotKjph4/mjqfliLY75rex5bqm5a2m5LmgO+aVsOaNruWkhOeQhjvlrp7ml7bnm5HmtYsgIOS9nOiAheeugOS7i++8muiigeiKrO+8iDE5ODPigJTvvInvvIzlpbPvvIznoZXlo6vvvIzorrLluIjvvIzkuLvopoHnoJTnqbbmlrnlkJHnlLXmsJToh6rliqjljJYgIOaUtueov+aXpeacn++8mjIwMjMtMDctMjUgIERlZXAgbGVhcm5pbmctYmFzZWQgcXVhbGl0eSBjb250cm9sIGZvciBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIG9mIG1hY2hpbmVyeSAgWVVBTiBGZW4gIERlcGFydG1lbnQgb2YgQXV0b21hdGlvbiBFbmdpbmVlcmluZywgTmFuamluZyBJbnN0aXR1dGUgb2YgTWVjaGFuaWNhbCBhbmQgRWxlY3RyaWNhbCBUZWNobm9sb2d5ICBBYnN0cmFjdO+8mlF1YWxpdHkgY29udHJvbCBvZiBtZWNoYW5pY2FsIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgYmFzZWQgb24gZGVlcCBsZWFybmluZyBpcyBhIGhvdCBhcmVhIG9mIGNvbmNlcm4gaW4gY3VycmVudCBpbmR1c3RyaWFsIHByb2R1Y3Rpb24uIFRoaXMgcGFwZXIgc3lzdGVtYXRpY2FsbHkgZGlzY3Vzc2VzIHRoZSBrZXkgdGVjaG5vbG9naWVzIGFuZCBtYWluIHByb2Nlc3NlcyBvZiBkZWVwIGxlYXJuaW5nLWJhc2VkIG1lY2hhbmljYWwgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBxdWFsaXR5IGNvbnRyb2wsIGFuZCBwdXRzIGZvcndhcmQgdGhlIGFwcGxpY2F0aW9uIHN0cmF0ZWdpZXMgb2YgZGVlcCBsZWFybmluZy1iYXNlZCBtZWNoYW5pY2FsIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgcXVhbGl0eSBjb250cm9sLCBpbmNsdWRpbmcgcmVhbC10aW1lIHF1YWxpdHkgbW9uaXRvcmluZyBiYXNlZCBvbiBpbnRlbGxpZ2VudCBzZW5zb3JzLCBmYXVsdCBkZXRlY3Rpb24gYW5kIGVhcmx5IHdhcm5pbmcgYmFzZWQgb24gcHJlZGljdGl2ZSBhbmFseXRpY3MsIGRpc3RyaWJ1dGVkIHF1YWxpdHkgY29udHJvbCBiYXNlZCBvbiByZW1vdGUgbW9uaXRvcmluZyBhbmQgZGlzdHJpYnV0ZWQgcXVhbGl0eSBjb250cm9sLCBhcyB3ZWxsIGFzIGtub3dsZWRnZSByZWFzb25pbmcgYW5kIGRlY2lzaW9uLW1ha2luZyBiYXNlZCBvbiBrbm93bGVkZ2UgZ3JhcGgsIGZvciByZWZlcmVuY2UuIEtleSB3b3Jkc++8mk1lY2hhbmljYWwgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyA7IFF1YWxpdHkgY29udHJvbCA7IERlZXAgbGVhcm5pbmcgOyBEYXRhIHByb2Nlc3NpbmcgOyBSZWFsLXRpbWUgbW9uaXRvcmluZyBSZWNlaXZlZO+8mjIwMjMtMDctMjUgIDAg5byV6KiAIOmaj+edgOacuuaisOaZuuiDveWItumAoOaKgOacr+eahOS4jeaWreWPkeWxle+8jOWItumAoOihjOS4muWvueS6p+WTgei0qOmHj+eahOimgeaxguS5n+i2iuadpei2iumrmOOAguS8oOe7n+eahOi0qOmHj+aOp+WItuaWueazleWcqOmdouWvueWkp+inhOaooeaVsOaNruWSjOWkjeadgueUn+S6p+i/h+eoi+aXtumdouS4tOedgOaMkeaImO+8jOWboOatpOmcgOimgeW8leWFpeaWsOeahOaKgOacr+aJi+auteadpeino+WGs+i/meS6m+mXrumimOOAgua3seW6puWtpuS5oOS9nOS4uuS6uuW3peaZuuiDvemihuWfn+eahOmHjeimgeWIhuaUr++8jOWcqOWbvuWDj+OAgeivremfs+WSjOiHqueEtuivreiogOWkhOeQhuetiemihuWfn+WPluW+l+S6huaYvuiRl+eahOaIkOaenO+8jOW5tuS4lOWcqOi0qOmHj+aOp+WItumihuWfn+S5n+WFt+acieW5v+mYlOeahOW6lOeUqOWJjeaZr+OAguacrOaWh+aXqOWcqOmAmui/h+WfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueglOeptu+8jOaPkOS+m+S4gOenjeaWsOeahOino+WGs+aWueahiOadpeaUueWWhOS8oOe7n+eahOi0qOmHj+aOp+WItuaWueazleOAgiAxIOWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueahOWFs+mUruaKgOacryAxLjEg5rex5bqm5a2m5Lmg566X5rOV5Z+656GAIOa3seW6puWtpuS5oOaYr+S4gOenjeS7peS6uuW3peelnue7j+e9kee7nOS4uuWfuuehgOeahOacuuWZqOWtpuS5oOaWueazle+8jOWug+mAmui/h+WkmuWxguasoeeahOelnue7j+e9kee7nOe7k+aehOadpeWvueaVsOaNrui/m+ihjOWtpuS5oOWSjOihqOekuuOAgua3seW6puWtpuS5oOeul+azleWfuuehgOWMheaLrOS7peS4i+WHoOS4quWFs+mUruimgee0oOOAgiDpppblhYjvvIznpZ7nu4/nvZHnu5zmqKHlnovmmK/mt7HluqblrabkuaDnrpfms5XnmoTmoLjlv4PjgILlroPnlLHlpJrkuKrnpZ7nu4/lhYPnu4TmiJDnmoTlsYLmrKHnu5PmnoTvvIzmr4/kuKrnpZ7nu4/lhYPpg73ku6XliqDmnYPlkoznmoTmlrnlvI/mjqXmlLbovpPlhaXvvIznhLblkI7nu4/ov4fpnZ7nur/mgKfmv4DmtLvlh73mlbDov5vooYzovazmjaLvvIzovpPlh7rliLDkuIvkuIDlsYLjgILpgJrluLjvvIzmt7HluqblrabkuaDkuK3kvb/nlKjnmoTnpZ7nu4/nvZHnu5zmqKHlnovljIXmi6zljbfnp6/npZ7nu4/nvZHnu5zvvIhDTk7vvInjgIHlvqrnjq/npZ7nu4/nvZHnu5zvvIhSTk7vvInlkozlj5jmjaLlmajnvZHnu5zvvIhUcmFuc2Zvcm1lcu+8ieetieOAguWFtuasoe+8jOa3seW6puWtpuS5oOeul+azleeahOWtpuS5oOi/h+eoi+aYr+mAmui/h+WPjeWQkeS8oOaSreeul+azlei/m+ihjOeahOOAguWPjeWQkeS8oOaSreeul+azlemAmui/h+iuoeeul+i+k+WHuuS4juecn+WunuWAvOS5i+mXtOeahOivr+W3ru+8jOW5tuWwhuivr+W3ruS7jui+k+WHuuWxgumAkOWxguWQkeWJjeS8oOaSre+8jOabtOaWsOelnue7j+e9kee7nOS4reeahOadg+mHjeWSjOWBj+e9ru+8jOS7peacgOWwj+WMluivr+W3rlsxXeOAguatpOWklu+8jOa3seW6puWtpuS5oOeul+azlei/mOmcgOimgemAieaLqeWQiOmAgueahOaNn+WkseWHveaVsOadpeW6pumHj+i+k+WHuue7k+aenOWSjOecn+WunuWAvOS5i+mXtOeahOW3ruW8guOAguW4uOeUqOeahOaNn+WkseWHveaVsOWMheaLrOWdh+aWueivr+W3ru+8iE1TRe+8ieOAgeS6pOWPieeGteaNn+WkseWHveaVsOetieOAguacgOWQju+8jOa3seW6puWtpuS5oOeul+azlei/mOmcgOimgemAieaLqeWQiOmAgueahOS8mOWMlueul+azleadpeabtOaWsOelnue7j+e9kee7nOS4reeahOWPguaVsOOAguW4uOeUqOeahOS8mOWMlueul+azleWMheaLrOmaj+acuuair+W6puS4i+mZje+8iFNHRO+8ieOAgUFkYW3kvJjljJbnrpfms5XnrYnvvIzlroPku6zog73lpJ/mnInmlYjlnLDosIPmlbTlj4LmlbDvvIzmj5Dpq5jmqKHlnovnmoTmgKfog73jgIIgMS4yIOaVsOaNrumHh+mbhuS4jumihOWkhOeQhuaKgOacryDmlbDmja7ph4fpm4bkuI7pooTlpITnkIbmioDmnK/lnKjmt7HluqblrabkuaDkuK3mmK/pnZ7luLjph43opoHnmoTkuIDmraXvvIzlroPkuLvopoHljIXmi6zmlbDmja7mlLbpm4bjgIHmlbDmja7muIXmtJfjgIHmlbDmja7ovazmjaLlkozmlbDmja7lop7lvLrnrYnov4fnqIvjgIIg6aaW5YWI77yM5pWw5o2u5pS26ZuG5piv5oyH5LuO5Yi26YCg6L+H56iL5Lit6I635Y+W55u45YWz55qE6LSo6YeP5o6n5Yi25pWw5o2u44CC6L+Z5Lqb5pWw5o2u5Y+v5Lul5YyF5ous5Lyg5oSf5Zmo6YeH6ZuG55qE54mp55CG5L+h5Y+344CB5bel6Im65Y+C5pWw44CB6KeG6KeJ5Zu+5YOP562J44CC5pWw5o2u5pS26ZuG55qE6LSo6YeP5ZKM5pyJ5pWI5oCn55u05o6l5b2x5ZON5Yiw5ZCO57ut5qih5Z6L55qE6K6t57uD5ZKM5oCn6IO944CC5YW25qyh77yM5pWw5o2u5riF5rSX5piv5oyH5a+56YeH6ZuG5Yiw55qE5Y6f5aeL5pWw5o2u6L+b6KGM5Y675Zmq44CB57y65aSx5YC85aGr5YWF44CB5byC5bi45YC85aSE55CG562J5pON5L2c77yM5Lul5raI6Zmk5pWw5o2u5Lit55qE5Zmq5aOw5ZKM5bmy5omw77yM5L+d6K+B5pWw5o2u55qE5YeG56Gu5oCn5ZKM5a6M5pW05oCn44CC5pWw5o2u6L2s5o2i5piv5bCG5Y6f5aeL5pWw5o2u6L2s5o2i5Li65rex5bqm5a2m5Lmg566X5rOV6IO95aSf5aSE55CG55qE5b2i5byP44CC5L6L5aaC77yM5a+55LqO5Zu+5YOP5pWw5o2u77yM5Y+v5Lul6L+b6KGM5Zu+5YOP6aKE5aSE55CG5pON5L2c77yM5aaC6LCD5pW05aSn5bCP44CB6KOB5Ymq44CB5peL6L2s562J44CC5a+55LqO5pWw5YC85Z6L5pWw5o2u77yM5Y+v5Lul6L+b6KGM5b2S5LiA5YyW5oiW5qCH5YeG5YyW5aSE55CG77yM5bCG5pWw5o2u57yp5pS+5Yiw5LiA5a6a55qE6IyD5Zu05YaF44CC5pyA5ZCO77yM5pWw5o2u5aKe5by65piv6YCa6L+H5LiA57O75YiX55qE5pWw5o2u5omp5YWF5pa55rOV77yM55Sf5oiQ5pu05aSa55qE6K6t57uD5qC35pys44CC5L6L5aaC77yM5a+55LqO5Zu+5YOP5pWw5o2u77yM5Y+v5Lul6L+b6KGM6ZqP5py657+76L2s44CB5peL6L2s44CB57yp5pS+562J5pON5L2c77yM5aKe5Yqg5pWw5o2u55qE5aSa5qC35oCn5ZKM5pWw6YeP77yM5o+Q6auY5qih5Z6L55qE5rOb5YyW6IO95Yqb44CCIDEuMyDnibnlvoHmj5Dlj5bkuI7ooajnpLrlrabkuaAg54m55b6B5o+Q5Y+W5LiO6KGo56S65a2m5Lmg5piv5rex5bqm5a2m5Lmg5Lit55qE5YWz6ZSu546v6IqC77yM5a6D6IO95aSf5LuO5Y6f5aeL5pWw5o2u5Lit5o+Q5Y+W5Ye65YW35pyJ5Yy65YiG6IO95Yqb55qE54m55b6B77yM5bm25bCG5YW26KGo56S65Li65LiA5Liq5L2O57u055qE5ZCR6YeP44CCIOWcqOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItuS4re+8jOeJueW+geaPkOWPluWSjOihqOekuuWtpuS5oOWPr+S7peS7juWOn+Wni+eahOS8oOaEn+WZqOS/oeWPt+aIluWbvuWDj+aVsOaNruS4reaPkOWPluWHuuS7o+ihqOi0qOmHj+eJueW+geeahOWFs+mUruS/oeaBr++8jOeUqOS6juWIpOaWreS6p+WTgeeahOWQiOagvOaAp+OAgiDlr7nkuo7lm77lg4/mlbDmja7vvIzlj6/ku6Xkvb/nlKjljbfnp6/npZ7nu4/nvZHnu5zvvIhDTk7vvInov5vooYznibnlvoHmj5Dlj5bjgIJDTk7og73lpJ/pgJrov4fkuIDns7vliJfnmoTljbfnp6/jgIHmsaDljJblkozpnZ7nur/mgKfmv4DmtLvnrYnmk43kvZzvvIzku47lm77lg4/kuK3mj5Dlj5blh7rlhbfmnInlsYDpg6jlkozlhajlsYDkv6Hmga/nmoTnibnlvoHjgILov5nkupvnibnlvoHlj6/ku6XooajnpLrlm77lg4/nmoTnurnnkIbjgIHlvaLnirblkozovrnnvJjnrYnnibnlvoHvvIznlKjkuo7liKTmlq3kuqflk4HooajpnaLnmoTnvLrpmbfjgIHlvaLnirblgY/lt67nrYlbMl3jgIIg5a+55LqO5Lyg5oSf5Zmo5L+h5Y+35pWw5o2u77yM5Y+v5Lul5L2/55So5b6q546v56We57uP572R57uc77yIUk5O77yJ5oiW5Y+Y5o2i5Zmo572R57uc77yIVHJhbnNmb3JtZXLvvInov5vooYznibnlvoHmj5Dlj5bjgIJSTk7og73lpJ/lr7nml7bpl7Tluo/liJfmlbDmja7ov5vooYzlu7rmqKHvvIzlubbmjZXmjYnliLDlhbbkuK3nmoTml7bluo/kvp3otZblhbPns7vjgILogIxUcmFuc2Zvcm1lcuWImeiDveWkn+WvueS4jeWQjOS8oOaEn+WZqOS/oeWPt+S5i+mXtOeahOWFs+ezu+i/m+ihjOW7uuaooe+8jOaPkOWPluWHuuWFqOWxgOS4iueahOeJueW+geihqOekuuOAgiAxLjQg5qih5Z6L5LyY5YyW5LiO5qih5Z6L6K6t57uDIOaooeWei+S8mOWMluWSjOaooeWei+iuree7g+aYr+a3seW6puWtpuS5oOS4reiHs+WFs+mHjeimgeeahOS4gOatpe+8jOWug+a2ieWPiuWIsOmAieaLqeWQiOmAgueahOaooeWei+aetuaehOOAgeaNn+WkseWHveaVsOWSjOS8mOWMlueul+azle+8jOS7peWPiuWvueaooeWei+i/m+ihjOacieaViOeahOiuree7g+WSjOiwg+S8mOOAgiDpgInmi6nlkIjpgILnmoTmqKHlnovmnrbmnoTmmK/mqKHlnovkvJjljJbnmoTpppbopoHku7vliqHjgILlnKjmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbkuK3vvIzlj6/ku6XmoLnmja7lhbfkvZPku7vliqHnmoTnibnngrnpgInmi6npgILlkIjnmoTnpZ7nu4/nvZHnu5znu5PmnoTvvIzlpoJDTk7jgIFSTk7miJZUcmFuc2Zvcm1lcuetieOAguWQjOaXtu+8jOi/mOmcgOimgeiAg+iZkeaooeWei+eahOa3seW6puOAgeWuveW6puWSjOi/nuaOpeaWueW8j+etiei2heWPguaVsOeahOiuvue9ru+8jOS7peWFheWIhuWPkeaMpeaooeWei+eahOihqOi+vuiDveWKm+OAgiDmjZ/lpLHlh73mlbDnmoTpgInmi6nkuI7mqKHlnovnmoTorq3nu4Pnm67moIflr4bliIfnm7jlhbPjgILlnKjotKjph4/mjqfliLbkuK3vvIzluLjnlKjnmoTmjZ/lpLHlh73mlbDljIXmi6zlnYfmlrnor6/lt67vvIhNU0XvvInjgIHkuqTlj4nnhrXmjZ/lpLHlh73mlbDnrYnjgILlkIjnkIbpgInmi6nmjZ/lpLHlh73mlbDlj6/ku6XmnInmlYjlnLDlvJXlr7zmqKHlnovlrabkuaDnm67moIfnibnlvoHvvIzlubbmj5Dpq5jmqKHlnovnmoTpooTmtYvmgKfog73jgIIg5LyY5YyW566X5rOV55qE6YCJ5oup5ZKM5Y+C5pWw6LCD5LyY5a+55LqO5qih5Z6L55qE6K6t57uD5pWI5p6c6Iez5YWz6YeN6KaB44CC5bi455So55qE5LyY5YyW566X5rOV5YyF5ous6ZqP5py65qKv5bqm5LiL6ZmN77yIU0dE77yJ44CBQWRhbeS8mOWMlueul+azleetieOAgui/meS6m+S8mOWMlueul+azleiDveWkn+mAmui/h+iuoeeul+air+W6puW5tuabtOaWsOaooeWei+WPguaVsO+8jOS4jeaWreS8mOWMluaooeWei+eahOaAp+iDveOAguatpOWklu+8jOi/mOmcgOimgeWvueWtpuS5oOeOh+OAgeato+WImeWMluezu+aVsOWSjOaJuemHj+Wkp+Wwj+etiei2heWPguaVsOi/m+ihjOiwg+S8mO+8jOS7peiOt+W+l+abtOWlveeahOaooeWei+aAp+iDveOAgiAyIOWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueahOS4u+imgea1geeoiyAyLjEg5pWw5o2u5pS26ZuG5LiO6aKE5aSE55CGIOWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueahOesrOS4gOatpeaYr+aVsOaNruaUtumbhuS4jumihOWkhOeQhuOAguWcqOi/meS4gOmYtuaute+8jOmcgOimgeaUtumbhuW5tuaVtOeQhuS4jueUn+S6p+i/h+eoi+WSjOS6p+WTgei0qOmHj+ebuOWFs+eahOaVsOaNruOAgui/meS6m+aVsOaNruWPr+S7peWMheaLrOS8oOaEn+WZqOaVsOaNruOAgeW3peiJuuWPguaVsOOAgeS6p+WTgeajgOa1i+e7k+aenOetieOAgiDmlbDmja7mlLbpm4bnmoTov4fnqIvpnIDopoHogIPomZHmlbDmja7nmoTlh4bnoa7mgKflkozlrozmlbTmgKfjgILlkIjpgILnmoTkvKDmhJ/lmajlkozorr7lpIfooqvnlKjmnaXlrp7ml7bmlLbpm4bmlbDmja7vvIznoa7kv53mlbDmja7lhbfmnInpq5jotKjph4/lkozpq5jnsr7luqbjgILlkIzml7bvvIzkuZ/opoHnoa7kv53mlbDmja7mlLbpm4bnmoTpopHnjoflkozml7bpl7TngrnlhbfmnInku6PooajmgKfvvIzku6Xkvr/lhajpnaLkuobop6PnlJ/kuqfov4fnqIvjgIIg5Zyo5pWw5o2u6aKE5aSE55CG6Zi25q6177yM5a+55pS26ZuG5Yiw55qE5pWw5o2u6L+b6KGM5riF5rSX44CB562b6YCJ5ZKM5L+u5q2j77yM5Lul5Y676Zmk5byC5bi45YC85ZKM5Zmq5aOw77yM5bm26L+b6KGM5pWw5o2u6KeE6IyD5YyW5ZKM5qCH5YeG5YyW77yM5L+d6K+B5pWw5o2u55qE5LiA6Ie05oCn5ZKM5Y+v5q+U5oCn44CC5q2k5aSW77yM5Zyo5pyJ57y65aSx5YC855qE5oOF5Ya15LiL77yM5Y+v5Lul5L2/55So5o+S5YC8562J5pa55rOV6L+b6KGM5pWw5o2u55qE5aGr6KGl44CCIDIuMiDmnoTlu7rmt7HluqblrabkuaDmqKHlnosg5p6E5bu65rex5bqm5a2m5Lmg5qih5Z6L5piv5a6e546w5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE5qC45b+D5q2l6aqk44CC5Zyo6L+Z5LiA6Zi25q6177yM6ZyA6KaB6YCJ5oup6YCC5ZCI55qE5rex5bqm5a2m5Lmg566X5rOV5ZKM5p625p6E77yM5bm25qC55o2u6Zeu6aKY55qE54m554K56L+b6KGM5qih5Z6L55qE6K6+6K6h5ZKM5LyY5YyW44CCIOmmluWFiO+8jOagueaNrui0qOmHj+aOp+WItueahOebruagh+WSjOmcgOaxgu+8jOmAieaLqeWQiOmAgueahOa3seW6puWtpuS5oOeul+azle+8jOWmguWNt+enr+elnue7j+e9kee7nO+8iENOTu+8ieOAgeW+queOr+elnue7j+e9kee7nO+8iFJOTu+8ieOAgeeUn+aIkOWvueaKl+e9kee7nO+8iEdBTu+8ieetieOAguagueaNruaVsOaNrueahOeJueeCueWSjOmXrumimOeahOWkjeadguW6pu+8jOmAieaLqeWQiOmAgueahOe9kee7nOaetuaehOWSjOWxguaVsOOAguWFtuasoe+8jOi/m+ihjOaVsOaNrueahOWIkuWIhu+8jOWwhuaVsOaNrumbhuWIhuS4uuiuree7g+mbhuOAgemqjOivgembhuWSjOa1i+ivlembhuOAguiuree7g+mbhueUqOS6juaooeWei+eahOiuree7g+WPguaVsO+8jOmqjOivgembhueUqOS6juaooeWei+eahOiwg+S8mOWSjOmAieaLqeacgOS9s+aooeWei++8jOa1i+ivlembhueUqOS6juivhOS8sOaooeWei+eahOaAp+iDveWSjOazm+WMluiDveWKm+OAguacgOWQju+8jOi/m+ihjOaooeWei+eahOiuree7g+WSjOS8mOWMluOAguS9v+eUqOiuree7g+mbhuWvueaooeWei+i/m+ihjOWPjeWkjei/reS7o+WSjOS8mOWMlu+8jOmAmui/h+S8mOWMlueul+azleWSjOaNn+WkseWHveaVsO+8jOiwg+aVtOaooeWei+WPguaVsO+8jOaPkOmrmOaooeWei+eahOmihOa1i+WHhuehruaAp+WSjOazm+WMluiDveWKm1szXeOAguWcqOiuree7g+eahOi/h+eoi+S4re+8jOWPr+S7pemHh+eUqOaVsOaNruWinuW8uuaKgOacr+adpeaJqeWFheiuree7g+mbhu+8jOWinuWKoOaooeWei+eahOmygeajkuaAp+OAgiAyLjMg5a6e5pe255uR5rWL5LiO5Y+N6aaI5py65Yi2IOmAmui/h+WunuaXtuebkea1i+eUn+S6p+i/h+eoi+S4reeahOaVsOaNruWSjOi0qOmHj+aMh+agh++8jOWPiuaXtuWPkeeOsOW8guW4uOWSjOi0qOmHj+mXrumimO+8jOW5tumHh+WPluebuOW6lOeahOWPjemmiOaOquaWveOAgiDlnKjlrp7ml7bnm5HmtYvpmLbmrrXvvIzkvb/nlKjorq3nu4Plpb3nmoTmt7HluqblrabkuaDmqKHlnovlr7nlrp7ml7bmlbDmja7ov5vooYzpooTmtYvlkozliIbnsbvvvIzor4bliKvlh7rlvILluLjlkozkuI3oia/otovlir/jgILov5npnIDopoHlnKjns7vnu5/kuK3pm4bmiJDlkITpobnkvKDmhJ/lmajlkoznm5HmtYvorr7lpIfvvIzpgJrov4flrp7ml7bmlbDmja7nmoTph4fpm4blkozkvKDovpPvvIzlrp7njrDlr7nnlJ/kuqfov4fnqIvnmoTlrp7ml7bnm5HmtYvjgIIg5LiA5pem5qOA5rWL5Yiw5byC5bi45oiW6LSo6YeP6Zeu6aKY77yM5Y+K5pe26L+b6KGM5Y+N6aaI5ZKM5o6n5Yi244CC57O757uf5Y+v5Lul6YCa6L+H6Ieq5Yqo5YyW6K6+5aSH44CB5py65Zmo5Lq65oiW5bel5Lq655qE5bmy6aKE5p2l5a6e546w6LSo6YeP6Zeu6aKY55qE5L+u5q2j5ZKM5o6n5Yi244CC5Y+N6aaI5py65Yi26L+Y5Y+v5Lul5bCG6Zeu6aKY5L+h5oGv5Lyg6YCS57uZ55u45YWz5Lq65ZGY77yM5Lul5L6/6L+b6KGM6L+b5LiA5q2l55qE5YiG5p6Q5ZKM5Yaz562W77yM6YG/5YWN57G75Ly86Zeu6aKY55qE5YaN5qyh5Y+R55Sf44CCIDPln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTlupTnlKjnrZbnlaUgMy4xIOWfuuS6juaZuuiDveS8oOaEn+WZqOeahOWunuaXtui0qOmHj+ebkea1iyDln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLblnKjlrp7ml7botKjph4/nm5HmtYvmlrnpnaLph4fnlKjmmbrog73kvKDmhJ/lmajnmoTnrZbnlaXjgILmmbrog73kvKDmhJ/lmajpm4bmiJDkuoblhYjov5vnmoTkvKDmhJ/mioDmnK/lkozmt7HluqblrabkuaDnrpfms5XvvIzpgJrov4flrp7ml7bph4fpm4blkozliIbmnpDnlJ/kuqfov4fnqIvkuK3nmoTmlbDmja7vvIzlrp7njrDlr7nkuqflk4HotKjph4/nmoTnm5HmtYvlkozor4TkvLDjgIIg6aaW5YWI77yM5pm66IO95Lyg5oSf5Zmo5Y+v5Lul5a6e5pe26YeH6ZuG55Sf5Lqn6L+H56iL5Lit55qE5ZCE56eN5Y+C5pWw5pWw5o2u77yM5aaC5rip5bqm44CB5Y6L5Yqb44CB5oyv5Yqo562J44CC6L+Z5Lqb5pWw5o2u57uP6L+H5Lyg5oSf5Zmo5YaF6YOo55qE5rex5bqm5a2m5Lmg566X5rOV5aSE55CG77yM5Y+v5Lul55So5LqO5a6e5pe255uR5rWL5Lqn5ZOB55qE5ZCE6aG56LSo6YeP5oyH5qCH77yM5L6L5aaC5bC65a+457K+5bqm44CB6KGo6Z2i5YWJ5rSB5bqm562J44CCIOWFtuasoe+8jOWfuuS6jua3seW6puWtpuS5oOeahOaZuuiDveS8oOaEn+WZqOiDveWkn+WtpuS5oOW5tuWIhuaekOS4jeWQjOW3peWGteS4i+eahOaooeW8j+WSjOinhOW+i+OAgumAmui/h+WvueWkp+mHj+aVsOaNrueahOWtpuS5oO+8jOS8oOaEn+WZqOWPr+S7peWHhuehruWcsOWIpOaWreaYr+WQpuWtmOWcqOi0qOmHj+mXrumimO+8jOW5tuWPiuaXtue7meWHuumihOitpuWSjOaPkOmGku+8jOW4ruWKqeS8geS4muWPiuaXtumHh+WPluaOquaWveS7pemBv+WFjei0qOmHj+mXrumimOeahOWPkeeUn+OAgiDmraTlpJbvvIzmmbrog73kvKDmhJ/lmajov5jlj6/ku6XkuI7mnLrlmajkurrmiJblhbbku5boh6rliqjljJborr7lpIfov5vooYzogZTliqjvvIzlrp7njrDlrp7ml7botKjph4/nm5HmtYvkuI7mjqfliLbnmoTpl63njq/jgILkuIDml6blj5HnjrDotKjph4/lvILluLjvvIzmmbrog73kvKDmhJ/lmajlj6/ku6XpgJrov4fnvZHnu5zkuI7nlJ/kuqfnur/kuIrnmoTlhbbku5borr7lpIfpgJrkv6HvvIzlj4rml7bov5vooYzosIPmlbTlkozkv67mraPvvIznoa7kv53kuqflk4HotKjph4/nmoTnqLPlrprmgKflkozkuIDoh7TmgKfjgIIgMy4yIOWfuuS6jumihOa1i+WIhuaekOeahOaVhemanOajgOa1i+S4jumihOitpiDln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLblnKjmlYXpmpzmo4DmtYvkuI7pooTorabmlrnpnaLph4fnlKjpooTmtYvliIbmnpDnmoTnrZbnlaXjgILpgJrov4fliIbmnpDljoblj7LmlbDmja7lkozlrp7ml7bmlbDmja7vvIzns7vnu5/lj6/ku6XpooTmtYvorr7lpIfov5DooYzkuK3lj6/og73lj5HnlJ/nmoTmlYXpmpzvvIzlubbmj5DliY3ov5vooYzpooTorabvvIzku6Xpgb/lhY3nlJ/kuqfkuK3nmoTotKjph4/pl67popjjgIIg6aaW5YWI77yM5rex5bqm5a2m5Lmg5qih5Z6L5Y+v5Lul5a2m5Lmg6K6+5aSH6L+Q6KGM6L+H56iL5Lit55qE5ZCE56eN5qih5byP5ZKM6KeE5b6L44CC6YCa6L+H5a+55aSn6YeP5Y6G5Y+y5pWw5o2u55qE6K6t57uD77yM57O757uf5Y+v5Lul6K+G5Yir5Ye65LiN5ZCM5pWF6Zqc5qih5byP55qE54m55b6B77yM5bu656uL5pWF6Zqc6aKE5rWL5qih5Z6L44CC5b2T5a6e5pe25pWw5o2u5LiO6aKE5rWL5qih5Z6L5LiN56ym5pe277yM57O757uf5Y+v5Lul5Yik5pat5Y+v6IO95a2Y5Zyo5pWF6Zqc77yM5bm25Y+R5Ye66aKE6K2m5L+h5Y+344CCIOWFtuasoe+8jOmihOa1i+WIhuaekOWPr+S7peWfuuS6juWkmuenjeaVsOaNrua6kO+8jOWMheaLrOiuvuWkh+aVsOaNruOAgeeOr+Wig+aVsOaNruOAgeS+m+W6lOmTvuaVsOaNruetieOAgumAmui/h+e7vOWQiOWIhuaekOi/meS6m+aVsOaNru+8jOezu+e7n+WPr+S7peabtOWHhuehruWcsOmihOa1i+aVhemanOeahOWPkeeUn++8jOW5tuWPiuaXtumHh+WPluebuOW6lOeahOaOquaWve+8jOS+i+WmguWBnOacuue7tOS/ruOAgeabtOaNoumbtumDqOS7tuetie+8jOS7pemBv+WFjS4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6ClBsZWFzZSBoZWxwIG1lIHdyaXRlIGFuIG91dGxpbmUgZm9yIGEgcmVzZWFyY2ggcGFwZXIgb24gdGhlIGNvbnRyb2wgc3lzdGVtIG9mIHNvZnQgcm9ib3RzLiBUaGUgcGFwZXIgbWFpbmx5IGZvY3VzZXMgb24gdGhlIGlzc3VlIG9mIHByZWNpc2UgZW5kLWVmZmVjdG9yIGNvbnRyb2wgb2Ygc29mdCByb2JvdHMgYmFzZWQgb24gdmlzdWFsIGZlZWRiYWNrLCB1c2luZyBST1MgYW5kIEdhemVibyBwbGF0Zm9ybXMgZm9yIHNpbXVsYXRpb24gZXhwZXJpbWVudHMsIHZlcmlmeWluZyB0aGUgY29udHJvbCBhbGdvcml0aG0gb24gYSBwaHlzaWNhbCBwcm90b3R5cGUsIGFuZCBjb2xsZWN0aW5nIGV4cGVyaW1lbnRhbCBkYXRhIHVuZGVyIHRocmVlIGRpZmZlcmVudCBsb2FkIGNvbmRpdGlvbnMgKG5vIGxvYWQsIDEwMGcsIDIwMGcpLiBUaGUgcGFwZXIgbmVlZHMgdG8gY29tcGFyZSBhbmQgYW5hbHl6ZSB0aGUgcGVyZm9ybWFuY2UgZGlmZmVyZW5jZXMgYmV0d2VlbiBQSUQgY29udHJvbCBhbmQgYWRhcHRpdmUgY29udHJvbCBhcHByb2FjaGVzLgp1c2VyOgpJIGFtIGNvbmR1Y3RpbmcgcmVzZWFyY2ggb24gaW50ZWxsaWdlbnQgYnVpbGRpbmcgZW5lcmd5LXNhdmluZyBjb250cm9sLiBJIGhhdmUgYSBzZXQgb2Ygb3BlcmF0aW9uYWwgZGF0YSBmcm9tIGFuIG9mZmljZSBidWlsZGluZydzIGFpciBjb25kaXRpb25pbmcgc3lzdGVtIHNwYW5uaW5nIDYgbW9udGhzLCBpbmNsdWRpbmcgbWVhc3VyZWQgZGF0YSBzdWNoIGFzIGluZG9vciB0ZW1wZXJhdHVyZSwgaHVtaWRpdHksIENPMiBjb25jZW50cmF0aW9uLCBlbmVyZ3kgY29uc3VtcHRpb24sIGFuZCBvcHRpbWl6YXRpb24gcmVjb3JkcyBvZiB0aGUgYWlyIGNvbmRpdGlvbmluZyBzeXN0ZW0gY29udHJvbCBhbGdvcml0aG0gYmFzZWQgb24gZGVlcCByZWluZm9yY2VtZW50IGxlYXJuaW5nLiBJIGhvcGUgdG8gd3JpdGUgYSBwYXBlciBmb2xsb3dpbmcgdGhlIHN1Ym1pc3Npb24gZ3VpZGVsaW5lcyBvZiB0aGUgam91cm5hbCAqQnVpbGRpbmcgYW5kIEVudmlyb25tZW50Ki4gUGxlYXNlIHByb3ZpZGUgYSBkZXRhaWxlZCBvdXRsaW5lIGZvciB0aGUgcGFwZXIuCnVzZXI6ClBsZWFzZSBoZWxwIG1lIHdyaXRlIGFuIGFic3RyYWN0IGZvciBhIHBhcGVyIG9uIGNvbnRhaW5lciB0ZWNobm9sb2d5LiBUaGUgb3RoZXIgcGFydHMgb2YgdGhlIHBhcGVyIGFyZSBhcyBmb2xsb3dzOiAqKlJlc2VhcmNoIG9uIENsb3VkIFBsYXRmb3JtIE5ldHdvcmsgQXJjaGl0ZWN0dXJlIEJhc2VkIG9uIENvbnRhaW5lciBUZWNobm9sb2d5KioKCjAgSW50cm9kdWN0aW9uICAKSW4gY2xvdWQgY29tcHV0aW5nIGVudmlyb25tZW50cywgb3B0aW1pemluZyBuZXR3b3JrIGFyY2hpdGVjdHVyZSBpcyBjcnVjaWFsIGZvciBlbmhhbmNpbmcgdGhlIHBlcmZvcm1hbmNlIG9mIGNsb3VkIHNlcnZpY2VzWzFdLiBDb250YWluZXIgdGVjaG5vbG9neSwgd2l0aCBpdHMgbGlnaHR3ZWlnaHQgYW5kIGVmZmljaWVudCBjaGFyYWN0ZXJpc3RpY3MsIG9mZmVycyBuZXcgcGVyc3BlY3RpdmVzIGZvciB0aGUgbmV0d29yayBhcmNoaXRlY3R1cmUgb2YgY2xvdWQgcGxhdGZvcm1zWzItNF0uIFRoaXMgc3R1ZHkgZm9jdXNlcyBvbiB0aGUgYXBwbGljYXRpb24gb2YgY29udGFpbmVyIHRlY2hub2xvZ3kgaW4gY2xvdWQgcGxhdGZvcm0gbmV0d29yayBhcmNoaXRlY3R1cmUsIGFpbWluZyB0byBzb2x2ZSBpc3N1ZXMgc3VjaCBhcyBuZXR3b3JrIGlzb2xhdGlvbiwgc2NhbGFiaWxpdHksIGFuZCBzZWN1cml0eSBwcm9ibGVtcyBwcmVzZW50IGluIHRyYWRpdGlvbmFsIHZpcnR1YWxpemF0aW9uIGVudmlyb25tZW50cy4gVGhlIGRlc2lnbiBvZiBjb250YWluZXIgbmV0d29yayBhcmNoaXRlY3R1cmUgbXVzdCBtZWV0IHRoZSBkeW5hbWljIGFuZCBlbGFzdGljIHJlcXVpcmVtZW50cyBvZiBjbG91ZCBzZXJ2aWNlcyB3aGlsZSBlbnN1cmluZyB0aGUgZWZmaWNpZW5jeSBhbmQgc2VjdXJpdHkgb2YgbmV0d29yayBjb21tdW5pY2F0aW9uLiBUaGlzIHJlc2VhcmNoIGV4cGxvcmVzIHRoZSBrZXkgdGVjaG5vbG9naWVzIG9mIGNvbnRhaW5lciBuZXR3b3JrcywgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byBuZXR3b3JrIGlzb2xhdGlvbiBtZWNoYW5pc21zLCBsb2FkIGJhbGFuY2luZyBzdHJhdGVnaWVzLCBzZXJ2aWNlIGRpc2NvdmVyeSwgYW5kIHNlY3VyaXR5IGhhcmRlbmluZyBtZWFzdXJlcy4gIAoKMSBDb250YWluZXIgTmV0d29yayBBcmNoaXRlY3R1cmUgRGVzaWduICAKMS4xIERlc2lnbiBDb25jZXB0ICAKVGhlIGNvcmUgb2YgY29udGFpbmVyIG5ldHdvcmsgYXJjaGl0ZWN0dXJlIGRlc2lnbiBpcyB0byBhY2hpZXZlIGVmZmljaWVudCwgZmxleGlibGUsIGFuZCBzZWN1cmUgbmV0d29yayBjb21tdW5pY2F0aW9uLiBJbiBjbG91ZCBwbGF0Zm9ybXMsIGNvbnRhaW5lcnMsIGFzIGEgbGlnaHR3ZWlnaHQgdmlydHVhbGl6YXRpb24gdGVjaG5vbG9neSwgcmVxdWlyZSBhIG5ldHdvcmsgZGVzaWduIHRoYXQgc2F0aXNmaWVzIHRoZSBuZWVkcyBvZiByYXBpZCBkZXBsb3ltZW50IGFuZCBkeW5hbWljIHNjYWxhYmlsaXR5IGluIGEgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUuIFRoaXMgc2VjdGlvbiB3aWxsIGRlbHZlIGludG8gdGhlIGRlc2lnbiBjb25jZXB0IG9mIGNvbnRhaW5lciBuZXR3b3JrIGFyY2hpdGVjdHVyZSwgaW5jbHVkaW5nIG5ldHdvcmsgaXNvbGF0aW9uLCBzZXJ2aWNlIGRpc2NvdmVyeSwgbG9hZCBiYWxhbmNpbmcsIGFuZCBzZWN1cml0eSBzdHJhdGVnaWVzLiAgCk5ldHdvcmsgaXNvbGF0aW9uIGlzIGVzc2VudGlhbCBmb3IgZW5zdXJpbmcgc2VjdXJlIGNvbW11bmljYXRpb24gYmV0d2VlbiBjb250YWluZXJzLiBUdW5uZWwgdGVjaG5vbG9naWVzIHN1Y2ggYXMgVlhMQU4gb3IgU1RUIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBuZXR3b3JrIGlzb2xhdGlvbiBiZXR3ZWVuIGRpZmZlcmVudCB0ZW5hbnRzLiBNZWFud2hpbGUsIERvY2tlcuKAmXMgbmV0d29yayBwbHVnaW5zIChlLmcuLCBDYWxpY28gb3IgRmxhbm5lbCkgY2FuIHByb3ZpZGUgZWFjaCBjb250YWluZXIgd2l0aCBhbiBpbmRlcGVuZGVudCBuZXR3b3JrIHN0YWNrLiBTZXJ2aWNlIGRpc2NvdmVyeSBpcyBhbiBpbnRlZ3JhbCBwYXJ0IG9mIG1pY3Jvc2VydmljZXMgYXJjaGl0ZWN0dXJlLiAgCgoxLjIgTmV0d29yayBDb21wb25lbnRzIGFuZCBGdW5jdGlvbnMgIApUaGUgZGVzaWduIG9mIGNvbnRhaW5lciBuZXR3b3JrIGFyY2hpdGVjdHVyZSBmb2N1c2VzIG9uIGJ1aWxkaW5nIGFuIGVmZmljaWVudCwgc2NhbGFibGUsIGFuZCBzZWN1cmUgbmV0d29yayBlbnZpcm9ubWVudCB0byBzdXBwb3J0IGNvbnRhaW5lcml6ZWQgZGVwbG95bWVudCBvbiBjbG91ZCBwbGF0Zm9ybXMuIFRoZSBjb3JlIGNvbXBvbmVudHMgaW5jbHVkZSBuZXR3b3JrIGludGVyZmFjZSBjb250cm9sbGVycywgc2VydmljZSBkaXNjb3ZlcnkgbWVjaGFuaXNtcywgbG9hZCBiYWxhbmNlcnMsIGFuZCBzZWN1cml0eSBwb2xpY2llcy4gVGhlIG5ldHdvcmsgaW50ZXJmYWNlIGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIGFuZCBtYW5hZ2luZyBjb250YWluZXIgbmV0d29ya3MsIGludGVyYWN0aW5nIHdpdGggdGhlIGNvbnRhaW5lciBydW50aW1lIHZpYSB0aGUgQXBwbGljYXRpb24gUHJvZ3JhbW1pbmcgSW50ZXJmYWNlIChBUEkpIHRvIGVuYWJsZSBkeW5hbWljIG5ldHdvcmsgY29uZmlndXJhdGlvbi4gVGhlIHNlcnZpY2UgZGlzY292ZXJ5IG1lY2hhbmlzbSBhbGxvd3MgY29udGFpbmVycyB0byBjb21tdW5pY2F0ZSB2aWEgc2VydmljZSBuYW1lcyByYXRoZXIgdGhhbiBJUCBhZGRyZXNzZXMgYnkgcmVnaXN0ZXJpbmcgc2VydmljZSBpbnN0YW5jZXMgYW5kIGluc3RhbmNlIGluZm9ybWF0aW9uLCBlbmFibGluZyBkeW5hbWljIHNlcnZpY2UgcmVnaXN0cmF0aW9uIGFuZCBkaXNjb3ZlcnkuICAKTG9hZCBiYWxhbmNlcnMgYXJlIGRpc3RyaWJ1dGVkIGFjcm9zcyB0aGUgbmV0d29yayBhbmQgYWxsb2NhdGUgcmVxdWVzdHMgdG8gYXBwcm9wcmlhdGUgY29udGFpbmVyIGluc3RhbmNlcyBiYXNlZCBvbiByZWFsLXRpbWUgdHJhZmZpYyBhbmQgaGVhbHRoIGNoZWNrIHJlc3VsdHMsIGVuc3VyaW5nIGhpZ2ggYXZhaWxhYmlsaXR5IGFuZCByZXNwb25zaXZlbmVzcyBvZiBzZXJ2aWNlcy4gU2VjdXJpdHkgcG9saWNpZXMgcHJvdGVjdCBkYXRhIHRyYW5zbWlzc2lvbiBiZXR3ZWVuIGNvbnRhaW5lcnMgYnkgaW1wbGVtZW50aW5nIG5ldHdvcmsgaXNvbGF0aW9uLCBhY2Nlc3MgY29udHJvbCwgYW5kIGVuY3J5cHRlZCBjb21tdW5pY2F0aW9uLiBUYWJsZSAxIGxpc3RzIHRoZSBwZXJmb3JtYW5jZSBtZXRyaWNzIG9mIGRpZmZlcmVudCBsb2FkIGJhbGFuY2luZyBhbGdvcml0aG1zLCBkZW1vbnN0cmF0aW5nIHRoZSBwZXJmb3JtYW5jZSBvZiBSb3VuZCBSb2JpbiwgUmFuZG9tLCBhbmQgTGVhc3QgQ29ubmVjdGlvbnMgYWxnb3JpdGhtcyBpbiB2YXJpb3VzIHNjZW5hcmlvcy4gIAoKVGFibGUgMTogUGVyZm9ybWFuY2UgTWV0cmljcyBvZiBEaWZmZXJlbnQgTG9hZCBCYWxhbmNpbmcgQWxnb3JpdGhtcyAgCgp8IEFsZ29yaXRobSBUeXBlIHwgQXZlcmFnZSBSZXNwb25zZSBUaW1lIChtcykgfCBSZXNvdXJjZSBVdGlsaXphdGlvbiAoJSkgfCAgCnwtLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18ICAKfCBSb3VuZCBSb2JpbiAgICB8IDUwICAgICAgICAgICAgICAgICAgICAgICAgIHwgODAgICAgICAgICAgICAgICAgICAgICAgIHwgIAp8IFJhbmRvbSAgICAgICAgIHwgNzUgICAgICAgICAgICAgICAgICAgICAgICAgfCA3NSAgICAgICAgICAgICAgICAgICAgICAgfCAgCnwgTGVhc3QgQ29ubmVjdGlvbnMgfCA0NSAgICAgICAgICAgICAgICAgICAgIHwgODUgICAgICAgICAgICAgICAgICAgICAgIHwgIAoKMS4zIElzb2xhdGlvbiBhbmQgU2VjdXJpdHkgb2YgQ29udGFpbmVyIE5ldHdvcmtzICAKVGhlIGlzb2xhdGlvbiBhbmQgc2VjdXJpdHkgb2YgY29udGFpbmVyIG5ldHdvcmtzIGFyZSBjcnVjaWFsIGZvciBlbnN1cmluZyB0aGUgc3RhYmxlIG9wZXJhdGlvbiBvZiBjbG91ZCBwbGF0Zm9ybXMuIENvbnRhaW5lciB0ZWNobm9sb2d5IGFjaGlldmVzIG5ldHdvcmsgaXNvbGF0aW9uIHRocm91Z2ggbmFtZXNwYWNlcyBhbmQgbmV0d29yayBwb2xpY2llcywgcHJldmVudGluZyB1bm5lY2Vzc2FyeSBjb21tdW5pY2F0aW9uIGJldHdlZW4gY29udGFpbmVycywgdGhlcmVieSByZWR1Y2luZyBzZWN1cml0eSByaXNrcy4gTmV0d29yayBwb2xpY2llcyBjb250cm9sIGluY29taW5nIGFuZCBvdXRnb2luZyB0cmFmZmljIHRvIGNvbnRhaW5lcnMgdGhyb3VnaCBpcHRhYmxlcyBydWxlcyBvciB0aGlyZC1wYXJ0eSBzb2x1dGlvbnMgKHN1Y2ggYXMgQ2FsaWNvKSwgZW5hYmxpbmcgZmluZS1ncmFpbmVkIGFjY2VzcyBjb250cm9sLiAgCkFkZGl0aW9uYWxseSwgZW5jcnlwdGlvbiB0ZWNobm9sb2d5IGluIGNvbnRhaW5lciBuZXR3b3JrcyBlbnN1cmVzIHRoZSBzZWN1cml0eSBvZiBkYXRhIHRyYW5zbWlzc2lvbi4gVGhlIFRyYW5zcG9ydCBMYXllciBTZWN1cml0eSAoVExTKSBwcm90b2NvbCBpcyB3aWRlbHkgdXNlZCB0byBlc3RhYmxpc2ggc2VjdXJlIGNvbW11bmljYXRpb24gY2hhbm5lbHMgYmV0d2VlbiBjb250YWluZXJzLCBlbnN1cmluZyB0aGUgaW50ZWdyaXR5IGFuZCBwcml2YWN5IG9mIGRhdGEgZHVyaW5nIHRyYW5zbWlzc2lvbi4gIApUbyBxdWFudGlmeSB0aGUgZWZmZWN0IG9mIG5ldHdvcmsgaXNvbGF0aW9uLCB0aGlzIHBhcGVyIHVzZXMgYW4gaXNvbGF0aW9uIGVmZmljaWVuY3kgZm9ybXVsYSwgYXMgc2hvd24gaW4gZXF1YXRpb24gKDEpLiAgCvCdnII98J2RmfCdkL/DlzEwMCUg4oCDKDEpICAKd2hlcmUgzrcgaXMgdGhlIGlzb2xhdGlvbiBlZmZpY2llbmN5LCBsIGlzIHRoZSBpbGxlZ2FsIHRyYWZmaWMgc3VjY2Vzc2Z1bGx5IGJsb2NrZWQsIGFuZCBMIGlzIHRoZSB0b3RhbCBpbGxlZ2FsIHRyYWZmaWMuICAKCjIgQ2xvdWQgUGxhdGZvcm0gTmV0d29yayBBcmNoaXRlY3R1cmUgSW1wbGVtZW50YXRpb24gIAoyLjEgTmV0d29yayBDb21wb25lbnQgSW1wbGVtZW50YXRpb24gVGVjaG5vbG9naWVzICAKS2V5IHRlY2hub2xvZ2llcyBmb3IgaW1wbGVtZW50aW5nIGNsb3VkIHBsYXRmb3JtIG5ldHdvcmsgYXJjaGl0ZWN0dXJlIGluY2x1Li4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgcmV2aXNlIHRoZSBpbnRyb2R1Y3Rpb24gb2YgdGhpcyBwYXBlciBvbiBzbWFydCBjaXRpZXMgYW5kIGV4cGFuZCBpdCBhIGJpdCBtb3JlLCBzdWNoIGFzIGFkZGluZyB0aGUgcmVzZWFyY2ggYmFja2dyb3VuZCwgcmVzZWFyY2ggc2lnbmlmaWNhbmNlLCBldGMuIFRoZSBvcmlnaW5hbCBmdWxsIHRleHQgb2YgdGhlIHBhcGVyIGlzIGFzIGZvbGxvd3M6ICoqUmVzZWFyY2ggb24gdGhlIENvbnN0cnVjdGlvbiBQbGFuIG9mIE5ldyBTbWFydCBDaXRpZXMqKiAgCkFic3RyYWN0OiBUaGUgY29uc3RydWN0aW9uIG9mIHNtYXJ0IGNpdGllcyBub3Qgb25seSBjb25jZXJucyB0aGUgYWNjdXJhY3kgb2YgdXJiYW4gcGxhbm5pbmcgYW5kIGRlY2lzaW9uLW1ha2luZyBidXQgYWxzbyBkaXJlY3RseSBpbXBhY3RzIHJlc2lkZW50cycgaGFwcGluZXNzIGFuZCBzYXRpc2ZhY3Rpb24sIHNlcnZpbmcgYXMgYSBrZXkgaW5kaWNhdG9yIGZvciBtZWFzdXJpbmcgdGhlIHF1YWxpdHkgb2YgdXJiYW4gZGV2ZWxvcG1lbnQuIFRoaXMgcGFwZXIgYWltcyB0byBjb21iaW5lIHRoZSBpbm5vdmF0aXZlIHByYWN0aWNlcyBpbiBkYXRhIHNoYXJpbmcsIGdvdmVybm1lbnQgc2VydmljZXMsIHVyYmFuIG1hbmFnZW1lbnQsIGFuZCBvdGhlciBhcmVhcyBmcm9tIGFkdmFuY2VkIGNpdGllcyBzdWNoIGFzIFNoYW5naGFpIGFuZCBIYW5nemhvdSwgcHJvcG9zaW5nIGEgZnJhbWV3b3JrIGFuZCBjb25zdHJ1Y3Rpb24gaWRlYXMgZm9yIHNtYXJ0IGNpdHkgZGV2ZWxvcG1lbnQsIHdpdGggdGhlIGdvYWwgb2YgcHJvbW90aW5nIHNjaWVudGlmaWMgYW5kIHByZWNpc2Ugc29jaWFsIGdvdmVybmFuY2UgYW5kIGVuaGFuY2luZyB0aGUgaW50ZWxsaWdlbmNlIGFuZCBjb252ZW5pZW5jZSBvZiBnb3Zlcm5tZW50IHNlcnZpY2VzLiAgCktleXdvcmRzOiBzbWFydCBjaXR5OyB1cmJhbiBvcGVyYXRpb247IGRhdGEgc2hhcmluZzsgY29sbGFib3JhdGl2ZSBhcHBsaWNhdGlvbnMgIAoKVGhlIGNvbnN0cnVjdGlvbiBvZiBzbWFydCBjaXRpZXMgZW1waGFzaXplcyB0aGUgY3JpdGljYWwgcm9sZSBvZiBjb21tdW5pY2F0aW9uIHRlY2hub2xvZ3kgaW5mcmFzdHJ1Y3R1cmUgaW52ZXN0bWVudCBhbmQgdGhlIGFwcGxpY2F0aW9uIG9mIG5ldyB0ZWNobm9sb2dpZXMgaW4gdGhlIHVyYmFuIGRldmVsb3BtZW50IHByb2Nlc3MgWzFdLiBJbiByZWNlbnQgeWVhcnMsIHRoZSBuYXRpb25hbCBhbmQgbG9jYWwgZ292ZXJubWVudHMgaGF2ZSBpbnRyb2R1Y2VkIGEgc2VyaWVzIG9mIHBvbGljeSBkb2N1bWVudHMgYWltZWQgYXQgcHJvbW90aW5nIHN1c3RhaW5hYmxlIHVyYmFuIGRldmVsb3BtZW50IHRocm91Z2ggZGlnaXRhbCB0cmFuc2Zvcm1hdGlvbi4gQmFzZWQgb24gdGhlIHN1Y2Nlc3NmdWwgZXhwZXJpZW5jZXMgb2YgYWR2YW5jZWQgY2l0aWVzLCB0aGlzIHBhcGVyIGZvY3VzZXMgb24gdGhlIHRocmVlIGNvcmUgb3BlcmF0aW9ucyBvZiDigJx1bmlmaWVkIG1hbmFnZW1lbnQsIHVuaWZpZWQgc2VydmljZSwgYW5kIHVuaWZpZWQgY29sbGFib3JhdGlvbuKAnSBhbmQgcHJvcG9zZXMgY29ycmVzcG9uZGluZyBpbnN0aXR1dGlvbmFsIGFuZCBtZWNoYW5pc20gc3VwcG9ydCBtZWFzdXJlcy4gVGhlIGFpbSBpcyB0byBwcm92aWRlIGVmZmVjdGl2ZSBwYXRod2F5cyBmb3Igc29sdmluZyBjb21tb24gcHJvYmxlbXMgaW4gY3VycmVudCBzbWFydCBjaXR5IGNvbnN0cnVjdGlvbiwgc3VjaCBhcyBkYXRhIHNpbG9zLCBpbnRlci1kZXBhcnRtZW50YWwgY29sbGFib3JhdGlvbiBkaWZmaWN1bHRpZXMsIGFuZCBpbnN1ZmZpY2llbnQgZGVjaXNpb24tbWFraW5nIHN1cHBvcnQuIEl0IHNlZWtzIHRvIHByb21vdGUgdGhlIGludGVncmF0aW9uIG9mIGdvdmVybm1lbnQgcGxhdGZvcm1zLCB0aGUgcmVsZWFzZSBvZiBkYXRhIHJlc291cmNlIHZhbHVlLCBhZ2lsZSBjYXBhYmlsaXRpZXMsIGVmZmljaWVudCBjb29yZGluYXRpb24gaW4gZGlnaXRhbCBnb3Zlcm5hbmNlLCBhbmQgaW1wcm92ZWQgcXVhbGl0eSBhbmQgY29udHJvbGxhYmlsaXR5IGluIHNlY3VyaXR5IGFuZCBvcGVyYXRpb25hbCBtYW5hZ2VtZW50IFsyXS4gIAoKMS4gUHJvYmxlbXMgIApDaGluYeKAmXMgc21hcnQgY2l0eSBjb25zdHJ1Y3Rpb24gaGFzIGdvbmUgdGhyb3VnaCBzZXZlcmFsIHN0YWdlczogdGhlIGluZHVzdHJ5IGFwcGxpY2F0aW9uLWRyaXZlbiBkaWdpdGFsIGNpdHksIGVtZXJnaW5nIHRlY2hub2xvZ3ktZHJpdmVuIHNtYXJ0IGNpdHkgZGV2ZWxvcG1lbnQgWzNdLCBhbmQgdGhlIGRpZ2l0YWwgZ292ZXJubWVudCB0cmFuc2l0aW9uIGZyb20gZS1nb3Zlcm5tZW50IGFuZCBkaWdpdGFsIGdvdmVybmFuY2UgdG8gYSBuZXcgc3RhZ2Ugb2YgY29vcmRpbmF0ZWQgYW5kIGlubm92YXRpdmUgbWFuYWdlbWVudCBbNF0uIExvY2FsIGRpZ2l0YWwgY29uc3RydWN0aW9uIGlzIGluIGEgcmFwaWQgZGV2ZWxvcG1lbnQgcGhhc2UsIGJ1dCBkdWUgdG8gZGlmZmVyZW5jZXMgaW4gZWNvbm9taWMgZm91bmRhdGlvbiwgdGVjaG5vbG9naWNhbCBsZXZlbHMsIGFuZCByZXNvdXJjZSBlbmRvd21lbnQsIGNvbnN0cnVjdGlvbiBwcm9ncmVzcyBhbmQgcmVzdWx0cyB2YXJ5LiBEZXNwaXRlIHNvbWUgYWNoaWV2ZW1lbnRzLCBjb21tb24gcHJvYmxlbXMgc3RpbGwgcGVyc2lzdC4gIAoKVGhlIHBoZW5vbWVub24gb2YgZGF0YSBzaWxvcyBpcyBzZXZlcmUuIEFsdGhvdWdoIHZhcmlvdXMgcmVnaW9ucyBoYXZlIGJ1aWx0IGRhdGEtc2hhcmluZyBvcGVuIHBsYXRmb3JtcyBhbmQgcHJvdmlkZWQgc29tZSBnb3Zlcm5tZW50IGRhdGEgc2hhcmluZyB3aW5kb3dzLCB0aGUgd2lsbGluZ25lc3MgdG8gc2hhcmUgZGF0YSBpcyB3ZWFrIGluIG1hbnkgZGVwYXJ0bWVudHMgb3IgdGhleSBoYXZlIGEgc3Ryb25nIHNlbnNlIG9mIGRhdGEgb3duZXJzaGlwLiBUaGlzIGxlYWRzIHRvIGluc3VmZmljaWVudCBkYXRhIHNoYXJpbmcgaW4gdGVybXMgb2Ygdm9sdW1lLCByZWFsLXRpbWUgYXZhaWxhYmlsaXR5LCBhbmQgYWNjdXJhY3ksIGFuZCBmYWlscyB0byB0dXJuIHRoZSBidXNpbmVzcyBkYXRhIGFjY3VtdWxhdGVkIGJ5IGRlcGFydG1lbnRzIGludG8gY2l0eSBkYXRhIGFzc2V0cy4gT24gdGhlIG90aGVyIGhhbmQsIGR1ZSB0byB0aGUgbGFjayBvZiBkZWVwIGxlYXJuaW5nLCBrbm93bGVkZ2UgZ3JhcGhzLCBkZWNpc2lvbiBzdXBwb3J0LCBhbmQgb3RoZXIgZm91bmRhdGlvbmFsIGRhdGEgdmFsdWUtYWRkZWQgcHJvZHVjdHMsIHRoZSBhcHBsaWNhdGlvbiB2YWx1ZSBhbmQgcG90ZW50aWFsIGVuZXJneSBvZiBkYXRhIGhhdmUgbm90IGJlZW4gZnVsbHkgcmVsZWFzZWQsIGxpbWl0aW5nIGl0cyByb2xlIGluIGltcHJvdmluZyB1cmJhbiBnb3Zlcm5hbmNlIGVmZmVjdGl2ZW5lc3MsIG9wdGltaXppbmcgcHVibGljIHNlcnZpY2VzLCBhbmQgcHJvbW90aW5nIGVjb25vbWljIGFuZCBzb2NpYWwgZGV2ZWxvcG1lbnQuICAKCkNyb3NzLWRlcGFydG1lbnRhbCBjb2xsYWJvcmF0aW9uIGlzIGRpZmZpY3VsdC4gVGhlcmUgaXMgYW4gb3ZlcmFsbCB0ZW5kZW5jeSB0byBmb2N1cyBvbiBidXNpbmVzcyByYXRoZXIgdGhhbiBjb2xsYWJvcmF0aW9uLCBhbmQgYSBsYWNrIG9mIGV2ZW50LWNlbnRlcmVkLCBzZXJ2aWNlLW9yaWVudGVkIHVyYmFuIG9wZXJhdGlvbmFsIGNvb3JkaW5hdGlvbiBtZWNoYW5pc21zLiBUaGlzIHJlc3VsdHMgaW4gZGVwYXJ0bWVudHMgc3RpY2tpbmcgdG8gdGhlaXIgb3duIHdvcmsgYW5kIGZhaWxpbmcgdG8gY3JlYXRlIGFuIGVmZmVjdGl2ZSB1bmlmaWVkIGdvYWwtb3JpZW50ZWQgYW5kIGNvbGxhYm9yYXRpdmUgY29uc2Vuc3VzLCBtYWtpbmcgaXQgZGlmZmljdWx0IHRvIGZvcm0gYSByYXBpZC1yZXNwb25zZSBhbmQgZWZmaWNpZW50IHVyYmFuIGdvdmVybmFuY2UgYW5kIHB1YmxpYyBzZXJ2aWNlIHN5c3RlbS4gVGhpcyBpcyBlc3BlY2lhbGx5IHRydWUgaW4gc29jaWFsIGdvdmVybmFuY2UsIHdoZXJlIGJyZWFrdGhyb3VnaCBhY2hpZXZlbWVudHMgYXJlIGxhY2tpbmcuICAKClN1cGVydmlzaW9uIGFuZCBhc3Nlc3NtZW50IG1lY2hhbmlzbXMgYXJlIGluYWRlcXVhdGUuIEluIHRlcm1zIG9mIGJ1c2luZXNzIHBlcmZvcm1hbmNlLCB0aGVyZSBpcyBhIGxhY2sgb2YgZWZmaWNpZW50IGluZm9ybWF0aW9uLWJhc2VkIG1vbml0b3JpbmcgbWV0aG9kcyBhbmQgbG9uZy10ZXJtIGFzc2Vzc21lbnQgbWVjaGFuaXNtcy4gSXQgaXMgZGlmZmljdWx0IHRvIHRyYWNrIGFuZCBhbmFseXplIHNvY2lhbCBnb3Zlcm5hbmNlIGFuZCBwdWJsaWMgc2VydmljZSBwcm9jZXNzZXMgYW5kIHJlc3VsdHMgY29tcHJlaGVuc2l2ZWx5LCBjb250aW51b3VzbHksIGFuZCBkZWVwbHksIGhpbmRlcmluZyB0aGUgZGlzY292ZXJ5IG9mIHBvdGVudGlhbCBpc3N1ZXMgYW5kIHRoZSBhZGp1c3RtZW50IG9mIG1lYXN1cmVzLCB3aGljaCBpcyBub3QgY29uZHVjaXZlIHRvIHRoZSBzdGFibGUgaW1wcm92ZW1lbnQgYW5kIGNvbnRpbnVvdXMgb3B0aW1pemF0aW9uIG9mIGJ1c2luZXNzIHBlcmZvcm1hbmNlIHF1YWxpdHkuICAKClRocm91Z2ggdG9wLWxldmVsIGRlc2lnbiwgY2xhcmlmeWluZyB0aGUgYm91bmRhcmllcyBvZiByaWdodHMgYW5kIHJlc3BvbnNpYmlsaXRpZXMsIHN0cmVuZ3RoZW5pbmcgdGhlIHJlLWVuZ2luZWVyaW5nIG9mIGdvdmVybmFuY2UgYnVzaW5lc3MgcHJvY2Vzc2VzIGJhc2VkIG9uIGluZm9ybWF0aW9uIHNoYXJpbmcsIGFuZCBzdGFuZGFyZGl6aW5nIHVyYmFuIGV2ZW50IGNsYXNzaWZpY2F0aW9uIGFuZCByZXNwb25zZSBwbGFucywgd2UgY2FuIGJ1aWxkIHRoZSBmb3VuZGF0aW9uIGZvciB1cmJhbiBnb3Zlcm5hbmNlIGJ1c2luZXNzIGNvbGxhYm9yYXRpb24sIGZ1cnRoZXIgZW5oYW5jZSByZXNwb25zZSBzcGVlZCBhbmQgZGlzcG9zYWwgY2FwYWJpbGl0aWVzLCBhbmQgcHJvbW90ZSB0aGUgZGV2ZWxvcG1lbnQgYW5kIGlubm92YXRpb24gb2YgZ292ZXJuYW5jZSBhbmQgc2VydmljZSBzeXN0ZW1zLiAgCgoyLiBDb25zdHJ1Y3Rpb24gUGxhbiAgCjIuMSBDb25zdHJ1Y3Rpb24gSWRlYXMgIApTdHJlbmd0aGVuIHRvcC1sZXZlbCBkZXNpZ24gYW5kIGNvb3JkaW5hdGVkIGNvbnN0cnVjdGlvbi4gRnJvbSBhIG1hY3JvIHBlcnNwZWN0aXZlLCAuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2UgaGVscCBtZSB3cml0ZSBhbiBpbnRyb2R1Y3Rpb24gZm9yIGFuIEludGVybmV0IG9mIFRoaW5ncyAoSW9UKSBzZWN1cml0eSBwYXBlciBiYXNlZCBvbiB0aGUgY29udGVudCBJIHByb3ZpZGUsIGV4cGxhaW5pbmcgdGhlIGluY3JlYXNpbmdseSBzZXJpb3VzIHNlY3VyaXR5IHRocmVhdHMgcG9zZWQgYnkgSW9UIGRldmljZXMuIFByb3ZpZGUgYSBkZXRhaWxlZCBleHBsYW5hdGlvbiBvZiB0aGUgdGVjaG5pY2FsIGZlYXR1cmVzIG9mIGN1cnJlbnQgbWFpbnN0cmVhbSBwcm90ZWN0aW9uIHNvbHV0aW9ucyAoc3VjaCBhcyBmaXJtd2FyZSBoYXJkZW5pbmcsIGFjY2VzcyBjb250cm9sLCBldGMuKSBhbmQgdGhlIGxpbWl0YXRpb25zIGVuY291bnRlcmVkIGluIHByYWN0aWNhbCBhcHBsaWNhdGlvbnMuIE5hdHVyYWxseSwgbGVhZCBpbnRvIHRoZSBpbm5vdmF0aXZlIHBvaW50cyBhbmQgYWR2YW50YWdlcyBvZiB0aGUgbmV3IHByb3RlY3Rpb24gbWV0aG9kIEkgcHJvcG9zZS4gIApBcyBhIGZyb250bGluZSByZXNlYXJjaGVyIGFuZCBkZXZlbG9wbWVudCBlbmdpbmVlciBpbiBJb1Qgc2VjdXJpdHksIEkgYW0gZGVlcGx5IGF3YXJlIG9mIHRoZSBpbmNyZWFzaW5nIHNlY3VyaXR5IGNoYWxsZW5nZXMgaW4gdGhlIEluZHVzdHJpYWwgSW50ZXJuZXQgb2YgVGhpbmdzIChJSW9UKSBlbnZpcm9ubWVudC4gSW4gYWN0dWFsIHByb2plY3RzLCBJIGhhdmUgYmVlbiBpbnZvbHZlZCBpbiB0aGUgc2VjdXJpdHkgYXNzZXNzbWVudCBhbmQgcHJvdGVjdGlvbiBkZXZlbG9wbWVudCBvZiBzZXZlcmFsIGluZHVzdHJpYWwgY29udHJvbCBzeXN0ZW1zLCBhbmQgaGF2ZSBlbmNvdW50ZXJlZCBzb21lIGNoYWxsZW5naW5nIHNlY3VyaXR5IGluY2lkZW50cy4gRm9yIGV4YW1wbGUsIGluIGEgdHlwaWNhbCBpbmR1c3RyaWFsIG1vbml0b3Jpbmcgc3lzdGVtLCB3ZSBkaXNjb3ZlcmVkIGFuIGF0dGFjayBtZXRob2Qgd2hlcmUgYW4gYXR0YWNrZXIgZXhwbG9pdGVkIGEgZGV2aWNlIGZpcm13YXJlIHZ1bG5lcmFiaWxpdHkgdG8gaW50ZXJmZXJlIHdpdGggdGhlIGluZHVzdHJpYWwgcHJvZHVjdGlvbiBwcm9jZXNzLCBjYXVzaW5nIHByb2R1Y3Rpb24gZG93bnRpbWUgYW5kIGRhdGEgbGVha2FnZS4gU3VjaCBjYXNlcyBoaWdobGlnaHQgdGhlIGltcG9ydGFuY2Ugb2Ygc2VjdXJpdHkgcHJvdGVjdGlvbiBmb3IgSW9UIGRldmljZXMgYW5kIGhhdmUgbWFkZSBtZSByZWFsaXplIHRoZSBsaW1pdGF0aW9ucyBvZiB0cmFkaXRpb25hbCBzZWN1cml0eSBtZWFzdXJlcyBpbiBkZWFsaW5nIHdpdGggdGhlc2Ugc3BlY2lmaWMgYXR0YWNrIHNjZW5hcmlvcy4KClRocm91Z2ggeWVhcnMgb2YgcHJhY3RpY2FsIGV4cGVyaWVuY2UsIEkgaGF2ZSBmb3VuZCB0aGF0IGFsdGhvdWdoIHRoZXJlIGFyZSBzb21lIHByb3RlY3Rpb24gc29sdXRpb25zIG9uIHRoZSBtYXJrZXQsIHN1Y2ggYXMgZmlybXdhcmUgaGFyZGVuaW5nLCBhY2Nlc3MgY29udHJvbCwgYW5kIGVuY3J5cHRlZCB0cmFuc21pc3Npb24sIHRoZXkgZmFjZSBtYW55IGNoYWxsZW5nZXMgaW4gcHJhY3RpY2FsIGFwcGxpY2F0aW9ucy4gRm9yIGluc3RhbmNlLCB3aGlsZSBmaXJtd2FyZSBoYXJkZW5pbmcgZWZmZWN0aXZlbHkgaW1wcm92ZXMgZGV2aWNlIHNlY3VyaXR5LCBpdCBvZnRlbiBpbmNyZWFzZXMgdGhlIGNvc3QgYW5kIGNvbXBsZXhpdHkgb2YgdGhlIGRldmljZSwgYW5kIHRoZSBoYXJkZW5lZCBkZXZpY2VzIGhhdmUgc2xvdyByZXNwb25zZSB0aW1lcyB3aGVuIGZhY2luZyBuZXcgdHlwZXMgb2YgYXR0YWNrczsgYWNjZXNzIGNvbnRyb2wgc29sdXRpb25zLCB3aGlsZSBlZmZlY3RpdmVseSByZXN0cmljdGluZyB1bmF1dGhvcml6ZWQgYWNjZXNzLCBhcmUgY29zdGx5IHRvIGltcGxlbWVudCwgY29tcGxleCB0byBjb25maWd1cmUsIGFuZCBkaWZmaWN1bHQgdG8gYWRhcHQgdG8gdGhlIGR5bmFtaWMgaW5kdXN0cmlhbCBlbnZpcm9ubWVudC4gVGhyb3VnaCB0aGVzZSBwZXJzb25hbCBleHBlcmllbmNlcywgSSBkZWVwbHkgcmVhbGl6ZSB0aGF0IGN1cnJlbnQgcHJvdGVjdGl2ZSBtZWFzdXJlcyBhcmUgZmFyIGZyb20gbWVldGluZyB0aGUgaGlnaCBzZWN1cml0eSByZXF1aXJlbWVudHMgaW4gdGhlIGluZHVzdHJpYWwgSW9UIGZpZWxkLgoKQmFzZWQgb24gbXkgYWNjdW11bGF0ZWQgZXhwZXJpZW5jZSBpbiBJSW9UIHNlY3VyaXR5LCB0aGlzIHBhcGVyIHByb3Bvc2VzIGEgbmV3IHByb3RlY3RpdmUgbWV0aG9kIGFpbWVkIGF0IG92ZXJjb21pbmcgdGhlIGxpbWl0YXRpb25zIG9mIGV4aXN0aW5nIHRlY2hub2xvZ2llcyBhbmQgaW1wcm92aW5nIHRoZSBzZWN1cml0eSBhbmQgYWRhcHRhYmlsaXR5IG9mIElvVCBkZXZpY2VzLiBPdXIgYXBwcm9hY2ggY29tYmluZXMgKiptdWx0aS1sYXllciBkeW5hbWljIG1vbml0b3JpbmcqKiB3aXRoIGFuICoqYWRhcHRpdmUgcmVzcG9uc2UgbWVjaGFuaXNtKiosIGFuYWx5emluZyBkZXZpY2UgYmVoYXZpb3IgYW5kIG5ldHdvcmsgdHJhZmZpYyBpbiByZWFsIHRpbWUgdG8gYXV0b21hdGljYWxseSBpZGVudGlmeSBhbmQgYmxvY2sgcG90ZW50aWFsIHNlY3VyaXR5IHRocmVhdHMuIFVubGlrZSB0cmFkaXRpb25hbCBzdGF0aWMgcHJvdGVjdGlvbiBtZWFzdXJlcywgdGhpcyBhcHByb2FjaCBjYW4gZmxleGlibHkgYWRqdXN0IHByb3RlY3Rpb24gc3RyYXRlZ2llcyBiYXNlZCBvbiBhY3R1YWwgY29uZGl0aW9ucywgc2lnbmlmaWNhbnRseSByZWR1Y2luZyBmYWxzZSBwb3NpdGl2ZSByYXRlcyBhbmQgaW1wcm92aW5nIHByb3RlY3Rpb24gZWZmaWNpZW5jeS4gQWRkaXRpb25hbGx5LCB3ZSBoYXZlIGludHJvZHVjZWQgYSAqKmJsb2NrY2hhaW4tYmFzZWQqKiBkZXZpY2UgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIHRvIGVuc3VyZSB0aGUgcmVsaWFiaWxpdHkgb2YgZGV2aWNlIGlkZW50aXRpZXMgYW5kIHRoZSB0cmFuc3BhcmVuY3kgb2YgY29tbXVuaWNhdGlvbiBwcm9jZXNzZXMsIGFkZHJlc3NpbmcgdGhlIGNvbW1vbiBzZWN1cml0eSByaXNrcyBhc3NvY2lhdGVkIHdpdGggZGV2aWNlIGlkZW50aXR5IGF1dGhlbnRpY2F0aW9uLiAKClRoZXNlIGlubm92YXRpb25zIG1ha2Ugb3VyIHByb3RlY3Rpb24gbWV0aG9kIG5vdCBvbmx5IHBlcmZvcm0gZXhjZWxsZW50bHkgaW4gcmVzcG9uZGluZyB0byBrbm93biB0aHJlYXRzIGJ1dCBhbHNvIGVmZmVjdGl2ZWx5IGRlYWwgd2l0aCBlbWVyZ2luZyB0eXBlcyBvZiBhdHRhY2tzLCBmaWxsaW5nIHRoZSBnYXAgaW4gZmxleGliaWxpdHkgYW5kIGFkYXB0YWJpbGl0eSBpbiBjdXJyZW50IHRlY2hub2xvZ2ljYWwgc29sdXRpb25zLgp1c2VyOgoqKlJlc2VhcmNoIG9uIHRoZSBQcmFjdGljZSBvZiBJbmR1c3RyaWFsIEludGVybmV0IFNlY3VyaXR5IENhcGFiaWxpdHkgQ29uc3RydWN0aW9uIGluIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMqKiAgCgojIyMgMS4gRGVzaWduIG9mIEluZHVzdHJpYWwgSW50ZXJuZXQgU2VjdXJpdHkgRnVuY3Rpb25hbCBBcmNoaXRlY3R1cmUgZm9yIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMgIAoKQmFzZWQgb24gY3liZXJzZWN1cml0eSByZWd1bGF0aW9ucywgdGhlIG9wZXJhdGlvbmFsIGNoYXJhY3RlcmlzdGljcyBvZiBwb3dlciBlbnRlcnByaXNlcywgYW5kIG5hdGlvbmFsIGluZHVzdHJ5IHJlZ3VsYXRvcnkgcHJhY3RpY2VzLCBwb3dlciBwcm9kdWN0aW9uIGVudGVycHJpc2VzIGhhdmUgZXN0YWJsaXNoZWQgYSB0YXJnZXRlZCBpbmR1c3RyaWFsIGludGVybmV0IHNlY3VyaXR5IHByb3RlY3Rpb24gc3lzdGVtLiBUaGlzIHN5c3RlbSBhaW1zIHRvIHByb21vdGUgdGhlIGludGVsbGlnZW50IHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBwb3dlciBpbmR1c3RyeSB3aGlsZSBlbnN1cmluZyBmdWxsIGNvbXBsaWFuY2UgYW5kIGVmZmljaWVudCBzZWN1cml0eSB0aHJvdWdoIGEgdHdvLXRpZXIsIHRocmVlLWxheWVyIGFyY2hpdGVjdHVyZSBvZiB0aGUgaW5kdXN0cmlhbCBpbnRlcm5ldCBzZWN1cml0eSBzZXJ2aWNlIHBsYXRmb3JtIChVQ1NQKSBbMV0uICAKClRoaXMgcGxhdGZvcm0gaW50ZWdyYXRlcyByZXNvdXJjZXMgZnJvbSB1cHN0cmVhbSBhbmQgZG93bnN0cmVhbSBwb3dlciBwcm9kdWN0aW9uIGVudGVycHJpc2VzLCByZWd1bGF0b3J5IGFnZW5jaWVzLCBhbmQgc2VydmljZSBwcm92aWRlcnMsIGZvcm1pbmcgYSBjb2xsYWJvcmF0aXZlIHNlY3VyaXR5IG9wZXJhdGlvbiBhbmQgbWFpbnRlbmFuY2UgbWVjaGFuaXNtLiBJdCBvZmZlcnMgb25lLXN0b3AgY3liZXJzZWN1cml0eSBzZXJ2aWNlcyB0byBhZGRyZXNzIHZhcmlvdXMgc2VjdXJpdHkgY2hhbGxlbmdlcyBmYWNlZCBieSBwb3dlciBlbnRlcnByaXNlcyBkdXJpbmcgZGlnaXRhbCB0cmFuc2Zvcm1hdGlvbi4gIAoKVUNTUCBpcyBhIHBsYXRmb3JtIGRlZGljYXRlZCB0byBpbmR1c3RyaWFsIGludGVybmV0IG1vbml0b3JpbmcgYW5kIHBlcmNlcHRpb24uIEl0IHNlYW1sZXNzbHkgY29ubmVjdHMgd2l0aCBuYXRpb25hbCBzdXBlcnZpc29yeSBtYW5hZ2VtZW50IHN5c3RlbXMgYW5kIHJlbGV2YW50IG5hdGlvbmFsIHBsYXRmb3JtcyB3aGlsZSBhY3RpdmVseSBwYXJ0aWNpcGF0aW5nIGluIHRocmVhdCBpbnRlbGxpZ2VuY2Ugc2hhcmluZyBhbmQgZW5mb3JjaW5nIGhpZ2ggc3RhbmRhcmRzIG9mIHJlZ3VsYXRvcnkgY29tcGxpYW5jZS4gSXRzIGZ1bmN0aW9uYWwgYXJjaGl0ZWN0dXJlIGRlc2lnbiBpcyBzaG93biBpbiAqKkZpZ3VyZSAxKiouIFRoZSBjb3JlIGZ1bmN0aW9ucyBpbmNsdWRlIGJ1dCBhcmUgbm90IGxpbWl0ZWQgdG86ICAKCi0gQXNzZXQgZGV0ZWN0aW9uICAKLSBUcmFmZmljIGFuZCByaXNrIGFuYWx5c2lzICAKLSBTaXR1YXRpb24gYXNzZXNzbWVudCAgCi0gRWFybHkgd2FybmluZyBzeXN0ZW1zICAKLSBFbWVyZ2VuY3kgcmVzcG9uc2UgIAoKVGhlc2UgZnVuY3Rpb25zIGNvbGxlY3RpdmVseSBjb250cmlidXRlIHRvIGEgZGVlcGVyIHVuZGVyc3RhbmRpbmcgYW5kIHZpc3VhbGl6YXRpb24gb2YgaW5kdXN0cmlhbCBuZXR3b3JrIHNlY3VyaXR5IGNvbmRpdGlvbnMsIGVuc3VyaW5nIHJlYWwtdGltZSBpZGVudGlmaWNhdGlvbiBhbmQgd2FybmluZyBvZiBwb3RlbnRpYWwgdGhyZWF0cywgcmlza3MsIGFuZCB2dWxuZXJhYmlsaXRpZXMsIHRodXMgcHJvdmlkaW5nIHN0cm9uZyBzdXBwb3J0IGZvciBwb3dlciBlbnRlcnByaXNlcycgY3liZXJzZWN1cml0eSBtYW5hZ2VtZW50LiAgCgoqKkZpZ3VyZSAxOiBPdmVyYWxsIEZ1bmN0aW9uYWwgQXJjaGl0ZWN0dXJlIERlc2lnbiBvZiBJbmR1c3RyaWFsIEludGVybmV0IFNlY3VyaXR5IENhcGFiaWxpdHkgZm9yIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMqKiAgCgpJbiB0aGUgaW5kdXN0cmlhbCBuZXR3b3JrIHNlY3VyaXR5IHJpc2sgbW9uaXRvcmluZyBhbmQgYW5hbHlzaXMgc3lzdGVtLCBzZWN1cml0eSBzdHJhdGVnaWVzIGFyZSBkZXNpZ25lZCB0byBzdXBwb3J0IHBvd2VyIGVudGVycHJpc2VzIGluIGFsaWduaW5nIHdpdGggTmF0aW9uYWwgU3RhbmRhcmQgMi4wLiBUaGlzIGVuc3VyZXMgc2VjdXJpdHkgaW4gbmV0d29yayBib3VuZGFyaWVzLCBjb21tdW5pY2F0aW9uLCBhcHBsaWNhdGlvbnMsIGFuZCBkYXRhIGxheWVycy4gVGhlIHN5c3RlbSBhZGhlcmVzIHRvIGluZHVzdHJ5IHNlY3VyaXR5IG5vcm1zLCBhaW1pbmcgZm9yIHJpc2sgY2xhcml0eSwgdmlzdWFsaXphdGlvbiwgYW5kIGNvbnRyb2xsYWJpbGl0eSB0byBlbmhhbmNlIHRoZSBjeWJlcnNlY3VyaXR5IG1hbmFnZW1lbnQgY2FwYWJpbGl0aWVzIG9mIHBvd2VyIGVudGVycHJpc2VzIFsyXS4gIAoKRm9yIG9mZmljZSBhcmVhIHNlY3VyaXR5IGRlc2lnbiwgaW5mb3JtYXRpb24gY29sbGVjdGlvbiwgYXNzZXQgY29udHJvbCwgYW5kIGF1ZGl0aW5nIHRhc2tzIGFyZSBjb3ZlcmVkIHRvIHByb3ZpZGUgcmVhbC10aW1lIG1vbml0b3JpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSB1bmlmaWVkIHNlY3VyaXR5IHBsYXRmb3JtIGFuZCBzdXBwb3J0IHBsYXRmb3JtIHNlcnZpY2VzLiBBdCB0aGUgY3JpdGljYWwgaW5kdXN0cmlhbCBjb250cm9sIGVkZ2UgbGF5ZXIsIGEgbGF5ZXJlZCBhbmQgZG9tYWluLXNlcGFyYXRlZCBzdHJhdGVneSBpcyBhZG9wdGVkLCBpbnRlZ3JhdGluZyBtdWx0aXBsZSBzZWN1cml0eSB0ZWNobm9sb2dpZXMgdG8gcmVpbmZvcmNlIG5ldHdvcmsgYm91bmRhcnkgcHJvdGVjdGlvbiBiZXR3ZWVuIGRldmljZXMgYW5kIGNvbnRyb2wgc3lzdGVtcy4gIAoKSW4gaW5kdXN0cmlhbCBjb250cm9sIGVxdWlwbWVudCwgcG93ZXIgZW50ZXJwcmlzZXMgaW1wbGVtZW50IHN0cmljdCBpZGVudGl0eSB2ZXJpZmljYXRpb24gYW5kIGFjY2VzcyBjb250cm9sLCB1dGlsaXppbmcgaGFyZHdhcmUtdW5pcXVlIGlkZW50aWZpZXJzIHRvIGVuc3VyZSBsZWdpdGltYXRlIG5ldHdvcmsgYWNjZXNzIGFuZCBydWxlLWJhc2VkIGRhdGEgaW50ZXJhY3Rpb24gY29udHJvbC4gKipGaWd1cmUgMioqIGlsbHVzdHJhdGVzIHRoZSBpbmR1c3RyaWFsIGludGVybmV0IGRhdGEgZmxvdyBhbmQgY3J5cHRvZ3JhcGhpYyBlbXBvd2VybWVudCBpbiBwb3dlciBwcm9kdWN0aW9uIGVudGVycHJpc2VzLiAgCgpTZWN1cml0eSBtZWFzdXJlcyBpbiB0aGUgY29udHJvbCBwcm9jZXNzIGluY2x1ZGU6ICAKCi0gU3RyZW5ndGhlbmluZyBwcm90b2NvbCBzZWN1cml0eSAgCi0gU29mdHdhcmUgaGFyZGVuaW5nICAKLSBDb21tYW5kIGF1ZGl0aW5nICAKLSBGYXVsdCBwcm90ZWN0aW9uICAKCkFsbCB1c2VycyBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQsIGFkZGl0aW9uYWwgYXV0aGVudGljYXRpb24gc3RlcHMgYXJlIHJlcXVpcmVkIGR1cmluZyBjb21tdW5pY2F0aW9uIHRvIHByZXZlbnQgdW5hdXRob3JpemVkIHNlc3Npb25zLCBlbmNyeXB0aW9uIGlzIHVzZWQgdG8gcHJvdGVjdCBkYXRhIHRyYW5zbWlzc2lvbiwgYW5kIHNvZnR3YXJlIHZ1bG5lcmFiaWxpdGllcyBhcmUgcHJvbXB0bHkgcGF0Y2hlZCBvciBtaXRpZ2F0ZWQuIENvbW1hbmQgYXVkaXRpbmcgcHJldmVudHMgc2VjdXJpdHkgaW5jaWRlbnRzLCBlbnN1cmluZyBjb21wcmVoZW5zaXZlIHByb3RlY3Rpb24gZm9yIGluZHVzdHJpYWwgaW50ZXJuZXQgc2VjdXJpdHkuICAKCioqRmlndXJlIDI6IEluZHVzdHJpYWwgSW50ZXJuZXQgRGF0YSBGbG93IGFuZCBDcnlwdG9ncmFwaGljIEVtcG93ZXJtZW50IGluIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMqKiAgCgojIyMgMi4gRGVwbG95bWVudCBQbGFuIGZvciBJbmR1c3RyaWFsIEludGVybmV0IFNlY3VyaXR5IENhcGFiaWxpdHkgaW4gUG93ZXIgUHJvZHVjdGlvbiBFbnRlcnByaXNlcyAgCgpGb3IgcG93ZXIgcHJvZHVjdGlvbiBlbnRlcnByaXNlcywgVUNTUCBpcyBhIGNvbXByZWhlbnNpdmUsIG11bHRpLWxheWVyZWQgc2VjdXJpdHkgcHJvdGVjdGlvbiBzeXN0ZW0uIEl0cyBmdW5kYW1lbnRhbCBjb21wb25lbnRzIGluY2x1ZGUgbXVsdGlwbGUgbGF5ZXJzIHN1Y2ggYXMgdGhlICoqaW5mcmFzdHJ1Y3R1cmUgbGF5ZXIqKiBhbmQgdGhlICoqc3lzdGVtIGNvbXBvbmVudCBsYXllcioqLCB3aGljaCBjb2xsYWJvcmF0ZSB0byBlbnN1cmUgbmV0d29yayBzZWN1cml0eSBhY3Jvc3MgdGhlIHBvd2VyIHN5c3RlbSBbM10uICAKCi0gKipJbmZyYXN0cnVjdHVyZSBMYXllcioqOiBFZmZpY2llbnQgcmVzb3VyY2UgYW5kIGRldmljZSBjb21wdXRpbmcgdG8gcHJvdmlkZSBhIHNvbGlkIHRlY2hub2xvZ2ljYWwgZm91bmRhdGlvbiBmb3IgdGhlIGVudGlyZSBzeXN0ZW0uICAKLSAqKlN5c3RlbSBDb21wb25lbnRzIGFuZCBGdW5jdGlvbmFsIFNlcnZpY2UgTGF5ZXIqKjogVUNTUCBzZXJ2ZXMgYXMgdGhlIGNvcmUsIGNvdmVyaW5nIG5pbmUgbWFqb3IgY29tcG9uZW50cywgaW5jbHVkaW5nIHNlY3VyZSBkYXRhIHN0b3JhZ2UsIGRhdGEgaW50ZWdyYXRpb24sIGFuZCBkYXRhIGNsdXN0ZXIgbm9kZXMuIFRoZXNlIGNvbXBvbmVudHMgZW5hYmxlIGVmZmljaWVudCBkYXRhIHByb2Nlc3NpbmcgYW5kIHByZWNpc2Ugc2VjdXJpdHkgc3RyYXRlZ2llcyB0byByYXBpZGx5IHJlc3BvbmQgdG8gc2VjdXJpdHkgdGhyZWF0cy4gIAotICoqU2l0dWF0aW9uIERpc3BsYXkgTGF5ZXIqKjogTGFyZ2Utc2NhbGUgc2l0dWF0aW9uYWwgbW9uaXRvcmluZyBzY3JlZW5zIHByb3ZpZGUgcmVhbC10aW1lIHZpc3VhbGl6YXRpb24gb2YgZml2ZSBtYWpvciBzZWN1cml0eSBzaXR1YXRpb25zLCBlbmFibGluZyBzZWN1cml0eSBwZXJzb25uZWwgdG8gZ3Jhc3AgdGhlIGN1cnJlbnQgc2VjdXJpdHkgc3RhdHVzIGF0IGEgZ2xhbmNlLiAgCgpBZGRpdGlvbmFsbHksIFVDU1Agb2ZmZXJzIHR3byBjcml0aWNhbCBidXNpbmVzcyBmdW5jdGlvbnM6ICAKCjEuICoqQWR2YW5jZWQgUGVyc2lzdGVudCBUaHJlYXQgKEFQVCkgRGV0ZWN0aW9uKiogIAoyLiAqKkN5YmVyc2VjdXJpdHkgU2l0dWF0aW9uIE1vbml0by4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6ClBsZWFzZSBoZWxwIG1lIHdyaXRlIGFuIGludHJvZHVjdGlvbiBmb3IgYSBwYXBlciBvbiBjbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlLiBUaGUgb3RoZXIgcGFydHMgb2YgdGhlIHBhcGVyIGFyZSBhcyBmb2xsb3dzIEFwcGxpY2F0aW9uIFJlc2VhcmNoIG9mIENsb3VkLU5hdGl2ZSBBcmNoaXRlY3R1cmUgQ29tcHV0aW5nIFBsYXRmb3JtIGluIE1lZGljYWwgSW1hZ2luZyBFZHVjYXRpb24KCjEgQ2xvdWQtTmF0aXZlIEFyY2hpdGVjdHVyZSBDb21wdXRpbmcgUGxhdGZvcm0gIAoxLjEgQ2xvdWQtTmF0aXZlIENvbmNlcHQgIApUaGUgY29uY2VwdCBvZiBjbG91ZC1uYXRpdmUgcmVwcmVzZW50cyBhIG5ldyBwYXJhZGlnbSBpbiBtb2Rlcm4gc29mdHdhcmUgZGV2ZWxvcG1lbnQsIGRlcGxveW1lbnQsIGFuZCBtYWludGVuYW5jZSwgZm9jdXNpbmcgb24gYnVpbGRpbmcgYXBwbGljYXRpb25zIHRoYXQgY2FuIHJ1biBlZmZpY2llbnRseSBpbiBjbG91ZCBlbnZpcm9ubWVudHMuIFRoZSBjb3JlIG9mIHRoaXMgYXBwcm9hY2ggaXMgZW5zdXJpbmcgdGhhdCBhcHBsaWNhdGlvbnMgZnVsbHkgbGV2ZXJhZ2UgdGhlIGVsYXN0aWNpdHksIHNjYWxhYmlsaXR5LCBhbmQgYXV0b21hdGlvbiBhZHZhbnRhZ2VzIHByb3ZpZGVkIGJ5IGNsb3VkIGNvbXB1dGluZy4gQnkgYWRvcHRpbmcgYWR2YW5jZWQgdGVjaG5vbG9naWVzIHN1Y2ggYXMgY29udGFpbmVyaXphdGlvbiwgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUsIERldk9wcyBwcmFjdGljZXMsIGFuZCBjb250aW51b3VzIGludGVncmF0aW9uL2NvbnRpbnVvdXMgZGVwbG95bWVudCAoQ0kvQ0QpLCBjbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIGNhbiBiZSByYXBpZGx5IGRlcGxveWVkLCBmbGV4aWJseSBzY2FsZWQgYWNjb3JkaW5nIHRvIGRlbWFuZCwgYWNoaWV2ZSBlZmZpY2llbnQgb3BlcmF0aW9ucyBtYW5hZ2VtZW50LCBhbmQgYWNjZWxlcmF0ZSBwcm9kdWN0IGl0ZXJhdGlvbiBhbmQgdXBncmFkZXMuIFRoZSBwcm9tb3Rpb24gb2YgdGhpcyBwYXJhZGlnbSBoYXMgbWFkZSBzb2Z0d2FyZSBkZXZlbG9wbWVudCBhbmQgb3BlcmF0aW9ucyBtb3JlIGZsZXhpYmxlIGFuZCBlZmZpY2llbnQsIGFkYXB0aW5nIHRvIHRoZSByYXBpZGx5IGNoYW5naW5nIGRlbWFuZHMgb2YgdGhlIGNsb3VkIGNvbXB1dGluZyBlcmEuICAKCjEuMiBDbG91ZC1OYXRpdmUgQXJjaGl0ZWN0dXJlICAKMS4yLjEgQ29tcG9uZW50cyBvZiBDbG91ZC1OYXRpdmUgQXJjaGl0ZWN0dXJlICAKQ2xvdWQtbmF0aXZlIGFyY2hpdGVjdHVyZSBjb25zaXN0cyBvZiBzZXZlcmFsIGtleSBjb21wb25lbnRzIHRoYXQgY29sbGFib3JhdGUgdG8gcHJvdmlkZSBhbiBlZmZpY2llbnQsIHJlbGlhYmxlLCBhbmQgc2NhbGFibGUgcnVudGltZSBlbnZpcm9ubWVudCBmb3IgYXBwbGljYXRpb25zLiBUaGVzZSBpbmNsdWRlIG1pY3Jvc2VydmljZXMsIGNvbnRhaW5lcml6YXRpb24sIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24vY29udGludW91cyBkZXBsb3ltZW50IChDSS9DRCksIGFuZCBEZXZPcHMsIGFtb25nIG90aGVycy4gIAoxKSBNaWNyb3NlcnZpY2VzOiBUaGUgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUgYnJlYWtzIGRvd24gbGFyZ2UgYXBwbGljYXRpb25zIGludG8gc21hbGxlciB0YXNrcyBhbmQgaW5kaXZpZHVhbCBzZXJ2aWNlcy4gVmFyaW91cyBidXNpbmVzcyBvcGVyYXRpb25zIHJ1biBpbiB0aGVpciBvd24gcHJvY2Vzc2VzIGFuZCBpbnRlcmFjdCB0aHJvdWdoIGxpZ2h0d2VpZ2h0IGNvbW11bmljYXRpb24gcHJvdG9jb2xzLiAgCjIpIENvbnRhaW5lcml6YXRpb246IFRoaXMgaXMgdGhlIGNvcm5lcnN0b25lIG9mIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUuIEJ5IGRlcGxveWluZyB0aGUgc3lzdGVtIGVudmlyb25tZW50LCBhcHBsaWNhdGlvbnMsIGFuZCByZWxhdGVkIGRlcGVuZGVuY2llcyBpbiBjb250YWluZXJzLCBpdCBlbnN1cmVzIHRoYXQgYXBwbGljYXRpb25zIGFyZSBmdWxseSBwb3J0YWJsZSBhY3Jvc3MgZGlmZmVyZW50IGRlcGxveW1lbnQgZW52aXJvbm1lbnRzLiAgCjMpIENvbnRpbnVvdXMgSW50ZWdyYXRpb24vQ29udGludW91cyBEZXBsb3ltZW50IChDSS9DRCk6IEluIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUsIENJL0NEIGVuYWJsZXMgcmFwaWQgcmVzcG9uc2UgdG8gY2hhbmdlcyBpbiBkZW1hbmQsIGltcHJvdmluZyBkZXZlbG9wbWVudCBlZmZpY2llbmN5IGFuZCBwcm9kdWN0IHF1YWxpdHkgdGhyb3VnaCBhdXRvbWF0ZWQgYnVpbGRpbmcsIHRlc3RpbmcsIGFuZCBkZXBsb3ltZW50IHByb2Nlc3Nlcy4gIAo0KSBEZXZPcHM6IERldk9wcyBpcyBwcmltYXJpbHkgcmVzcG9uc2libGUgZm9yIHRoZSBjb29yZGluYXRpb24gYW5kIGNvbGxhYm9yYXRpb24gYmV0d2VlbiBvcGVyYXRpb25zIGFuZCBkZXZlbG9wbWVudCB3aXRoaW4gdGhlIHBsYXRmb3JtLCBzZXR0aW5nIHVwIHN0YW5kYXJkaXplZCBhbmQgYXV0b21hdGVkIHByb2Nlc3NlcyB0byBhY2hpZXZlIGVmZmljaWVudCBpdGVyYXRpb24sIHJhcGlkIG9wZXJhdGlvbnMsIGFuZCBjb250aW51b3VzIGltcHJvdmVtZW50LiAgCgoxLjIuMiBBZHZhbnRhZ2VzIG9mIENsb3VkLU5hdGl2ZSBBcmNoaXRlY3R1cmUgIApDb21wYXJlZCB0byB0cmFkaXRpb25hbCBhcmNoaXRlY3R1cmUsIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUgaGFzIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyaXN0aWNzOiBlbGFzdGljIHNjYWxpbmcsIGhpZ2ggYXZhaWxhYmlsaXR5LCBlZmZpY2llbnQgb3BlcmF0aW9ucywgcmFwaWQgaXRlcmF0aW9uLCBhbmQgY29zdCByZWR1Y3Rpb24sIGFzIG91dGxpbmVkIGJlbG93OiAgCjEpIEVsYXN0aWMgU2NhbGluZzogQ2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBjYW4gcmFwaWRseSBhbmQgZmxleGlibHkgc2NhbGUgdG8gYWNjb21tb2RhdGUgY2hhbmdlcyBpbiBidXNpbmVzcyBkZW1hbmQgdGhyb3VnaCBjb250YWluZXJpemF0aW9uIGFuZCBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZS4gIAoyKSBIaWdoIEF2YWlsYWJpbGl0eTogQ2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBhcmUgaGlnaGx5IGF2YWlsYWJsZSBhbmQgcmVzaWxpZW50LCBjYXBhYmxlIG9mIHJhcGlkIHJlY292ZXJ5IGluIHRoZSBldmVudCBvZiBmYWlsdXJlLiAgCjMpIEVmZmljaWVudCBPcGVyYXRpb25zOiBDbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIGNhbiBhdXRvbWF0ZSBvcGVyYXRpb25zLCBpbmNsdWRpbmcgYXV0b21hdGVkIGJ1aWxkaW5nLCBkZXBsb3ltZW50LCBtb25pdG9yaW5nLCBhbmQgYWxlcnRzLiAgCjQpIFJhcGlkIEl0ZXJhdGlvbjogQ2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBwcmltYXJpbHkgdXNlIERldk9wcyBhbmQgYWdpbGUgZGV2ZWxvcG1lbnQgbWV0aG9kcywgZW5hYmxpbmcgcmFwaWQgaXRlcmF0aW9uIGFuZCB1cGRhdGVzLiAgCjUpIENvc3QgUmVkdWN0aW9uOiBDbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIG1ha2UgZnVsbCB1c2Ugb2YgY2xvdWQgcGxhdGZvcm0gcmVzb3VyY2VzLCBlZmZlY3RpdmVseSByZWR1Y2luZyBjb3N0cy4gIAoKMS4zIENsb3VkLU5hdGl2ZSBSZXNlYXJjaCBhbmQgVGVhY2hpbmcgUGxhdGZvcm0gRnJhbWV3b3JrICAKVGhpcyBwYXBlciBwcm9wb3NlcyBhIGRlc2lnbiBzY2hlbWUgZm9yIGEgdGVhY2hpbmcgYW5kIHJlc2VhcmNoIGNvbXB1dGluZyBwbGF0Zm9ybSBiYXNlZCBvbiBjbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlLCBhcyBzaG93biBpbiBGaWd1cmUgMS4gSXQgaW5jbHVkZXMgS3ViZXJuZXRlcyAoSzhTKSBjb21wYXRpYmlsaXR5LCBkaXN0cmlidXRlZCBzdG9yYWdlLCB0YXNrIHF1ZXVlcywgYXV0b21hdGVkIG9wZXJhdGlvbnMsIGFuZCByZXNvdXJjZSBzY2hlZHVsaW5nLiAgCgpGaWd1cmUgMTogQ2xvdWQtTmF0aXZlIEFyY2hpdGVjdHVyZSBUZWFjaGluZyBhbmQgUmVzZWFyY2ggQ29tcHV0aW5nIFBsYXRmb3JtICAKVGhlIHByb3Bvc2VkIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUgdGVhY2hpbmcgYW5kIHJlc2VhcmNoIGNvbXB1dGluZyBwbGF0Zm9ybSBpcyBhIG11bHRpLXVzZXIgcGFyYWxsZWwgY29tcHV0aW5nIHBsYXRmb3JtIGNlbnRlcmVkIG9uIHN0dWRlbnQgcmVzZWFyY2ggYW5kIHRlYWNoaW5nIHNjZW5hcmlvcy4gSXQgcHJvdmlkZXMgZnVsbC1zdGFjayBJVCBhdXRvbWF0aW9uIG9wZXJhdGlvbnMgY2FwYWJpbGl0aWVzLCBzaW1wbGlmeWluZyB0aGUgd29ya2Zsb3cgb2YgdGVhY2hpbmcgYW5kIHJlc2VhcmNoLCBhbmQgcHJvdmlkZXMgYSB1c2VyLWZyaWVuZGx5IGd1aWRlZCBpbnRlcmZhY2UgdGhhdCBlbXBvd2VycyBpbnN0cnVjdG9ycyB0byBxdWlja2x5IGJ1aWxkIGEgcG93ZXJmdWwgYW5kIGZlYXR1cmUtcmljaCBjb250YWluZXIgY2xvdWQgcGxhdGZvcm0gZm9yIHN0dWRlbnRzLiAgCgpGaWd1cmUgMjogQ2xvdWQtTmF0aXZlIFRlYWNoaW5nIGFuZCBSZXNlYXJjaCBQbGF0Zm9ybSBGcmFtZXdvcmsgIApGcm9tIEZpZ3VyZSAyLCB3ZSBjYW4gc2VlIHRoYXQgdGhpcyBwbGF0Zm9ybSBpbnRlZ3JhdGVzIGEgcG93ZXJmdWwgR1BVIGNsdXN0ZXIgdG8gcHJvdmlkZSBlZmZpY2llbnQgZGF0YSBwcm9jZXNzaW5nIGFuZCB2aXN1YWxpemF0aW9uIGNhcGFiaWxpdGllcywgc3VwcG9ydGluZyBpbi1kZXB0aCByZXNlYXJjaCBhbmQgdGVhY2hpbmcgb2YgbWVkaWNhbCBpbWFnaW5nLiBUaGUgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUgZW5zdXJlcyB0aGF0IHRoZSBwbGF0Zm9ybSBoYXMgc3Ryb25nIG9wZW5uZXNzIGFuZCBzY2FsYWJpbGl0eS4gVGhlIHVzZXIgY2VudGVyIGVuc3VyZXMgdGhlIHNlY3VyZSBhbmQgb3JkZXJseSB1c2Ugb2YgcmVzb3VyY2VzLiBBZGRpdGlvbmFsbHksIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyBHUFUgcGh5c2ljYWwgbWFjaGluZXMgYW5kIFdpbmRvd3MgdmlydHVhbCBtYWNoaW5lcywgbWVldGluZyBkaXZlcnNlIHNvZnR3YXJlIG5lZWRzLiBPdmVyYWxsLCB0aGUgcGxhdGZvcm0gcHJvdmlkZXMgc29saWQgdGVjaG5pY2FsIHN1cHBvcnQgZm9yIHRlYWNoaW5nIGFuZCByZXNlYXJjaCBpbiB0aGUgZmllbGQgb2YgbWVkaWNhbCBpbWFnaW5nLCBwcm9tb3RpbmcgdGhlIGNvbnRpbnVvdXMgZGV2ZWxvcG1lbnQgb2YgdGhlIGZpZWxkLiAgCgoyLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgY2hlY2sgYW5kIGltcHJvdmUgdGhlIGludHJvZHVjdGlvbiBvZiB0aGlzIHBhcGVyIG9uIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5LCBleHBhbmRpbmcgdGhlIHJlc2VhcmNoIGJhY2tncm91bmQgYW5kIHByb3ZpZGluZyBhIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoZSBwYWluIHBvaW50cyBhbmQgc29sdXRpb25zLCAqKklubm92YXRpb24gb2YgVHJ1bmsgTG9naXN0aWNzIEF1dG9ub21vdXMgRHJpdmluZyBUZWNobm9sb2d5IGFuZCBFdm9sdXRpb24gb2YgQnVzaW5lc3MgTW9kZWxzKioKCkFic3RyYWN0OiBBdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBoYXMgZmlyc3QgYmVlbiBpbXBsZW1lbnRlZCBpbiB0aGUgdHJ1bmsgbG9naXN0aWNzIGZpZWxkLiBUaGUgcmlzZSBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBicmluZ3MgbmV3IGRldmVsb3BtZW50IG9wcG9ydHVuaXRpZXMgdG8gdGhlIHRydW5rIGxvZ2lzdGljcyBpbmR1c3RyeS4gVHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGlzIGJlY29taW5nIG1hdHVyZSBhbmQgaGFzIGJlZ3VuIHRvIGV4cGxvcmUgY29tbWVyY2lhbGl6YXRpb24gbW9kZWxzLiBCeSBhbmFseXppbmcgdGhlIHNwZWNpZmljIHNjZW5hcmlvcyBhbmQgY2hhcmFjdGVyaXN0aWNzIG9mIHRydW5rIGxvZ2lzdGljcywgdGhlIGtleSB0ZWNobm9sb2dpZXMgb2YgYXV0b25vbW91cyBkcml2aW5nIGluIHRydW5rIGxvZ2lzdGljcyBhcmUgaWRlbnRpZmllZCwgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmdW5jdGlvbiBhbmQgc3lzdGVtIGRlc2lnbiBvZiB0cnVuayB2ZWhpY2xlcy4gQmFzZWQgb24gdGhlIG1hcmtldCBkZW1hbmQgb2YgdHJ1bmsgbG9naXN0aWNzLCB0aGlzIGFydGljbGUgcHJvbW90ZXMgdGhlIGNvbW1lcmNpYWxpemF0aW9uIGV2b2x1dGlvbiBvZiB0cnVuayBsb2dpc3RpY3MgYmFzZWQgb24gdGhlIGlubm92YXRpb24gb2YgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3kuCgpLZXl3b3JkczogdHJ1bmsgbG9naXN0aWNzOyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neTsgYnVzaW5lc3MgbW9kZWxzOyB0ZWNobm9sb2dpY2FsIHJvdXRlcwoKVGhlIHRyYWRpdGlvbmFsIGxvZ2lzdGljcyBvcGVyYXRpb24gbW9kZWwgaGFzIHByb2JsZW1zIHN1Y2ggYXMgaGlnaCBsYWJvciBjb3N0LCBoaWdoIGNvc3RzLCBsb3cgZWZmaWNpZW5jeSwgbG9uZyBkZWxpdmVyeSB0aW1lLCBhbmQgaGlkZGVuIHNhZmV0eSBoYXphcmRzLiBUaHJvdWdoIHRoZSBpbXByb3ZlbWVudCBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSwgdGhlIGRlZmVjdHMgb2YgdGhlIHRyYWRpdGlvbmFsIGxvZ2lzdGljcyBvcGVyYXRpb24gbW9kZWwgY2FuIGJlIGJldHRlciBhZGRyZXNzZWQuIFRoZXJlZm9yZSwgdGhlIGNvbnRpbnVvdXMgZGV2ZWxvcG1lbnQgb2YgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3kgYnJpbmdzIG5ldyBkZXZlbG9wbWVudCBvcHBvcnR1bml0aWVzIHRvIHRoZSBsb2dpc3RpY3MgaW5kdXN0cnkuIEF0IHByZXNlbnQsIGRvbWVzdGljIGFuZCBmb3JlaWduIHJlc2VhcmNoIGlzIG1vc3RseSBsaW1pdGVkIHRvIHRoZSBhbmFseXNpcyBvZiBzcGVjaWZpYyBzY2VuYXJpb3Mgb24gdHJ1bmsgcm9hZHMsIGxhY2tpbmcgYSBzeXN0ZW1hdGljIGFuYWx5c2lzIG9mIHZhcmlvdXMgYXBwbGljYXRpb24gc2NlbmFyaW9zIHRoYXQgdHJ1bmsgYXV0b25vbW91cyBsb2dpc3RpY3MgdmVoaWNsZXMgbWF5IGZhY2UuIFRoaXMgYXJ0aWNsZSBhaW1zIHRvIGFkZHJlc3Mga2V5IGlzc3VlcyBpbiB2aXN1YWwgcGVyY2VwdGlvbiwgcG9zaXRpb25pbmcsIGFuZCBvdGhlciBjcml0aWNhbCB0ZWNobm9sb2dpZXMgZm9yIHRydW5rIGF1dG9ub21vdXMgbG9naXN0aWNzIHZlaGljbGVzIHRocm91Z2ggaW4tZGVwdGggcmVzZWFyY2ggYW5kIGlubm92YXRpb24gb24gdGhlaXIgdW5pcXVlIHNjZW5hcmlvcyBhbmQgdGVjaG5vbG9naWVzLCBhbmQgcHJvdmlkZSBuZXcgaWRlYXMgZm9yIHRoZSBwcmFjdGljYWwgYXBwbGljYXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGJ1c2luZXNzIG1vZGVscy4KCjEuICoqSW5ub3ZhdGlvbiBvZiBUcnVuayBMb2dpc3RpY3MgQXV0b25vbW91cyBEcml2aW5nIFRlY2hub2xvZ3kgYW5kIEJ1c2luZXNzIE1vZGVsIEFyY2hpdGVjdHVyZSoqCgpUaGUgcmVzZWFyY2ggb24gdGhlIGlubm92YXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGFuZCB0aGUgZXZvbHV0aW9uIG9mIGJ1c2luZXNzIG1vZGVscyBjb25zaXN0cyBvZiB0aHJlZSBwYXJ0czogY29uc3RydWN0aW5nIGEgZmxleGlibGUgYXV0b25vbW91cyBkcml2aW5nIG1vZGUsIHRydW5rIGxvZ2lzdGljcyBjbG91ZCBkYXRhIGludGVsbGlnZW5jZSBhbmQgYXV0b25vbW91cyBkcml2aW5nIGludGVncmF0aW9uLCBhbmQgdGhlIHRlY2huaWNhbCByb3V0ZSBvZiB0aGUgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyBidXNpbmVzcyBtb2RlbCwgYXMgc2hvd24gaW4gRmlndXJlIDEuCgoqKkZpZ3VyZSAxKio6IFRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBpbm5vdmF0aW9uIGFuZCBidXNpbmVzcyBtb2RlbCBhcmNoaXRlY3R1cmUKCkJhc2VkIG9uIGV4aXN0aW5nIHRlY2hub2xvZ2llcywgdGhlIGxhdGVzdCB0ZWNobm9sb2dpZXMgYXJlIGludGVncmF0ZWQgdG8gdXBncmFkZSB0aGUgdGVjaG5vbG9neS4gVGhlIGV4cGxvcmF0aW9uIG9mIHRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBpbm5vdmF0aW9uIGFuZCBidXNpbmVzcyBtb2RlbHMgd2lsbCBwcm9jZWVkIGZyb20gdGhyZWUgYXNwZWN0czogZmlyc3RseSwgY29uc3RydWN0aW5nIGEgZmxleGlibGUgYXV0b25vbW91cyBkcml2aW5nIG1vZGUsIHdoaWNoIGluY2x1ZGVzIHRoZSBkZXNpZ24gb2YgbXVsdGlwbGUgZHJpdmluZyBtb2RlcywgZGV2ZWxvcG1lbnQgb2YgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nIG1vZHVsZXMsIGltcHJvdmVtZW50IG9mIHZlaGljbGUgcGVyY2VwdGlvbiB0ZWNobm9sb2dpZXMsIGFuZCBvcHRpbWl6YXRpb24gb2YgYXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2UgYWxnb3JpdGhtcywgY29udGludW91c2x5IGltcHJvdmluZyB0aGUgZXhpc3RpbmcgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5LCBlbmhhbmNpbmcgaXRzIGFwcGxpY2FiaWxpdHkgYW5kIHVuaXZlcnNhbGl0eTsgc2Vjb25kbHksIGFjaGlldmluZyB0aGUgaW50ZWdyYXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGNsb3VkIGRhdGEgaW50ZWxsaWdlbmNlIGFuZCBhdXRvbm9tb3VzIGRyaXZpbmcsIHdoaWNoIGluY2x1ZGVzIGNsb3VkIGRhdGEgb3B0aW1pemF0aW9uIGFuZCB0aGUgaXRlcmF0aW9uIG9mIGNsb3VkIGNvbXB1dGluZyBkYXRhIGludGVsbGlnZW5jZSDigJxzdXBwb3J04oCdIHRlY2hub2xvZ3ksIGltcHJvdmluZyB2ZWhpY2xlIHZhbHVlIHRocm91Z2ggY29tcHV0aW5nIHBvd2VyIHNlcnZpY2VzLCBhbmQgZm9ybWluZyBpbnRlbGxpZ2VudCBkcml2aW5nOyB0aGlyZGx5LCBzdHVkeWluZyB0aGUgdGVjaG5pY2FsIHJvdXRlIG9mIHRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgYnVzaW5lc3MgbW9kZWxzLCBpbmNsdWRpbmcgdGhlIHVwZ3JhZGluZyBvZiBpbnRlbGxpZ2VudCBtb25pdG9yaW5nIGFuZCBtYW5hZ2VtZW50IHN5c3RlbXMsIHRoZSBpbnRlZ3JhdGlvbiBvZiB2ZWhpY2xlIG5ldHdvcmtzIGFuZCBWMlgsIGFuZCB0aGUgaXRlcmF0aW9uIG9mIGNsb3VkIGNvbXB1dGluZyBkYXRhIGludGVsbGlnZW5jZSAic3VwcG9ydCIgdGVjaG5vbG9neS4gQnkgaW50ZWdyYXRpbmcgYW5kIHJlZm9ybWluZyB0aGUgdGVjaG5vbG9neSBvZiB0cnVuayBsb2dpc3RpY3MgYXV0b25vbW91cyBkcml2aW5nIGJ1c2luZXNzIG1vZGVscywgdGhlIGRldmVsb3BtZW50IG9mIHRoZSBpbmR1c3RyeSBjYW4gYmUgYWNjZWxlcmF0ZWQsIHJlc291cmNlIHV0aWxpemF0aW9uIGVmZmljaWVuY3kgaW1wcm92ZWQsIGFuZCBlY29ub21pYyBiZW5lZml0cyBwcm9tb3RlZC4KCjIuICoqRGVzaWduIG9mIFRydW5rIExvZ2lzdGljcyBBdXRvbm9tb3VzIERyaXZpbmcgVGVjaG5vbG9neSBJbm5vdmF0aW9uIE1vZGVsKioKCjIuMSAqKkNvbnN0cnVjdGluZyBhIEZsZXhpYmxlIEF1dG9ub21vdXMgRHJpdmluZyBNb2RlKioKCjIuMS4xICoqRGVzaWduIG9mIE11bHRpcGxlIERyaXZpbmcgTW9kZXMqKgoKVHJ1bmsgbG9naXN0aWNzIHZlaGljbGVzIGFyZSBkZXNpZ25lZCB3aXRoIHZhcmlvdXMgZHJpdmluZyBtb2RlcyBiYXNlZCBvbiBkaWZmZXJlbnQgZGVsaXZlcnkgbG9jYXRpb25zIGFuZCByb2FkIGNvbXBsZXhpdGllcywgYXMgd2VsbCBhcyBkaWZmZXJlbnQgZHJpdmluZyBzY2VuYXJpb3MgYW5kIHJlcXVpcmVtZW50cyB0byByZWR1Y2UgY29zdHMgYW5kIGltcHJvdmUgZWZmaWNpZW5jeS4gVGhlIGF1dG9ub21vdXMgZHJpdmluZyBtb2RlIGNhbiBjaG9vc2UgdGhlIG9wdGltYWwgZHJpdmluZyByb3V0ZSBiYXNlZCBvbiBkaWZmZXJlbnQgc2l0dWF0aW9ucy4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlIG9mIHRyYWZmaWMgY29uZ2VzdGlvbiBvbiB1cmJhbiByb2FkcywgYSBsb3ctc3BlZWQgZGVjZWxlcmF0aW9uIHRyYW5zcG9ydCBtb2RlIGNhbiBiZSB1c2VkIHRvIHJlZHVjZSB2ZWhpY2xlIGVuZXJneSBjb25zdW1wdGlvbiBhbmQgZHJpdmluZyBub2lzZTsgb24gaGlnaHdheXMgb3Igb3BlbiByb2FkcyBpbiBzdWJ1cmJhbiBhcmVhcywgYSBoaWdoLXNwZWVkIHRyYW5zcG9ydCBtb2RlIGlzIHJlcXVpcmVkIHRvIGltcHJvdmUgdHJhbnNwb3J0YXRpb24gZWZmaWNpZW5jeS4KCjIuMS4yICoqRGV2ZWxvcG1lbnQgb2YgSW50ZWxsaWdlbnQgRGVjaXNpb24tTWFraW5nIE1vZHVsZXMqKgoKSW4gb3JkZXIgdG8gZGVsaXZlciBnb29kcyBvbiB0aW1lIGFuZCBpbXByb3ZlIGN1c3RvbWVyIHNhdGlzZmFjdGlvbiwgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nIG1vZHVsZXMgYXJlIHJlcXVpcmVkLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUmVzZWFyY2ggb24gdGhlIERldmVsb3BtZW50IG9mIFNtYXJ0IEFncmljdWx0dXJlIGluIFN1cWlhbiBDaXR5IGluIHRoZSBOZXcgRXJhIOKAkyBBIENhc2UgU3R1ZHkgb2YgVGlhbndhIFNtYXJ0IEluZHVzdHJpYWwgUGFyawoKQWJzdHJhY3Q6IFdpdGggdGhlIGFycml2YWwgb2YgdGhlIGRpZ2l0YWwgZXJhLCBzbWFydCBhZ3JpY3VsdHVyZSBoYXMgZ3JhZHVhbGx5IGJlY29tZSBhIGhvdCB0b3BpYy4gSXQgcGxheXMgYW4gaW1wb3J0YW50IHJvbGUgaW4gaW1wcm92aW5nIGxhYm9yIGVmZmljaWVuY3ksIGVuaGFuY2luZyBwcm9kdWN0aXZpdHkgcXVhbGl0eSwgb3B0aW1pemluZyByZXNvdXJjZSBhbGxvY2F0aW9uLCBhbmQgcHJvbW90aW5nIGVudmlyb25tZW50YWwgcHJvdGVjdGlvbi4gSXQgaGFzIGJlY29tZSBhbiBpbXBvcnRhbnQgZGV2ZWxvcG1lbnQgY29uY2VwdCBmb3IgaW1wbGVtZW50aW5nIHRoZSBydXJhbCByZXZpdGFsaXphdGlvbiBzdHJhdGVneSBhbmQgYSBwb3dlcmZ1bCB0b29sIGZvciBidWlsZGluZyDigJxuZXcgYWdyaWN1bHR1cmUsIG5ldyBjb3VudHJ5c2lkZSwgbmV3IGZhcm1lcnPigJ0gaW4gdGhlIG5ldyBlcmEuIEluIHRoaXMgcmVnYXJkLCBob3cgdG8gdXNlICJJbnRlcm5ldCArIiB0ZWNobm9sb2d5IHRvIGluamVjdCBzbWFydCAiZ2VuZXMiIGludG8gYWdyaWN1bHR1cmFsIG1vZGVybml6YXRpb24gaGFzIGJlY29tZSB0aGUgZm9jdXMgb2YgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IHdvcmsgaW4gdmFyaW91cyByZWdpb25zLiBUYWtpbmcgdGhlIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBvZiBUaWFud2EgU21hcnQgSW5kdXN0cmlhbCBQYXJrIGluIFN1cWlhbiBDaXR5LCBKaWFuZ3N1IFByb3ZpbmNlLCBhcyBhbiBleGFtcGxlLCB0aGlzIHBhcGVyIGV4cGxvcmVzIHRoZSBwb3NpdGl2ZSBzaWduaWZpY2FuY2UgYW5kIHZhbHVhYmxlIGV4cGVyaWVuY2UgcHJvdmlkZWQgYnkgdGhlIGRldmVsb3BtZW50IG9mIHNtYXJ0IGFncmljdWx0dXJlIGluIFN1cWlhbiBDaXR5IGZvciB0aGUgZW50aXJlIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBpbiBOb3J0aGVybiBKaWFuZ3N1IFByb3ZpbmNlIHRocm91Z2ggZmllbGQgc3VydmV5cyBhbmQgcmVzZWFyY2guCgpLZXl3b3JkczogU21hcnQgQWdyaWN1bHR1cmU7IFJ1cmFsIFJldml0YWxpemF0aW9uOyBUaWFud2EgU21hcnQgSW5kdXN0cmlhbCBQYXJrCgpUaGUgcmVwb3J0IG9mIHRoZSAyMHRoIE5hdGlvbmFsIENvbmdyZXNzIG9mIHRoZSBDb21tdW5pc3QgUGFydHkgb2YgQ2hpbmEgZW1waGFzaXplczogV2UgbXVzdCBhZGhlcmUgdG8gcHJpb3JpdGl6aW5nIGFncmljdWx0dXJhbCBhbmQgcnVyYWwgZGV2ZWxvcG1lbnQsIGFuZCBtYWtlIGltcG9ydGFudCBkZXBsb3ltZW50cyBmb3IgY29tcHJlaGVuc2l2ZWx5IHByb21vdGluZyBydXJhbCByZXZpdGFsaXphdGlvbiwgYWNjZWxlcmF0aW5nIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSBzdHJvbmcgYWdyaWN1bHR1cmFsIGNvdW50cnksIGFuZCBjbGFyaWZ5aW5nIHRoZSBncmVhdCBnb2FscyBmb3IgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IGluIHRoZSBuZXcgZXJhIGFuZCBuZXcgam91cm5leSwgcG9pbnRpbmcgb3V0IHRoZSBkaXJlY3Rpb24gZm9yIHRoZSBtb2Rlcm5pemF0aW9uIG9mIHJ1cmFsIGRldmVsb3BtZW50IGluIENoaW5hIGFuZCB0aGUgZnVuZGFtZW50YWwgd29yayB0byBmb2xsb3cuIEluIHRoZSBuZXcgZXJhLCBvbmx5IGJ5IGNvbWJpbmluZyAidGVjaG5vbG9neSIgd2l0aCAiYWdyaWN1bHR1cmUsIiBlbXBvd2VyaW5nIGFncmljdWx0dXJlIHdpdGggdGVjaG5vbG9neSwgYW5kIHByb21vdGluZyB0aGUgZGV2ZWxvcG1lbnQgYW5kIGNvbnN0cnVjdGlvbiBvZiBzbWFydCBhZ3JpY3VsdHVyZSBjYW4gd2UgdWx0aW1hdGVseSBhY2hpZXZlIHRoZSBlZmZlY3Qgb2YgIjErMT4yLiIKCjEuIFRoZSBDb25jZXB0IGFuZCBDb25ub3RhdGlvbiBvZiBTbWFydCBBZ3JpY3VsdHVyZSAgClNpbmNlIGFuY2llbnQgdGltZXMsIENoaW5hIGhhcyBiZWVuIGEgbGFyZ2UgYWdyaWN1bHR1cmFsIGNvdW50cnksIHdpdGggYSBsYXJnZSBwcm9wb3J0aW9uIG9mIHJ1cmFsIHBvcHVsYXRpb24sIGFuZCBhZ3JpY3VsdHVyZSBoYXMgcGxheWVkIGEgc2lnbmlmaWNhbnQgcm9sZSBpbiB0aGUgbmF0aW9uYWwgZWNvbm9teS4gV2l0aCB0aGUgZXN0YWJsaXNobWVudCBvZiB0aGUgUGVvcGxlJ3MgUmVwdWJsaWMgb2YgQ2hpbmEgYW5kIHRoZSBkZXZlbG9wbWVudCBvZiB0aGUgcmVmb3JtIGFuZCBvcGVuaW5nLXVwIHBvbGljeSwgdGhlIENoaW5lc2UgZWNvbm9teSBoYXMgcmFwaWRseSBzb2FyZWQsIHRoZSB0ZXJ0aWFyeSBpbmR1c3RyeSBoYXMgcmlzZW4sIGFuZCBoYXMgY29uc3RhbnRseSBpbXBhY3RlZCB0aGUgb2xkIGVjb25vbWljIHN0cnVjdHVyZS4gVGhlIHByb3BvcnRpb24gb2YgYWdyaWN1bHR1cmFsIGVjb25vbXkgaGFzIGNvbnRpbnVlZCB0byBkZWNsaW5lLCBhbmQgdGhlIG1haW4gc29jaWFsIGNvbnRyYWRpY3Rpb24gaGFzIHNoaWZ0ZWQgdG8gdGhlIGNvbnRyYWRpY3Rpb24gYmV0d2VlbiB0aGUgcGVvcGxlJ3MgZ3Jvd2luZyBkZW1hbmQgZm9yIGEgYmV0dGVyIGxpZmUgYW5kIHVuYmFsYW5jZWQgYW5kIGluc3VmZmljaWVudCBkZXZlbG9wbWVudC4gSW4gcmVzcG9uc2UsIG9ubHkgYnkgY29uc3RhbnRseSBpbXByb3ZpbmcgcHJvZHVjdGl2aXR5IGFuZCBsYWJvciBlZmZpY2llbmN5IGNhbiB3ZSBmdXJ0aGVyIG1lZXQgdGhlIGxpdmluZyBuZWVkcyBvZiB0aGUgcGVvcGxlIGFuZCBhY2hpZXZlIHRoZSAiVHdvIENlbnRlbmFyeSBHb2Fscy4iICAKU21hcnQgYWdyaWN1bHR1cmUgcmVmZXJzIHRvIGludGVsbGlnZW50IGFncmljdWx0dXJhbCB0ZWNobm9sb2d5LCB3aGljaCBpbnZvbHZlcyBhIHNlcmllcyBvZiBhZ3JpY3VsdHVyYWwgcHJvZHVjdGlvbiBhY3Rpdml0aWVzIGNhcnJpZWQgb3V0IGJ5IGFncmljdWx0dXJhbCBwcm9kdWNlcnMgdXNpbmcgSW50ZXJuZXQgb2YgVGhpbmdzIChJb1QpIHRlY2hub2xvZ2llcy4gVGhyb3VnaCBtb2JpbGUgcGhvbmVzLCBjb21wdXRlcnMsIGFuZCBvdGhlciBkZXZpY2VzLCBhZ3JpY3VsdHVyYWwgcHJvZHVjdGlvbiBwcm9jZXNzZXMgYXJlIGNvbnRyb2xsZWQgYW5kIG1vbml0b3JlZCwgYWxsb3dpbmcgZm9yIHByZWNpc2lvbiBtYW5hZ2VtZW50IG9mIGFncmljdWx0dXJhbCBwcm9kdWN0aW9uIGFuZCB1bHRpbWF0ZWx5IG9idGFpbmluZyBjb3JyZXNwb25kaW5nIHByb2R1Y3Rpb24gZGF0YS4gQXMgYW4gZW1lcmdpbmcgYWdyaWN1bHR1cmFsIHByb2R1Y3Rpb24gY29uY2VwdCBpbnRlZ3JhdGVkIHdpdGggSW9UIHRlY2hub2xvZ3ksIHRoZSBkZXZlbG9wbWVudCBvZiBzbWFydCBhZ3JpY3VsdHVyZSBvZnRlbiBzZXJ2ZXMgYXMgYW4gaW1wb3J0YW50IHJlZmVyZW5jZSBmb3IgdGhlIGxldmVsIG9mIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBpbiBhIHJlZ2lvbi4gVGhlIGRlZ3JlZSBvZiBpbnRlbGxpZ2VuY2UgYW5kIG1lY2hhbml6YXRpb24gaW4gYSByZWdpb24gaXMgb2YgZ3JlYXQgaW1wb3J0YW5jZSBpbiBhc3Nlc3NpbmcgdGhlIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBzdGF0dXMgb2YgdGhhdCBhcmVhLiAgCkFzIGFuIGltcG9ydGFudCBjb21wb25lbnQgb2YgdGhlIHNtYXJ0IGVjb25vbXksIHNtYXJ0IGFncmljdWx0dXJlIGZ1bGx5IHV0aWxpemVzIG1vZGVybiBpbmZvcm1hdGlvbiB0ZWNobm9sb2d5IHRvIHNlcnZlIHRyYWRpdGlvbmFsIGFncmljdWx0dXJlLCBwcm92aWRpbmcgcHJlY2lzZSBwbGFudGluZywgdmlzdWFsIGR5bmFtaWMgbW9uaXRvcmluZywgYW5kIGludGVsbGlnZW50IGRlY2lzaW9uLW1ha2luZyBmb3IgYWdyaWN1bHR1cmFsIHByb2R1Y3Rpb24uIFRoZSBkZXZlbG9wbWVudCBvZiBzbWFydCBhZ3JpY3VsdHVyZSBub3Qgb25seSBhZGRyZXNzZXMgcnVyYWwgZW1wbG95bWVudCBpc3N1ZXMgYnV0IGFsc28gZWZmZWN0aXZlbHkgaW1wcm92ZXMgdGhlIGFncmljdWx0dXJhbCBlY29sb2dpY2FsIGVudmlyb25tZW50LCBlbmhhbmNlcyBhZ3JpY3VsdHVyYWwgcHJvZHVjdGl2aXR5LCBhbmQgcmVzb2x2ZXMgdGhlIGlzc3VlIG9mIGEgc2hvcnRhZ2Ugb2YgZHJpdmluZyBmb3JjZSBpbiBhZ3JpY3VsdHVyZS4gUHJvbW90aW5nIGFncmljdWx0dXJhbCBhbmQgcnVyYWwgbW9kZXJuaXphdGlvbiByZXF1aXJlcyB0aGUgYXNzaXN0YW5jZSBvZiBzbWFydCBhZ3JpY3VsdHVyZSBhbmQgaXMgYSBrZXkgcGFydCBvZiBhY2NlbGVyYXRpbmcgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIHN0cm9uZyBhZ3JpY3VsdHVyYWwgY291bnRyeS4KCjIuIE92ZXJ2aWV3IG9mIFJ1cmFsIERldmVsb3BtZW50IElzc3VlcyBpbiBOb3J0aGVybiBKaWFuZ3N1IGFuZCBBbmFseXNpcyBvZiBDYXVzZXMgIApUaGUgTm9ydGhlcm4gSmlhbmdzdSByZWdpb24gaXMgbG9jYXRlZCBpbiBvbmUgb2YgQ2hpbmEncyB0aHJlZSBtYWpvciBwbGFpbnMg4oCUIHRoZSBtaWRkbGUgYW5kIGxvd2VyIFlhbmd0emUgUml2ZXIgcGxhaW4uIEl0IGJlbmVmaXRzIGZyb20gaXRzIGxvY2F0aW9uIGFsb25nIHRoZSByaXZlciwgd2l0aCBmYXZvcmFibGUgZ2VvZ3JhcGhpY2FsIGNvbmRpdGlvbnMsIGFuZCBpcyBrbm93biBhcyB0aGUgIkdyYW5hcnkgb2YgdGhlIFdvcmxkLiIgSG93ZXZlciwgd2l0aCB0aGUgYWR2YW5jZW1lbnQgb2YgdGltZSwgdGhlIGFjY2VsZXJhdGlvbiBvZiB1cmJhbml6YXRpb24gYWNyb3NzIHRoZSBzb2NpZXR5LCBhbmQgdGhlIGZ1cnRoZXIgZGV2ZWxvcG1lbnQgb2YgdGhlIHRlcnRpYXJ5IGluZHVzdHJ5LCBwYXJ0aWN1bGFybHkgaW4gdGhlIHNvdXRoZXJuIEppYW5nc3UgcmVnaW9uLCBoYXZlIGltcGFjdGVkIHRoZSBhZ3JpY3VsdHVyYWwgZGV2ZWxvcG1lbnQgaW4gTm9ydGhlcm4gSmlhbmdzdS4gIAoyLjEgQWNjZWxlcmF0ZWQgTG9zcyBvZiBQcm9kdWN0aXZpdHkgYW5kIFNldmVyZSBSdXJhbCBIb2xsb3dpbmcuICAKU2luY2UgdGhlIHJlZm9ybSBhbmQgb3BlbmluZy11cCwgZXNwZWNpYWxseSB3aXRoIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc29jaWFsaXN0IG1hcmtldCBlY29ub215LCB0aGVyZSBoYXZlIGJlZW4gbW9yZSBkZXZlbG9wbWVudCBvcHBvcnR1bml0aWVzIGFuZCBpbi4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6ClBsZWFzZSB3cml0ZSBhbiBpbnRyb2R1Y3Rpb24gY2hhcHRlciBmb3IgYSBtZWRpY2FsIGltYWdpbmcgYW5hbHlzaXMgdGhlc2lzLCB3aXRoIGEgd29yZCBjb3VudCByZXF1aXJlbWVudCBvZiAyMDAwLTI1MDAgd29yZHMuIFRoZSBmb2xsb3dpbmcgaXMgdGhlIG1haW4gdGV4dCBvZiBteSB0aGVzaXM6ICoqUmVzZWFyY2ggUHJvZ3Jlc3Mgb2YgTWVkaWNhbCBJbWFnZSBBbmFseXNpcyBCYXNlZCBvbiBEZWVwIENvbnZvbHV0aW9uYWwgTmV0d29ya3MqKgoKMS4gT3ZlcnZpZXcgb2YgRGVlcCBDb252b2x1dGlvbmFsIE5ldXJhbCBOZXR3b3JrcyAgClRoZSBodW1hbiBicmFpbiBpcyB0aGUgaW5mb3JtYXRpb24gcHJvY2Vzc2luZyBjZW50ZXIsIGNvbnRyb2xsaW5nIGh1bWFuIGJlaGF2aW9yIGFuZCB0aG91Z2h0LiBUbyBzdHVkeSB0aGUgc3RydWN0dXJlIGFuZCBmdW5jdGlvbiBvZiB0aGUgaHVtYW4gYnJhaW4ncyBuZXJ2b3VzIHN5c3RlbSwgYmlvbG9naWNhbCBuZXVyYWwgbmV0d29ya3Mgd2VyZSBwcm9wb3NlZC4gSW5zcGlyZWQgYnkgdGhpcywgY29tcHV0ZXIgcmVzZWFyY2hlcnMgaW50cm9kdWNlZCBhcnRpZmljaWFsIG5ldXJhbCBuZXR3b3JrcyB0byBzaW11bGF0ZSB0aGUgc3RydWN0dXJlIGFuZCBmdW5jdGlvbmluZyBvZiB0aGUgaHVtYW4gYnJhaW7igJlzIG5lcnZvdXMgc3lzdGVtLiAgCkZyb20gYW4gaW5mb3JtYXRpb24gcHJvY2Vzc2luZyBwZXJzcGVjdGl2ZSwgYW4gYXJ0aWZpY2lhbCBuZXVyYWwgbmV0d29yayBpcyBhIGNvbXBsZXggbWF0aGVtYXRpY2FsIG1vZGVsIHRoYXQgY29ubmVjdHMgYSBsYXJnZSBudW1iZXIgb2YgbWF0aGVtYXRpY2FsIGZ1bmN0aW9ucyBpbiB0aGUgZm9ybSBvZiBuZXVyb25zLiBUaGUgdHJhbnNtaXNzaW9uIG9mIGluZm9ybWF0aW9uIGJldHdlZW4gbmV1cm9ucyBpcyBzaW1pbGFyIHRvIHRoZSB0cmFuc2ZlciBvZiBob3Jtb25lcyBiZXR3ZWVuIGFkamFjZW50IG5lcnZlIGNlbGxzIGluIHRoZSBicmFpbi4gVGhlIG51bWJlciBvZiBuZXVyb25zLCB0aGUgY29ubmVjdGlvbiBtZXRob2QsIGludGVybmFsIHBhcmFtZXRlcnMsIGFuZCBhY3RpdmF0aW9uIGZ1bmN0aW9ucyBkaWZmZXIgdG8gZm9ybSB2YXJpb3VzIG5ldXJhbCBuZXR3b3JrIHN0cnVjdHVyZXMuIFRoZSBzaW1wbGVzdCB0eXBlIG9mIGFydGlmaWNpYWwgbmV1cmFsIG5ldHdvcmsgaXMgY2FsbGVkIGEgc2luZ2xlLWxheWVyIHBlcmNlcHRyb24sIGNvbnNpc3Rpbmcgb2Ygb25lIGlucHV0IGxheWVyLCBvbmUgaGlkZGVuIGxheWVyLCBhbmQgb25lIG91dHB1dCBsYXllciwgYXMgc2hvd24gaW4gRmlndXJlIDEuIEJlY2F1c2UgdGhpcyBzdHJ1Y3R1cmUgaXMgdG9vIHNpbXBsZSB0byBoYW5kbGUgY29tcGxleCBjb21wdXRhdGlvbnMsIGl0cyBhcHBsaWNhdGlvbiBpcyBsaW1pdGVkLiAgCk11bHRpbGF5ZXIgbmV1cmFsIG5ldHdvcmtzLCBhbHNvIGtub3duIGFzIG11bHRpLWxheWVyIHBlcmNlcHRyb25zIChNTFApLCBoYXZlIG11bHRpcGxlIGhpZGRlbiBsYXllcnMgYW5kIGFyZSB2YWx1YWJsZSBhcnRpZmljaWFsIG5ldXJhbCBuZXR3b3JrcyBmb3IgcHJhY3RpY2FsIGFwcGxpY2F0aW9ucy4gVGhlIG1vc3QgdHlwaWNhbCBtdWx0aWxheWVyIG5ldXJhbCBuZXR3b3JrIG1vZGVsIGlzIHRoZSBiYWNrcHJvcGFnYXRpb24gKEJQKSBuZXVyYWwgbmV0d29yayBpbnZlbnRlZCBieSBSdW1lbGhhcnQgZXQgYWwuICAKCkZpZ3VyZSAxOiBTaW5nbGUtTGF5ZXIgTmV1cm9uIFN0cnVjdHVyZSAgCgpXaXRoIHRoZSBhZHZhbmNlbWVudCBvZiBjb21wdXRlciBwb3dlciBhbmQgbWF0aGVtYXRpY2FsIGxvZ2ljLCBtdWx0aWxheWVyIG5ldXJhbCBuZXR3b3JrIHN0cnVjdHVyZXMgaGF2ZSBiZWNvbWUgaW5jcmVhc2luZ2x5IGNvbXBsZXggYW5kIGRpdmVyc2UuIERlZXAgbGVhcm5pbmcgYWxnb3JpdGhtcyByZXByZXNlbnRlZCBieSBDTk5zIGZ1cnRoZXIgZXhwYW5kIHRoZSBkZXB0aCBhbmQgYnJlYWR0aCBvZiBjb21wdXRlciBhbGdvcml0aG1zIHNpbXVsYXRpbmcgaHVtYW4gY29nbml0aXZlIGRvbWFpbnMuIEFzIHNob3duIGluIEZpZ3VyZSAyLCBhIHR5cGljYWwgQ05OIHN0cnVjdHVyZSBjb25zaXN0cyBvZiBvbmUgaW5wdXQgbGF5ZXIsIG9uZSBvdXRwdXQgbGF5ZXIsIHNldmVyYWwgY29udm9sdXRpb25hbCBsYXllcnMsIHBvb2xpbmcgbGF5ZXJzLCBhbmQgZnVsbHkgY29ubmVjdGVkIGxheWVycy4gVGhpcyBuZXR3b3JrIHN0cnVjdHVyZSBwZXJmb3JtcyBiZXR0ZXIgdGhhbiB0cmFkaXRpb25hbCBtdWx0aWxheWVyIG5ldXJhbCBuZXR3b3JrcyBpbiBjb21wdXRlciB2aXNpb24gdGFza3MgYmVjYXVzZSBjb252b2x1dGlvbmFsIGxheWVycyBhbmQgcG9vbGluZyBsYXllcnMgY2FuIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHdlaWdodCBwYXJhbWV0ZXJzIHRoYXQgbmVlZCB0byBiZSB0cmFpbmVkIGJ5IHVzaW5nIHBhcmFtZXRlciBzaGFyaW5nIGFuZCBwYXJ0aWFsIGRpc2NhcmRpbmcgbWV0aG9kcy4gVGhpcyByZWR1Y2VzIG5ldHdvcmsgY29tcGxleGl0eSwgZWFzZXMgdGhlIGNvbXB1dGF0aW9uYWwgbG9hZCwgYW5kIGVuYWJsZXMgQ05OcyB3aXRoIHRoZSBzYW1lIGRlcHRoIHRvIGhhdmUgc3Ryb25nZXIgZGF0YSBwcm9jZXNzaW5nIGFuZCBmZWF0dXJlIGV4dHJhY3Rpb24gY2FwYWJpbGl0aWVzIHRoYW4gbXVsdGktbGF5ZXIgcGVyY2VwdHJvbnMuICAKR2VuZXJhdGl2ZSBBZHZlcnNhcmlhbCBOZXR3b3JrcyAoR0FOcykgYXJlIHRoZSBtb3N0IHdpZGVseSBhcHBsaWVkIGNvbnZvbHV0aW9uYWwgbmV1cmFsIG5ldHdvcmtzIGluIHJlY2VudCB5ZWFycy4gVW5saWtlIGNsYXNzaWMgQ05OIG1vZGVscyBzdWNoIGFzIEFsZXhOZXQsIFZHRywgYW5kIFJlc05ldCwgR0FOIGNvbnNpc3RzIG9mIHR3byBpbmRlcGVuZGVudCBuZXR3b3JrIG1vZGVsczogYSBnZW5lcmF0b3IgYW5kIGEgZGlzY3JpbWluYXRvciwgYXMgc2hvd24gaW4gRmlndXJlIDMuIEluIG1vc3QgY2FzZXMsIGJvdGggdGhlIGdlbmVyYXRvciBhbmQgZGlzY3JpbWluYXRvciBhcmUgaW1wbGVtZW50ZWQgd2l0aCBDTk5zLiBUaGV5IGFjdCBsaWtlIGFkdmVyc2FyaWVzOiBib3RoIGluZGVwZW5kZW50IGFuZCBjb21wbGVtZW50YXJ5LCBjb21wZXRpbmcgd2l0aCBlYWNoIG90aGVyIGFuZCBlbmhhbmNpbmcgZWFjaCBvdGhlcidzIHBlcmZvcm1hbmNlLiAgClRoZSBHQU4sIGNvbnNpc3Rpbmcgb2YgdHdvIG1vZGVscywgaW5oZXJlbnRseSBoYXMgc2VsZi1kaXNjcmltaW5hdGlvbiwgc2VsZi1vcHRpbWl6YXRpb24sIGFuZCBzdHJvbmcgZ2VuZXJhbGl6YXRpb24gYWJpbGl0aWVzLCBhY2hpZXZpbmcgZ29vZCByZXN1bHRzIGluIGltYWdlIHJlY29uc3RydWN0aW9uIGFuZCBnZW5lcmF0aW9uLiBGdXJ0aGVybW9yZSwgaW1wcm92ZWQgR0FOIG1vZGVscyBzdWNoIGFzIENvbmRpdGlvbmFsIEdlbmVyYXRpdmUgQWR2ZXJzYXJpYWwgTmV0d29ya3MgKENHQU4pIGFuZCBDeWNsZSBHZW5lcmF0aXZlIEFkdmVyc2FyaWFsIE5ldHdvcmtzIChDeWNsZSBHQU4pIHByb3ZpZGUgbmV3IHNvbHV0aW9ucyBmb3IgY29tcGxleCBjb21wdXRlciB2aXNpb24gdGFza3MuCgoyLiBBcHBsaWNhdGlvbnMgb2YgQ05OcyBpbiBNZWRpY2FsIEltYWdlIFByb2Nlc3NpbmcgIAoyLjEgSW1hZ2UgU2VnbWVudGF0aW9uICAKSW1hZ2Ugc2VnbWVudGF0aW9uIGludm9sdmVzIGRpdmlkaW5nIHRoZSB0YXJnZXQgaW1hZ2UgaW50byByZWdpb25zIG9mIGludGVyZXN0LCBzdWNoIGFzIGRpc2Vhc2VkIG9yZ2FucywgdGlzc3VlcywgYW5kIHR1bW9ycy4gTW9zdCBtZWRpY2FsIGltYWdlcyBhcmUgZ3JheXNjYWxlLCBhbmQgdGhleSBvZnRlbiBzdWZmZXIgZnJvbSB1bmV2ZW4gZ3JheXNjYWxlIGRpc3RyaWJ1dGlvbiwgc2lnbmlmaWNhbnQgbm9pc2UsIGFuZCB1bmNsZWFyIG9yIGNoYW5naW5nIGJvdW5kYXJpZXMgb2YgdGlzc3VlcyBhbmQgb3JnYW5zLCBtYWtpbmcgdGhlbSBkaWZmaWN1bHQgdG8gaW50ZXJwcmV0IGFuZCB1bmRlcnN0YW5kIGZvciBub24tcHJvZmVzc2lvbmFscy4gVHJhZGl0aW9uYWwgaW1hZ2Ugc2VnbWVudGF0aW9uIG1ldGhvZHMgcHJpbWFyaWx5IHVzZSBsb2NhbCBwaHlzaWNhbCBmZWF0dXJlcyBzdWNoIGFzIGNvbG9yLCB0ZXh0dXJlLCBhbmQgbW9ycGhvbG9neSBmb3IgcmVnaW9uLWJhc2VkIGFuZCBib3VuZGFyeS1iYXNlZCBzZWdtZW50YXRpb24uIENvbW1vbiBtZXRob2RzIGluY2x1ZGUgY2x1c3RlcmluZyBhbGdvcml0aG1zIGluIHRyYWRpdGlvbmFsIG1hY2hpbmUgbGVhcm5pbmcsIHN1Y2ggYXMgZnV6enkgQy1tZWFucyAoRkNNKSBmb3IgbWFnbmV0aWMgcmVzb25hbmNlIGltYWdlIChNUkkpIHNlZ21lbnRhdGlvbiwgSy1tZWFucyBjbHVzdGVyaW5nIGFuZCBXYXRlcnNoZWQgYWxnb3JpdGhtcyBmb3IgaW1hZ2Ugc2VnbWVudGF0aW9uLCBhbmQgU3VwcG9ydCBWZWN0b3IgTWFjaGluZSAoU1ZNKS1iYXNlZCBpbWFnZSBzZWdtZW50YXRpb24sIGFtb25nIG90aGVycy4gVGhlc2UgbWV0aG9kcyBtYWlubHkgdXRpbGl6ZSBsb2NhbCBwaHlzaWNhbCBpbmZvcm1hdGlvbiBhbmQgZG8gbm90IGZ1bGx5IHV0aWxpemUgdGhlIHNlbWFudGljIGluZm9ybWF0aW9uIGNvbnRhaW5lZCBpbiB0aGUgaW1hZ2UgaXRzZWxmLgoKRmlndXJlIDI6IFR5cGljYWwgQ29udm9sdXRpb25hbCBOZXVyYWwgTmV0d29yayBTdHJ1Y3R1cmUgIApGaWd1cmUgMzogQmFzaWMgRnJhbWV3b3JrIG9mIEdlbmVyYXRpdmUgQWR2ZXJzYXJpYWwgTmV0d29ya3MgIAoKQ05Ocywgd2l0aCB0aGVpciBtdWx0aS1ub2RlIGFuZCBtdWx0aS1sYXllcmVkIHN0cnVjdHVyZSwgaGF2ZSB0aGUgYWJpbGl0eSB0byBhdXRvbWF0aWNhbGx5IGV4dHJhY3QgZGVlcCBmZWF0dXJlcyBmcm9tIGlucHV0IGRhdGEsIG1ha2luZyB0aGVtIG1vcmUgc3VpdGFibGUgZm9yIGltYWdlIGNsYXNzaWZpY2F0aW9uIG9yIHJlZ3Jlc3Npb24gdGFza3MuIFRoYW5rcyB0byB0aGUgYWR2ZW50IG9mIEZ1bGx5IENvbnZvbHV0aW9uYWwgTmV0d29ya3MgKEZDTnMpLCBpbWFnZSBzZWdtZW50YXRpb24gdGFza3MgaGF2ZSBmb3VuZCBuZXcgc29sdXRpb25zLiBGQ05zIHJlcGxhY2UgdGhlIGZpbmFsIGZ1bGx5IGNvbm5lY3RlZCBsYXllcnMgb2YgdGhlIGNsYXNzaWNhbCBDTk4gbW8uLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgoqKlNpbXVsYXRpb24gTW9kZWwgRGVzaWduIGFuZCBDb25uZWN0aXZpdHkgUmVhbGl6YXRpb24gb2YgRGlnaXRhbCBUd2luIGluIFNtYXJ0IEZhY3RvcnkqKgoKQWJzdHJhY3Q6IEJhc2VkIG9uIHRoZSBkaXNjcmV0ZSBtYW51ZmFjdHVyaW5nIHNtYXJ0IGZhY3RvcnkgZXhwZXJpbWVudGFsIHBsYXRmb3JtLCB0aGlzIHBhcGVyIGRlZXBseSBhbmFseXplcyBpdHMgc3lzdGVtIGFyY2hpdGVjdHVyZS4gSXQgdXNlcyBGbGV4U2ltIDNEIG1vZGVsaW5nIHRlY2hub2xvZ3kgdG8gYnVpbGQgYSB2aXJ0dWFsIGltYWdlIG9mIHRoZSBzbWFydCBmYWN0b3J5LCBhbmQgYWNoaWV2ZXMgcmVhbC10aW1lIGluZm9ybWF0aW9uIGZsb3cgYW5kIGJpZGlyZWN0aW9uYWwgaW50ZXJhY3Rpb24gYmV0d2VlbiB0aGUgcGh5c2ljYWwgZW50aXR5IGFuZCB0aGUgdmlydHVhbCBtb2RlbCB0aHJvdWdoIGEgU29ja2V0IGNvbW11bmljYXRpb24gbWVjaGFuaXNtLiBUaGUgZGlnaXRhbCB0d2luIHN5c3RlbSBvZiB0aGUgc21hcnQgZmFjdG9yeSBpcyBzdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQsIHByb3ZpZGluZyBpbm5vdmF0aXZlIGlkZWFzIGFuZCBlbXBpcmljYWwgcmVmZXJlbmNlcyBmb3IgZGlnaXRhbCB0d2luIHByYWN0aWNlcy4KCkZ1bmQ6IE5pbmdibyBDaXR5ICJTY2llbmNlIGFuZCBUZWNobm9sb2d5IElubm92YXRpb24gWW9uZ2ppYW5nIDIwMzUiIE1ham9yIEFwcGxpY2F0aW9uIERlbW9uc3RyYXRpb24gUGxhbiDigJQgUmVzZWFyY2ggYW5kIEFwcGxpY2F0aW9uIG9mIHRoZSBDb21tYW5kIGFuZCBEaXNwYXRjaCBEZWNpc2lvbi1NYWtpbmcgU3lzdGVtIEJhc2VkIG9uIERpZ2l0YWwgVHdpbiBQbGF0Zm9ybSBmb3IgTW9sZCBJbmR1c3RyaWFsIFBhcmsgKFByb2plY3QgTm86IDIwMjRaMDA3KQoKS2V5d29yZHM6IFNtYXJ0IGZhY3Rvcnk7IGRpZ2l0YWwgdHdpbiBzaW11bGF0aW9uIHRlY2hub2xvZ3kKCkludHJvZHVjdGlvbjogSW4gcmVjZW50IHllYXJzLCB3aXRoIHRoZSBjb250aW51b3VzIGRldmVsb3BtZW50IG9mIHByb2R1Y3Rpdml0eSwgQ2hpbmHigJlzIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkgaGFzIGdyYWR1YWxseSB0cmFuc2Zvcm1lZCBmcm9tIHRyYWRpdGlvbmFsIG1hbnVmYWN0dXJpbmcgdG8gaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZy4gSW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBoYXMgYmVjb21lIGFuIGltcG9ydGFudCBwYXRoIHRvIGxlYWQgdGhlIHVwZ3JhZGluZyBhbmQgZGV2ZWxvcG1lbnQgb2YgdGhlIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkuIEludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgaXMgbm90IG9ubHkgdGhlIGVuZ2luZSBmb3IgdGhlIHRyYW5zZm9ybWF0aW9uIGFuZCB1cGdyYWRpbmcgb2YgdGhlIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkgYnV0IGFsc28gdGhlIGtleSB0byBwcm9tb3RpbmcgaGlnaC1xdWFsaXR5IGVjb25vbWljIGRldmVsb3BtZW50LiBCeSBpbnRyb2R1Y2luZyBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHRlY2hub2xvZ3ksIENoaW5h4oCZcyBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5IGNhbiBhY2hpZXZlIGEgZnVuZGFtZW50YWwgY2hhbmdlIGluIHRoZSBtb2RlIG9mIHByb2R1Y3Rpb24sIHRyYW5zZm9ybWluZyBmcm9tIGxhYm9yLWludGVuc2l2ZSB0byB0ZWNobm9sb2d5LWludGVuc2l2ZSwgaW1wcm92aW5nIHRoZSBjb3JlIGNvbXBldGl0aXZlbmVzcyBhbmQgaW50ZXJuYXRpb25hbCBzdGF0dXMgb2YgdGhlIGluZHVzdHJ5LiBBdCB0aGUgc2FtZSB0aW1lLCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHByb21vdGVzIHRoZSBkZWVwIGludGVncmF0aW9uIG9mIG1hbnVmYWN0dXJpbmcgYW5kIGluZm9ybWF0aW9uIHRlY2hub2xvZ3ksIGRyaXZpbmcgdGhlIGVtZXJnZW5jZSBvZiBuZXcgYnVzaW5lc3MgZm9ybXMgYW5kIG1vZGVscywgaW5qZWN0aW5nIG5ldyB2aXRhbGl0eSBpbnRvIGVjb25vbWljIGRldmVsb3BtZW50LiBJbiBzbWFydCBtYW51ZmFjdHVyaW5nLCB0aGUgZGlnaXRhbCB0d2luIHNpbXVsYXRpb24gdGVjaG5vbG9neSBvZiBzbWFydCBmYWN0b3JpZXMgaXMgcGxheWluZyBhbiBpbmNyZWFzaW5nbHkgaW1wb3J0YW50IHJvbGUuIFRoZSBkaWdpdGFsIHR3aW4gc2ltdWxhdGlvbiB0ZWNobm9sb2d5IG9mIHRoZSBzbWFydCBmYWN0b3J5IGNhbiBhY2hpZXZlIGRlZXAgaW50ZWdyYXRpb24gYW5kIGFjY3VyYXRlIG1hcHBpbmcgYmV0d2VlbiB0aGUgcGh5c2ljYWwgd29ybGQgYW5kIHRoZSB2aXJ0dWFsIHdvcmxkLiBJdCBub3Qgb25seSBzaW11bGF0ZXMgcHJvZHVjdGlvbiBwcm9jZXNzZXMsIGVxdWlwbWVudCBvcGVyYXRpb24sIGFuZCBwcm9kdWN0aW9uIGxpbmUgb3B0aW1pemF0aW9uIGluIGFkdmFuY2UgdG8gZWZmZWN0aXZlbHkgYXZvaWQgcmlza3MgYW5kIGNvc3Qgd2FzdGUgaW4gYWN0dWFsIG9wZXJhdGlvbnMgYnV0IGFsc28gY29uZHVjdHMgY291bnRsZXNzIGl0ZXJhdGlvbnMgaW4gdGhlIHZpcnR1YWwgZW52aXJvbm1lbnQsIGFjY2VsZXJhdGluZyBwcm9kdWN0IGlubm92YXRpb24gY3ljbGVzLCBwcm92aWRpbmcgZGVjaXNpb24gc3VwcG9ydCBmb3IgbWFuYWdlcnMsIG9wdGltaXppbmcgcmVzb3VyY2UgYWxsb2NhdGlvbiwgYW5kIGltcHJvdmluZyBwcm9kdWN0aW9uIGVmZmljaWVuY3kgYW5kIGZsZXhpYmlsaXR5LiBJbiBjb25jbHVzaW9uLCB0aGUgZGlnaXRhbCB0d2luIHNpbXVsYXRpb24gdGVjaG5vbG9neSBvZiBzbWFydCBmYWN0b3JpZXMgaXMgYSBrZXkgZm9yY2UgaW4gZHJpdmluZyB0aGUgdHJhbnNmb3JtYXRpb24gb2YgbWFudWZhY3R1cmluZyB0byBpbnRlbGxpZ2VudCBhbmQgZWZmaWNpZW50IHN5c3RlbXMuCgoxLiBDb3JlIENvbXBvbmVudHMgb2YgRGlnaXRhbCBUd2luICAKSW4gdGhlIGN1cnJlbnQgd2F2ZSBvZiBpbmR1c3RyaWFsIHRyYW5zZm9ybWF0aW9uIGFuZCB1cGdyYWRpbmcsIHNtYXJ0IGZhY3RvcmllcyBhbmQgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBhcmUgbGVhZGluZyBwcm9mb3VuZCBjaGFuZ2VzIGluIHRoZSBpbmR1c3RyaWFsIHNlY3Rvci4gQXMgYSBtb2RlbCBvZiB0aGUgZnVzaW9uIG9mIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkgbWFuYWdlbWVudCB3aXNkb20gYW5kIGFkdmFuY2VkIHRlY2hub2xvZ3ksIHNtYXJ0IGZhY3RvcmllcyByZWx5IG9uIGZyb250aWVyIHRlY2hub2xvZ2llcyBzdWNoIGFzIHRoZSBJbnRlcm5ldCBvZiBUaGluZ3MsIGF1dG9tYXRpb24sIG5ldHdvcmsgY29tbXVuaWNhdGlvbiwgYW5kIGFydGlmaWNpYWwgaW50ZWxsaWdlbmNlIHRvIGJ1aWxkIGEgaGlnaGx5IGludGVncmF0ZWQgZWNvc3lzdGVtIG9mIHBlb3BsZSwgbWFjaGluZXMsIG1hdGVyaWFscywgYW5kIHRoZSBlbnZpcm9ubWVudC4gVGhpcyBzeXN0ZW0gbm90IG9ubHkgYWNoaWV2ZXMgaW50ZWdyYXRpb24gb2YgcHJvZHVjdGlvbiBhbmQgbWFuYWdlbWVudCBidXQgYWxzbyBsYXlzIGEgc29saWQgZm91bmRhdGlvbiBmb3IgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIHNtYXJ0IHN1cHBseSBjaGFpbi4gSG93ZXZlciwgdGhlIGVmZmljaWVudCBvcGVyYXRpb24gYW5kIG1hbmFnZW1lbnQgb2Ygc21hcnQgZmFjdG9yaWVzIHJlbHkgb24gdGhlIGRlZXAgaW52b2x2ZW1lbnQgb2Ygc2ltdWxhdGlvbiB0ZWNobm9sb2d5IHRvIGV2YWx1YXRlIGFuZCBvcHRpbWl6ZSB0aGVpciBjb21wbGV4IHN5c3RlbXMuIFRoZSBsaW1pdGF0aW9uIG9mIHRyYWRpdGlvbmFsIHNpbXVsYXRpb24gdGVjaG5vbG9neSBsaWVzIGluIGl0cyAib2ZmbGluZSIgbmF0dXJlLCB3aGljaCBtYWtlcyBpdCBkaWZmaWN1bHQgdG8gcmVmbGVjdCB0aGUgZHluYW1pYyBjaGFuZ2VzIG9mIHRoZSBwaHlzaWNhbCBzeXN0ZW0gaW4gcmVhbC10aW1lIGFuZCBmYWlscyB0byBtZWV0IHRoZSByZWFsLXRpbWUgbW9uaXRvcmluZyBhbmQgcHJlY2lzZSBkZWNpc2lvbi1tYWtpbmcgbmVlZHMgb2Ygc21hcnQgZmFjdG9yaWVzLgoKQWdhaW5zdCB0aGlzIGJhY2tncm91bmQsIGRpZ2l0YWwgdHdpbiB0ZWNobm9sb2d5IGVtZXJnZWQgYXMgYSBrZXkgZm9yY2UgZHJpdmluZyB0aGUgZGV2ZWxvcG1lbnQgb2Ygc21hcnQgZmFjdG9yaWVzIGFuZCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nLiBEaWdpdGFsIHR3aW5zIGNyZWF0ZSBhbiBhY2N1cmF0ZSB2aXJ0dWFsIGltYWdlIG9mIHRoZSBwaHlzaWNhbCBlbnRpdHksIGVuYWJsaW5nIHNlYW1sZXNzIGludGVncmF0aW9uIGFuZCByZWFsLXRpbWUgaW50ZXJhY3Rpb24gYmV0d2VlbiB0aGUgcGh5c2ljYWwgd29ybGQgYW5kIHRoZSBkaWdpdGFsIHdvcmxkLiBBIGRpZ2l0YWwgdHdpbiBjb25zaXN0cyBvZiB0aHJlZSBtYWluIHBhcnRzOiB0aGUgcGh5c2ljYWwgZW50aXR5IGluIHRoZSBwaHlzaWNhbCBzcGFjZSwgdGhlIHZpcnR1YWwgZW50aXR5IGluIHRoZSB2aXJ0dWFsIHNwYWNlLCBhbmQgdGhlIGRhdGEgYW5kIGluZm9ybWF0aW9uIGV4Y2hhbmdlIGludGVyZmFjZSBiZXR3ZWVuIHRoZSBwaHlzaWNhbCBhbmQgdmlydHVhbCBzcGFjZXMuIERpZ2l0YWwgdHdpbnMgY2FuIG5vdCBvbmx5IHJlY2VpdmUgcmVhbC10aW1lIGRhdGEgZnJvbSBwaHlzaWNhbCBlbnRpdGllcyB0byBkcml2ZSBzaW11bGF0aW9uIGFuZCBkeW5hbWljIGFkanVzdG1lbnRzIG9mIHZpcnR1YWwgbW9kZWxzIGJ1dCBhbHNvIGZlZWQgYmFjayBvcHRpbWl6YXRpb24gc3RyYXRlZ2llcyBmcm9tIHRoZSB2aXJ0dWFsIHdvcmxkIHRvIHRoZSBwaHlzaWNhbCB3b3JsZCwgZ3VpZGluZyB0aGUgcHJlY2lzZSBleGVjdXRpb24gb2YgYWN0dWFsIHByb2R1Y3Rpb24gcHJvY2Vzc2VzLiBUaGUgY29yZSBvZiBkaWdpdGFsIHR3aW5zIGxpZXMgaW4gdGhlaXIgYmlkaXJlY3Rpb25hbCBkeW5hbWljIG1hcHBpbmcgYW5kIGludGVyYWN0aW9uIG1lY2hhbmlzbXMsIHdoaWNoIGJyZWFrIGRvd24gdGhlIGJvdW5kYXJpZXMgYmV0d2VlbiB0aGUgcGh5c2ljYWwgYW5kIGRpZ2l0YWwgd29ybGRzLCBjcmVhdGluZyBhIGNsb3NlZC1sb29wIGNvbnRyb2wgc3lzdGVtIGZvciBjb21wcmVoZW5zaXZlIHBlcmNlcHRpb24sIHJlYWwtdGltZSBhbmFseXNpcywgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nLCBhbmQgcHJlY2lzZSBleGVjdXRpb24uIFRocm91Z2ggdGhlIGRlZXAgaW50ZWdyYXRpb24gb2YgcGh5cy4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6ClBsZWFzZSBoZWxwIG1lIHdyaXRlIGEgdGVjaG5pY2FsIHBvZGNhc3QgKDEwMDDigJMyMDAwIHdvcmRzKSBpbnRyb2R1Y2luZyB0aGUgbWFpbiBjb250cmlidXRpb25zIG9mIHRoZSBBcGFjaGUgUE9JIG9wZW4tc291cmNlIHRlY2hub2xvZ3kgbGlicmFyeS4KdXNlcjoK5oiR6KaB5YaZ5LiA56+H44CK5pWw5a2X5a2q55Sf5oqA5pyv5Zyo5pm66IO95Yi26YCg5Lit55qE5bqU55So56CU56m244CL77yM6K+35qC55o2u5omA5o+Q5L6b55qE5Y+C6ICD6K665paH55u45YWz6LWE5paZ57uT5ZCI5Lul5LiL6K+m57uG6KaB5rGC5biu5oiR5YaZ55u45YWz5bel5L2c6YOo5YiG44CCCiDlhoXlrrnnu5PmnoTopoHmsYLvvJoKLSDmpoLov7DmlbDlrZflrarnlJ/mioDmnK/nmoTlj5HlsZXljobnqIvlkozln7rmnKzmpoLlv7UKLSDns7vnu5/morPnkIbmmbrog73liLbpgKDpoobln5/mlbDlrZflrarnlJ/nmoTkuLvopoHlupTnlKjlnLrmma8KLSDph43ngrnliIbmnpDlt6XnqIvlrp7ot7XkuK3nmoTlhbPplK7mioDmnK/pmr7ngrkKLSDor6bnu4borqjorrrnm67liY3lt6XnqIvokL3lnLDpnaLkuLTnmoTkuLvopoHmjJHmiJjvvIjmioDmnK/jgIHmiJDmnKzjgIHmoIflh4bljJbnrYnmlrnpnaLvvIkKLSDlr7nmnKrmnaXlj5HlsZXotovlir/ov5vooYzlsZXmnJsKCuaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWei+S4juWFs+mUruaKgOacr+eglOeptiAg6b2Q5aSp5rOTIO+8jCDpu4Tmtbfls7Ag77yMIOabueS5kCDvvIwg5byg56yR56u5ICAg5YyX5Lqs56eR5oqA5aSn5a2mICDvvIwgIOS4reWbveeUteenkeWkp+aVsOaNrueglOeptumZouaciemZkOWFrOWPuCAg77yMICDlpKrmnoHorqHnrpfmnLrogqHku73mnInpmZDlhazlj7ggICDmkZjopoHvvJrkuLrmjqjliqjliLbpgKDkuJrmlbDlrZfljJbjgIHmmbrog73ljJbovazlnovljYfnuqfvvIzmj5Dlh7rmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnovvvIzljIXlkKvmpoLlv7XmqKHlnovopoHmsYLjgIHmpoLlv7XmqKHlnovmnrbmnoTjgIHmpoLlv7XmqKHlnovlh4bnoa7mgKflkozlj6/pnaDmgKfkv53pmpzmlrnms5U05Liq57u05bqm77yM5Zyo6K+l5qaC5b+15qih5Z6L5Z+656GA5LiK5LuL57uN5LqG5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5oqA5pyv5p625p6E77yM5YiG5p6Q5LqG5pWw5a2X5a2q55Sf5bu65qih44CB5Lu/55yf5ZKM5pWw5o2u5YiG5p6Q562J5YWz6ZSu5oqA5pyv77yM5bm25a+55pyq5p2l5oqA5pyv5Y+R5bGV6L+b6KGM5LqG5bGV5pyb44CCICDlhbPplK7or43vvJrmmbrog73liLbpgKA75qaC5b+15qih5Z6LO+aVsOWtl+WtqueUn+WunuS9kyAg5pS256i/5pel5pyf77yaMjAyNC0wMy0yOSAgUmVzZWFyY2ggb24gSW50ZWxsaWdlbnQgTWFudWZhY3R1cmluZyBEaWdpdGFsIFR3aW4gQ29uY2VwdHVhbCBNb2RlbCBhbmQgS2V5IFRlY2hub2xvZ2llcyAgQWJzdHJhY3TvvJpUbyBwcm9tb3RlIHRoZSBkaWdpdGFsIHRyYW5zZm9ybWF0aW9uIGFuZCB1cGdyYWRpbmcgb2Ygc21hcnQgbWFudWZhY3R1cmluZyxhIGNvbmNlcHR1YWwgbW9kZWwgb2YgdGhlIGRpZ2l0YWwgdHdpbiBmb3Igc21hcnQgbWFudWZhY3R1cmluZyBpcyBwcm9wb3NlZC5JdCBpbmNsdWRlcyBmb3VyIGRpbWVuc2lvbnM6cmVxdWlyZW1lbnRzIG9mIHRoZSBjb25jZXB0dWFsIG1vZGVsLGFyY2hpdGVjdHVyZSBvZiB0aGUgY29uY2VwdHVhbCBtb2RlbCxhbmQgbWV0aG9kcyB0byBlbnN1cmUgdGhlIGFjY3VyYWN5IGFuZCByZWxpYWJpbGl0eSBvZiB0aGUgY29uY2VwdHVhbCBtb2RlbC5CYXNlZCBvbiB0aGlzIGNvbmNlcHR1YWwgbW9kZWwsdGhlIHRlY2huaWNhbCBmcmFtZXdvcmsgb2YgdGhlIGRpZ2l0YWwgdHdpbiBmb3Igc21hcnQgbWFudWZhY3R1cmluZyBpcyBpbnRyb2R1Y2VkLktleSB0ZWNobm9sb2dpZXMgc3VjaCBhcyBkaWdpdGFsIHR3aW4gbW9kZWxpbmcsc2ltdWxhdGlvbixhbmQgZGF0YSBhbmFseXNpcyBhcmUgYW5hbHl6ZWQsYW5kIGZ1dHVyZSB0ZWNobm9sb2dpY2FsIGRldmVsb3BtZW50cyBhcmUgcHJvc3BlY3RlZC4gS2V5IHdvcmRz77yaaW50ZWxsaWdlbmNlIG1hbnVmYWN0dXJpbmcgOyBjb25jZXB0dWFsIG1vZGVsIDsgZGlnaXRhbCB0d2luIGVudGl0eSBSZWNlaXZlZO+8mjIwMjQtMDMtMjkgIDAg5byV6KiAIOaZuuiDveWItumAoOaYr+aWsOi0qOeUn+S6p+WKm+W9ouaIkOWSjOWPkeWxleeahOmHjeimgempseWKqOWKm++8jOaYr+W3peS4mjQuMC81LjDnmoTmoLjlv4PvvIzku6Xlj4rmjqjliqjlrp7njrDpq5jmlYjjgIHngbXmtLvjgIHnu7/oibLjgIHmmbrog73nmoTnlJ/kuqfmlrnlvI9bMV3jgILmlbDlrZflrarnlJ/mioDmnK/kvZzkuLrmmbrog73liLbpgKDnmoTlhbPplK7mioDmnK/kuYvkuIDvvIzpgJrov4fmnoTlu7rniannkIborr7lpIfkuI7omZrmi5/mqKHlnovkuYvpl7TnmoTlrp7ml7bmmKDlsITlkozlkIzmraXvvIzkuLrliLbpgKDkuJrnmoTmmbrog73ljJbjgIHpq5jmlYjljJbmj5DkvpvmnInlipvmlK/mjIHvvIzmjqjliqjliLbpgKDkuJrnmoTovazlnovljYfnuqfjgIIg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5piv5Zyo546w5Luj5Lyg5oSf5oqA5pyv44CB572R57uc5oqA5pyv44CB6Ieq5Yqo5YyW5oqA5pyv44CB5ouf5Lq65YyW5pm66IO95oqA5pyv562J5oqA5pyv55qE5Z+656GA5LiK77yM6YCa6L+H5pm66IO95YyW55qE5oSf55+l44CB5Lq65py65Lqk5LqS44CB5Yaz562W5ZKM5omn6KGM5oqA5pyv77yM5a+55Lqn5ZOB44CB5Yi26YCg6L+H56iL5oiW5pW05Liq5bel5Y6C6L+b6KGM6Jma5ouf5Lu/55yf77yM5a6e546w6K6+6K6h6L+H56iL44CB5Yi26YCg6L+H56iL44CB566h55CG6L+H56iL5ZKM5Yi26YCg6KOF5aSH5pm66IO95YyW77yM5o+Q6auY5Yi26YCg5LyB5Lia5Lqn5ZOB56CU5Y+R44CB5Yi26YCg5ZKM566h55CG5pWI546H77yM5piv5L+h5oGv5oqA5pyv44CB5pm66IO95oqA5pyv5LiO6KOF5aSH5Yi26YCg5oqA5pyv55qE5rex5bqm6J6N5ZCI5LiO6ZuG5oiQWzItNF3jgILkvovlpoLvvIzlnKjkuqflk4Horr7orqHmlrnpnaLvvIzpgJrov4fmlbDlrZflrarnlJ/mnoTlu7rkuqflk4HomZrmi5/mqKHlnovvvIzov5vooYzkuqflk4HmgKfog73ku7/nnJ/lkozkvJjljJborr7orqHvvIzmj5Dpq5jkuqflk4Horr7orqHotKjph4/lkozmlYjnjofvvJvlnKjnlJ/kuqfliLbpgKDmlrnpnaLvvIzlrp7ml7bnm5HmjqfnlJ/kuqfov4fnqIvvvIzpooTmtYvorr7lpIfmlYXpmpzvvIzkvJjljJbnlJ/kuqfmtYHnqIvvvIzpmY3kvY7nlJ/kuqfmiJDmnKzvvJvlnKjkvpvlupTpk77nrqHnkIbmlrnpnaLvvIzln7rkuo7mlbDlrZflrarnlJ/lrp7njrDkvpvlupTpk77mlbDmja7nmoTpm4bmiJDlkozlhbHkuqvvvIzkvJjljJbotYTmupDphY3nva7vvIzmj5Dpq5jkvpvlupTpk77ljY/lkIzmlYjnjofjgIIg5pys5paH6aaW5YWI5LuL57uN5LqG5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6L5ZKM5oqA5pyv5qGG5p6277yb5YW25qyh77yM6ZiQ6L+w5LqG5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5YWz6ZSu5oqA5pyv77yM5pyA5ZCO77yM5a+55pyq5p2l5oqA5pyv5Y+R5bGV6L+b6KGM5bGV5pyb44CCIDEg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6LIDEuMSDmpoLlv7XmqKHlnovopoHmsYIg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6LKOS7peS4i+eugOensOKAnOamguW/teaooeWei+KAnSnmmK/lnKjmlbDlrZfnqbrpl7Tlrp7njrDniannkIblrp7kvZPlj4rov4fnqIvnmoTlsZ7mgKfjgIHmlrnms5XjgIHooYzkuLrnrYnnibnmgKfnmoTmlbDlrZfljJblu7rmqKHvvIzmmK/lr7nlrp7kvZPlr7nosaHlpJbpg6jlvaLmgIHjgIHlhoXpg6jmnLrnkIblkozov5DooYzlhbPns7vnrYnnmoTmlbTkvZPmir3osaHmj4/ov7DjgILmpoLlv7XmqKHlnovkuLvopoHlupTmu6HotrPlpoLkuIvopoHmsYLvvJogKDEp5oyB57ut6L+t5Luj5pu05pawWzVd44CCIOWcqOeUn+S6p+i/h+eoi+S4re+8jOWQhOexu+eUn+S6p+aVsOaNruWunuaXtuWPmOWMlu+8jOamguW/teaooeWei+W6lOiDveagueaNrueJqeeQhuWunuS9k+eahOi/kOihjOeKtuaAgeWSjOWPjemmiOS/oeaBr+aMgee7reabtOaWsOi/reS7o++8jOS/neaMgeS4jueJqeeQhuWunuS9k+eahOWQjOatpeOAgiAoMinomZrlrp7kuqTkupLmmKDlsITjgIIg5pSv5oyB6Jma5ouf56m66Ze05LiO54mp55CG56m66Ze055qE5Lqk5LqS77yM6Jma5ouf56m66Ze05pei6IO95a6e5pe25Y+N5pig5Yi26YCg6L+H56iL54mp55CG56m66Ze054q25oCB77yM5pu05bqU6IO96YCa6L+H5pWw5o2u6J6N5ZCI44CB5YiG5p6Q44CB5LyY5YyW44CB5o6n5Yi254mp55CG56m66Ze055qE6L+Q6KGM44CCICgzKeWkmua6kOaVsOaNrumpseWKqOOAgiDliLbpgKDov4fnqIvmtonlj4rmlbDmja7nsbvlnovkvJflpJrvvIzlupTog73ono3lkIjlpJrmupDlvILmnoTmlbDmja7vvIzljIXmi6zlrp7ml7bkvKDmhJ/lmajmlbDmja7lkozljoblj7LmlbDmja7vvIzku6Xmj5Dpq5jmpoLlv7XmqKHlnovnmoTlh4bnoa7mgKfjgIIgKDQp6Ieq6YCC5bqU5Y+C5pWw6LCD5pW044CCIOamguW/teaooeWei+iDveagueaNruS4jeWQjOW6lOeUqOWcuuaZr+aUr+aMgeiHqumAguW6lOiwg+aVtOWPguaVsOiuvue9ru+8jOS7peaPkOmrmOamguW/teaooeWei+WcqOS4jeWQjOeOr+Wig+S4i+eahOmAgueUqOaAp+OAgiAoNSnov63ku6PkvJjljJblhrPnrZZbNl3jgIIg57uT5ZCI6Jma5ouf5Lu/55yf5LiO5pWw5o2u5YiG5p6Q77yM5pSv5oyB6L+t5Luj5LyY5YyW5Yaz562W77yM6L6F5Yqp5a6e546w55Sf5Lqn57O757uf55qE5pm66IO95YyW44CCIDEuMiDmpoLlv7XmqKHlnovmnrbmnoQg5pys5paH5o+Q5Ye655Sx54mp55CG5a6e5L2T44CB5pyN5Yqh5a6e5L2T44CB5pWw5a2X5a2q55Sf5a6e5L2T44CB5pWw5o2u5a6e5L2T5ZKM5ZCE6YOo5YiG6Ze055qE6L+e5o6l5a6e5L2T57uE5oiQ55qE5LqU57u05pWw5a2X5a2q55Sf5qih5Z6L44CC5Z+65LqO5paH54yuWzdd77yM6ZKI5a+55pm66IO95Yi26YCg6aKG5Z+f54m554K577yM5o+Q5Ye65aaC5Zu+MeaJgOekuuamguW/teaooeWei+aetuaehOOAgiAoMSnniannkIblrp7kvZMg5Zu+MSDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnovmnrbmnoQgIOeJqeeQhuWunuS9k+aYr+WfuuehgO+8jOWvueaZuuiDveWItumAoOeahOavj+S4gOS4quaVsOWtl+WtqueUn+W6lOeUqOWcuuaZr++8jOWPr+S7pei/m+S4gOatpeWIkuWIhuWNleWFg+e6p+OAgeezu+e7n+e6p+WSjOWkjeadguezu+e7n+e6p+etieS4jeWQjOeykuW6puWxguasoVs4XeOAguS+i+Wmgu+8jOaVtOS4quaZuuiDveW3peWOgueahOaVsOWtl+WtqueUn++8jOi9pumXtOeUn+S6p+e6v+WPr+S9nOS4uuWNleWFg+e6p++8jOeUn+S6p+e6v+aJgOWcqOi9pumXtOWPr+S9nOS4uuezu+e7n+e6p++8jOiAjOaVtOS4quW3peWOguWImeS9nOS4uuWkjeadguezu+e7n+e6p+OAguWmguaenOS7pei9pumXtOS4uuaVsOWtl+WtqueUn+Wvueixoe+8jOWImeWPr+WwhuaehOaIkOeUn+S6p+e6v+eahOiuvuWkh+S9nOS4uuWNleWFg+e6p++8jOWunueOsOWNleS4quiuvuWkh+eahOebkea1i+OAgeaVhemanOmihOa1i+WSjOmihOitpuS7peWPiue7tOaKpFs5Xe+8m+eUn+S6p+e6v+S9nOS4uuezu+e7n+e6p++8jOWvueeUn+S6p+i/m+ihjOiwg+W6puOAgei/m+W6puaOp+WItuWSjOS6p+WTgei0qOmHj+aOp+WItu+8m+aVtOS4qui9pumXtOWImeS9nOS4uuWkjeadguezu+e7n+e6p++8jOWvueaVtOS4qui9pumXtOeUn+S6p+i/kOihjOi/m+ihjOebkea1i+S4juiwg+W6puS8mOWMluOAgiAoMinmlbDlrZflrarnlJ/lrp7kvZMg5pWw5a2X5a2q55Sf5a6e5L2T5qC55o2u54mp55CG5a6e5L2T55qE5LiN5ZCM5bGC5qyh5ZKM54m554K577yM5LuO5LiN5ZCM5pe26Ze05ZKM56m66Ze05bC65bqm5a+554mp55CG5a6e5L2T6L+b6KGM5o+P6L+w77yM5YyF5ous5Yeg5L2V5qih5Z6L44CB54mp55CG5qih5Z6L44CB6KeE5YiZ5qih5Z6L5ZKM6KGM5Li65qih5Z6L562JWzEwXe+8jOaUr+aMgeS6p+WTgeaVsOWtl+WtqueUn+OAgeeUn+S6p+aVsOWtl+WtqueUn+OAgeiuvuWkh+aVsOWtl+WtqueUn++8jOi0r+epv+aVtOS4quaZuuiDveWItumAoOS6p+WTgeeUn+WRveWRqOacn+euoeeQhuS7t+WAvOmTvuOAgiDlh6DkvZXmqKHlnovmj4/ov7DniannkIblrp7kvZPlpoLlt6XljoLjgIHovabpl7TjgIHnlJ/kuqfnur/jgIHorr7lpIfmiJborr7lpIflhYPlmajku7bnrYnnmoTlvaLnirbjgIHlsLrlr7jjgIHkvY3nva7jgIHnqbrpl7TluIPlsYDmiJboo4XphY3lhbPns7vnrYnvvIzkuIDoiKzlhbfmnInml7bnqbrkuIDoh7TmgKfvvIzluLjnlKjova/ku7blt6XlhbfpgJrov4fkuInnu7Tlu7rmqKHmlrnlvI/liJvlu7rjgIIg54mp55CG5qih5Z6L5Zyo5Yeg5L2V5qih5Z6L5Z+656GA5LiK5aKe5Yqg54mp55CG5a6e5L2T55qE54mp55CG5bGe5oCn44CB57qm5p2f5ZKM54m55b6B562J77yM5aaC57uT5p6E44CB5rWB5L2T44CB55S15Zy644CB56OB5Zy65bu65qih5Lu/55yf562J77yM5Y+v5LuO5b6u6KeC5ZKM5a6P6KeC562J5LiN5ZCM5bC65bqm6YCa6L+H5LiA5Lqb5bel5YW36L2v5Lu26L+b6KGM5pWw5a2m6L+R5Ly85qih5ouf5ZKM5Yi755S744CCIOihjOS4uuaooeWei+aPj+i/sOS4jeWQjOWxguasoeOAgeS4jeWQjOaXtuepuuS4i+eJqeeQhuWunuS9k+WcqOWGheWklumDqOS4jeWQjOS9nOeUqOWboOe0oOWSjOS9nOeUqOacuuWItuS4i+eahOihjOS4uuWSjOihjOS4uua8lOWMlu+8jOaYr+S4gOS4quWkjeadgueahOi/h+eoi++8jOWPr+mHh+eUqOmprOWwlOWPr+Wkq+mTvuOAgeaciemZkOeKtuaAgeacuuetiei/m+ihjOaPj+i/sOOAgiDop4TliJnmqKHlnovmj4/ov7Dpoobln5/jgIHlh4bliJnjgIHnn6Xor4blkoznu4/pqozvvIzkvovlpoLorr7lpIfmk43kvZzop4TnqIvjgIHorr7lpIfosIPkvJjlj4LmlbDjgIHnlJ/kuqfnur/ov5DooYznrqHnkIbop4TliJnjgIHnianmlpnmipXmlL7moIflh4bnrYnvvIzpmo/nnYDop4TliJnnmoTlop7liqDlkozmvJTljJbvvIzkvb/mlbDlrZflrarnlJ/lrp7kvZPpgJDmuJDlvaLmiJDlrp7ml7bliKTmlq3jgIHoh6rkvJjljJbjgIHoh6rmoKHmraPlkozpooTmtYvnrYnog73lipvvvIzlr7nniannkIblrp7kvZPov5vooYzmjqfliLblkozov5DooYzmjIflr7zjgILop4TliJnmqKHlnovlj6/ku6XpgJrov4fmlbTlkIjnjrDmnInnn6Xor4blupPvvIzlubbnu5PlkIjmnLrlmajlrabkuaDmioDmnK/mnaXlj5HmjpjmlrDnmoTop4TliJnvvIzku47ogIzmnoTlu7rlkozlrozlloTjgILpgJrov4fomZrmi5/njrDlrp4oVlIp5ZKM5aKe5by6546w5a6eKEFSKeetieaKgOacr+WvueWHoOS9leaooeWei+OAgeeJqeeQhuaooeWei+OAgeihjOS4uuaooeWei+WSjOinhOWImeaooeWei+etiei/m+ihjOmbhuaIkOOAgeiejeWQiOWSjOS4gOiHtOaAp+agoeaguO+8jOW5tuS4jueJqeeQhuWunuS9k+iZmuWunuWPoOWKoOWPiuiejeWQiOaYvuekuu+8jOaPkOmrmOaVsOWtl+WtqueUn+S9k+eahOecn+WunuaAp+OAgeayiea1uOaAp+WSjOS6pOS6kuaAp+OAgiAoMynmnI3liqHlrp7kvZMg5pyN5Yqh5a6e5L2T5a+55pWw5o2u44CB5qih5Z6L44CB566X5rOV562J6L+b6KGM5pyN5Yqh5YyW5bCB6KOF77yM5Li65pWw5a2X5a2q55Sf5a6e546w5o+Q5L6b5pyN5Yqh5pSv5oyB44CC5qC55o2u5pyN5Yqh57G75Z6L77yM5Y+v5YiG5Li65pWw5o2u5pyN5Yqh44CB5Lu/55yf5pyN5Yqh44CB5Lia5Yqh5pyN5Yqh562J44CC5pWw5o2u5pyN5Yqh5YyF5ous5pWw5o2u6YeH6ZuG44CB5a2Y5YKo44CB5riF5rSX44CB5YWz6IGU44CB6J6N5ZCI44CB5oyW5o6Y44CB5o6l5YWl44CB6K6/6Zeu562J5ZCE57G75pWw5o2u566h55CG44CB5aSE55CG5LiO6K6/6Zeu5pyN5Yqh77yb5Lu/55yf5pyN5Yqh5YyF5ous5bu65qih5Lu/55yf44CB5Lu/55yf5qih5Z6L57uE6KOF44CB5Lu/55yf5qih5Z6L6J6N5ZCI44CB5Lu/55yf5qih5Z6L566h55CG562J44CC5Lia5Yqh5pyN5Yqh5a+55pWw5a2X5a2q55Sf5bqU55So6L+H56iL5Lit6Z2i5ZCR5LiN5ZCM5Yi26YCg6aKG5Z+f44CB5LiN5ZCM5bGC5qyh55So5oi35ruh6Laz5ZCE57G75Yi26YCg5Lia5Yqh6ZyA5rGC55qE5pyN5Yqh6L+b6KGM5bCB6KOF77yM5Lul5ZCE57G76L2v5Lu25b2i5byP5a2Y5Zyo77yM5YyF5ous6Z2i5ZCR546w5Zy65pON5L2c5Lq65ZGY55qE5pyN5Yqh44CB6Z2i5ZCR566h55CG5Yaz562W5Lq65ZGY55qE5pyN5Yqh562J77yM5oyJ6ZyA5L2/55So44CB54G15rS757uE5ZCI77yM5a6e546w5ZCE57G75Yi26YCg5Lia5Yqh6IO95Yqb44CCICg0KeaVsOaNruWunuS9kyDmlbDmja7lrp7kvZPpm4bmiJDono3lkIjkv6Hmga/mlbDmja7jgIHniannkIbmlbDmja7vvIzmu6HotrPkv6Hmga/nqbrpl7TkuI7niannkIbnqbrpl7TnmoTkuIDoh7TmgKfpnIDmsYLvvIzkuLrmmbrog73liLbpgKDmlbDlrZflrarnlJ/mj5DkvpvlhajopoHntKDjgIHlhajmtYHnqIvlkozlhajkuJrliqHnmoTmlbDmja7mlK/mjIHjgIIg54mp55CG5pWw5o2u5YyF5ous5Y+N5pig5ZCE57G754mp55CG5a6e5L2T6KeE5qC844CB5Yqf6IO944CB5oCn6IO944CB5YWz57O7562J55qE6Z2Z5oCB5bGe5oCn5pWw5o2u5LiO5Y+N5pig54mp55CG5a6e5L2T6L+Q6KGM54q25Ya144CB5oCn6IO944CB546v5aKD5Y+C5pWw562J55qE5Yqo5oCB6L+H56iL5pWw5o2u77yM6L+Z5Lqb5pWw5o2u6YCa6L+H6aKE6K6+55qE5qCH5YeG5YC85ZKM5ZCE57G75Lyg5oSf5Zmo6YeH6ZuG55qE5pWw5o2u6L+b6KGM6K6+5a6a5ZKM6I635Y+W44CCIOS/oeaBr+aVsOaNruWMheaLrOaVsOWtl+WtqueUn+aooeWei+aVsOaNruOAgeefpeivhuaVsOaNruOAgeeUn+S6p+WItumAoOS4muWKoeaVsOaNruetieOAguaooeWei+aVsOaNruWPjeaYoOaVsOWtl+WtqueUn+WunuS9k+WHoOS9leaooeWei+OAgeeJqeeQhuaooeWei+OAgeihjOS4uuaooeWei+WSjOinhOWImeaooeWei+etieWtqueUn+aooeWei+aVsO+8m+efpeivhuaVsOaNruWMheaLrOWQhOexu+WItumAoOS4muWKoeagh+WHhuS4juinhOWImeOAgeeUn+S6p+efpeivhuOAgeS4k+Wutuefpeivhuetie+8m+eUn+S6p+WItumAoOS4muWKoeaVsOaNruWMheaLrOeUn+S6p+euoeeQhuOAgeS6p+WTgeeuoeeQhuOAgeeJqeaWmeeuoeeQhuOAgeiwg+W6pueuoeeQhuOAgeS8geS4mueuoeeQhuetieaVsOaNruOAgiAoNSnov57mjqXlrp7kvZMg6L+e5o6l5a6e5L2T5a6e546w54mp55CG5a6e5L2T44CB5pWw5a2X5a2q55Sf5a6e5L2T44CB5pyN5Yqh5a6e5L2T5Lul5Y+K5pWw5o2u5a6e5L2T5LmL6Ze055qE5pmu6YCC5YyW5bel5Lia5LqS6IGU77yM5pSv5oyB6Jma5a6e5a6e5pe25LqS6IGU5LiO6J6N5ZCIWzExXeOAgumAmui/h+WQhOenjeS8oOaEn+WZqOOAgeW1jOWFpeW8j+ezu+e7n+etieWvueeJqeeQhuWunuS9k+aVsOaNrui/m+ihjOWunuaXtumHh+mbhuW5tuS8oOi+k+WIsOWtqueUn+aVsOaNruWunuS9k++8jOe7j+i/h+WtqueUn+aVsOaNruWunuS9k+WkhOeQhuWQjueahOmAmui/h+ebuOW6lOeahOWNj+iuruS8oOi+k+WPjemmiOe7meeJqeeQhuWunuS9k++8jOWunueOsOeJqeeQhuWunuS9k+eahOi/kOihjOS8mOWMluOAgueJqeeQhuWunuS9k+WunuaXtuaVsOaNrumAmui/h+WNj+iuruS8oOi+k+WIsOaVsOWtl+WtqueUn+WunuS9k++8jOi/m+ihjOaVsOWtl+WtqueUn+aooeWei+eahOiZmuWunuS4gOiHtOaAp+agoeato++8jOaVsOWtl+WtqueUn+WunuS9k+S7v+ecn+WIhuaekOetieaVsOaNrui9rOWMluS4uuaOp+WItuaMh+S7pOS8oOi+k+WIsOeJqeeQhuWunuS9k++8jOWvueeJqeeQhuWunuS9k+i/m+ihjOWunuaXtuS6pOS6kuaOp+WItuOAgueJqeeQhuWunuS9k+OAgeaVsOWtl+WtqueUn+WunuS9k+WSjOaVsOaNruWunuS9k+S4juacjeWKoeWunuS9k+WunuaXtui/nuaOpe+8jOi/m+ihjOaVsOaNruOAgeaooeWei+OAgeS4muWKoeacjeWKoeeahOWunuaXtuiuv+mXruS4juS8mOWMluOAgiAxLjMg5qaC5b+15qih5Z6L5YeG56Gu5oCn5ZKM5Y+v6Z2g5oCnIOamguW/teaooeWei+eahOWHhuehruaAp+WSjOWPr+mdoOaAp+aYr+aVsOWtl+WtqueUn+aKgOacr+W6lOeUqOS6juaZuuiDveWItumAoOeahOWFs+mUruOAguWPr+mAmui/h+WmguS4i+aJi+auteS/nemanOamguW/teaooeWei+eahOWHhuehruaAp+WSjOWPr+mdoOaAp+OAgiAoMSnmlbDmja7ono3lkIjjgIIg6ZuG5oiQ5LiN5ZCM5p2l5rqQ5pWw5o2u77yM6YCa6L+H5pe256m65a+56b2Q44CB5qC85byP5a+56b2Q562J5pWw5o2u6J6N5ZCI55qE5pa55byP77yM5o+Q6auY5pWw5o2u55qE5YeG56Gu5oCn5ZKM5LiA6Ie05oCn44CCICgyKeeyvuehruW7uuaooeOAgiDph4fnlKjnsr7noa7mlbDlrabmqKHlnovlkoznrpfms5XvvIzmqKHmi5/niannkIblrp7kvZPnmoTooYzkuLrvvIzkvb/mpoLlv7XmqKHlnovog73lpJ/lh4bnoa7lj43mmKDniannkIblrp7kvZPnmoTnibnmgKfjgIIgKDMp5qaC5b+15qih5Z6L5qCh5YeG44CCIOWvueaVsOWtl+WtqueUn+WunuS9k+WSjOeJqeeQhuWunuS9k+i/m+ihjOaVsOaNruWQjOatpeaAp+WSjOS4gOiHtOaAp+ajgOafpe+8jOehruS/neaVsOaNruWQjOatpeWSjOS4gOiHtOOAgiAoNCnpl63njq/lj43ppojjgIIg5q+U6L6D5pWw5a2X5a2q55Sf5qih5Z6L55qE6L6T5Ye65LiO54mp55CG5a6e5L2T55qE5a6e6ZmF5oCn6IO95beu5byC77yM5ZCR5qih5Z6L5L6d5o2u5beu5byC5oOF5Ya16L+b6KGM5qih5Z6L6LCD5pW077yM5bu656uL5qih5Z6L5LiO54mp55CG5a6e5L2T55qE6Zet546v5Y+N6aaI5py65Yi244CCICg1KeamguW/teaooeWei+aMgee7reiHquWtpuS5oOWSjOS8mOWMluOAgiDpgJrov4fkurrlt6Xmmbrog73nrYnmioDmnK/vvIzov5vooYzmpoLlv7XmqKHlnovmjIHnu63oh6rosIPmlbTlkozoh6rkvJjljJbvvIzmjIHnu63mj5Dpq5jmqKHlnovpooTmtYvlkozliIbmnpDog73lipvjgIIgKDYp5qaC5b+15qih5Z6L5rWL6K+V5ZKM6aqM6K+B44CCIOi/m+ihjOS4jeWQjOWcuuaZr+S4i+amguW/teaooeWei+WHhuehruaAp+WSjOWPr+mdoOaAp+a1i+ivleWSjOmqjOivgeOAgiAoNynlronlhajmgKfkv53miqTjgIIg56Gu5L+d5qaC5b+15qih5Z6L5pWw5o2u5a6J5YWo77yM6Ziy5q2i5pWw5o2u5rOE6Zyy5ZKM56+h5pS544CCIDIg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5oqA5pyv5p625p6EIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+aKgOacr+aetuaehOaPj+i/sOS6huaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWei+S4jeWQjOWunuS9k+S5i+mXtOS6pOS6kueahOaKgOacr+WunueOsOe7k+aehOOAgiDlpoLlm74y5omA56S677yM54mp55CG5bGC5raJ5Y+K5Yi26YCg6aKG5Z+f5Lq65ZGY44CB6K6+5aSH44CB54mp5paZ44CB5bel6Im644CB546v5aKD562J55Sf5Lqn6KaB57Sg44CC5LiN5ZCM5Yi26YCg6aKG5Z+f55qE54mp55CG5a6e5L2T5pyJ5omA5LiN5ZCM44CC5L6L5aaC77yM6ZKi6ZOB5Ya254K85Yqg5bel5LyB5Lia77yM54mp55CG5a6e5L2T5pyJ5Ya254K86auY54KJ44CB55+/55+z44CB6ZO45Lu244CB5Ya254K85o6n5Yi257O757uf562J77yb6Ii56Ii25Yi26YCg5LyB5Lia77yM54mp55CG5a6e5L2T5pyJ6Ii56Ii25Y6f5Z6L44CB6Ii56Ii26YOo5Lu244CB5b6F5L+u6Ii56Ii2562J44CCIOWbvjIg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5oqA5pyv5p625p6EICDmhJ/nn6XkvKDovpPlsYLmj5DkvpvniannkIblsYLkuI3lkIzlsYLmrKHkuYvpl7TnmoTkupLpgJrjgIIg5pWw5o2u5bGC5YyF5ous54mp55CG5a6e5L2T55qE5ZCE57G76Z2Z5oCB5ZKM5Yqo5oCB5pWw5a2X5YyW5L+h5oGv44CCIOaooeWei+WxguWSjOacjeWKoeWxguS4uuW6lOeUqOWxguaPkOS+m+WQhOexu+acjeWKoe+8jOWMheaLrOaooeWei+acjeWKoeOAgeaVsOaNruacjeWKoeOAgeS7v+ecn+acjeWKoeWSjOS4muWKoeacjeWKoeetieOAgiDlupTnlKjlsYLliKnnlKjkuIrov7DlkITlsYLog73lipvvvIzngbXmtLvmnoTlu7rmmbrog73liLbpgKDkuI3lkIzpoobln5/jgIHkuI3lkIznspLluqbnmoTmlbDlrZflrarnlJ/lrp7kvZPvvIzkvovlpoLnlJ/kuqfov4fnqIvmlbDlrZflrarnlJ/jgIHorr7lpIfmlbDlrZflrarnlJ/jgIHlt6XoibrkvJjljJbmlbDlrZflrarnlJ/nrYnvvIzopobnm5bkuqflk4HnlJ/lkb3lkajmnJ/nrqHnkIblhajku7flgLzpk77lkozliLbpgKDlhajmtYHnqIvpk77jgIIgMyDmmbrog73liLbpgKDmlbDlrZflrarnlJ/lhbPplK7mioDmnK8gMy4xIOaVsOWtl+WtqueUn+W7uuaooeaKgOacryDlu7rmqKHmoLnmja7ooqvku7/nnJ/lr7nosaHmiJbns7vnu5/nmoTmnoTmiJDopoHntKDjgIHov5Dliqjop4TlvovjgIHnuqbmnZ/mnaHku7blkozniannkIbnibnmgKfnrYnvvIzlu7rnq4vlvaLlvI/ljJbnmoTkuI7niannkIblrp7kvZPnm7jlr7nlupTnmoTomZrmi5/mlbDlrZflrarnlJ/lrp7kvZPmqKHlnovvvIzlj43mmKDniannkIblrp7kvZPnmoTlpJbop4LjgIHlhoXpg6jnmoTnibnmgKfjgIHnu5PmnoTlkozooYzkuLrjgILlhbfkvZPlnKjmmbrog73liLbpgKDpoobln5/vvIzlu7rmqKHmioDmnK/mmK/pkojlr7nliLbpgKDkuK3nmoTovb3kvZMo5aaC5pWw5o6n5py65bqKKeOAgeWItumAoOi/h+eoiyjlpoLliqDlt6Xov4fnqIvkuK3nmoTng63jgIHlipvnrYkp5ZKM6KKr5Yqg5bel5a+56LGhKOWmguiiq+WItumAoOeahOmjnuacuinnrYnvvIzlupTnlKjmnLrmorDjgIHniannkIbjgIHlipvlrabjgIHorqHnrpfmnLrlkozmlbDlrabnrYnnn6Xor4bvvIzlr7nlu7rmqKHlr7nosaHnmoTkuIDnp43ov5HkvLzooajovr7jgIIg5pWw5a2X5a2q55Sf5a6e5L2T5qih5Z6L5Zyo6IyD5Zu05LiK77yM5pyJ5YWo5bGA57uT5p6E5qih5Z6LKOS+i+WmguW3peWOguWFqOeUn+S6p+e6vynjgIHlsYDpg6jnu5PmnoTmqKHlnoso5aaC5p+Q5LiA6L2m6Ze055Sf5Lqn6KOF572uKeOAgeS6p+WTgee7k+aehOaooeWei+WSjOeUn+S6p+iuoeWIkuiwg+W6puaooeWei+etie+8m+WcqOaWueazleS4iu+8jOacieaVsOWtpuino+aekOaooeWeiyjlpoLnirbmgIHnqbrpl7TmqKHlnosp44CB5Zu+56S64oCU6Kej5ZCI5qih5Z6LKOWmglBldHJp572R5qih5Z6LKeetie+8m+WcqOWKn+iDveS4iu+8jOaciee7k+aehOaPj+i/sOaooeWei+OAgeezu+e7n+WIhuaekOaooeWei+OAgeezu+e7n+iuvuiuoeWunuaWveaooeWei+WSjOezu+e7n+i/kOihjOeuoeeQhuaooeWei+etieOAgiDlu7rmqKHnmoTkuLvopoHov4fnqIvljIXmi6zliLbpgKDmlbDmja7ph4fpm4bkuI7pm4bmiJDjgIHmqKHlnovliJvlu7rjgIHlrp7ml7bmlbDmja7lkIzmraXjgIHpl63njq8uLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpJIGFtIHdyaXRpbmcgYSByZXBvcnQgb24gYW4gb3B0aWNhbCBmaWJlciBjb21tdW5pY2F0aW9uIGV4cGVyaW1lbnQuIENvdWxkIHlvdSBwbGVhc2UgaGVscCBtZSB3cml0ZSB0aGUgdGhlb3J5IHNlY3Rpb24/IFVzZSBzaW1wbGUgbGFuZ3VhZ2UgdG8gZXhwbGFpbiB0aGUgdGhlb3J5IG9mIG9wdGljYWwgZmliZXIgY29tbXVuaWNhdGlvbi4gVGhlIGxlbmd0aCBzaG91bGQgYmUgYmV0d2VlbiAxMDAwIGFuZCAxNTAwIHdvcmRzLiBUaGUga2V5IHRvcGljcyB0byBiZSBjb3ZlcmVkIGluY2x1ZGU6IHRoZSBiYXNpYyBwcmluY2lwbGVzIG9mIG9wdGljYWwgZmliZXIgY29tbXVuaWNhdGlvbiwgdGhlIHRyYW5zbWlzc2lvbiBjaGFyYWN0ZXJpc3RpY3Mgb2Ygb3B0aWNhbCBmaWJlcnMsIHNpZ25hbCBtb2R1bGF0aW9uIGFuZCBkZW1vZHVsYXRpb24gbWV0aG9kcywgYW5kIGNvcmUgY29uY2VwdHMgc3VjaCBhcyBmaWJlciBsb3NzIGFuZCBkaXNwZXJzaW9uLgp1c2VyOgpUaGlzIGlzIGEgcmVwb3J0IG9uIHRoZSB0ZW5zaWxlIGV4cGVyaW1lbnQgb2YgbWF0ZXJpYWwgbWVjaGFuaWNzLCAqKk1hdGVyaWFsKioKCjEuIFNhbXBsZSBJbmZvcm1hdGlvbgoKICAgIE1hdGVyaWFsIE5hbWU6IExvdyBDYXJib24gU3RlZWwgIAogICAgU2FtcGxlIFNoYXBlOiBSb3VuZCBCYXIgIAogICAgU2FtcGxlIERpYW1ldGVyOiAxMCBtbSAgCiAgICBTYW1wbGUgTGVuZ3RoOiAxMDAgbW0gIAogICAgU2FtcGxlIElEOiBBLTAxICAKCjIuIFRlc3RpbmcgRXF1aXBtZW50CgogICAgVGVzdGluZyBNYWNoaW5lIE5hbWU6IElOU1RST04gNTU2OSBUZW5zaWxlIFRlc3RpbmcgTWFjaGluZSAgCiAgICAgICAgTWF4aW11bSBMb2FkOiAxMDAga04gIAogICAgICAgIFRlbnNpbGUgU3BlZWQ6IDIgbW0vbWluICAKICAgICAgICBEaXNwbGFjZW1lbnQgUmVzb2x1dGlvbjogMC4wMDEgbW0gIAogICAgICAgIFN0cmFpbiBNZWFzdXJlbWVudCBTeXN0ZW06IEhpZ2gtUHJlY2lzaW9uIERpc3BsYWNlbWVudCBTZW5zb3IgIAogICAgICAgIENvbnRyb2wgU3lzdGVtOiBEaWdpdGFsIENvbnRyb2wgU3lzdGVtLCBzdXBwb3J0cyByZWFsLXRpbWUgZGlzcGxheSBvZiBmb3JjZS1kaXNwbGFjZW1lbnQgY3VydmUgYW5kIGRhdGEgcmVjb3JkaW5nICAKCjMuIEV4cGVyaW1lbnQgUHJvY2VzcwoKICAgIFNhbXBsZSBQcmVwYXJhdGlvbjogIAogICAgICAgIEluc3BlY3QgdGhlIHNhbXBsZSBzdXJmYWNlIGZvciBjcmFja3Mgb3IgZGVmZWN0cywgZW5zdXJpbmcgdGhlIHN1cmZhY2UgaXMgc21vb3RoLiAgCiAgICAgICAgTWVhc3VyZSB0aGUgaW5pdGlhbCBkaWFtZXRlciBvZiB0aGUgc2FtcGxlIHRvIGJlIDEwLjAgbW0gYW5kIHRoZSBsZW5ndGggdG8gYmUgMTAwIG1tIHVzaW5nIGNhbGlwZXJzLiAgCgogICAgVGVzdGluZyBQcm9jZXNzOiAgCiAgICAgICAgSW5zdGFsbCB0aGUgc2FtcGxlIGluIHRoZSB0ZXN0aW5nIG1hY2hpbmUgZ3JpcHMsIGVuc3VyaW5nIHN5bW1ldHJpYyBsb2FkaW5nLiAgCiAgICAgICAgU3RhcnQgdGhlIHRlbnNpbGUgdGVzdGluZyBtYWNoaW5lLCBzZXQgdGhlIHRlbnNpbGUgc3BlZWQgdG8gMiBtbS9taW4sIGFuZCBiZWdpbiBsb2FkaW5nLiAgCgo0LiBFeHBlcmltZW50YWwgUmF3IERhdGEKCiAgICBTdHJlc3MgKE1QYSkgICBTdHJhaW4gKG1tL21tKSAgIExvYWQgKGtOKSAgIERlZm9ybWF0aW9uIChtbSkgIAogICAgMCAgICAgICAgICAgICAwICAgICAgICAgICAgICAgIDAgICAgICAgICAgIDAgIAogICAgNTAgICAgICAgICAgICAwLjAwMiAgICAgICAgICAgIDAuNSAgICAgICAgIDAuMiAgCiAgICAxMDAgICAgICAgICAgIDAuMDA0ICAgICAgICAgICAgMS4wICAgICAgICAgMC40ICAKICAgIDE1MCAgICAgICAgICAgMC4wMDYgICAgICAgICAgICAxLjUgICAgICAgICAwLjYgIAogICAgMjAwICAgICAgICAgICAwLjAwOCAgICAgICAgICAgIDIuMCAgICAgICAgIDAuOCAgCiAgICAyNTAgICAgICAgICAgIDAuMDEwICAgICAgICAgICAgMi41ICAgICAgICAgMS4wICAKICAgIDMwMCAgICAgICAgICAgMC4wMTIgICAgICAgICAgICAzLjAgICAgICAgICAxLjIgIAogICAgMzUwICAgICAgICAgICAwLjAxNSAgICAgICAgICAgIDMuNSAgICAgICAgIDEuNCAgCiAgICA0MDAgICAgICAgICAgIDAuMDE4ICAgICAgICAgICAgNC4wICAgICAgICAgMS42ICAKICAgIDQ1MCAgICAgICAgICAgMC4wMjAgICAgICAgICAgICA0LjUgICAgICAgICAxLjggIAogICAgNTAwICAgICAgICAgICAwLjAyMiAgICAgICAgICAgIDUuMCAgICAgICAgIDIuMCAgCiAgICA1MTAgICAgICAgICAgIDAuMDIzICAgICAgICAgICAgNS4xICAgICAgICAgMi4xICAKCjUuIFRoZW9yZXRpY2FsIENhbGN1bGF0aW9uCgogICAgWWllbGQgU3RyZW5ndGggKM+DX3kpICAKICAgIFRoZSB5aWVsZCBzdHJlbmd0aCBvZiB0aGUgc3RyZXNzLXN0cmFpbiBjdXJ2ZSBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGV4cGVyaW1lbnRhbCBkYXRhLCBhc3N1bWluZyB0aGUgeWllbGQgcG9pbnQgYXMgdGhlIHBvaW50IGJlZm9yZSB0aGUgc3RyZXNzIHJlYWNoZXMgaXRzIG1heGltdW0gdmFsdWUuICAKICAgICAgICBNYXhpbXVtIFN0cmVzcyDPg19tYXggPSA1MTAgTVBhICAKICAgICAgICBZaWVsZCBTdHJlbmd0aCDPg195ID0gMjUwIE1QYSAoVGhlb3JldGljYWwgVmFsdWUpICAKCiAgICBUZW5zaWxlIFN0cmVuZ3RoICjPg19iKSAgCiAgICBUaGUgdGVuc2lsZSBzdHJlbmd0aCBpcyB0aGUgc3RyZXNzIGF0IHRoZSBtYXhpbXVtIGxvYWQgcG9pbnQgZHVyaW5nIHN0cmV0Y2hpbmcuICAKICAgICAgICBUaGVvcmV0aWNhbCBWYWx1ZSDPg19iID0gNTEwIE1QYSAgCgogICAgRWxvbmdhdGlvbiBBZnRlciBGcmFjdHVyZSAoQSkgIAogICAgQWNjb3JkaW5nIHRvIHRoZSBmb3JtdWxhOiAgCiAgICBBID0gKGxfZiAtIGxfMCkgLyBsXzAgw5cgMTAwJSAgCiAgICBXaGVyZSwgbF9mIGlzIHRoZSBsZW5ndGggb2YgdGhlIHNhbXBsZSBhZnRlciBmcmFjdHVyZSwgYW5kIGxfMCBpcyB0aGUgb3JpZ2luYWwgbGVuZ3RoLiAgCiAgICBBc3N1bWUgdGhlIGxlbmd0aCBhZnRlciBmcmFjdHVyZSBpcyBsX2YgPSAxMDIgbW0sICAKICAgIEEgPSAoMTAyIC0gMTAwKSAvIDEwMCDDlyAxMDAlID0gMiUgIAogICAgICAgIEVsb25nYXRpb24gQWZ0ZXIgRnJhY3R1cmU6IDIlICAKCiAgICBFbGFzdGljIE1vZHVsdXMgKEUpICAKICAgIFRoZSBlbGFzdGljIG1vZHVsdXMgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgc2xvcGUgb2YgdGhlIGluaXRpYWwgbGluZWFyIHNlY3Rpb24gb2YgdGhlIHN0cmVzcy1zdHJhaW4gY3VydmU6ICAKICAgIEUgPSDPgyAvIM61ICAKICAgIFRha2luZyBzdHJlc3MgYXMgMTAwIE1QYSBhbmQgc3RyYWluIGFzIDAuMDA0OiAgCiAgICBFID0gMTAwIE1QYSAvIDAuMDA0ID0gMjUsMDAwIE1QYSA9IDI1IEdQYSAgCiAgICAgICAgRWxhc3RpYyBNb2R1bHVzIEUgPSAyNSBHUGEgKFRoZW9yZXRpY2FsIFZhbHVlKSAgCgo2LiBBbmFseXNpcyBvZiBFeHBlcmltZW50YWwgUmVzdWx0cwoKICAgIFlpZWxkIFN0cmVuZ3RoIG9mIHRoZSBNYXRlcmlhbDogVGhlIGV4cGVyaW1lbnRhbCByZXN1bHQgc2hvd3MgdGhhdCB0aGUgeWllbGQgc3RyZW5ndGggb2YgdGhlIHNhbXBsZSBpcyAyNTAgTVBhLCB3aGljaCBpcyBjbG9zZSB0byB0aGUgdGhlb3JldGljYWwgdmFsdWUgYW5kIG1lZXRzIGV4cGVjdGF0aW9ucy4gIAogICAgVGVuc2lsZSBTdHJlbmd0aDogVGhlIG1heGltdW0gc3RyZXNzIHJlYWNoZXMgNTEwIE1QYSwgbXVjaCBoaWdoZXIgdGhhbiB0aGUgeWllbGQgc3RyZW5ndGgsIGluZGljYXRpbmcgc3Ryb25nIHRlbnNpbGUgY2FwYWJpbGl0eSBvZiB0aGUgbWF0ZXJpYWwuICAKICAgIEVsb25nYXRpb24gQWZ0ZXIgRnJhY3R1cmU6IFRoZSAyJSBlbG9uZ2F0aW9uIGFmdGVyIGZyYWN0dXJlIHNob3dzIHRoYXQgdGhlIG1hdGVyaWFsIGhhcyBhIGNlcnRhaW4gZGVncmVlIG9mIGR1Y3RpbGl0eSwgbWFraW5nIGl0IHN1aXRhYmxlIGZvciBhcHBsaWNhdGlvbnMgdGhhdCByZXF1aXJlIHN1YnN0YW50aWFsIHBsYXN0aWMgZGVmb3JtYXRpb24uICAKICAgIEVsYXN0aWMgTW9kdWx1czogVGhlIGVsYXN0aWMgbW9kdWx1cyBpcyAyNSBHUGEsIGluZGljYXRpbmcgaGlnaCByaWdpZGl0eSwgY29uc2lzdGVudCB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgbG93IGNhcmJvbiBzdGVlbC4gIAoKNy4gQ29uY2x1c2lvbgoKICAgIFRoaXMgdGVuc2lsZSB0ZXN0IHZlcmlmaWVkIHRoZSB5aWVsZCBzdHJlbmd0aCwgdGVuc2lsZSBzdHJlbmd0aCwgYW5kIGR1Y3RpbGl0eSBvZiBsb3cgY2FyYm9uIHN0ZWVsLiBDb21wYXJpbmcgd2l0aCB0aGUgdGhlb3JldGljYWwgdmFsdWVzLCB0aGUgZXhwZXJpbWVudGFsIHJlc3VsdHMgYXJlIGluIGxpbmUgd2l0aCB0aGUgYmFzaWMgcHJpbmNpcGxlcyBvZiBtYXRlcmlhbCBtZWNoYW5pY3MsIHByb3ZpbmcgdGhhdCB0aGlzIG1hdGVyaWFsIGhhcyBnb29kIG1lY2hhbmljYWwgcHJvcGVydGllcyBhbmQgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzdHJ1Y3R1cmFsIGNvbXBvbmVudHMgdGhhdCBiZWFyIGxhcmdlIGxvYWRzLi4gUGxlYXNlIHdyaXRlIGEgZGlzY3Vzc2lvbiBzZWN0aW9uIG9mIGFwcHJveGltYXRlbHkgMzAwMCB3b3JkcyBiYXNlZCBvbiB0aGlzIHJlcG9ydC4gRnJvbSB0aGUgdGhyZWUgZGltZW5zaW9ucyBvZiB0aGVvcmV0aWNhbCBmb3VuZGF0aW9uLCBleHBlcmltZW50YWwgcHJvY2VzcywgYW5kIGRhdGEgYW5hbHlzaXMsIGVsYWJvcmF0ZSBvbiB0aGUgcmVhc29ucyBmb3IgdGhlIGRldmlhdGlvbiBiZXR3ZWVuIHRoZSBleHBlcmltZW50YWwgcmVzdWx0cyBhbmQgdGhlIHRoZW9yZXRpY2FsIHZhbHVlcy4gRm9yIGVhY2ggZGV2aWF0aW9uIHJlYXNvbiwgcHJvcG9zZSBzcGVjaWZpYyBhbmQgZmVhc2libGUgaW1wcm92ZW1lbnQgbWVhc3VyZXMsIGluY2x1ZGluZyBpbnN0cnVtZW50IHNlbGVjdGlvbiwgb3B0aW1pemF0aW9uIG9mIGV4cGVyaW1lbnRhbCBzdGVwcywgZGF0YSBwcm9jZXNzaW5nIG1ldGhvZHMsIGV0Yy4KdXNlcjoK5YW35L2T5Luq5Zmo5Z6L5Y+355qE5oqA5pyv5omL5YaM5oiW6K+05piO5Lmm77yaCuaXpeeri1NVODAxMOWei+WPt1NFTQoxIOW8gOacugrlvIDlvaLosoznlLXohJHvvJrmiZPlvIDlvqrnjq/msLTigJTigJRkaXNwbGF55oyJ6ZKu5Yiw4puU77iP4oCU4oCUIOS8muiHquWKqOW8gOacuuKAlOKAlOeCueWHu+eUqOaItyBzdTgwMTAg5rKh5pyJ5a+G56CBIO+8iOWmguaenOWcqOW8gOacuuS5i+WQjuS4jeWwj+W/g+aKiui9r+S7tuWFs+aOieS6hueCueWHu+eUteiEkeW3puS4i+inkuW8gOWni++8jOeCueWHu3BjLXNlbeWwseWPr+S7peaJk+W8gOi9r+S7tu+8iQoK5byA6IO96LCx55S16ISR77ya54K55Ye76IO96LCx55S16ISR5Li75py66IOM5ZCO55qE6buR6Imy5oyJ6ZKu5Yiw4puU77iP4oCU4oCU5omT5byA5Li75py64oCU4oCU5omT5byA5pi+56S65bGP5byA5YWz4oCU4oCU5omT5byA6L2v5Lu277yIIOeUqOaIt1NVODAxMC1FRFMg5rKh5pyJ5a+G56CB77yJQVp0ZWMKCuavj+asoeW8gOacuuWQjumcgOimgeajgOafpe+8mgoK6auY5YCN5LiL5p+l55yL5piv5ZCm5oqK56OB5oCn5qih5byP5YWz5LqG77ya54K55Ye7c2V0dXDigJTigJTli77pgInkuIrno4HmgKfmqKHlvI8K5qOA5p+l55S15Y6L5piv5LiN5pivM2t277ya54K55Ye76L2v5Lu25bem5LiK6KeS6buR6Imy5pyJ55S15Y6L55qE6YOo5YiGCmZsYXNoaW5n5LiA5LiL77ya54K55Ye75bem5LiK6KeS6buR6Imy5qGG4oCU4oCU54K55Ye7Zmxhc2hpbmfigJTigJTngrnlh7tleGVjdXRl4oCU4oCU5Zyo5Lik5Y+w55S16ISR5Lit6Ze055qE5pys5a2Q5LiK6K6w5b2V55S15rWB5pWw5YC85ZKM5b2T5pel5byA5aeL5pe26Ze0CuiusOW9lUlQ5pWw5YC877ya54K55Ye75Y+z5LiL6KeSbWFpbnRl4oCU4oCU5Zyo5LiK6Z2i55qE5pys5a2Q5LiK6K6w5b2V5LiJ5LiqSVDmlbDlgLwK5q2k5pe25Y+v5Lul6aG65L6/5omT5byA5bCP6KeG6aKR55qE5oyJ6ZKuCu+8iOazqO+8mjMsNOS4pOmhueavj+WkqTXngrnkuZ/pnIDopoHmk43kvZzkuIDmrKHvvIkKCjIg5Yi25qC3CuehruWumueUqOaIt+a1i+eahOaYr+aWremdoui/mOaYr+ihqOmdou+8muW5s+mdouWPsCDmn7Hplb8g77yb5pat6Z2i5Y+wIOafseefreOAggoK5qC35ZOB5Y+w5pyJ5Lik5Liq77yM5LiA5Liq5aSn55qE77yM5LiA5Liq5bCP55qE77yM6K6p55So5oi36Ieq5bex6YCJ5oup6ZyA6KaB55qE44CCCgrlhbPkuo7lr7znlLXog7bvvJrnuqLoibLlr7znlLXog7bpgILlkIjnsonmnKvoja/lk4HnlKjvvIzku7fmoLzotLXvvJvok53oibLlr7znlLXog7bpgILlkIjpmaTnsonmnKvlpJblhbbku5bmoLflk4HvvIzku7fmoLzkvr/lrpzvvIzog73nnIvliLDlrZTjgIIKCuagt+WTgeWPsOS4iui0tOWlveWvvOeUteiDtuWQju+8jOWGjei0tOWlveeUqOaIt+aJgOacieeahOW+hea1i+agt+WTgeOAggoKMyDplYDph5EK5byA5py677yaIHN3aXRjaCBvbuKAlOKAlCBGRkIgb27igJTigJRwb3dlciBvbuKblO+4j+KAlOKAlEJMbG9r77yMIG9wZW4g77yI5q+P5aSp5LiA5p2l5Y+v5Lul5YWI57uZ6ZWA6YeR5Luq5omT5byA77yJCgrlhbPmnLrvvJrngrnlh7tTdGFydOaKveecn+epuuKAlOKAlOaKveWIsEUwIFBh4oCU4oCUQkxsb2vovazliqjliLBjbG9zZeKAlOKAlOeCueWHu+aYvuekuuWxj3N0b3DigJTigJRwb3dlcm9mZuKAlOKAlCBGRkIgb2Zm4oCU4oCUc3dpdGNoIG9mZgoK5YWz5LqO5Za36YeRCgrllrfnmoTlhbblrp7mmK/piZEKCuWWt+mHkSDomb3nhLborr7nva7nmoTmmK80MHPjgIE2MHPvvIzkvYbmmK/lrp7pmYXkuIropoE4LjnliIbpkp/vvIzlm6DkuLropoFhaXLvvIxldmFj77ybCgrllrfph5Hms6jmhI/ngrnvvJrkuIDkuKrmmK/mlbDlrZfopoHlr7nlh4bvvJvkuozmmK/pk77mnaHkuI3opoHljaHliLDph4zpnaLljrvvvJsKCuWWt+mHkeWujOaIkOeahOagh+W/l+aYr+mVgOmHkeS7queahOmch+WKqOWjsOWBnOatouOAggoKNCDnoazku7bov5vmoLcK5Y+v5Lul5Zyo5qC35ZOB5Y+w5LiK55So6K6w5Y+356yU5qCH6K6w5LiA5LiL56ys5LiA5Liq5qC35ZOB55qE5L2N572u44CCCgrmi6fntKfljp/niYfvvIzorqnljp/niYflkozplIHlrprlmajmiJDkuLrmlbTkvZPigJTigJTmiormoLflk4Hlj7DmlL7liLDlubPpnaLlj7DmiJbogIXmlq3pnaLlj7DplIHlrprlmajkuIrigJTigJTpobrml7bpkojmi6fntKfmoLflk4Hlj7DigJTigJTmnInkuKTkuKrlsI/lrZTnmoTmnJ3lkJHoh6rlt7HigJTigJTlsIbkuK3pl7TnmoTljp/niYfpgIbml7bpkojmlrnlkJHnqI3lvq7mi6fmnb7kuIDngrnngrnvvIjpobrlhbPpgIblvIDvvInigJTigJQg5peL6L2s5qC35ZOB5Y+w77yM6LCD5pW06ZSB5a6a5Zmo6J665q+N55qE6auY5bqm77yI6aG65pe26ZKI6ZmN5L2O77yM6YCG5pe26ZKI5Y2H6auY77yJ77yM5L2/5b6X5qC35ZOB5Y+w55qE6YeP6auY5q+U5rWL6auY5Luq56iN5b6u5L2OMS0ybW3vvIjms6jvvJrlpoLmnpzmmK/no4HmgKfmoLflk4HvvIzpnIDopoHnm7jlt64zLTRtbe+8ieKAlOKAlOWQjOaXtuS5n+mcgOimgeehruS/neeUqOaIt+eahOesrOS4gOS4quagt+WTgeWcqOW3puS4iuinkuaWueWQkeKAlOKAlOmhuuaXtumSiOaLp+e0p+S4remXtOWOn+eJh+KAlOKAlOeUqOa0l+iAs+eQg+WQueS4gOWQueagt+WTgeihqOmdoueahOiEj+S4nOilv++8jOi2heWbm+WRqOWQue+8jOS4jeimgeS6kuebuOaxoeafk+agt+WTge+8jOacneWcsOmdouWQue+8jOS4jeimgeWvueedgOahjOmdouWQueaxoeafk+ahjOmdouOAggoK6LW35aeL54q25oCB77yaY2xvc2UgZXZlYwoK54K55Ye7YWly5Zyo5Lqk5o2i5LuT6YeM5rOo5YWl56m65rCU4oCU4oCU5omL5Yqo5oqK5Lqk5o2i5LuT5ouJ5Ye65p2l4oCU4oCU5pS+5LiK5Yi25aSH5aW955qE5qC35ZOB5Y+w5ZCM5pe2bG9ja+S4gOS4i+KAlOKAlOaKiuS6pOaNouS7k+mAgei/m+WOu+KAlOKAlOeCueWHu2V2YWPmir3nnJ/nqbrigJTigJTngrnlh7tvcGVu5omT5byA6Iix6Zeo4oCU4oCU5o6o6L+b5Y675qC35ZOB5p2G5Yiw5pyA6YeM6Z2i55u05YiweGPok53nga/kuq7otbfigJTigJR1bmxvY2vmoLflk4Hmi4nlh7rmoLflk4HmnYbliLDmnIDov5znq6/lkKzliLDnoLDnmoTkuIDlo7DkuI3mlL7miYvigJTigJTngrnlh7tjbG9zZeWFs+mXreS7k+mXqOKAlOKAlOadvuW8gOaLieedgOagt+WTgeadhueahOaJiwoKNSDova/ku7bosIPmlbQK5aaC5p6c5b6F5rWL5qC35ZOB5piv56OB5oCn5qC35ZOB77yM6L2v5Lu2c2V0dXDno4HmgKfmqKHlvI/li77pgInkuIrvvIzlkIzkuIDkuKrkurrnmoTmoLflk4HnlKjlrozkuoborrDlvpfopoHlj5bmtojli77pgInvvIHvvIEKCuWmguaenOaYr+aAleawp+WMlueahOagt+WTgSDkuIDlrpropoHlv6vpgJ/mk43kvZzvvIHvvIEKCueCueWHu+i9r+S7tuW3puS4iuinkm9u5omT5byA55S15Y6L77yI5q2k5pe26ZyA6KaB56iN5b6u562J5LiA5Lya5YS/77yJ4oCU4oCU6LCD5pW05Yiw5L2O5YCN5qih5byPTE3igJTigJTmib7liLDnrKzkuIDkuKrmoLflk4Hotbflp4vkvY3nva4o5aSn5qC35ZOB5Y+wOuacgOW3pui+ue+8iC0xNyww77yJIOW3puS4iuinku+8iC0xNyw177yJ77yb5bCP5qC35ZOB5Y+w77yIIC0xMiww77yJKeKAlOKAlOWIh+aNouWIsOmrmOWAjeS4i+KAlOKAlOiwg+WIsAoKMTBr5bem5Y+z77yI5bel5L2c6Led56a75Li6OOW3puWPs++8ieKAlOKAlOi+ueaUvuWkp+i+ueeyl+iwg+eEtuWQjuWGjee7huiwg+WIsOWwveWPr+iDvea4healmuKAlOKAlOWGjUJBbGlnbuKAlOKAlOKRoCDvuI94eeiwg+eUteWtkOadn+WxheS4reKAlOKAlOKRoXh56LCD5YWJ6ZiR5bGF5Lit77yM5Yiw5LiN5bem5Y+z5pmD77yM6YeM5aSW6ZyH5Yqo5Li65q2i4oCU4oCU4pGi4pGjIO+4j++4j+iwg+eahOaYr+WDj+aVo++8jOiwg+WIsOS4jeW3puWPs+aZg++8jOWPmOaIkOmHjOWklumch+WKqOS4uuatouKAlOKAlOeCueWHu3JlZDHlsI/nqpflj6PvvIxmaW5l57uG6LCD77yM5YaNIHh56LCD5pW05Yiw55S76Z2i5riF5pmw77yM5YaNZmluZee7huiwg+KAlOKAlOS6pOe7meeUqOaIt+a1i+ivlQoK5YWz5LqO5peL6L2s5Zu+5YOP77yM5Yu+6YCJcm90YXRpb24g5Y2z5Y+v6L+b6KGM6LCD5pW044CCCgo2IOiDveiwsQrms6jvvJrmiZPog73osLHlsI/op4bpopHlv4XpobvopoHlhbPmjonvvIEKCui+k+WFpei+k+WHuuiuoeaVsOeOh+mDveimgSAyMDAw5Lul5LiK77yM5YW25a6eMTUwMOS5n+ihjO+8jOWmguaenOWPquacieWHoOeZvuWwseaciemXrumimOS6hu+8jOWZqumfs+S8muW+iOWkmu+8gQoK5aaC5p6c55So5oi36ZyA6KaB5omT6IO96LCx77yM6K6p55So5oi36Ieq5bex55So56yU6K6w5b2V5LiL5oOz6KaB5omT6IO96LCx55qE5L2N572u77ybCgrlt6bovrnnlLXohJHvvJrngrnlh7vova/ku7blt6bkuIrop5Lpu5HoibLpg6jliIbvvIznlLXljovosIPmlbTliLAxNS4wa1bigJTigJTosIPmlbTlt6XkvZzot53nprvvvJrog73osLHpnIDopoHnmoTlt6XkvZzot53nprvkuLoxNW1t77yM5aaC5p6c5q2k5pe25b2i6LKM5Zu+5pi+56S65bel5L2c6Led56a75Li6eO+8jOWPs+S+p3rkuIvmlrnmmL7npLrlt6XkvZzot53nprvkuLp577yM5YiZ6ZyA6KaB5omL5Yqo5Zyo6L2v5Lu25Y+z5L6neuS4i+aWuei+k+WFpeW3peS9nOi3neemu++8iDE1LXgree+8ieKAlOKAlOWcqHjjgIF555qE5L2N572u5omL5Yqo6L6T5YWl55So5oi36K6w5b2V55qE5b6F5omT6IO96LCx55qE5L2N572u77yM56Gu5a6a4oCU4oCU6LCD5pW05aW95Yiw5ZCI6YCC55qE5pS+5aSn5YCN5pWw77ybCgrlj7PovrnnlLXohJHvvJrmiZPlvIDog73osLHova/ku7bvvIzlpoLmnpzmnInkuIrkuIDkuKrkurrpgZfnlZnnmoTmlbDmja7vvIzngrnlh7vlj5bmtojvvIzkuI3opoHngrnigJzmmK/igJ3miJbigJzlkKbigJ3vvIzkvJropobnm5bmjonkuIrkuIDkuKrkurrnmoTmlbDmja7igJTigJTpobnnm67lj6blrZjkuLrvvIzmib7liLDnlKjmiLfnmoTkuKrkurrmlofku7blpLnigJTigJTkvp3mrKHngrnlh7vikaDpnaLliIbluIPlm77ikaHmiavmj4/lm77lg48t5byA5aeL4pGi6YeH6ZuG5YiG5biD5Zu+5pWw5o2uLeW8gOWni+KRo+aehOW7uuWIhuW4g+WbvuaVsOaNruKRpOehruiupOWFg+e0oOKRpee8lui+keWIl+KAlOKAlOmdouenr+iuoeaVsOWIsOi+vjI1dyvml7blsLHlj6/ku6Xli77pgInlj7PkvqfljLox55qE5pa55qGG5Y+v5Lul5YGc5LqG4oCU4oCU5re75Yqg5oiW6ICF5Yig6Zmk5YWD57Sg77ya54K55Ye74oCc6K6h566X5oiQ5YiG4oCdIO+8jOeCueWHu+KAnOe8lui+keWIlyDigJ3vvIzlj6rli77pgIl3dCXjgIF3dCVzaWdtYeOAgeWOn+WtkOeZvuWIhuavlOi/meS4ieS4quWwseihjOKAlOKAlOmdouWIhuW4g+WbvuaooeW8j+S4i++8jOWPs+mUruaKpeWRiu+8jOi/veWKoOKAlOKAlHBvaW50SUTmqKHlvI/kuIvvvIzlj7PplK7miqXlkYrvvIzngrnlh7vov73liqDigJTigJTkv53lrZjlpb3mlofku7bigJTigJTmib7kuIvkuIDkuKrkvY3nva7miZPog73osLHmiJbogIXnu5PmnZ/igJTigJTlnKh1cGxvYWQgZGF0YeaWh+S7tuWkueS4i++8jOaWsOW7uueUqOaIt+mihOe6pue8luWPt+WRveWQjeeahOaWh+S7tuWkue+8jOWmgjI0MjQyMu+8iOatpOaWh+S7tuWkuemHjOmdouWPquiDveaUvuWNleS4quaWh+S7tuaIluiAheWOi+e8qeWMhe+8ie+8jOaKiuaWh+S7tuaUvuWIsOivpeaWh+S7tuWkueS4i+OAguazqO+8muaJk+WujOiDveiwse+8jOiDveiwseWIh+aNouWIsOW9ouiyjO+8jOS4gOWumuaKiueUteWOi+iwg+WbnuWIsDNrViEKNyDmjaLmoLflk4EK54K55Ye76L2v5Lu255qEaG9tZei/m+ihjOWkjeS9jeKAlOKAlOeCueWHu29mZuWFs+mXreeUteWOi+KAlOKAlOeCueWHu29wZW7miZPlvIDkuqTmjaLku5Ppl6jigJTigJTmjqjov5vmoLflk4HmnYbliLDmnIDph4zpnaLnm7TliLB4Y+etieS6rui1t+KAlOKAlGxvY2vplIHkvY/moLflk4Hlj7DigJTigJTmi4nlh7rmoLflk4HmnYbliLDmnIDlpJbpnaLkuI3opoHmnb7miYvvvIzmi4nliLDkvY3kvJrlkKzliLDlo7Dpn7PigJTigJTngrnlh7tjbG9zZeWFs+mXreS6pOaNouS7k+mXqO+8jOmXqOWFs+S4iuS6huWGjeadvuaJi+KAlOKAlOeCueWHu2FpcuiuqeS6pOaNouS7k+i/m+epuuawlO+8jOWujOaIkOWQjmFpcueBr+S4jemXqu+8jOWPmOaIkOm7hOiJsu+8jOW5tuS4lOacieWjsOmfs+aPkOekuuKAlOKAlOaLieW8gOS6pOaNouS7k+KAlOKAlOW3puaJi+aJtuS9j+agt+WTgeWPsO+8jOWPs+aJi3VubG9ja+agt+WTgeadhu+8jOW3puaJi+WPluS4i+agt+WTgeWPsO+8jOaKiuS6pOaNouS7k+aOqOi/m+WOu+KAlOKAlOaKiuS4i+S4gOS4quS6uueahOagt+WTgeWPsOaUvuWIsOmUgeWumuWZqOS4iuOAggoKOCDkuIrkvKDmlbDmja4K5YWz5o6J5b2i6LKM5oiW6ICF6IO96LCx77yI5YWzU0VN6L2v5Lu277yaZmlsZS1leGl0LW9rIO+8ieeahOi9r+S7tuKAlOKAlOWcqOS4u+acuuS4iuaPkuWFpee9keWNoeKAlOKAlOetieW+hXdpZmnov57mjqXliLAyLjRHSHrigJTigJTlj4zlh7vpu4ToibLnmoR1cGxvYWTova/ku7bigJTigJTngrnlh7vkuIrkvKDvvIjkuI3pnIDopoHlhajpgInvvInigJTigJTnrYnlvoXkuIrkvKDlrozmr5XigJTigJTlhbPmjol1cGxvYWTova/ku7bjgIIKCjkg5YWz5py6CuWFs+iDveiwseeUteiEke+8muWFs+aYvuekuuWxj+KAlOKAlOWFs+S4u+acuuWQjumdoueahOm7keiJsuaMiemSruWIsDDnmoTkvY3nva7vvJsK5YWz5b2i6LKM55S16ISR77ya5YWz5pi+56S65bGP4oCU4oCU5YWzZGlzcGxheeKAlOKAlOWFs+W+queOr+awtOOAggoxMCDlhbbku5bvvIjlhbPkuo7lj7DlvI/vvIkK5qC35ZOB5Y+w77ya56qE55qE5LiA5L6n5pyd5ZCR6Ieq5bex77yM6ZyA6KaB55So55m96Imy5p2/6YeP6auY77yM55S16ISR6L6T5YWl5pWw5o2u5q+U5a6e6ZmF5qC35ZOB5Y+w6auY5bqm6auYMW1t77ybCgrova/ku7bvvJrikaDliKDpmaTmjonkuIrkuIDkuKrkurrnmoTlm77niYfvvIzngrlyZW1vdmXvvIzkuI3opoHngrlkZWxldGXvvIzlnLrlj5HlsITlj6/ku6XngrlkZWxldGXvvJvikaHlhbPkuo7ml4vovazlm77lg4/vvIzlj7DlvI/li77pgIlvbu+8jOWcuuWPkeWwhOWLvumAiXJvdGF0aW9u77ybCgrnvZHljaHvvJrlj7DlvI/nmoTlvaLosozlkozlnLrlj5HlsITnmoTlvaLosozjgIHog73osLHlhbHnlKjkuIDkuKrnvZHljaHvvIzlj7DlvI/nmoTog73osLHljZXni6zkuIDkuKrnvZHljaHvvJsKCuiDveiwse+8muWPsOW8j+mcgOimgeWcqOiDveiwseeUteiEkeWPs+S4i+inkuaJi+WKqOi+k+WFpeaUvuWkp+WAjeeOh+OAgeW3peS9nOi3neemu+OAgeeUteWOi++8jOWcuuWPkeWwhOS4jemcgOimgeOAggrluIPpsoHlhYtEOCBYUkQKMS7lvIDmnLrlh4blpIfvvJrpppblhYjmj5LlhaXnlLXmupDnur/vvIzmj5LkuIrpkqXljJnlubbmi6jliLBPTuS9jee9ru+8jOetieW+heWxj+W5leS6rui1t+W5tuWHuueOsOiPnOWNleeVjOmdouOAguWQjOaXtu+8jOivt+ehruS/nVXnm5jvvIjnlKjkuo7nlJ/miJDlsYDln5/nvZHvvInlt7Lmj5LlhaXkuJTkuI3pnIDopoHmi5TkuIvvvIznhLblkI7ov57mjqXmoLflk4HmjK/ojaHlmajjgIIKMi7moLflk4HlpITnkIbvvJrku47moLflk4HkuIrliK7lj5bpgILph4/nsonmnKvvvIjnuqY1MG1n77yJ5bm26L+H562b44CC5L2/55So5Yiu5Yu65bCG57KJ5pyr6YCB5YWl5qC35ZOB5rGg77yM5LmL5ZCO56uW55u05oyv6I2h5Zmo6K6p57KJ5pyr6Ieq54S26JC95YWl6YCa6YGT5YaF44CCCjMu6ZyH6I2h6YCB5qC377ya6KOF5aW95oyv6I2h5Zmo5ZCO77yM5Zyo5Li76I+c5Y2V55WM6Z2i6YCJ5oup4oCcU0hBS0XigJ3lvIDlp4vpnIfojaHvvIzlsIbmoLflk4HpgIHlhaXmoLflk4HmsaDlhoXjgILmoLnmja7pnIDopoHpgInmi6nmjK/ojaHlipvluqbvvIzlvZPmoLflk4Hln7rmnKzlrozlhajov5vlhaXmoLflk4HmsaDlkI7vvIzlgZzmraLpnIfojaHjgIIKNC7ova/ku7blronoo4XkuI7mlbDmja7liIbmnpDvvJpYUkTmlbDmja7liIbmnpDova/ku7blkI3kuLrigJxYUG93ZGVy4oCd77yM5a6J6KOF56iL5bqP5L2N5LqO5Luq5Zmo6Ieq5bim55qEVeebmOS4reOAguWwhuWuieijheeoi+W6j+aLt+i0neiHs+iHquW3seeahOiuvuWkh+W5tui/m+ihjOWuieijhe+8jOWuieijheWujOaIkOWQjumcgOimgea/gOa0u+i9r+S7tuOAguS5i+WQjuWuieijheaVsOaNruW6k++8jOW5tuWwhuWQhOexu+aVsOaNruW6k+aLt+i0neiHs+i9r+S7tuWuieijheebruW9leeahOaMh+WumuaWh+S7tuWkueOAguaJk+W8gOi9r+S7tuWQju+8jOmAieaLqeWImuWImuWuieijheeahOaVsOaNruW6k++8jOW8gOWni+WIhuaekOaVsOaNruOAggo1LuWFs+acuuS4jua4heeQhu+8muS9v+eUqOaMr+iNoeWZqOmch+iNoeWKn+iDveWwhuagt+WTgeeyieacq+aMr+WHuu+8jOW/heimgeaXtueUqOWOi+e8qeawlOaequaIluieuuS4neWIgOa4heeQhuagt+WTgeaxoOOAguWcqOS7quWZqOiPnOWNleagj+S4remAieaLqeKAnHNodXQgZG93buKAneWFs+mXreacuuWZqO+8jOeEtuWQjuaLp+WKqOmSpeWMmeiHs09GRuS9jee9ru+8jOacgOWQjuaLlOWHuuaMr+iNoeWZqOe6v+WPiueUtea6kOe6v+OAggror7fnoa7kv53mjInnhafkuIrov7DmraXpqqTmraPnoa7mk43kvZzku6rlmajvvIzku6Xojrflvpflh4bnoa7nmoTliIbmnpDnu5PmnpzjgIIKCgrnsbvkvLzku6rlmajnmoTmoIflh4bmk43kvZzop4TnqIsoU09QKeaooeadv++8mgrmoIflh4YKCkEu5qC55o2u546v5aKD55qE5rSB5YeA56iL5bqm77yM5Y+v5a6a5pyf77yI5LiA6IisMu+9njPkuKrmnIjvvInlsIbnspfmu6TluIPmi4bkuIvmuIXmtJfkuojku6Xmm7TmjaLvvJsKCkIu5a6a5pyf77yI5LiA6Iis5Li65LiA5ZGo77yJ5a+56LaF5YeA5bel5L2c5Y+w546v5aKD6L+b6KGM54Gt6I+M77yM5ZCM5pe277yM57uP5bi455So57qx5biD5rK+5LiK6YWS57K+5oiW5LiZ6YWu5pyJ5py65rq25YmC5bCG57Sr5aSW5p2A6I+M54Gv5aSW6KGo6Z2i5o+p5pOm5bmy5YeA77yM5L+d5oyB6KGo6Z2i5riF5rSB77yM5ZCm5YiZ5Lya5b2x5ZON5p2A6I+M5pWI5p6c77ybCgpDLuW9k+WKoOWkp+mjjuacuueUteWOi+S4jeiDveS9v+aTjeS9nOmjjumAn+i+vuWIsDAuMzJtL3Pml7bvvIzlv4Xpobvmm7TmjaLpq5jmlYjnqbrmsJTov4fmu6TlmajvvJsKCkQu5pu05o2i6auY5pWI56m65rCU6L+H5ruk5Zmo5pe25Y+v5omT5byA6aG255uW77yM5pu05o2i5pe25bqU5rOo5oSP6L+H5ruk5Zmo5LiK55qE566t5aS05qCH5b+X77yM566t5aS05oyH5ZCR5Y2z5Li65bGC5rCU5rWB5rWB5ZCR77ybCgpFLuabtOaNoumrmOaViOepuuawlOi/h+a7pOawlOWQju+8jOW6lOeUqOWwmOWfg+eykuWtkOiuoeaVsOWZqOajgOafpeWbm+WRqOi+ueahhuWvhuWwgeaYr+WQpuiJr+Wlve+8jOiwg+iKgumjjuacuueUteWOi++8jOS9v+aTjeS9nOW5s+Wdh+mjjumAn+S/neaMgeWcqDAuMzLvvZ4wLjQ4bS9z6IyD5Zu05YaF77yM5YaN5pyJ55SoWTA5LTTlnovlsJjln4PnspLlrZDorqHmlbDlmajmo4Dmn6XmtIHlh4DluqbjgIIKCuaTjeS9nOinhOeoi++8mgoKQS7kvb/nlKjlt6XkvZzlj7Dml7bvvIzlupTmj5DliY0x5bCP5pe25byA5py677yM5ZCM5pe25byA5ZCv57Sr5aSW54Gt6I+M54Gv77yM5aSE55CG5pON5L2c5Yy65YaF6KGo6Z2i56ev57Sv55qE5b6u55Sf54mp77yM5LiJ5Y2B5YiG6ZKf5ZCO5YWz6Zet5p2A6I+M54Gv77ybCgpCLuaWsOWuieijheeahOaIlumVv+acn+acquS9v+eUqOeahOW3peS9nOWPsO+8jOS9v+eUqOWJjeW/hemhu+WvueW3peS9nOWPsOWSjOWRqOWbtOeOr+Wig+WFiOeUqOi2heWHgOecn+epuuWQuOWwmOWZqOaIlueUqOS4jeS6p+eUn+e6pOe7tOeahOW3peWFt+i/m+ihjOa4hea0geW3peS9nOWPsO+8jOWGjemHh+eUqOiNr+eJqeeBreiPjOazleWSjOe0q+Wklue6v+eBreiPjOazlei/m+ihjOeBreiPjOWkhOeQhu+8mwoKQy7mk43kvZzljLrlhoXkuI3lhYHorrjlrZjmlL7kuI3lv4XopoHnmoTnianlk4HvvIzku6Xkv53mjIHmk43kvZzljLrnmoTmtIHlh4DmsJTmtYHmtYHlnovkuI3lj5flubLmibDvvJsKCkQu5pON5L2c5Yy65YaF5bqU5bC96YeP6YG/5YWN5L2c5piO5pi+5omw5Lmx5rCU5rWB5rWB5Z6L55qE5Yqo5L2c77ybRS7mk43kvZzljLrlhoXnmoTkvb/nlKjmuKnluqbkuI3lvpflpKfkuo42MOKEg+OAggoKCn3lrp7pqozlrqTlt7LmnInnmoTmk43kvZzop4TojIPmlofmoaPvvJoKCgrkuIDjgIHlrp7pqozlrqTlrojliJkKCjHjgIHov5vlhaXlrp7pqozlrqTlt6XkvZzml7bvvIzlv4Xpobvnqb/lt6XkvZzmnI3vvIznprvlvIDlrp7pqozlrqTml7blupTohLHkuIvjgILlt6XkvZzmnI3lupTnu4/luLjkv53mjIHmlbTmtIHvvIznpoHmraLnqb/lt6XkvZzmnI3ov5vlhaXlhazlhbHlnLrmiYDjgILlnKjov5vooYzku7vkvZXmnInlj6/og73norDkvKTjgIHliLrmv4DmiJbng6fkvKTnnLznnZvnmoTlt6XkvZzml7bvvIzlv4XpobvmiLTpmLLmiqTnnLzplZzjgILnu4/luLjmjqXop6bmtZPphbjjgIHmtZPnorHnmoTlt6XkvZzkurrlkZjvvIzlupTmiLTog7bluIPmiYvlpZflj4rlt6XkvZzluL3vvIzor5XmoLfliqDlt6Xmk43kvZzml7bkuI3lvpfmiLTmiYvlpZfjgIIKCjLjgIHnpoHmraLlnKjlrp7pqozlrqTlhoXlkLjng5/lj4rlkIPkuJzopb/jgILkuI3lh4bkvb/nlKjor5Xpqozlmajnmr/kvZzojLbmna/miJbppJDlhbfvvIzkuI3lvpfnlKjlmLTlt7Tlk4HlsJ3lkbPpgZPnmoTmlrnms5XmnaXpibTliKvmnKrnn6XnianjgIIKCjPjgIHlt6XkvZzlrozmr5XlkI7nprvlvIDlrp7pqozlrqTml7blupTnlKjogqXnmoLmtJfmiYvjgIIKCjTjgIHlrp7pqozlrqTlgZzmraLkvpvnlLXjgIHkvpvmsLTml7blupTlsIbmsLTmupDjgIHnlLXmupDlvIDlhbPlhajpg6jlhbPkuIrvvIzku6XpmLLmgaLlpI3kvpvnlLXjgIHkvpvmsLTml7bnlLHkuo7lvIDlhbPmnKrlhbPogIzlj5HnlJ/kuovmlYXjgILnprvlvIDlrp7pqozlrqTml7blupTmo4Dmn6Xpl6jjgIHnqpfjgIHmsLTjgIHnlLXjgIHmsJTmmK/lkKblronlhajlj4rlhbPpl63jgIIKCjXjgIHlrp7pqozlrqTlhoXnmoTmr4/nk7bor5XliYLlv4XpobvotLTmnInmmI7mmL7nmoTkuI7or5XliYLnm7jnrKbnmoTmoIfnrb7jgIHlubbmoIfmmI7or5XliYLlkI3np7DjgIHmtZPluqblj4rphY3liLbml6XmnJ/miJbmoIflrprml6XmnJ/jgIIKCjbjgIHpq5jmuKnniankvZPvvIjkvovlpoLliJrnlLHpq5jmuKnngonkuK3lj5blh7rnmoTlnanln5rlkoznk7foiJ/opoHmlL7lnKjlubLlh4DnmoTogJDngavnn7Pmo4nmnb/vvInkuIrmiJbnk7fnm5jkuK3pmYTov5HkuI3lvpfmnInmmJPnh4PnianjgILpnIDnp7Dph4/nmoTlnanln5rlvoXnqI3lhrflkI7mlrnlj6/np7voh7PlubLnh6XlmajkuK3lhrfljbTjgIIKCjfjgIHmk43kvZzml7bkvJrkuqfnlJ/mnInlrrPmsJTkvZPjgIHng5/pm77miJbnsonlsJjml7bvvIzlv4XpobvlnKjoia/lpb3nmoTpgJrpo47mn5zlhoXov5vooYzjgIIKCjjjgIHlrp7pqozlrqTnmoTku6rlmajlnKjmnKrmjozmj6Hlronlhajmk43kvZzop4TnqIvliY3kuI3lvpfpmo/mhI/liqjnlKjjgIIKCuS6jOOAgeeUteWZqOOAgeaYk+eHg+OAgeaYk+eIhgoK77yI5LiA77yJ55S15Zmo5a6J5YWo5pON5L2c6KeE56iLCgox44CB5a6e6aqM5a6k5YaF5LiN5b6X5pyJ6KO46Zyy55qE55S157q/44CB6Ze45YiA5byA5YWz5bqU5a6M5YWo5ZCI5LiK5oiW5pat5byA77yM5Lul6Ziy5q2i5o6l6Kem5LiN5aW95Lqn55Sf54Gr6Iqx6L+b6ICM5byV6LW35piT54eD54mp55qE54iG54K477yM5ouU5LiL5o+S5aS05pe25bqU55So5omL5o2P5L2P5o+S5aS05YaN5ouU77yM5LiN5b6X5omv5ouJ55S157q/44CCCgoy44CB5ZCE56eN55S15Zmo6K6+5aSH5Y+K55S157q/5bqU5aeL57uI5L+d5oyB5bmy54el77yM5LiN5b6X5rW45rm/77yM5Lul6Ziy55+t6Lev5byV6LW354Gr54G+5oiW54On5Z2P55S15Zmo6K6+5aSH44CCCgoz44CBIOWQhOexu+eUteWZqOiuvuWkh+WPkeeUn+W8guW4uOaIluaVhemanOaXtu+8jOW6lOWPiuaXtuaWreeUte+8jOeUseS4k+S4muS6uuWRmOajgOS/ruOAggoKNOOAgSDkv53pmankuJ3nhpTmlq3ml7bvvIzlupTmn6XmuIXljp/lm6DvvIzkuI3lvpfku7vmhI/lop7liqDmiJbliqDnspfkv53pmankuJ3vvIzmm7TkuI3lvpfku6Xpk5zkuJ3ku6Pmm7/jgIIKCu+8iOS6jO+8ieawp+awlOOAgea2suWMluawlOeTtueahOWuieWFqOS9v+eUqOinhOeoiwoKMeOAgeawp+awlOOAgea2suWMluawlOaYr+W8uueDiOeahOWKqeeHg+awlOS9k++8jOawp+awlOOAgea2suWMluawlOeTtuS4gOWumuimgeS4pemYsuS4juayueiEguaOpeinpuOAguW8gOWQr+awp+awlOOAgea2suWMluawlOeTtueahOaJs+aJi+S4jeW+l+ayvuacieayueiEguOAggoKMuOAgeaQrOi/kOawp+awlOOAgea2suWMluawlOeTtuaXtu+8jOW6lOWFiOijheS4iuWuieWFqOW4ve+8jOS4jeWPr+S9v+awlOS9k+WPl+WIsOmch+WKqOaIluaSnuWHu++8jOS7pemYsuatoueIhueCuOOAggoKM+OAgeW9k+awp+awlOOAgea2suWMluawlOeTtuS4uuerluebtOaUvue9ruaXtu+8jOW/hemhu+WbuuWumuaLtOeJouOAggoKNOOAgeawp+awlOOAgea2suWMluawlOeTtuS4jeW+l+S4jueUtee6v+aOpeinpu+8jOS5n+S4jeW+l+aUvuWcqOmdoOi/keWKoOeDreWZqOOAgeaYjueBq+aIluaaluawlOmZhOi/ke+8jOS7peWPiumYs+WFieebtOWwhOeahOWcsOaWue+8jOS7pemYsuatouawlOS9k+WPl+eDreiGqOiDgOW8lei1t+eIhueCuOOAggoKNeOAgeW8gOWQr+WOi+WKm+ihqOmYgOmXqOaXtuimgee8k+aFou+8jOawlOa1geS4jeWPr+WkquW/q++8jOS7pemYsuWGsuWdj+S7quWZqOaIluW8lei1t+edgOeBq++8jOeIhueCuOOAggoK5LiJ44CB54Gt54Gr5LiO5oCl5pWRCgrvvIjkuIDvvInnga3ngasKCjHjgIHlrp7pqozlrqTlpLHngavlkI7vvIzkuIDlrpropoHmsonnnYDjgIHkuI3opoHmg4rmhYzvvIzopoHmoLnmja7otbfngavljp/lm6DkuI7ngavlir/lpKflsI/vvIzlj4rml7bph4flj5bku6XkuIvmjqrmlr3vvJoKCjLjgIHnq4vljbPlhbPmjonnlLXmupDjgIHmsJTmupDlj4rpgJrpo47mnLoKCjPjgIHlsIblrqTlhoXmmJPnh4PjgIHmmJPniIbnianvvIjkvovlpoLljovnvKnmsJTnk7bvvInlsI/lv4PmkKznprvngavmupDvvIzms6jmhI/mkKzliqjml7bliIfkuI3lj6/norDmkp7vvIzku6XlhY3lvJXotbfmm7TlpKfngavngb7jgIIKCjTjgIHov4XpgJ/pgInnlKjpgILlvZPnmoTnga3ngavlmajvvIzlsIbliJrotbfnmoTngavmiZHnga3jgILms6jmhI/kuI3opoHnlKjmsLTmnaXmiZHnga3kuI3murbkuo7msLTnmoTmsrnnsbvku6Xlj4rlhbbku5bmnInmnLrmurbliYLnrYnlj6/nh4PnianjgIIKCjXjgIHlj4rml7bmiqXorabvvJrlronlhajkv53ljavnlLXor53vvJowODcxLTY1OTM3MTEwIOeBq+itpueUteivnTExOeOAggoKNuOAgei6q+S4iuiho+acjeedgOeBq+aXtu+8jOWIh+S4jeWPr+S7u+aEj+i3keWKqOOAguW6lOeUqOefs+ajieavr+ijueWcqOi6q++8jOS7pemalOe7neepuuawlOiAjOeBreeBq+OAguWmguaXoOefs+ajieavr+aIluiWhOavr+aXtu+8jOWPr+WwseWcsOi6uuS4i+aJk+a7muS7peeBreeBq+OAggoKN+OAgeWunumqjOWupOW6lOijheWkh+W/heimgeeahOeBreeBq+iuvuWkh+OAggoKLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKSSBhbSBhIGdyYWR1YXRlIHN0dWRlbnQgaW4gdGhlIGZpZWxkIG9mIGNyeXB0b2dyYXBoeSBhbmQgbmVlZCB0byB3cml0ZSBhIHBhcGVyIG9uIHRoZSBhcHBsaWNhdGlvbiBvZiBxdWFudHVtIGNvbXB1dGluZyBpbiBjcnlwdG9ncmFwaHkuIFBsZWFzZSBwcm92aWRlIHRoZSBjb250ZW50IGZvciB0aGUgcmVsYXRlZCB3b3JrIHNlY3Rpb24gb2YgdGhlIHBhcGVyLCB3aXRoIGEgZm9jdXMgb246Ci0gVGhyZWF0IGFuYWx5c2lzIG9mIFNob3IncyBhbGdvcml0aG0gb24gZXhpc3RpbmcgY3J5cHRvZ3JhcGhpYyBzeXN0ZW1zCi0gTGF0ZXN0IHJlc2VhcmNoIHByb2dyZXNzIG9uIG1haW5zdHJlYW0gcG9zdC1xdWFudHVtIGNyeXB0b2dyYXBoeSB0ZWNobmlxdWVzIChsYXR0aWNlLWJhc2VkIGNyeXB0b2dyYXBoeSwgbXVsdGl2YXJpYXRlIGNyeXB0b2dyYXBoeSwgaGFzaC1iYXNlZCBzaWduYXR1cmVzLCBldGMuKQotIERldGFpbGVkIGRpc2N1c3Npb24gb2YgdGhlIGxhdGVzdCBwcm9ncmVzcyBpbiB0aGUgTklTVCBwb3N0LXF1YW50dW0gY3J5cHRvZ3JhcGh5IHN0YW5kYXJkaXphdGlvbiBwcm9qZWN0LCBlc3BlY2lhbGx5IHRoZSB0ZWNobmljYWwgZGV0YWlscyBvZiB0aGUgZmlyc3QgYmF0Y2ggb2Ygc2VsZWN0ZWQgYWxnb3JpdGhtcyBpbiAyMDIyCi0gU3BlY2lmaWMgZXhhbXBsZXMgb2YgdGhlIGNvbW1lcmNpYWxpemF0aW9uIG9mIHBvc3QtcXVhbnR1bSBjcnlwdG9ncmFwaHkgYnkgbWFqb3IgdGVjaG5vbG9neSBjb21wYW5pZXMgKEdvb2dsZSwgSUJNLCBldGMuKQp1c2VyOgpJIG5lZWQgdG8gd3JpdGUgYSByZXNlYXJjaCBwYXBlciBvbiBhbiBBSS1iYXNlZCBtZWRpY2FsIGltYWdpbmctYXNzaXN0ZWQgZGlhZ25vc2lzIHN5c3RlbS4gUGxlYXNlIGhlbHAgbWUgZHJhZnQgYSBwYXBlciBvdXRsaW5lLgp1c2VyOgpJIGFtIGNvbmR1Y3RpbmcgcmVzZWFyY2ggb24gaW50ZWxsaWdlbnQgYnVpbGRpbmcgZW5lcmd5LXNhdmluZyBjb250cm9sLiBJIGhhdmUgYSBzZXQgb2Ygb3BlcmF0aW9uYWwgZGF0YSBmcm9tIGFuIG9mZmljZSBidWlsZGluZydzIGFpciBjb25kaXRpb25pbmcgc3lzdGVtIHNwYW5uaW5nIDYgbW9udGhzLCBpbmNsdWRpbmcgbWVhc3VyZWQgZGF0YSBzdWNoIGFzIGluZG9vciB0ZW1wZXJhdHVyZSwgaHVtaWRpdHksIENPMiBjb25jZW50cmF0aW9uLCBlbmVyZ3kgY29uc3VtcHRpb24sIGFuZCBvcHRpbWl6YXRpb24gcmVjb3JkcyBvZiB0aGUgYWlyIGNvbmRpdGlvbmluZyBzeXN0ZW0gY29udHJvbCBhbGdvcml0aG0gYmFzZWQgb24gZGVlcCByZWluZm9yY2VtZW50IGxlYXJuaW5nLiBJIGhvcGUgdG8gd3JpdGUgYSBwYXBlciBmb2xsb3dpbmcgdGhlIHN1Ym1pc3Npb24gZ3VpZGVsaW5lcyBvZiB0aGUgam91cm5hbCAqQnVpbGRpbmcgYW5kIEVudmlyb25tZW50Ki4gUGxlYXNlIHByb3ZpZGUgYSBkZXRhaWxlZCBvdXRsaW5lIGZvciB0aGUgcGFwZXIuCnVzZXI6ClBsZWFzZSBoZWxwIG1lIGRyYWZ0IGFuIG91dGxpbmUgZm9yIGEgcmV2aWV3IHBhcGVyIG9uIHRoZSBhcHBsaWNhdGlvbiBvZiBhdWdtZW50ZWQgcmVhbGl0eSB0ZWNobm9sb2d5IGluIGluZHVzdHJpYWwgbWFpbnRlbmFuY2UsIHRhcmdldGluZyBpbmR1c3RyeSBwcm9mZXNzaW9uYWxzLgp1c2VyOgoqKkRlc2lnbiBvZiBEaXN0cmlidXRlZCBIaWdoLUNvbmN1cnJlbmN5IFN5c3RlbSBBcmNoaXRlY3R1cmUgQmFzZWQgb24gUG9sYXJEQioqCgowIEludHJvZHVjdGlvbgoKVGhlIGRlbWFuZCBmb3IgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW1zIGhhcyBiZWVuIGdyb3dpbmcgd2l0aCB0aGUgY29udGludW91cyBkZXZlbG9wbWVudCBvZiBpbnRlcm5ldCBhcHBsaWNhdGlvbnMuIEFuIGltcG9ydGFudCBjaGFsbGVuZ2UgaW4gdGhpcyBjb250ZXh0IGlzIGhvdyB0byBkZXNpZ24gYSBwb3dlcmZ1bCwgcmVsaWFibGUsIGFuZCBzdGFibGUgc3lzdGVtIGZyYW1ld29yay4gQXMgYSBoaWdoLXBlcmZvcm1hbmNlIGFuZCBzY2FsYWJsZSBjbG91ZC1uYXRpdmUgZGlzdHJpYnV0ZWQgZGF0YWJhc2UsIFBvbGFyREIgcHJvdmlkZXMgYSBuZXcgcG9zc2liaWxpdHkgZm9yIGJ1aWxkaW5nIGRpc3RyaWJ1dGVkIGhpZ2gtY29uY3VycmVuY3kgc3lzdGVtcy4gVGhpcyBhcnRpY2xlIGFpbXMgdG8gZXhwbG9yZSB0aGUgZGlzdHJpYnV0ZWQgc3lzdGVtIGFyY2hpdGVjdHVyZSBkZXNpZ24gYmFzZWQgb24gUG9sYXJEQiwgZm9jdXNpbmcgb24ga2V5IGlzc3VlcyBzdWNoIGFzIHBlcmZvcm1hbmNlLCBhdmFpbGFiaWxpdHksIGFuZCBjb25zaXN0ZW5jeS4gSXQgZGVsdmVzIGludG8gdGhlIFBvbGFyREIgYXJjaGl0ZWN0dXJlLCBzdW1tYXJpemVzIHByYWN0aWNhbCBleHBlcmllbmNlLCBwcm92aWRlcyB0ZWNobmljYWwgc3VwcG9ydCBhbmQgcmVmZXJlbmNlIGZvciBhZGRyZXNzaW5nIHRoZSBpbmNyZWFzaW5nIGJ1c2luZXNzIGRlbWFuZHMsIGFuZCBvZmZlcnMgbmV3IGlkZWFzIGFuZCBtZXRob2RzIGZvciBkaXN0cmlidXRlZCBzeXN0ZW0gYXJjaGl0ZWN0dXJlIGRlc2lnbi4KCjEgSW50cm9kdWN0aW9uIHRvIFBvbGFyREIKCjEuMSBBcmNoaXRlY3R1cmUgT3ZlcnZpZXcKClRoZSBkaXN0cmlidXRlZCBzeXN0ZW0gYXJjaGl0ZWN0dXJlIGRlc2lnbiBiYXNlZCBvbiBQb2xhckRCIGlzIGFuIGlubm92YXRpdmUgc29sdXRpb24gdG8gYWRkcmVzcyBsYXJnZS1zY2FsZSBkYXRhIHN0b3JhZ2UgYW5kIGhpZ2gtY29uY3VycmVuY3kgYWNjZXNzIGNoYWxsZW5nZXMgaW4gY2xvdWQgY29tcHV0aW5nIGVudmlyb25tZW50cy4gVGhlIGNvcmUgZmVhdHVyZSBvZiB0aGUgUG9sYXJEQiBhcmNoaXRlY3R1cmUgaXMgdGhlIHNlcGFyYXRpb24gb2Ygc3RvcmFnZSBhbmQgY29tcHV0YXRpb24sIHdoZXJlIGRpc3RyaWJ1dGVkIGRhdGFiYXNlIGNsdXN0ZXJzIGFyZSBidWlsdCB1c2luZyBpbmRlcGVuZGVudCBjb21wdXRlIG5vZGVzIGFuZCBzdG9yYWdlIG5vZGVzLCB0aHVzIGFjaGlldmluZyBob3Jpem9udGFsIHNjYWxhYmlsaXR5IGFuZCBlbGFzdGljIGV4cGFuc2lvbi4gSW4gdGhlIFBvbGFyREIgYXJjaGl0ZWN0dXJlLCBzdG9yYWdlIG5vZGVzIGFyZSByZXNwb25zaWJsZSBmb3IgZGF0YSBwZXJzaXN0ZW5jZSBzdG9yYWdlIGFuZCBtYW5hZ2VtZW50LCB3aGlsZSBjb21wdXRlIG5vZGVzIGhhbmRsZSBTUUwgcmVxdWVzdHMgYW5kIGNvbXB1dGF0aW9uYWwgbG9naWMuIFRoaXMgZGlzdHJpYnV0ZWQgYXJjaGl0ZWN0dXJlIG1vZGVsIGFsbG93cyBQb2xhckRCIHRvIHByb3ZpZGUgaGlnaC1wZXJmb3JtYW5jZSwgaGlnaC1hdmFpbGFiaWxpdHksIGFuZCBoaWdobHkgc2NhbGFibGUgZGF0YWJhc2Ugc2VydmljZXMuIFBvbGFyREIgYWxzbyBhZG9wdHMgYSBzaGFyZWQgYXJjaGl0ZWN0dXJlLCBlbmFibGluZyBkYXRhIHNoYXJpbmcgYW5kIHJldXNlIHRocm91Z2ggYSBzaGFyZWQgc3RvcmFnZSBsYXllciwgdGhlcmVieSByZWR1Y2luZyB0aGUgc3lzdGVtJ3MgY29zdCBhbmQgY29tcGxleGl0eS4gSW4gdGVybXMgb2YgYXJjaGl0ZWN0dXJhbCBkZXNpZ24sIFBvbGFyREIgZnVsbHkgY29uc2lkZXJzIHN5c3RlbSBzZWN1cml0eSBhbmQgcmVsaWFiaWxpdHksIG9mZmVyaW5nIGZlYXR1cmVzIHN1Y2ggYXMgZGF0YSBlbmNyeXB0aW9uLCBhY2Nlc3MgY29udHJvbCwgYW5kIGZhdWx0IHJlY292ZXJ5IHRvIHByb3RlY3QgdXNlciBkYXRhIHNlY3VyaXR5IGFuZCBwcml2YWN5LiBUaGUgUG9sYXJEQiBhcmNoaXRlY3R1cmUgb3V0bGluZXMgYW4gaW5ub3ZhdGl2ZSBkaXN0cmlidXRlZCBkYXRhYmFzZSBtb2RlbCwgcHJvdmlkaW5nIG5ldyBpZGVhcyBhbmQgbWV0aG9kcyBmb3IgYnVpbGRpbmcgaGlnaC1wZXJmb3JtYW5jZSwgaGlnaC1hdmFpbGFiaWxpdHkgZGlzdHJpYnV0ZWQgc3lzdGVtcy4KCjEuMiBGZWF0dXJlcyBhbmQgQWR2YW50YWdlcwoKUG9sYXJEQiBoYXMgbWFueSBvdXRzdGFuZGluZyBmZWF0dXJlcyBhbmQgYWR2YW50YWdlcyB0aGF0IG1ha2UgaXQgdGhlIHByZWZlcnJlZCBkYXRhYmFzZSBzb2x1dGlvbiBmb3IgZW50ZXJwcmlzZXMgYnVpbGRpbmcgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW1zLiBQb2xhckRCIGFkb3B0cyBhIHNoYXJlZCBhcmNoaXRlY3R1cmUsIHNlcGFyYXRpbmcgY29tcHV0YXRpb24gYW5kIHN0b3JhZ2UgdG8gYWNoaWV2ZSBlbGFzdGljIHNjYWxpbmcgYW5kIGhpZ2ggcGVyZm9ybWFuY2UsIGVmZmVjdGl2ZWx5IHNvbHZpbmcgdGhlIGJvdHRsZW5lY2sgaXNzdWVzIG9mIHRyYWRpdGlvbmFsIGRhdGFiYXNlcy4gUG9sYXJEQiBzdXBwb3J0cyBvbmxpbmUgaG9yaXpvbnRhbCBzY2FsaW5nLCBlbmFibGluZyBub2RlcyB0byBiZSBkeW5hbWljYWxseSBhZGRlZCBiYXNlZCBvbiBidXNpbmVzcyByZXF1aXJlbWVudHMgd2l0aG91dCBkb3dudGltZSBvciBkYXRhIG1pZ3JhdGlvbiwgZW5zdXJpbmcgaGlnaCBhdmFpbGFiaWxpdHkgYW5kIHN0YWJpbGl0eS4gUG9sYXJEQiBhbHNvIGZlYXR1cmVzIGludGVsbGlnZW50IG9wdGltaXphdGlvbiBhbmQgYXV0b21hdGVkIG1hbmFnZW1lbnQsIG1ha2luZyBhZGFwdGl2ZSBhZGp1c3RtZW50cyBiYXNlZCBvbiByZWFsLXRpbWUgbG9hZCBhbmQgZGF0YSBhY2Nlc3MgcGF0dGVybnMgdG8gaW1wcm92ZSBzeXN0ZW0gZWZmaWNpZW5jeSBhbmQgcmVzb3VyY2UgdXRpbGl6YXRpb24uIFBvbGFyREIgaXMgaGlnaGx5IGNvbXBhdGlibGUsIGVhc3kgdG8gdXNlLCBzdXBwb3J0cyBzdGFuZGFyZCBTUUwgc3ludGF4IGFuZCBwcm90b2NvbHMsIGFuZCBmYWNpbGl0YXRlcyB0aGUgbWlncmF0aW9uIGFuZCBpbnRlZ3JhdGlvbiBvZiBleGlzdGluZyBhcHBsaWNhdGlvbnMsIHJlZHVjaW5nIHN5c3RlbSBtYWludGVuYW5jZSBhbmQgZGV2ZWxvcG1lbnQgY29zdHMsIHdoaWxlIGltcHJvdmluZyBkZXZlbG9wbWVudCBlZmZpY2llbmN5IGFuZCB1c2VyIGV4cGVyaWVuY2UuIFBvbGFyREIgaXMgYW4gaWRlYWwgY2hvaWNlIGZvciBidWlsZGluZyBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMsIHdpdGggaXRzIHBlcmZvcm1hbmNlLCBzdGFiaWxpdHksIGFuZCBlYXNlIG9mIHVzZSBzdGFuZGluZyBvdXQuCgoyIFJlcXVpcmVtZW50cyBmb3IgRGlzdHJpYnV0ZWQgSGlnaC1Db25jdXJyZW5jeSBTeXN0ZW0gRGVzaWduCgoyLjEgUGVyZm9ybWFuY2UgUmVxdWlyZW1lbnRzIEFuYWx5c2lzCgpXaGVuIGRlc2lnbmluZyBhIGRpc3RyaWJ1dGVkIGhpZ2gtY29uY3VycmVuY3kgc3lzdGVtLCBwZXJmb3JtYW5jZSBpcyBvbmUgb2YgdGhlIG1vc3QgaW1wb3J0YW50IGNvbnNpZGVyYXRpb25zLiBQZXJmb3JtYW5jZSByZXF1aXJlbWVudHMgYW5hbHlzaXMgaXMgdGhlIGtleSBwcm9jZXNzIGZvciBkZXRlcm1pbmluZyB0aGUgcGVyZm9ybWFuY2UgbWV0cmljcyBhbmQgcmVxdWlyZW1lbnRzIHRoYXQgdGhlIHN5c3RlbSBtdXN0IG1lZXQgd2hlbiBwcm9jZXNzaW5nIGxhcmdlLXNjYWxlIGNvbmN1cnJlbnQgcmVxdWVzdHMuIFRvIGFjY29tbW9kYXRlIHRoZSBncm93aW5nIG51bWJlciBvZiB1c2VycywgdGhlIHN5c3RlbSdzIHRocm91Z2hwdXQgbXVzdCBiZSBkeW5hbWljYWxseSBzY2FsYWJsZSB0byBtZWV0IHBlYWsgYWNjZXNzIHByZXNzdXJlLiBBbm90aGVyIGNyaXRpY2FsIGZhY3RvciBhZmZlY3Rpbmcgc3lzdGVtIHBlcmZvcm1hbmNlIGlzIGxhdGVuY3ksIHdoaWNoIHJlZmVycyB0byB0aGUgcmVzcG9uc2UgdGltZSBvZiB0aGUgc3lzdGVtIGluIHByb2Nlc3NpbmcgcmVxdWVzdHMuIEZvciBkaXN0cmlidXRlZCBzeXN0ZW1zLCB0byBtaW5pbWl6ZSB0aGUgaW1wYWN0IG9mIG5ldHdvcmsgbGF0ZW5jeSBhbmQgZGF0YSB0cmFuc21pc3Npb24gbGF0ZW5jeSBvbiB0aGUgc3lzdGVtJ3MgcmVzcG9uc2UgdGltZSwgaXQgaXMgbmVjZXNzYXJ5IHRvIGFkb3B0IGFwcHJvcHJpYXRlIG5ldHdvcmsgYXJjaGl0ZWN0dXJlcyBhbmQgZGF0YSBkaXN0cmlidXRpb24gc3RyYXRlZ2llcyB0byBvcHRpbWl6ZSBzeXN0ZW0gcGVyZm9ybWFuY2UuIFdoZW4gZGVzaWduaW5nIGRpc3RyaWJ1dGVkIGhpZ2gtY29uY3VycmVuY3kgc3lzdGVtcywgcGVyZm9ybWFuY2UgbWV0cmljcyBhbmQgcmVxdWlyZW1lbnRzIG11c3QgYmUgY29tcHJlaGVuc2l2ZWx5IGNvbnNpZGVyZWQuIEluIGFkZGl0aW9uLCB0aGUgc3lzdGVtJ3MgY29uY3VycmVuY3kgY2FwYWJpbGl0eSBhbmQgbG9hZCBiYWxhbmNpbmcgbWVjaGFuaXNtcyBtdXN0IGJlIGNvbnNpZGVyZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHN5c3RlbSBjYW4gZWZmZWN0aXZlbHkgaGFuZGxlIGxhcmdlIHZvbHVtZXMgb2YgY29uY3VycmVudCByZXF1ZXN0cyBhbmQgbWFpbnRhaW4gc3RhYmxlIG9wZXJhdGlvbiBpbiB0aGUgZXZlbnQgb2Ygbm9kZSBmYWlsdXJlcyBvciBuZXR3b3JrIGFibm9ybWFsaXRpZXMuIFBlcmZvcm1hbmNlIHJlcXVpcmVtZW50cyBhbmFseXNpcyBpcyBhIGNydWNpYWwgcGFydCBvZiBkZXNpZ25pbmcgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW1zLiBJdCBpcyBlc3NlbnRpYWwgdG8gZnVsbHkgY29uc2lkZXIgdmFyaW91cyBwZXJmb3JtYW5jZSByZXF1aXJlbWVudHMsIHN1Y2ggYXMgdGhyb3VnaHB1dCBzY2FsYWJpbGl0eSwgbGF0ZW5jeSBzdGFiaWxpdHksIGNvbmN1cnJlbmN5IGNhcGFiaWxpdHksIGFuZCBsb2FkIGJhbGFuY2luZywgdG8gZW5zdXJlIGV4Y2VsbGVudCBzeXN0ZW0gcGVyZm9ybWFuY2UuCgoyLjIgQXZhaWxhYmlsaXR5IFJlcXVpcmVtZW50cyBBbmFseXNpcwoKQW5vdGhlciBjcml0aWNhbCBkZXNpZ24gcmVxdS4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CkkgYW0gYSB0cmFmZmljIGNvbnRyb2wgc3lzdGVtIGVuZ2luZWVyIGFuZCB3b3VsZCBsaWtlIHRvIHdyaXRlIGEgcGFwZXIgb24gdGhlIHRvcGljIG9mIHVyYmFuIHRyYWZmaWMgc2lnbmFsIG9wdGltaXphdGlvbiBjb250cm9sIHN5c3RlbXMuIFBsZWFzZSBoZWxwIG1lIGNvbXBsZXRlIGFuIG91dGxpbmUgZm9yIHRoZSBwYXBlciwgcmV0dXJuaW5nIGl0IGluIGhpZXJhcmNoaWNhbCBmb3JtLiBUaGUgcGFwZXIgc2hvdWxkIGJlIGFpbWVkIGF0IHByb2Zlc3Npb25hbCByZWFkZXJzIGluIHRoZSBmaWVsZCBvZiB0cmFmZmljIGVuZ2luZWVyaW5nLCB3aXRoIGEgcmlnb3JvdXMgYW5kIHByb2Zlc3Npb25hbCB3cml0aW5nIHN0eWxlIHRoYXQgZW1waGFzaXplcyBlbmdpbmVlcmluZyBwcmFjdGljZS4gVGhlIGZvbGxvd2luZyBwb2ludHMgbmVlZCB0byBiZSBoaWdobGlnaHRlZDogMSkgSW50ZWdyYXRpbmcgYWN0dWFsIGRlcGxveW1lbnQgcHJvamVjdCBjYXNlcyBhbmQgZGF0YSB0aGF0IEkgYW0gcmVzcG9uc2libGUgZm9yOyAyKSBIaWdobGlnaHRpbmcgdGVjaG5pY2FsIGlubm92YXRpb24sIGVzcGVjaWFsbHkgaW1wcm92ZW1lbnRzIGluIGFsZ29yaXRobSBvcHRpbWl6YXRpb24gYW5kIHJlYWwtdGltZSBjb250cm9sOyAzKSBUaGUgd3JpdGluZyBzdHlsZSBzaG91bGQgbWVldCB0aGUgc3VibWlzc2lvbiByZXF1aXJlbWVudHMgZm9yIGNvcmUgam91cm5hbHMuICAKTXkgcHJvY2VzcyBkb2N1bWVudGF0aW9uIGFuZCBmb3JtYXR0aW5nIHJlcXVpcmVtZW50cyBmb3IgdGhlIHBhcGVyIGNhbiBiZSByZWZlcmVuY2VkIGluOiAqKjEuIERldGFpbGVkIFRlY2huaWNhbCBEb2N1bWVudGF0aW9uIG9mIHRoZSBBY3R1YWwgRGVwbG95bWVudCBQcm9qZWN0LCBJbmNsdWRpbmcgU3lzdGVtIEFyY2hpdGVjdHVyZSwgQWxnb3JpdGhtIERlc2lnbiwgYW5kIEludGVyZmFjZSBTcGVjaWZpY2F0aW9uczoqKiAgCgpUaGUgc3lzdGVtIGFkb3B0cyBhIGNvbnRyb2wgc2NoZW1lIGNlbnRlcmVkIGFyb3VuZCB0aGUgQVQ4OUM1MSBtaWNyb2NvbnRyb2xsZXIuIEl0IGNhbGN1bGF0ZXMgdGhlIGdyZWVuIGFuZCByZWQgbGlnaHQgZHVyYXRpb25zIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucyB1c2luZyBhbiBhbGdvcml0aG0gYW5kIGRpc3BsYXlzIHRoZSBjb3VudGRvd24gb24gYSBkaWdpdGFsIGRpc3BsYXkuIEF0IHRoZSBzYW1lIHRpbWUsIHRoZSBzeXN0ZW0gY29udHJvbHMgdmVoaWNsZSBwYXNzYWdlIGFuZCBzdG9wcGluZyBieSB0dXJuaW5nIHRoZSB0cmFmZmljIGxpZ2h0cyBhdCB0aGUgaW50ZXJzZWN0aW9uIG9uIGFuZCBvZmYuIEFkZGl0aW9uYWxseSwgdGhlIHNjaGVtZSBpbmNsdWRlcyBhbiBlbWVyZ2VuY3kgdmVoaWNsZSBwYXNzYWdlIGJ1dHRvbi4gV2hlbmV2ZXIgYW4gZW1lcmdlbmN5IHZlaGljbGUgbmVlZHMgdG8gcGFzcywgdGhlIG9wZXJhdG9yIHByZXNzZXMgdGhlIGJ1dHRvbiwgdHVybmluZyBhbGwgdHJhZmZpYyBsaWdodHMgaW4gYm90aCBlYXN0LXdlc3QgYW5kIG5vcnRoLXNvdXRoIGRpcmVjdGlvbnMgcmVkIHdoaWxlIHNvdW5kaW5nIGFuIGFsYXJtIHRvIHByb2hpYml0IHJlZ3VsYXIgdmVoaWNsZXMgZnJvbSBwYXNzaW5nLCBhbGxvd2luZyB0aGUgZW1lcmdlbmN5IHZlaGljbGUgdG8gZ28gZmlyc3QuICAKClRoZSBpbnRlcnNlY3Rpb24gY29uc2lzdHMgb2YgdHdvIG1haW4gcm9hZHMgY3Jvc3NpbmcgZWFjaCBvdGhlciwgd2l0aCBlYWNoIHJvYWQgaGF2aW5nIGEgc2V0IG9mIHJlZCwgeWVsbG93LCBhbmQgZ3JlZW4gdHJhZmZpYyBsaWdodHMsIGFzIHdlbGwgYXMgYSBsZWZ0LXR1cm4gaW5kaWNhdG9yLiBUaGVzZSBsaWdodHMgZGlyZWN0IHZlaGljbGVzIGZvciBzYWZlIHBhc3NhZ2U6IHJlZCBtZWFucyBzdG9wLCBncmVlbiBtZWFucyBnbywgYW5kIHllbGxvdyBzZXJ2ZXMgYXMgYSB3YXJuaW5nIGluZGljYXRpbmcgYW4gaW1taW5lbnQgY2hhbmdlIGJldHdlZW4gcmVkIGFuZCBncmVlbi4gVGhlIGR1cmF0aW9uIG9mIHRoZSB5ZWxsb3cgbGlnaHQgaXMgc2V0IGFzIHRoZSBzaGFyZWQgc3RvcHBpbmcgdGltZSBmb3IgYm90aCB0aGUgZWFzdC13ZXN0IGFuZCBub3J0aC1zb3V0aCByb2Fkcy4gVGhlIGxlZnQtdHVybiBpbmRpY2F0b3IgYWxsb3dzIHZlaGljbGVzIG9uIHRoZSBtYWluIHJvYWQgdG8gbWFrZSBhIGxlZnQgdHVybi4gIAoKVGhpcyBzeXN0ZW0gdXRpbGl6ZXMgdGhlIEFUODlDNTEgbWljcm9jb250cm9sbGVyIGFzIGl0cyBjb3JlIGNvbnRyb2wgY29tcG9uZW50LiBJdCBlbXBsb3lzIHRpbWVycyB0byBjb250cm9sIHRoZSBvbi9vZmYgc3RhdGVzIG9mIHRoZSB0cmFmZmljIGxpZ2h0cyBjb25uZWN0ZWQgdG8gdGhlIFAwIHBvcnQgd2hpbGUgZGlzcGxheWluZyB0aGUgY291bnRkb3duIG9uIGFuIDgtc2VnbWVudCBkaWdpdGFsIGRpc3BsYXkgY29ubmVjdGVkIHRvIHRoZSBQMSBhbmQgUDIgcG9ydHMuIFRoZSBjaXJjdWl0IGRpYWdyYW0gbWFpbmx5IGNvbnNpc3RzIG9mIGEgcG93ZXIgc3VwcGx5IGNpcmN1aXQsIGEgdHJhZmZpYyBsaWdodCBkaXNwbGF5IGNpcmN1aXQsIGEgdHJhZmZpYyBsaWdodCBjb3VudGRvd24gdGltZXIgY2lyY3VpdCwgYW5kIGFuIGVtZXJnZW5jeSBidXR0b24gKEsxKSBjaXJjdWl0LiAgCgpUaGUgcG93ZXIgc3VwcGx5IGFkb3B0cyBhIHJlZ3VsYXRlZCBwb3dlciBjaXJjdWl0IHRoYXQgb3V0cHV0cyBhIHN0YWJsZSArNVYgREMgdm9sdGFnZS4gVGhlIElDIHVzZXMgdGhlIGludGVncmF0ZWQgdm9sdGFnZSByZWd1bGF0b3IgNzgwNSwgYSBzdGFuZGFyZGl6ZWQsIHdpZGVseSB1c2VkIGxpbmVhciB2b2x0YWdlIHJlZ3VsYXRvciB3aXRoIGFkdmFudGFnZXMgc3VjaCBhcyBzbWFsbCBzaXplLCBsb3cgY29zdCwgZ29vZCBwZXJmb3JtYW5jZSwgaGlnaCByZWxpYWJpbGl0eSwgYW5kIGVhc2Ugb2YgdXNlLiBJdCBpcyBvbmUgb2YgdGhlIG1vc3Qgd2lkZWx5IGFwcGxpZWQgbW9ub2xpdGhpYyBpbnRlZ3JhdGVkIHJlZ3VsYXRvcnMgaW4gcmVndWxhdGVkIHBvd2VyIHN1cHBsaWVzLiBXaGVuIHRoZSBvdXRwdXQgY3VycmVudCBpcyByZWxhdGl2ZWx5IGhpZ2gsIHRoZSA3ODA1IHNob3VsZCBiZSBlcXVpcHBlZCB3aXRoIGEgaGVhdCBzaW5rLiBDYXBhY2l0b3IgQzMgc2VydmVzIGFzIHRoZSBpbnB1dCBmaWx0ZXIgY2FwYWNpdG9yLCB3aGlsZSBDNSBhY3RzIGFzIHRoZSBvdXRwdXQgZmlsdGVyIGNhcGFjaXRvci4gIAoKVGhlIHN5c3RlbSB1c2VzIGEgMjIwViBBQyBwb3dlciBzb3VyY2UuIEFmdGVyIHBhc3NpbmcgdGhyb3VnaCBhIDVWIGFkYXB0ZXIgYW5kIGZpbHRlcmluZywgaXQgZm9ybXMgYSByZWxhdGl2ZWx5IHVuc3RhYmxlIERDIHZvbHRhZ2UgYXQgdGhlIFZpbiBhbmQgR05EIHRlcm1pbmFscyBvZiB0aGUgZml4ZWQgdGhyZWUtdGVybWluYWwgdm9sdGFnZSByZWd1bGF0b3IgTE03ODA1LiBUaGlzIHZvbHRhZ2Ugb2Z0ZW4gZmx1Y3R1YXRlcyBkdWUgdG8gdmFyaWF0aW9ucyBpbiB0aGUgbWFpbnMgdm9sdGFnZSBvciBsb2FkIGNoYW5nZXMuIEFmdGVyIExNNzgwNSByZWd1bGF0aW9uIGFuZCBjYXBhY2l0b3IgZmlsdGVyaW5nLCB0aGUgb3V0cHV0IHNpZGUgb2YgdGhlIHJlZ3VsYXRlZCBwb3dlciBzdXBwbHkgZ2VuZXJhdGVzIGEgaGlnaGx5IGFjY3VyYXRlIGFuZCBzdGFibGUgREMgdm9sdGFnZS4gIAoKVGhpcyBkZXNpZ24gYWRvcHRzIEMgbGFuZ3VhZ2UgYXMgdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlLiBDb21wYXJlZCB0byBhc3NlbWJseSBsYW5ndWFnZSwgQyBnZW5lcmF0ZXMgbWFjaGluZSBjb2RlIHdpdGggc2ltaWxhciBlZmZpY2llbmN5IHdoaWxlIG9mZmVyaW5nIG11Y2ggYmV0dGVyIHJlYWRhYmlsaXR5IGFuZCBwb3J0YWJpbGl0eS4gQWx0aG91Z2ggYXNzZW1ibHkgbGFuZ3VhZ2UgYWxsb3dzIGZvciBoaWdobHkgZWZmaWNpZW50IG1hY2hpbmUgY29kZSBnZW5lcmF0aW9uLCBpdCBpcyBkaWZmaWN1bHQgdG8gcmVhZCwgZXNwZWNpYWxseSBmb3IgY29tcGxleCBwcm9ncmFtcy4gQyBsYW5ndWFnZSwgaW4gbW9zdCBjYXNlcywgbWF0Y2hlcyBhc3NlbWJseSBsYW5ndWFnZSBpbiBtYWNoaW5lIGNvZGUgZWZmaWNpZW5jeSB3aGlsZSBncmVhdGx5IHN1cnBhc3NpbmcgaXQgaW4gcmVhZGFiaWxpdHkgYW5kIHBvcnRhYmlsaXR5LiBBZGRpdGlvbmFsbHksIEMgYWxsb3dzIGZvciBlbWJlZGRlZCBhc3NlbWJseSBjb2RlIHRvIGhhbmRsZSByZWFsLXRpbWUgY3JpdGljYWwgdGFza3MuICAKCkZvciBkZXZlbG9wbWVudCB0aW1lLCBtZWRpdW0tdG8tbGFyZ2Ugc29mdHdhcmUgcHJvamVjdHMgd3JpdHRlbiBpbiBDIGdlbmVyYWxseSBoYXZlIGEgc2lnbmlmaWNhbnRseSBzaG9ydGVyIGRldmVsb3BtZW50IGN5Y2xlIHRoYW4gdGhvc2Ugd3JpdHRlbiBpbiBhc3NlbWJseS4gQ29uc2lkZXJpbmcgdGhlc2UgYWR2YW50YWdlcywgdGhpcyBkZXNpZ24gdXNlcyBDIGFzIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZS4gIAoKVGhlIHByb2dyYW1taW5nIGVudmlyb25tZW50IGNob3NlbiBmb3IgdGhpcyBwcm9qZWN0IGlzIEtlaWwgwrVWaXNpb24gMi4wLiBUaGlzIHNvZnR3YXJlIHN1cHBvcnRzIHZhcmlvdXMgTUNTLTUxIGFyY2hpdGVjdHVyZSBtaWNyb2NvbnRyb2xsZXJzIGZyb20gZGlmZmVyZW50IG1hbnVmYWN0dXJlcnMsIGludGVncmF0aW5nIGVkaXRpbmcsIGNvbXBpbGluZywgYW5kIHNpbXVsYXRpb24gZnVuY3Rpb25hbGl0aWVzLiBJdCBhbHNvIHN1cHBvcnRzIFBMTSwgYXNzZW1ibHksIGFuZCBDIHByb2dyYW1taW5nLCBmZWF0dXJpbmcgYSB1c2VyLWZyaWVuZGx5IGludGVyZmFjZSB0aGF0IGlzIGVhc3kgdG8gbGVhcm4uIEtlaWwgwrVWaXNpb24gcHJvdmlkZXMgYSBjb252ZW5pZW50IGRlYnVnZ2luZyBlbnZpcm9ubWVudCBpbiB0aGUgZWFybHkgc3RhZ2VzIG9mIHNvZnR3YXJlIHRlc3RpbmcgYW5kIG9mZmVycyBzdHJvbmcgc2ltdWxhdGlvbiBjYXBhYmlsaXRpZXMuICAKCkN1cnJlbnRseSwgdGhlIG1vc3QgY29tbW9uIHByb2dyYW1taW5nIGxhbmd1YWdlcyBmb3IgTUNTLTUxIG1pY3JvY29udHJvbGxlcnMgaW5jbHVkZSBQTE0sIGFzc2VtYmx5LCBhbmQgQy4gQW1vbmcgdGhlbSwgYXNzZW1ibHkgYW5kIEMgYXJlIHRoZSBtb3N0IHdpZGVseSB1c2VkLiBBc3NlbWJseSBsYW5ndWEuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2UgaGVscCBtZSB3cml0ZSBhbiBvdXRsaW5lIGZvciBhIHJlc2VhcmNoIHBhcGVyIG9uIHRoZSBjb250cm9sIHN5c3RlbSBvZiBzb2Z0IHJvYm90cy4gVGhlIHBhcGVyIG1haW5seSBmb2N1c2VzIG9uIHRoZSBpc3N1ZSBvZiBwcmVjaXNlIGVuZC1lZmZlY3RvciBjb250cm9sIG9mIHNvZnQgcm9ib3RzIGJhc2VkIG9uIHZpc3VhbCBmZWVkYmFjaywgdXNpbmcgUk9TIGFuZCBHYXplYm8gcGxhdGZvcm1zIGZvciBzaW11bGF0aW9uIGV4cGVyaW1lbnRzLCB2ZXJpZnlpbmcgdGhlIGNvbnRyb2wgYWxnb3JpdGhtIG9uIGEgcGh5c2ljYWwgcHJvdG90eXBlLCBhbmQgY29sbGVjdGluZyBleHBlcmltZW50YWwgZGF0YSB1bmRlciB0aHJlZSBkaWZmZXJlbnQgbG9hZCBjb25kaXRpb25zIChubyBsb2FkLCAxMDBnLCAyMDBnKS4gVGhlIHBhcGVyIG5lZWRzIHRvIGNvbXBhcmUgYW5kIGFuYWx5emUgdGhlIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VzIGJldHdlZW4gUElEIGNvbnRyb2wgYW5kIGFkYXB0aXZlIGNvbnRyb2wgYXBwcm9hY2hlcy4KdXNlcjoKKipEZXNpZ24gYW5kIE9wdGltaXphdGlvbiBvZiBJbnRlbGxpZ2VudCBNYW51ZmFjdHVyaW5nIFN5c3RlbXMgQmFzZWQgb24gQXJ0aWZpY2lhbCBJbnRlbGxpZ2VuY2UgVGVjaG5vbG9neSoqICAKCiMjIyAxIEFuYWx5c2lzIG9mIEFJIEFwcGxpY2F0aW9ucyBpbiBNYW51ZmFjdHVyaW5nICAKCiMjIyMgMS4xIFZpc3VhbCBJbnNwZWN0aW9uIGFuZCBEZWZlY3QgUmVjb2duaXRpb24gIApJbiB0aGUgZmllbGQgb2YgbWFudWZhY3R1cmluZywgdmlzdWFsIGluc3BlY3Rpb24gYW5kIGRlZmVjdCByZWNvZ25pdGlvbiB0ZWNobm9sb2dpZXMgaGF2ZSBiZWVuIGRldmVsb3BpbmcgcmFwaWRseS4gVGhlc2UgdGVjaG5vbG9naWVzIGxldmVyYWdlIGltYWdlIHByb2Nlc3NpbmcgYW5kIG1hY2hpbmUgdmlzaW9uIHByaW5jaXBsZXMgdG8gZWZmaWNpZW50bHkgYW5kIGFjY3VyYXRlbHkgaWRlbnRpZnkgZGVmZWN0cyBvbiB0aGUgc3VyZmFjZSBvciBpbnNpZGUgb2YgcHJvZHVjdHMgd2l0aG91dCBodW1hbiBpbnRlcnZlbnRpb24sIGVuc3VyaW5nIHByb2R1Y3QgcXVhbGl0eS4gV2l0aCB0aGUgYXBwbGljYXRpb24gb2YgZGVlcCBsZWFybmluZyB0ZWNobm9sb2d5LCB0aGUgcmVjb2duaXRpb24gY2FwYWJpbGl0aWVzIG9mIHZpc3VhbCBpbnNwZWN0aW9uIHN5c3RlbXMgaGF2ZSBncmVhdGx5IGltcHJvdmVkLiBUaGV5IGNhbiBkZXRlY3QgZXZlbiB0aGUgc21hbGxlc3QgZmxhd3MgYW5kIG9wZXJhdGUgcmVsaWFibHkgaW4gY29tcGxleCBpbmR1c3RyaWFsIGVudmlyb25tZW50cy4gIAoKRm9yIGV4YW1wbGUsIGluIHRoZSBlbGVjdHJvbmljcyBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5LCB2aXN1YWwgaW5zcGVjdGlvbiBzeXN0ZW1zIGNhbiBpZGVudGlmeSB0aW55IGNyYWNrcyBhbmQgc29sZGVyaW5nIGlzc3VlcyBvbiBwcmludGVkIGNpcmN1aXQgYm9hcmRzLCBlbnN1cmluZyB0aGUgZnVuY3Rpb25hbGl0eSBhbmQgc2FmZXR5IG9mIGVsZWN0cm9uaWMgcHJvZHVjdHMuIFdpdGggaW5jcmVhc2VkIGNvbXB1dGluZyBwb3dlciBhbmQgb3B0aW1pemVkIGFsZ29yaXRobXMsIHZpc3VhbCBpbnNwZWN0aW9uIHRlY2hub2xvZ3kgaGFzIGFsc28gbWFkZSBzaWduaWZpY2FudCBwcm9ncmVzcyBpbiBpbXByb3ZpbmcgZGV0ZWN0aW9uIHNwZWVkIGFuZCBhY2N1cmFjeS4gQnkgcHJvY2Vzc2luZyBsYXJnZSBhbW91bnRzIG9mIGltYWdlIGRhdGEgaW4gcmVhbCB0aW1lLCB0aGVzZSBzeXN0ZW1zIGNhbiBxdWlja2x5IHByb3ZpZGUgZGV0ZWN0aW9uIHJlc3VsdHMsIGdyZWF0bHkgZW5oYW5jaW5nIHByb2R1Y3Rpb24gbGluZSBlZmZpY2llbmN5LiAgCgpJbiB0aGUgYXV0b21vdGl2ZSBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5LCB2aXN1YWwgaW5zcGVjdGlvbiB0ZWNobm9sb2d5IGlzIHdpZGVseSB1c2VkIGZvciBjaGVja2luZyB0aGUgcXVhbGl0eSBvZiBjYXIgYm9keSBjb2F0aW5ncywgYWNjdXJhdGVseSBpZGVudGlmeWluZyBpc3N1ZXMgc3VjaCBhcyB1bmV2ZW4gY29hdGluZyB0aGlja25lc3MgYW5kIGNvbG9yIGluY29uc2lzdGVuY2llcy4gIAoKIyMjIyAxLjIgUHJlZGljdGl2ZSBNYWludGVuYW5jZSBhbmQgRmF1bHQgRGlhZ25vc2lzICAKUHJlZGljdGl2ZSBtYWludGVuYW5jZSBhbmQgZmF1bHQgZGlhZ25vc2lzIHBsYXkgYSBjcnVjaWFsIHJvbGUgaW4gbW9kZXJuIG1hbnVmYWN0dXJpbmcuIEJ5IGxldmVyYWdpbmcgYmlnIGRhdGEgYW5hbHlzaXMgYW5kIG1hY2hpbmUgbGVhcm5pbmcgYWxnb3JpdGhtcywgdGhlc2UgdGVjaG5vbG9naWVzIGNhbiBhY2N1cmF0ZWx5IHByZWRpY3QgcG90ZW50aWFsIGVxdWlwbWVudCBmYWlsdXJlcywgZW5hYmxpbmcgcHJvYWN0aXZlIG1haW50ZW5hbmNlIHRvIHByZXZlbnQgcHJvZHVjdGlvbiBkaXNydXB0aW9ucyBhbmQgZWNvbm9taWMgbG9zc2VzLiBUaGlzIGFwcHJvYWNoIHNoaWZ0cyBmcm9tIHRyYWRpdGlvbmFsIHJlYWN0aXZlIG1haW50ZW5hbmNlIHRvIGEgbW9yZSBwcm9hY3RpdmUgbWFpbnRlbmFuY2Ugc3RyYXRlZ3ksIGVmZmVjdGl2ZWx5IGV4dGVuZGluZyBlcXVpcG1lbnQgbGlmZXNwYW4gYW5kIGltcHJvdmluZyBwcm9kdWN0aW9uIGVmZmljaWVuY3kuICAKCkZvciBleGFtcGxlLCBpbiBoZWF2eSBpbmR1c3RyaWVzLCBwcmVkaWN0aXZlIG1haW50ZW5hbmNlIHN5c3RlbXMgY2FuIG1vbml0b3IgcGFyYW1ldGVycyBzdWNoIGFzIGVxdWlwbWVudCB2aWJyYXRpb24sIHRlbXBlcmF0dXJlLCBhbmQgc291bmQgdG8gZGV0ZWN0IGFub21hbGllcyBpbiByZWFsIHRpbWUgYW5kIGludGVydmVuZSBiZWZvcmUgcHJvYmxlbXMgZXNjYWxhdGUuIFdpdGggY29udGludW91cyBhZHZhbmNlbWVudHMgaW4gdGVjaG5vbG9neSwgZmF1bHQgZGlhZ25vc2lzIHN5c3RlbXMgaGF2ZSBzaWduaWZpY2FudGx5IGltcHJvdmVkIGluIHByZWRpY3Rpb24gYWNjdXJhY3kgYW5kIHJlc3BvbnNlIHNwZWVkLiBUaGVzZSBzeXN0ZW1zIGFuYWx5emUgaGlzdG9yaWNhbCBhbmQgcmVhbC10aW1lIGRhdGEsIHV0aWxpemluZyBjb21wbGV4IGFsZ29yaXRobSBtb2RlbHMgdG8gcHJlZGljdCBlcXVpcG1lbnQgZmFpbHVyZXMuIFRoZXkgY2FuIGV2ZW4gYXV0b21hdGljYWxseSBhZGp1c3QgcHJvZHVjdGlvbiBwYXJhbWV0ZXJzIGJhc2VkIG9uIGVxdWlwbWVudCBzdGF0dXMgdG8gZW5zdXJlIHVuaW50ZXJydXB0ZWQgcHJvZHVjdGlvbi4gIAoKSW4gdGhlIGF1dG9tb3RpdmUgaW5kdXN0cnksIHByZWRpY3RpdmUgbWFpbnRlbmFuY2UgYW5kIGZhdWx0IGRpYWdub3NpcyB0ZWNobm9sb2dpZXMgYXJlIHVzZWQgdG8gbW9uaXRvciB0aGUgcGVyZm9ybWFuY2Ugb2Yga2V5IGNvbXBvbmVudHMgc3VjaCBhcyBlbmdpbmVzIGFuZCB0cmFuc21pc3Npb25zLCBwcmV2ZW50aW5nIGZhaWx1cmVzIGFuZCBlbnN1cmluZyBkcml2aW5nIHNhZmV0eS4gIAoKIyMjIDIgRGVzaWduIG9mIEFJLUJhc2VkIEludGVsbGlnZW50IE1hbnVmYWN0dXJpbmcgU3lzdGVtcyAgCgojIyMjIDIuMSBTeXN0ZW0gQXJjaGl0ZWN0dXJlIERlc2lnbiAgClN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduIGlzIHRoZSBmb3VuZGF0aW9uIG9mIEFJLWJhc2VkIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgc3lzdGVtcy4gSXQgaW52b2x2ZXMgcGxhbm5pbmcgdGhlIGVudGlyZSBwcm9kdWN0aW9uIHN5c3RlbSwgZnJvbSBkYXRhIGZsb3cgdG8gY29udHJvbCBsb2dpYywgZW5zdXJpbmcgZWZmaWNpZW50IGNvbGxhYm9yYXRpb24gYmV0d2VlbiBjb21wb25lbnRzIGFuZCB0aGUgc3lzdGVtJ3MgYWRhcHRhYmlsaXR5IGFuZCBzY2FsYWJpbGl0eS4gVGhlIGhpZXJhcmNoaWNhbCBkZXNpZ24gY29uY2VwdCBpbnRlZ3JhdGVzIGFuZCBvcHRpbWl6ZXMgbWFudWZhY3R1cmluZyByZXNvdXJjZXMgZWZmZWN0aXZlbHkuICAKCkZvciBleGFtcGxlLCBwaHlzaWNhbCBkZXZpY2VzIGF0IHRoZSBib3R0b20gbGF5ZXIgY29tbXVuaWNhdGUgaW4gcmVhbCB0aW1lIHdpdGggdXBwZXItbGF5ZXIgZGVjaXNpb24tbWFraW5nIG1vZHVsZXMgdmlhIHNlbnNvcnMuIFRoZSBkYXRhIHByb2Nlc3NpbmcgbGF5ZXIgYW5hbHl6ZXMgdGhlIGNvbGxlY3RlZCBpbmZvcm1hdGlvbiwgcHJvdmlkaW5nIGEgYmFzaXMgZm9yIGludGVsbGlnZW50IGRlY2lzaW9uLW1ha2luZy4gRmlndXJlIDEgaWxsdXN0cmF0ZXMgdGhlIHN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduLiBUaGlzIHN0cnVjdHVyZWQgYXBwcm9hY2ggZW5oYW5jZXMgc3lzdGVtIHN0YWJpbGl0eSBhbmQgZWZmaWNpZW5jeSB3aGlsZSBmYWNpbGl0YXRpbmcgbWFpbnRlbmFuY2UgYW5kIHVwZ3JhZGVzLiAgCgoqKkZpZ3VyZSAxOiBTeXN0ZW0gQXJjaGl0ZWN0dXJlIERlc2lnbioqICAKClN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduIG11c3QgYWxzbyBpbmNvcnBvcmF0ZSBBSSB0ZWNobm9sb2dpZXMsIHJlcXVpcmluZyBkZXNpZ25lcnMgdG8gaGF2ZSBpbnRlcmRpc2NpcGxpbmFyeSBrbm93bGVkZ2UsIGluY2x1ZGluZyBtYW51ZmFjdHVyaW5nIHByb2Nlc3NlcywgZGF0YSBzY2llbmNlLCBhbmQgbWFjaGluZSBsZWFybmluZy4gSW4gcHJhY3RpY2UsIHRoZSBzeXN0ZW0gYXJjaGl0ZWN0dXJlIHNob3VsZCBzdXBwb3J0IGNvbXBsZXggYWxnb3JpdGhtIG9wZXJhdGlvbnMsIHN1Y2ggYXMgbmV1cmFsIG5ldHdvcmtzIGFuZCBkZWVwIGxlYXJuaW5nIG1vZGVscywgZW5hYmxpbmcgc2VsZi1sZWFybmluZyBhbmQgc2VsZi1vcHRpbWl6YXRpb24gZHVyaW5nIHByb2R1Y3Rpb24uIFRoaXMgYWxsb3dzIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgc3lzdGVtcyB0byBhZGFwdCBmbGV4aWJseSB0byB2YXJpb3VzIHByb2R1Y3Rpb24gdGFza3MgYW5kIG1hcmtldCBjaGFuZ2VzIHdoaWxlIGNvbnRpbnVvdXNseSBpbXByb3ZpbmcgdGhlaXIgaW50ZWxsaWdlbmNlIGJ5IGxlYXJuaW5nIGZyb20gcHJvZHVjdGlvbiBkYXRhLiAgCgojIyMjIDIuMiBIdW1hbi1NYWNoaW5lIEludGVyZmFjZSAoSE1JKSBEZXNpZ24gIApUaGUgaHVtYW4tbWFjaGluZSBpbnRlcmZhY2UgKEhNSSkgc2VydmVzIGFzIGEgYnJpZGdlIGJldHdlZW4gaHVtYW4gb3BlcmF0aW9uIGFuZCBtYWNoaW5lIGV4ZWN1dGlvbiBpbiBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHN5c3RlbXMuIEl0cyBpbnR1aXRpdmVuZXNzIGFuZCBlYXNlIG9mIHVzZSBkaXJlY3RseSBhZmZlY3Qgc3lzdGVtIGVmZmljaWVuY3kuIEEgd2VsbC1kZXNpZ25lZCBITUkgc2ltcGxpZmllcyBjb21wbGV4IG9wZXJhdGlvbnMsIGVmZmVjdGl2ZWx5IHRyYW5zbGF0aW5nIGh1bWFuIGludGVudGlvbnMgaW50byBwcmVjaXNlIG1hY2hpbmUgcmVzcG9uc2VzLiAgCgpVc2VyIGV4cGVyaWVuY2UgaXMgYSB0b3AgcHJpb3JpdHkgaW4gSE1JIGRlc2lnbiwgZW5zdXJpbmcgaW50dWl0aXZlIG9wZXJhdGlvbiBhbmQgcmVkdWNpbmcgZXJyb3JzIHRocm91Z2ggcHJvcGVyIHVzZSBvZiBncmFwaGljcywgaWNvbnMsIGFuZCBjb2xvcnMuIEZvciBleGFtcGxlLCBpbnR1aXRpdmUgZ3JhcGhpY2FsIGludGVyZmFjZXMgb24gdG91Y2ggc2NyZWVucyBoZWxwIG9wZXJhdG9ycyBxdWlja2x5IGlkZW50aWZ5IHN5c3RlbSBzdGF0dXNlcyBhbmQgcmVzcG9uZCB0byBhbGVydHMsIGltcHJvdmluZyBlZmZpY2llbmN5IGFuZCBzYWZldHkuICAKCldpdGguLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgror7fkuLrkuIDnr4fmjqLorqjljLrlnZfpk77mioDmnK/lnKjkvpvlupTpk77kuK3lupTnlKjnmoTlrabmnK/orrrmlofmkrDlhpnkuK3mlofmkZjopoHvvIzorrrmloflhbbku5bpg6jliIblpoLkuIs65LiA44CB5byV6KiAIOiHqjIwMDjlubTkuK3mnKzogarlnKjmr5TnibnluIHorrrlnZvkuIrlj5HooajlkI3kuLrigJxCaXRjb2luOkEgUGVlci10by1QZWVyIEVsZWN0cm9uaWMgQ2FzaCBTeXN0ZW3igJ1bMV3nmoTorrrmlofku6XmnaXvvIzljLrlnZfpk77nmoTmpoLlv7Xpmo/nnYDmr5TnibnluIHnmoTngavniIblj5fliLDkuoblkITlm73mlL/lupzlkozlrabogIXnmoTpq5jluqblhbPms6jjgILlkITkuKrlm73lrrbnm7jnu6fmjqjlh7rmtonlj4rljLrlnZfpk77mioDmnK/nmoTns7vliJfmlL/nrZbmlofku7bvvIzliqDpgJ/ljLrlnZfpk77nmoTlupTnlKjokL3lnLDvvIzkvb/lhbbmiJDkuLrlvJXpoobmlrDkuIDku6Pkv6Hmga/mioDmnK/nmoTkuLvop5LjgILmiJHlm73ml6nlnKgyMDE25bm05bCx5Y+R6KGo5LqG6aaW5Lu944CK5Lit5Zu95Yy65Z2X6ZO+5oqA5pyv5ZKM5bqU55So5Y+R5bGV55m955qu5Lmm44CL44CC44CK55m955qu5Lmm44CL6K+m57uG5LuL57uN5LqG5Yy65Z2X6ZO+5Zyo5Zu95YaF5aSW55qE5Y+R5bGV546w54q244CB5bqU55So5Zy65pmv5LiO5pyq5p2l5Y+R5bGV5pa55ZCRWzJd44CC5ZCM5bm077yM5Zu95Yqh6Zmi5Y2w5Y+R55qE44CK4oCc5Y2B5LiJ5LqU4oCd5Zu95a625L+h5oGv5YyW6KeE5YiS44CL5Lit5piO56Gu5bCG5Yy65Z2X6ZO+5oqA5pyv5YiX5Li65oiY55Wl5oCn5YmN5rK/5oqA5pyvWzNd44CCMjAxOeW5tDEw5pyIMjTml6XvvIzkuaDov5HlubPmgLvkuaborrDlnKjkuK3lpK7mlL/msrvlsYDnrKzljYHlhavmrKHpm4bkvZPlrabkuaDml7blvLrosIPvvIzigJzmiorljLrlnZfpk77kvZzkuLrmoLjlv4PmioDmnK/oh6rkuLvliJvmlrDph43opoHnqoHnoLTlj6PvvIzliqDlv6vmjqjliqjljLrlnZfpk77mioDmnK/lkozkuqfkuJrliJvmlrDlj5HlsZXigJ1bNF3vvIzov5vkuIDmraXlh7jmmL7kuobljLrlnZfpk77nmoTph43opoHkvZznlKjjgIIg5Yy65Z2X6ZO+5oqA5pyv57uZ5ZCE6KGM5ZCE5Lia5bim5p2l5LqG5paw55qE5Y+R5bGV5py66YGH77yM5YW25bqU55So6YCQ5riQ5LuO6YeR6J6N6aKG5Z+f5omp5bGV5Yiw5YW25LuW6aKG5Z+f77yM5L6b5bqU6ZO+5bCx5piv5YW25Lit5LmL5LiA44CC6ZqP552A5Yy65Z2X6ZO+5oqA5pyv55qE5LiN5pat5Y+R5bGV77yM5Lyg57uf55qE5L6b5bqU6ZO+566h55CG5qih5byP5Lqf6aG75Zyo6J6N5YWl5paw5oqA5pyv55qE5Z+656GA5LiK6L+b6KGM5YWo5paw55qE5Y+Y6Z2p44CC5Zug5q2k77yM56eR5a2m5Zyw5qKz55CG5bm25oC757uT4oCc5Yy65Z2X6ZO+K+S+m+W6lOmTvuKAnemihuWfn+eahOeglOeptueDreeCueS4juWJjeayv+i2i+WKv++8jOWFt+aciemHjeimgeeahOeQhuiuuuWSjOWunui3teaEj+S5ieOAguacrOaWh+S7pUNpdGUgU3BhY2XmlofnjK7orqHph4/liIbmnpDkuLrmjIflvJXvvIzlr7nljLrlnZfpk77mioDmnK/lnKjkvpvlupTpk77kuK3nmoTlupTnlKjnoJTnqbbov5vooYzov7Dor4TvvIzpgJrov4fmorPnkIbnjrDmnInmlofnjK7vvIzlnKjmmI7mmbDljLrlnZfpk77mioDmnK/nu5nkvpvlupTpk77luKbmnaXnmoTmt7HliLvlj5jpnanlj4rlupTnlKjnjrDnirbnmoTln7rnoYDkuIrvvIzlr7nmnKrmnaXnoJTnqbbmlrnlkJHov5vooYzlsZXmnJvjgIIg5LqM44CB5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So56CU56m25paH54yu6K6h6YeP5YiG5p6QIOS4uuWFqOmdouS6huino+WMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOeglOeptueOsOeKtu+8jOWAn+WKqUNpdGUgU3BhY2Xlj6/op4bljJbliIbmnpDova/ku7bov5vooYzmlofnjK7lhbHooqvlvJXliIbmnpDjgIHlhbPplK7or43lhbHnjrDliIbmnpDjgIHlhbPplK7or43ogZrnsbvliIbmnpBbNV3jgILku6XigJxibG9ja2NoYWlu4oCd5ZKM4oCcc3VwcGx5IGNoYWlu4oCd5Li65qOA57Si5Li76aKY6K+N5ZyoV2ViIG9mIFNjaWVuY2XmlbDmja7lupPkuK3ov5vooYzmlofnjK7mo4DntKLvvIzor63np43orr7lrprkuLroi7Hor63vvIzmlofnjK7nsbvlnovpgInmi6nigJxBcnRpY2xl4oCd5oiW4oCcUmV2aWV34oCd77yM5qOA57Si5pe26Ze05Li6MjAyMOW5tDEy5pyI77yM5pe26Ze06Leo5bqm6K6+5Li6MjAwOOKAlDIwMjDvvIzlhbHmo4DntKLliLDoi7HmlofmlofnjK40NTXnr4fjgIIg6YCa6L+H5paH54yu5YWx6KKr5byV5YiG5p6Q77yM5Y+R546w5pyJ5LiA5Lqb5a+55Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So56CU56m25b2x5ZON6L6D5aSn55qE5paH54yu44CC5aaCU3dhbls2XeWcqDIwMTXlubTlh7rniYjkuobokZfkvZxCbG9ja2NoYWluOkJsdWVwcmludCBmb3IgYSBOZXcgRWNvbm9tee+8jOiuqOiuuuS6huavlOeJueW4geWSjOWMuuWdl+mTvuaKgOacr+eahOS4ieS4quS4jeWQjOmYtuautTrljLrlnZfpk74xLjDjgIHljLrlnZfpk74yLjDlkozljLrlnZfpk74zLjDvvIzlubbmj5Dlh7rljLrlnZfpk74zLjDlnKjotKfluIHjgIHph5Hono3jgIHnp5HmioDjgIHln7rlm6Dnu4TlrabjgIHlgaXlurfjgIHlrabkuaDjgIHlrabmnK/lh7rniYjjgIHlvIDlj5HjgIHmlZHmj7TlkozmlofljJbnrYnpoobln5/nmoTor7jlpJrlupTnlKjliY3mma/vvIzkuLrlkI7nu63noJTnqbblpaDlrprkuobln7rnoYDjgIJLc2hldHJpWzdd5ZyoMjAxOOW5tOWPkeihqOS6huiuuuaWh+KAnEJsb2NrY2hhaW4ncyBSb2xlcyBpbiBNZWV0aW5nIEtleSBTdXBwbHkgQ2hhaW4gTWFuYWdlbWVudCBPYmplY3RpdmVz4oCd77yM5Lul6ams5aOr5Z+644CB6Zi/6YeM5be05be044CB5rKD5bCU546b562JMTHlrrbmiJDlip/ov5DnlKjljLrlnZfpk77nmoTku6PooajmgKfkvIHkuJrkuLrkvovvvIznoJTnqbbkuobljLrlnZfpk77lr7nlhbPplK7kvpvlupTpk77nrqHnkIbnm67moIfvvIzlpoLmiJDmnKzjgIHotKjph4/jgIHpgJ/luqbjgIHlj6/pnaDmgKfjgIHpo47pmanpmY3kvY7jgIHlj6/mjIHnu63mgKflkozngbXmtLvmgKfnmoTlvbHlk43vvIzmjIflh7rkuobljLrlnZfpk77lnKjpo5/lk4HkvpvlupTpk77jgIHlm73pmYXnianmtYHjgIHnvZHnu5zlronlhajnrYnor7jlpJrpoobln5/nmoTlupTnlKjjgIJTYWJlcmkgZXQgYWwuWzhd5ZyoMjAxOeW5tOWPkeihqOeahOiuuuaWh+KAnEJsb2NrY2hhaW4gVGVjaG5vbG9neSBhbmQgSXRzIFJlbGF0aW9uc2hpcHMgdG8gU3VzdGFpbmFibGUgU3VwcGx5IENoYWluIE1hbmFnZW1lbnTigJ3ns7vnu5/ku4vnu43kuobljLrlnZfpk77lnKjkvpvlupTpk77nrqHnkIbkuK3nmoTlupTnlKjvvIzlubbku47nu4/mtY7jgIHnpL7kvJrlkoznjq/looPkuInkuKrnu7TluqbpmJDph4rkuobljLrlnZfpk77lnKjlj6/mjIHnu63kvpvlupTpk77nvZHnu5zkuK3nmoTkvJjlir875Z+65LqO5a+55paH54yu55qE5Zue6aG+77yM5bCG5Yy65Z2X6ZO+5oqA5pyv5bqU55So6Z2i5Li055qE6Zqc56KN5YiG5Li65Zub5Liq5pa56Z2iOue7hOe7h+mXtOOAgee7hOe7h+WGheOAgeaKgOacr+WSjOWklumDqOmanOeijTvmnIDlkI7mj5Dlh7rkuobmnKrmnaXnmoTnoJTnqbbmlrnlkJHku6XmnInmlYjop6PlhrPljLrlnZfpk77nmoTmioDmnK/pmpznoo3vvIzkvb/ljLrlnZfpk77mm7Tlpb3lnLDlupTnlKjliLDkvpvlupTpk77nrqHnkIbkuK3jgILov5nkupvmlofnjK7lvJXpoobkuobljLrlnZfpk77lnKjkvpvlupTpk77poobln5/nmoTlupTnlKjnoJTnqbbvvIzlubbkvb/nm7jlhbPnoJTnqbblvpfku6XkuI3mlq3mt7HljJbjgIIg5YWz6ZSu6K+N5YWx546w5YiG5p6Q5pi+56S6KOWmguihqDHmiYDnpLop77yM5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So5Li76aKY6L6D5aSa77yM5LuO5Yy65Z2X6ZO+44CB5L6b5bqU6ZO+44CB5pm66IO95ZCI57qm5Yiw6aOf5ZOB5L6b5bqU6ZO+44CB5L6b5bqU6ZO+57up5pWI44CB5b2x5ZON44CB5oyR5oiY44CB5Y+v5oyB57ut5oCn562J44CC6L+b5LiA5q2l6YCa6L+H5YWz6ZSu6K+N6IGa57G75YiG5p6QKOWmguihqDLmiYDnpLop5Y+R546w77yM56CU56m255qE54Ot54K55Li76aKY5Li76KaB5raJ5Y+K5Yy65Z2X6ZO+5oqA5pyv44CB5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So6aKG5Z+f44CB5a+55L6b5bqU6ZO+55qE5b2x5ZON44CB5pyq5p2l5oyR5oiY562J5pa56Z2i44CC5Z+65LqO5q2k77yM5LiL6Z2i5bCG5Zu057uV5Lul5LiL5LqU5Liq5pa56Z2i6Zeu6aKY5a+5546w5pyJ5paH54yu6L+b6KGM6L+w6K+EOigxKeS7gOS5iOaYr+WMuuWdl+mTvuaKgOacrz8oMinkuLrku4DkuYjopoHlnKjkvpvlupTpk77kuK3ono3lhaXljLrlnZfpk77mioDmnK8/KDMp5Yy65Z2X6ZO+5oqA5pyv5Li76KaB5bqU55So5Zyo5L6b5bqU6ZO+55qE5ZOq5Lqb6aKG5Z+fPyg0Kei/meS6m+W6lOeUqOe7meS+m+W6lOmTvuW4puadpeS7gOS5iOW9seWTjT8oNSnmnKrmnaXpnaLkuLTlk6rkupvmjJHmiJg/IOihqDEg5YWz6ZSu6K+N5YWx546w5YiG5p6QICDooagyIOWFs+mUruivjeiBmuexu+e7k+aenCAg5LiJ44CB5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So56CU56m25Li76aKY546w54q26L+w6K+EICjkuIAp5Yy65Z2X6ZO+5oqA5pyvOuamguW/teOAgeS9nOeUqOS4juexu+WeiyDljLrlnZfpk77mnIDliJ3kvZzkuLrkuIDnp43mlK/mjIHliqDlr4botKfluIHpoobln5/kuqTmmJPnmoTmioDmnK/ogIzlh7rnjrBbMV3jgIJDaHJpc3RpZGlzIGFuZCBEZXZldHNpb2tpb3Rpc1s5XeWwhuWMuuWdl+mTvuWumuS5ieS4uuKAnOWcqOe9kee7nOaIkOWRmOS5i+mXtOWkjeWItuWSjOWFseS6q+eahOWIhuW4g+W8j+aVsOaNrue7k+aehOKAneOAgkFsLVNhcWFmIGFuZCBTZWlkbGVyWzEwXeWImeWwhuWMuuWdl+mTvuWumuS5ieS4uuKAnOWIhuW4g+W8j+aVsOWtl+WIhuexu+i0puaIluS8muiuoei0puewv+KAneOAguWcqOatpOWfuuehgOS4iu+8jFJpc2l1cyBhbmQgU3BvaHJlclsxMV3lr7nljLrlnZfpk77mioDmnK/nu5nlh7rkuobkuIDkuKrovoPmraPlvI/nmoTlrprkuYnvvIzljbPigJzljLrlnZfpk77mioDmnK/mmK/mjIfkuIDnp43nlKjkuo7ku6XliqDlr4bmlrnlvI/mjZXojrflkozlrZjlgqjnvZHnu5zlj4LkuI7ogIXkuYvpl7TkuIDoh7TnmoTjgIHkuI3lj5jnmoTjgIHnur/mgKfnmoTkuovliqHml6Xlv5fnmoTlrozlhajliIbluIPlvI/ns7vnu5/jgILlnKjlip/og73kuIrnsbvkvLzkuo7liIbluIPlvI/liIbnsbvotKbvvIznlLHnvZHnu5zlhoXmiYDmnInlj4LkuI7kuqTmmJPnmoTlkITmlrnkuIDoh7Tkv53lrZjjgIHmm7TmlrDlkozpqozor4HjgILor6XmioDmnK/liqDlvLrkuobnvZHnu5zpgI/mmI7luqbvvIzlubbnoa7kv53mnIDnu4jlnKjns7vnu5/ojIPlm7TlhoXlsLHmlbTkuKrkuqTmmJPljoblj7LnmoTmnInmlYjmgKfovr7miJDlhbHor4bigJ3jgILlsL3nrqHnu5nlh7rkuobov5nkuKrmraPlvI/lrprkuYnvvIzkvYbmmL7nhLbljLrlnZfpk77ov5jmnInkuIDkupvlhbbku5bnibnlvoHvvIzlpoLljrvkuK3lv4PjgIHljrvkuK3ku4vjgIHpmLLnr6HmlLnnrYnjgILlm73lhoXlrabogIXnjovlhYPlnLDnrYlbMTJd57u86L+w5LqG5pyJ5YWz5Yy65Z2X6ZO+5oqA5pyv55qE5YaF5ra177yM5bCG5YW25YiG5Li65LqU57G7OuS4gOaYr+WfuuS6juaVsOaNrueahOinhuinkuWwhuWMuuWdl+mTvuWumuS5ieS4uuS4gOenjeaVsOaNrue7k+aehOaIluaVsOaNruW6kzvkuozmmK/ln7rkuo7orrDotKbnmoTop4bop5LlsIbljLrlnZfpk77lrprkuYnkuLrkuIDnp43liIbluIPlvI/orrDotKbnmoTlupXlsYLmioDmnK875LiJ5piv5Z+65LqO5Y2P6K6u55qE6KeG6KeS5bCG5Yy65Z2X6ZO+5a6a5LmJ5Li65LiA56eN5LqS6IGU572R5Y2P6K6uO+Wbm+aYr+WfuuS6juaKgOacr+eahOinhuinkuWwhuWMuuWdl+mTvuWumuS5ieS4uuS4gOenjeeUseWkmuenjeaKgOacr+aehOaIkOeahOaWsOaKgOacr+aWueahiDvkupTmmK/ln7rkuo7nu4/mtY7nmoTop4bop5LlsIbljLrlnZfpk77lrprkuYnkuLrkuIDnp43ku7flgLzkupLogZTnvZHnu5zjgILku47kvpvlupTpk77op4bop5LmnaXnnIvvvIzljLrlnZfpk77mioDmnK/lj6/ku6XnkIbop6PkuLrkuI7kuqTmmJPnmoTljrvkuK3ku4vljJbnm7jlhbPvvIzljbPml6DpobvkuK3ku4vmnLrmnoTmnaXpqozor4HkuqTmmJPlubbkuLrkuqTmmJPmj5Dkvpvlj6/kv6HluqbnmoTmioDmnK9bMTNd44CCIOWMuuWdl+mTvuaKgOacr+S4u+imgeino+WGs+S6pOaYk+eahOS/oeS7u+WSjOWuieWFqOmXrumimO+8jOmSiOWvuei/meS4qumXrumimO+8jOS4u+imgeacieWbm+mhueaguOW/g+aKgOacr++8jOWMheaLrOWIhuW4g+W8j+WtmOWCqOOAgemdnuWvueensOWKoOWvhuOAgeWFseivhuacuuWItuOAgeaZuuiDveWQiOe6plsxNC0xN13jgILljLrlnZfpk77mioDmnK/lhbfmnInljrvkuK3lv4PljJbjgIHljrvkv6Hku7vjgIHlhazlvIDpgI/mmI7jgIHlvIDmlL7mgKfjgIHpmLLnr6HmlLnjgIHlj6/ov73muq/mgKfjgIHlronlhajlj6/pnaDnrYnnibnngrlbMTgtMTld44CC5Yy65Z2X6ZO+5oqA5pyv55qE6L+Z5Lqb54m55oCn5oSP5ZGz552A5YW25bCG5a+55L6b5bqU6ZO+566h55CG6K+45aaC5oiQ5ZGY5YWz57O744CB5Y2P5L2c44CB5L+h5Lu75ZKM5Z+65LqO6KeS6Imy55qE5LqR5pWP5o235oCn5pON5L2c5qih5Z6L55qE5Y+Y5YyW562J5pa56Z2i5Lqn55Sf5b2x5ZONWzEzXeOAguWug+iDveacieaViOino+WGs+e9kee7nOS/oeaBr+S4jeWvueensO+8jOWFtuacgOS4uuaguOW/g+eahOS7t+WAvOWcqOS6juWvuee9kee7nOS4reeahOavj+S4gOS4quiKgueCueWFheWIhui1i+iDve+8jOino+WGs+S6pOaYk+eahOS/oeS7u+acuuWItuWSjOa/gOWKseacuuWItumXrumimFsyMF3jgIIg5qC55o2u6K+75Y+W5Yy65Z2X6ZO+44CB5ZCR5Yy65Z2X6ZO+5o+Q5Lqk5Lqk5piT5bm25Y+C5LiO5YWx6K+G5rWB56iL5o6n5Yi2562J5pa56Z2i55qE6K6/6Zeu5p2D6ZmQ77yM5Y+v5Lul5bCG5Yy65Z2X6ZO+5Yy65YiG5Li65LiJ56eN5Li76KaB57G75Z6LOuWFrOaciemTvihwdWJsaWMgYmxvY2tjaGFpbinjgIHnp4HmnInpk74ocHJpdmF0ZSBibG9ja2NoYWluKeWSjOiBlOebn+mTvihjb25zb3J0aXVtIGJsb2NrY2hhaW4pWzE5XeOAguWcqOWFrOaciemTvuS4re+8jOavj+S4quS6pOaYk+mDveaYr+WFrOW8gOeahO+8jOeUqOaIt+WPr+S7peS/neaMgeWMv+WQjeOAgue9kee7nOmAmuW4uOacieS4gOS4qua/gOWKseacuuWItuadpem8k+WKseWPguS4juiAheWKoOWFpee9kee7nOOAguavlOeJueW4geWSjOS7peWkquWdiuWwseaYr+WFrOaciemTvueahOS+i+WtkOOAguWcqOacieadg+mZkOiuuOWPr+eahOWMuuWdl+mTvuS4re+8jOWPguS4juiAhemcgOimgeiOt+W+l+WKoOWFpeeahOmCgOivt+aIluiuuOWPr++8jOiuv+mXruadg+mZkOeUseaIkOWRmOiBlOebnyjogZTnm5/pk74p5oiW5Y2V5Liq57uE57uHKOengeaciemTvinmjqfliLbjgILkvpvlupTpk77lsLHmmK/kuIDnp43ogZTnm5/pk77vvIzmiJDlkZjpgJrov4fmjojmnYPlkI7miY3og73liqDlhaXkuI7pgIDlh7rnvZHnu5zjgILlnKjogZTnm5/pk77kuIrvvIzkvpvlupTpk77lkITlj4LkuI7mlrnlhbHkuqvkuIDkuKrpgI/mmI7lj6/pnaDnmoTkv6Hmga/lubPlj7Dlkozov73muq/mtYHnqIvvvIzlkIzml7bvvIzlkITlj4LkuI7mlrnkuZ/lj6/ku6Xln7rkuo7ljLrlnZfpk77mlbDmja7lvIDlsZXlpoLkvpvlupTpk77ph5Hono3jgIHnsr7lh4bokKXplIDnrYnmnI3liqFbMjFd44CCICjkuowp5L6b5bqU6ZO+5bqU55So5Yy65Z2X6ZO+5oqA5pyv55qE6amx5Yqo5Zug57SgIOWFs+S6juS4uuS7gOS5iOimgeWcqOS+m+W6lOmTvuS4reW6lOeUqOWMuuWdl+mTvuaKgOacr++8jOWbveWkluWtpuiAhei/kOeUqOaKgOacr+aOpeWPl+WSjOmHh+eUqOeQhuiuuuS7peWPiuihjOS4uueQhuiuuu+8jOS7jue7qeaViOmihOacn+OAgeekvuS8muW9seWTjeOAgeacieWIqeadoeS7tuOAgeWvueaKgOacr+eahOS/oeS7u+OAgee7hOe7h+mXtOeahOS/oeS7u+etieaWuemdouWIhuaekOS6huS+m+W6lOmTvumHh+eUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oFsyMl3vvIzlubblr7nmr5TliIbmnpDkuobljbDluqblkoznvo7lm73mg4Xmma/kuIvnmoTlt67lvIJbMjNd44CC5L6b5bqU6ZO+6YeH55So5Yy65Z2X6ZO+5oqA5pyv55qE6amx5Yqo5Zug57Sg5aaC5Zu+MeaJgOekuuOAgiDlm74xIOS+m+W6lOmTvumHh+eUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oCAg6LWE5paZ5p2l5rqQOueslOiAheagueaNrkZyYW5jaXNjbyBhbmQgU3dhbnNvbiAoMjAxOClbMjJd5Y+KUXVlaXJveiBhbmQgV2FtYmEgKDIwMTgpWzIzXeeahOebuOWFs+aWh+eMruaVtOeQhuOAgiAg6aaW5YWI77yM57up5pWI6aKE5pyf5piv5L6b5bqU6ZO+5bqU55So5Yy65Z2X6ZO+5oqA5pyv55qE5pyA6YeN6KaB55qE6amx5Yqo5Yqb44CC5bey5pyJ56CU56m26KGo5piO77yM5Liq5L2T6YeH57qz5ZKM5L2/55So5oqA5pyv55qE5oSP5oS/5Zyo5b6I5aSn56iL5bqm5LiK5Y+W5Yaz5LqO57up5pWI6aKE5pyfWzI0LTI2Xe+8jOiAjOWMuuWdl+mTvuaKgOacr+W6lOeUqOWvueS+m+W6lOmTvuS7juaViOeOh+WSjOS6p+WTgei0qOmHj+WIsOWFs+mUrua1geeoi+eahOaUuei/m+aWuemdoumDveS6p+eUn+S6huW+iOmrmOeahOmihOacn1s3XeOAguWFtuasoeaYr+ekvuS8muW9seWTjeWboOe0oOOAguekvuS8muW9seWTjeaYr+aMh+S4quS9k+WvueWFtuS7luS6uuiupOS4uuW6lOivpeS9v+eUqOaWsOaKgOacr+eahOmHjeimgeeoi+W6pueahOiupOefpVsyN13jgILljLrlnZfpk77lupTnlKjmmK/kuIDnp43igJznpL7kvJrmgKfigJ3mioDmnK/vvIzlpoLmnpzpmo/nnYDop4TojIPmgKfljovlipvlkoznlKjmiLfigJzkuLTnlYzmlbDph4/igJ3nmoTlop7liqDvvIzov5vogIzlrp7njrDnvZHnu5zmlYjlupTnmoTlop7liqDvvIzov5nnp43mg4XlhrXkuIvlj6/og73kvJrlr7zoh7Tmm7Tpq5jnmoTkvb/nlKjmhI/mhL9bMjJd44CC5Zug5q2k5L6b5bqU6ZO+5oiQ5ZGY6Ze0546w5pyJ5YWz57O75a+55piv5ZCm6YeH55So6Leo572R57uc55qE5Yy65Z2X6ZO+5oqA5pyv5Lya5Lqn55Sf6YeN5aSn5b2x5ZON44CC5YaN5qyh5piv5L6/5Yip5p2h5Lu25Zug57Sg44CC5L6/5Yip5p2h5Lu25piv5oyH4oCc5Liq5L2T6K6k5Li657uE57uH5oqA5pyv5Z+656GA6K6+5pa96LWW5Lul5pSv5oyB57O757uf5L2/55So55qE56iL5bqm4oCdWzI3XeOAguWwseWMuuWdl+mTvuiAjOiogO+8jOWwseaYr+aMh+S4quS9k+Wvuee7hOe7h+S4reWPr+eUqOS6juaUr+aMgeWMuuWdl+mTvuS9v+eUqOeahOi1hOa6kOeahOeQhuino+OAguW3suacieeglOeptuihqOaYju+8jOWMheaLrOiuoeeul+acuuOAgee9kemAn+OAgeS4juWFtuS7luezu+e7n+eahOmbhuaIkOetieWcqOWGheeahOS+v+WIqeadoeS7tumDveS8muW9seWTjeebuOWFs+aKgOacr+eahOmHh+e6s+WSjOS9v+eUqFsyOC0zMF3jgILmnIDlkI7mmK/kv6Hku7vlm6DntKDvvIzljIXmi6zlr7nmioDmnK/nmoTkv6Hku7vku6Xlj4rkvpvlupTpk77liKnnm4rnm7jlhbPogIXkuYvpl7TnmoTkv6Hku7vjgILmioDmnK/lhazkv6HlipvkvJrlvbHlk43kurrku6zlr7nmioDmnK/nmoTmgIHluqbvvIzov5vogIzlvbHlk43kurrku6zkvb/nlKjmioDmnK/nmoTmhI/mhL/jgIJUaGF0Y2hlciBldCBhbC5bMzFd5oyH5Ye677yM57y65LmP5a+5SVTnmoTkv6Hku7vlj6/og73lr7zoh7TnlKjmiLflh7rkuo7lr7nlj6/pnaDmgKfmiJbmgKfog73nvLrkuY/kv6Hlv4PogIzlgZzmraLkvb/nlKjor6XmioDmnK/jgILlpoLmnpznlKjmiLfmhI/or4bliLDljLrlnZfpk77mioDmnK/kuI3lronlhajvvIzku5bku6zlsIbkuI3kvJrkvb/nlKjor6XmioDmnK/jgILlvZPnhLbvvIzpmo/nnYDnlKjmiLflr7nmioDmnK/nmoTkuobop6PlkozlrabkuaDotorlpJrvvIzku5bku6zmi6XmnInnmoTnu4/pqozlkoznn6Xor4blsLHotorlpJrvvIzmioDmnK/lnKjku5bku6znnIvmnaXlsLHotorlj6/kv6HjgILlm6DmraTvvIzlr7nmioDmnK/nmoTkv6Hku7vmiJDkuLrkuobop6PnlKjmiLfkvb/nlKjmhI/mhL/nmoTkuIDkuKrph43opoHlm6DntKDjgILkvpvlupTpk77liKnnm4rnm7jlhbPogIXkuYvpl7TnmoTkv6Hku7vmmK/mjIfkvpvlupTpk77nvZHnu5zkuK3kuKTkuKrmiJbkuKTkuKrku6XkuIrnmoTmiJDlkZjkuYvpl7Tnm7jkupLkvp3otZblubbnu7TmiqTlvbzmraTmnJ/mnJvnmoTmhI/mhL9bMjNd44CC5L6b5bqU6ZO+5Yip55uK55u45YWz6ICF5LmL6Ze055qE5L+h5Lu75piv5bCG5Yy65Z2X6ZO+5oqA5pyv5bqU55So5LqO5L6b5bqU6ZO+572R57uc5Lit55qE5Z+65pys5YmN5o+Q44CCIOatpOWklu+8jOi/mOacieWtpuiAheS7juS+m+W6lOmTvueuoeeQhuebruagh+inkuW6puWIhuaekOW6lOeUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oO+8jOavlOWmguWFi+acjeS+m+W6lOmTvuS4reaWreS4juWkjeadguaAp1szMi0zM13vvIznoa7kv53kuqflk4HnmoTlronlhajjgIHnnJ/lrp7jgIHlkIjms5VbMzQtMzVd77yM5Lul5Y+K5YWs5YWx5a6J5YWo5LiO5Y+N6IWQ6LSlWzM2LTM3XeetieOAgiAo5LiJKeWMuuWdl+mTvuWcqOS+m+W6lOmTvuS4reeahOS4u+imgeW6lOeUqOmihuWfnyDljLrlnZfpk77mioDmnK/otbfliJ3kuLvopoHlupTnlKjkuo7ph5Hono3ooYzkuJrvvIzkuYvlkI7pgJDmuJDmi5PlsZXliLDlhpzkuJrjgIHpm7bllK7jgIHljLvnlpfjgIHliLbpgKDkuJrku6Xlj4rog73mupDnrYnlpJrooYzkuJrvvIzlm73lhoXlpJbnoJTnqbbmma7pgY3orqTkuLrnianmtYHlkozkvpvlupTpk77poobln5/mmK/ov5npobnmioDmnK/og73lpJ/luKbmnaXlvbvlupXlj5jpnannmoTkuLvopoHpoobln5/kuYvkuIBbMzgtNDJd44CCIOmmluWFiO+8jOKAnOWMuuWdl+mTvivkvpvlupTpk77ph5Hono3igJ3mmK/lm73lhoXlpJbnoJTnqbbnmoTng63pl6jpoobln5/jgILljLrlnZfpk77mioDmnK/nmoTov5DnlKjog73op6PlhrPkvKDnu5/kvpvlupTpk77ph5Hono3kuK3kvpvlupTllYbkv6HnlKjkv6Hmga/orrDlvZXkuI3lhajjgIHkuoznuqfku6XkuIrnmoTkvpvlupTllYbkuI7nu4/plIDllYbpmr7ojrfotLfmrL7jgIHkuK3lsI/lvq7kvIHkuJrpmr7ojrfmjojkv6HjgIHmjojkv6Hpop3luqbpmr7ku6Xnoa7orqTjgIHono3otYTlkI7lsaXnuqbjgIHmuIXnrpfmu57lkI7nrYnpl67pophbMjFd44CC5Yy65Z2X6ZO+5Zyo5o+Q6auY5L6b5bqU6ZO+6YeR6J6N6KGM5Lia55qE6YCP5piO5bqm44CB5omp5aSn5pyN5Yqh5a+56LGh44CB5o+Q6auY5pWI546H44CB6ZmN5L2O6aOO6Zmp44CB5Yqg5by66LWE6YeR5rWB566h55CG5Lit5YW35pyJ5piO5pi+5LyY5Yq/WzQzXeOAguWMuuWdl+mTvuWcqOWbveWGheS+m+W6lOmTvumHkeiejeW6lOeUqOahiOS+i+ihqOeOsOS4uuS7peaguOW/g+S8geS4muS4uuS4u+WvvOeahOKAnENoYWluZWQgRmluYW5jZeKAneWMuuWdl+mTvumHkeiejeW5s+WPsOOAgeS7peaKgOacr+aPkOS+m+aWueS4uuS4u+WvvOeahOiFvuiur+KAnOWMuuWdl+mTvivkvpvlupTpk77ph5Hono3op6PlhrPmlrnmoYjigJ3jgIHku6Xph5Hono3mnLrmnoTkuLrkuLvlr7znmoTlubPlronpk7booYzkvpvlupTpk77lupTmlLbotKbmrL7mnI3liqHlubPlj7DnrYnkuInkuKrkuLvopoHnsbvlnotbNDRd44CC5Zyo5Zu95aSW77yM6YeR6J6N56eR5oqA5YWs5Y+4T0dZRG9jc+aehOW7uuWMuuWdl+mTvui0uOaYk+mHkeiejeW5s+WPsFdhdmXvvIzliKnnlKjliIbluIPlvI/otKbmnKzlr7nmlofku7blkozllYblk4HlnKjov5DovpPov4fnqIvkuK3nmoTmiYDmnInmnYPov5vooYznrqHnkIbvvIzmm7/ku6PkvKDnu5/nmoTlkITpobnnurjotKjljZXor4HvvIzku6Xmj5Dpq5jlm73pmYXotLjmmJPnmoTkuqTmmJPmlYjnjoflkozlronlhajmgKfvvIzljrvpmaTnuqDnurfjgIHkvKrpgKDlk4HlkozkuI3lv4XopoHnmoTpo47pmalbNDRd44CCIOWFtuasoe+8jOeJqea1geS+m+W6lOmTvumihuWfn+aYr+WMuuWdl+mTvuacgOacieW6lOeUqOWJjeaZr+eahOmihuWfn+S5i+S4gFs0NV3jgILljLrlnZfpk77mioDmnK/nmoTliIbluIPlvI/orrDotKbnibnmgKfog73kvb/kvpvlupTpk77kuIrnmoTkv6Hmga/kv53mjIHkuIDoh7TvvIzlkIToioLngrnmiJDlkZjlhbHkuqvlhazlvIDnmoTkv6Hmga/otYTmupDvvIzmnInliKnkuo7op6PlhrPkv6Hmga/kuI3lr7nnp7Dpl67popg75pm66IO95ZCI57qm5py65Yi25Y+v5Zyo5peg6ZyA56ys5LiJ5pa55LuL5YWl55qE5oOF5Ya15LiL5oyJ6KeE5YiZ6Ieq5Yqo55Sf5oiQ5ZCI57qm77yM5bm25Zyo5ruh6Laz5Lqk5piT5p2h5Lu25pe26Ieq5Yqo5omn6KGM5ZCI57qm5p2h5qy+77yM6IO95o+Q6auY5ZCE546v6IqC5pSv5LuY5ZKM5Lqk5piT5pWI546H77yM6YG/5YWN6LWE6YeR5bu26L+f6aOO6ZmpO+aXtumXtOaIs+WSjOa6r+a6kOmYsuS8quaKgOacr+WPr+WvueeJqea1geS+m+W6lOmTvuS4iueahOS6p+WTgei/m+ihjOWFqOmTvui3n+i4qu+8jOWunueOsOWuieWFqOOAgemrmOaViOOAgeWPr+mdoOeahOS/oeaBr+S8oOi+kzvpnZ7lr7nnp7DliqDlr4bmioDmnK/lj6/ku6Xkv53or4HmlbDmja7kuI3ooqvnr6HmlLnvvIzmnInliqnkuo7kuqTmmJPkuLvpopjkuYvpl7Tkv6Hku7vlhbPns7vnmoTlu7rnq4tbNDZd44CC5Zyo5ZCE5Zu95pS/5bqc5ZKM55u45YWz5LyB5Lia55qE5pSv5oyB5LiL77yM5LiA5Lqb4oCc5Yy65Z2X6ZO+K+eJqea1geS+m+W6lOmTvuKAnemhueebruW+l+S7peWunui3te+8jOWmguS4uem6puiIqui/kOWFrOWPuOmprOWjq+WfuuS4jklCTeeahOWFqOeQg+i3qOWig+eJqea1geezu+e7n1s0N13jgIHmlrDliqDlnaHlhazlj7hZb2plZeeahOi/kOi+k+S8mOWMluezu+e7n1s0OF3jgIHnkZ7lo6vlhazlj7hNb2R1beS4juiLj+m7juS4luWkp+WtpuWQiOS9nOiuvuiuoeeahOWMu+iNr+i/kOi+k+ezu+e7n1s3XeOAgeiLseWbveWFrOWPuEV2ZXJsZWRnZXLln7rkuo7ljLrlnZfpk77nmoTkuqflk4HmnaXmupDpqozor4Hns7vnu59bNDld562J44CC6L+Z5Lqb6aG555uu55qE5oiQ5Yqf5a6e5pa95Li65Yy65Z2X6ZO+5bqU55So56ev57Sv5LqG5a6d6LS157uP6aqM44CCIOacgOWQju+8jOWMuuWdl+mTvuWcqOWFtuS7lumihuWfn+S+m+W6lOmTvuS4iueahOW6lOeUqOS9k+eOsOS6huWMuuWdl+mTvuaKgOacr+W6lOeUqOeahOWkmuagt+aAp++8jOWFt+S9k+ihqOeOsOS4uuWcqOWGnOS6p+WTgeOAgemjn+WTgeOAgeWMu+iNr+OAgeeUteWKm+OAgeWGm+S6i+S+m+W6lOmTvuetieS8l+WkmumihuWfn+eahOWFt+S9k+i/kOeUqOOAguWMuuWdl+mTvuWcqOWGnOS6p+WTgVs1MF3lkozpo5/lk4FbNTFd5L6b5bqULi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKV3JpdGUgYW4gYWJzdHJhY3QgZm9yIHRoaXMgcGFwZXIgb24gdGhlIGRlc2lnbiBvZiBhIHNvZnR3YXJlIHRlc3RpbmcgYXV0b21hdGlvbiBmcmFtZXdvcmsgZm9yICoqMS4gSW50cm9kdWN0aW9uKioKClNvIGZhciwgdGhlIHJhcGlkIGRldmVsb3BtZW50IG9mIGluZm9ybWF0aW9uIHRlY2hub2xvZ3kgaGFzIGxlZCB0byB0aGUgYXBwbGljYXRpb24gb2Ygc29mdHdhcmUgcHJvZHVjdHMgaW4gdmFyaW91cyBzZWN0b3JzIG9mIHNvY2lldHkuIE5hdHVyYWxseSwgdGhlIHF1YWxpdHkgb2Ygc29mdHdhcmUgcHJvZHVjdHMgaGFzIGJlY29tZSBhIGNvbW1vbiBmb2N1cyBvZiBhdHRlbnRpb24uIFRvIGVuc3VyZSBwcm9kdWN0IHF1YWxpdHksIHNvZnR3YXJlIHRlc3Rpbmcgd2lsbCByZW1haW4gYW4gZWZmZWN0aXZlIG1ldGhvZCBmb3Igc29mdHdhcmUgcHJvZHVjdCBxdWFsaXR5IGFzc3VyYW5jZSBmb3IgYSBsb25nIHRpbWUgaW4gdGhlIGZ1dHVyZS4gQXV0b21hdGVkIHRlc3RpbmcgaXMgYSB3aWRlbHkgZGlzY3Vzc2VkIGRpcmVjdGlvbiBpbiB0b2RheSdzIHNvZnR3YXJlIHRlc3RpbmcgaW5kdXN0cnkuIEN1cnJlbnRseSwgcGVyZm9ybWFuY2UgdGVzdGluZyBhdXRvbWF0aW9uIGlzIHRoZSBtb3N0IG1hdHVyZSBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgaW5kdXN0cnkuIEFzIGZvciBzeXN0ZW0gdGVzdGluZyBhdXRvbWF0aW9uLCBpbmNsdWRpbmcgVUkgdGVzdGluZyBhdXRvbWF0aW9uLCB1bml0IHRlc3RpbmcgYXV0b21hdGlvbiwgYW5kIGZ1bmN0aW9uYWwgdGVzdGluZyBhdXRvbWF0aW9uLCBhbHRob3VnaCBwb3dlcmZ1bCB0aGlyZC1wYXJ0eSBzb2Z0d2FyZSB0ZXN0aW5nIHRvb2xzIHN1Y2ggYXMgUVRQLCBXSU5SVU5ORVIsIGFuZCBTRUxFTklVTSBjYW4gYmUgdXNlZCBhcyBzb2x1dGlvbnMsIGluIHByYWN0aWNlLCBjb21wYW5pZXMgZmluZCBpdCBkaWZmaWN1bHQgdG8gc3VjY2Vzc2Z1bGx5IGltcGxlbWVudCB0ZXN0IGF1dG9tYXRpb24gcmVseWluZyBvbiBhIHNpbmdsZSB0b29sLiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoZSBsYWNrIG9mIGEgY29tcGxldGUgc2V0IG9mIHRlc3QgYXV0b21hdGlvbiBzb2x1dGlvbnMsIGkuZS4sIHRoZSBhYnNlbmNlIG9mIGEgdGVzdGluZyBmcmFtZXdvcmsuIFRoZXJlZm9yZSwgbW9yZSBtYW5wb3dlciBpcyBvZnRlbiByZXF1aXJlZCB0byBsZWFybiBob3cgdG8gdXNlIHRoZSB0b29scywgd3JpdGUgY29tcGxleCB0ZXN0IHNjcmlwdHMsIG1hbnVhbGx5IG9idGFpbiB0ZXN0IHJlc3VsdHMgYW5kIGFuYWx5emUgdGhlbSwgYW5kIGRlYWwgd2l0aCB0aGUgZGFtYWdlIGNhdXNlZCBieSBjaGFuZ2VzIGluIHByb2plY3QgcGVyc29ubmVsLiBIZW5jZSwgYnVpbGRpbmcgYSBjb21wbGV0ZSB0ZXN0IGF1dG9tYXRpb24gZnJhbWV3b3JrIGlzIGFuIGluZXZpdGFibGUgdHJlbmQuIAoKQW4gYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3JrIGlzIGEgY29tcHJlaGVuc2l2ZSBzb2x1dGlvbiBmb3IgdGVzdCBhdXRvbWF0aW9uLCBwbGF5aW5nIGEga2V5IHJvbGUgaW4gdGhlIHNwZWNpZmljIHdvcmsgb2Ygc29mdHdhcmUgdGVzdCBhdXRvbWF0aW9uLiBUaGUgaW5kdXN0cnkgaXMgYWN0aXZlbHkgY29uc3RydWN0aW5nIGF1dG9tYXRlZCB0ZXN0aW5nIGZyYW1ld29ya3MgdGFpbG9yZWQgdG8gdGhlIG5lZWRzIG9mIHRoZWlyIHJlc3BlY3RpdmUgY29tcGFuaWVzLiBDb21tb25seSBtZW50aW9uZWQgYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3JrcyBpbiB0aGUgaW5kdXN0cnkgaW5jbHVkZSBkYXRhLWRyaXZlbiBhdXRvbWF0ZWQgdGVzdGluZyBmcmFtZXdvcmtzLCBrZXl3b3JkLWRyaXZlbiB0ZXN0aW5nIGZyYW1ld29ya3MsIGFuZCB0YWJsZS1kcml2ZW4gYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3Jrcy4gVGhlc2UgdGVzdGluZyBmcmFtZXdvcmtzIGltcHJvdmUgdGVzdGluZyBlZmZpY2llbmN5IGluIGNlcnRhaW4gc3RhZ2VzIG9mIHNvZnR3YXJlIHRlc3RpbmcsIGJ1dCBhbHNvIGludHJvZHVjZSBvdGhlciBpc3N1ZXMuIFRoaXMgYXJ0aWNsZSBhcmd1ZXMgdGhhdCB0ZXN0aW5nIGZyYW1ld29ya3Mgc2hvdWxkIG5vdCBiZSBkZXNpZ25lZCBmb3Igc3BlY2lmaWMgdGVzdGluZyBhY3Rpdml0aWVzIGJ1dCBzaG91bGQgYmUgY2F0ZWdvcml6ZWQgYWNjb3JkaW5nIHRvIGRldmVsb3BtZW50IHR5cGVzLCB3aGljaCBpcyBhIG1vcmUgcmVhc29uYWJsZSBhcHByb2FjaC4gVGhpcyBwYXBlciBwcm9wb3NlcyBhIHRlc3QgZnJhbWV3b3JrIHN1aXRhYmxlIGZvciBpdGVyYXRpdmUgZGV2ZWxvcG1lbnQuCgoqKjIuIERlc2lnbiBvZiB0aGUgU29mdHdhcmUgVGVzdGluZyBBdXRvbWF0aW9uIEZyYW1ld29yayBCYXNlZCBvbiBJdGVyYXRpdmUgU29mdHdhcmUgRGV2ZWxvcG1lbnQqKgoKKioyLjEgU29mdHdhcmUgVGVzdCBBdXRvbWF0aW9uKioKCkN1cnJlbnRseSwgc29mdHdhcmUgdGVzdCBhdXRvbWF0aW9uIHJlZmVycyB0byB0aGUgdXNlIG9mIHByb2dyYW0gZXhlY3V0aW9uIHRvIHJlcGxhY2UgbWFudWFsIHRlc3RpbmcsIHRodXMgcmVkdWNpbmcgbWFudWFsIHdvcmtsb2FkIGFuZCBpbXByb3ZpbmcgdGVzdGluZyBlZmZpY2llbmN5LiBBdXRvbWF0ZWQgdGVzdGluZyBmcmFtZXdvcmtzIGFyZSBjb21wcmVoZW5zaXZlIHNvbHV0aW9ucyB0aGF0IGFjaGlldmUgaGlnaC1lZmZpY2llbmN5LCBoaWdoLXF1YWxpdHkgYXV0b21hdGVkIHRlc3RpbmcuIEl0ZXJhdGl2ZSBkZXZlbG9wbWVudCBpcyBhIGdyYWR1YWwgZGV2ZWxvcG1lbnQgbWV0aG9kIHRoYXQgZGl2aWRlcyB0aGUgZW50aXJlIGRldmVsb3BtZW50IHByb2Nlc3MgaW50byBzZXZlcmFsIGl0ZXJhdGl2ZSBjeWNsZXMsIHdpdGggZWFjaCBjeWNsZSBwcm9kdWNpbmcgYSBydW5uYWJsZSBzb2Z0d2FyZS4gSXRlcmF0aXZlIGRldmVsb3BtZW50IGlzIHRoZSBtb3N0IHN1aXRhYmxlIGRldmVsb3BtZW50IGFjdGl2aXR5IGZvciB0ZXN0IGF1dG9tYXRpb24gYW5kIGNhbiBtYXhpbWl6ZSB0aGUgYmVuZWZpdHMgb2YgYXV0b21hdGVkIHRlc3RpbmcuIAoKSW4gaXRlcmF0aXZlIGRldmVsb3BtZW50LCBlYWNoIHNvZnR3YXJlIGRldmVsb3BtZW50IGN5Y2xlIGFkZHMgbmV3IGZlYXR1cmVzLCB3aGVyZSB0ZXN0ZXJzIGRlc2lnbiB0ZXN0cyBmb3IgdGhlIG5ldyBmZWF0dXJlcywgdHJhbnNpdGlvbiB0byBmdW5jdGlvbmFsIHZlcmlmaWNhdGlvbiwgZXhlY3V0ZSB0ZXN0cyBmb3IgbmV3IGZlYXR1cmVzLCBhbmQgcGVyZm9ybSByZWdyZXNzaW9uIHRlc3RpbmcgZm9yIGlzc3VlcyBkaXNjb3ZlcmVkIGluIHRoZSBwcmV2aW91cyByb3VuZCBvZiB0ZXN0aW5nLiBJbiB0aGVzZSB0ZXN0aW5nIGFjdGl2aXRpZXMsIGFjdGl2aXRpZXMgc3VjaCBhcyB0ZXN0IHZlcmlmaWNhdGlvbiwgbmV3IGZlYXR1cmUgdGVzdGluZywgYW5kIHJlZ3Jlc3Npb24gdGVzdGluZyBhcmUgZWFzeSB0byBhdXRvbWF0ZSBhbmQgc3VpdGFibGUgZm9yIGF1dG9tYXRpb24uIAoKSW4gdGhlIHRlc3RpbmcgcHJvY2VzcyAoYXMgc2hvd24gaW4gRmlndXJlIDEpOgoKMS4gQWZ0ZXIgdmVyc2lvbiB0cmFuc2l0aW9uIHRlc3RpbmcsIGZ1bmN0aW9uYWwgdmVyaWZpY2F0aW9uIGlzIGNvbmR1Y3RlZCBmaXJzdCB0byBwcm92ZSB0aGF0IG5vIG5ldyBzZXJpb3VzIGlzc3VlcyBoYXZlIGJlZW4gaW50cm9kdWNlZCBpbiB0aGUgdHJhbnNpdGlvbmVkIHZlcnNpb24uIEFwcHJvcHJpYXRlIHRlc3QgY2FzZXMgYXJlIHNlbGVjdGVkIGZyb20gdGhlIHNjcmlwdCBsaWJyYXJ5IGZvciB0ZXN0aW5nLgoyLiBSZWdyZXNzaW9uIHRlc3RpbmcgaXMgcGVyZm9ybWVkIGZvciBkZWZlY3RzIGZvdW5kIGluIHRoZSBwcmV2aW91cyBzdGFnZS4gVGhlIHVzZSBvZiBwcmV2aW91cyBzY3JpcHRzIGNhbiBwcmV2ZW50IHRoZSBhcmJpdHJhcmluZXNzIG9mIG1hbnVhbCB0ZXN0aW5nIGFuZCBhY2hpZXZlIGEgY29tcGxldGVseSByZXN0b3JlZCBvbi1zaXRlIHNjZW5hcmlvLgozLiBOZXcgZnVuY3Rpb25hbGl0eSBpcyB0ZXN0ZWQgdXNpbmcgbmV3IHRlc3Qgc2NyaXB0cy4gQWZ0ZXIgdGVzdGluZywgdGhlIG5ldyBmZWF0dXJlIHNjcmlwdHMgYXJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBzY3JpcHQgbGlicmFyeSBmb3IgdGhlIG5leHQgcm91bmQgb2YgdHJhbnNpdGlvbiB0ZXN0aW5nIGFuZCByZWdyZXNzaW9uIHRlc3RpbmcuCgoqKkZpZ3VyZSAxKioKCkNsZWFybHksIHRlc3Qgc2NyaXB0cyBhcmUgcnVuIG11bHRpcGxlIHRpbWVzIHRocm91Z2hvdXQgdGhlIGVudGlyZSBpdGVyYXRpdmUgcHJvY2VzcywgbWFraW5nIHRoZWlyIHVzYWdlIGhpZ2hseSBlZmZpY2llbnQsIHdoaWNoIGRpcmVjdGx5IGltcHJvdmVzIHRoZSBvdXRwdXQtdG8taW5wdXQgcmF0aW8gb2YgYXV0b21hdGVkIHRlc3RpbmcuCgoqKjIuMiBEZXNpZ24gb2YgU29mdHdhcmUgVGVzdGluZyBBdXRvbWF0aW9uIEZyYW1ld29yayoqCgpUaGUgc29mdHdhcmUgdGVzdGluZyBhdXRvbWF0aW9uIGZyYW1ld29yayBpcyBhIGNvbXByZWhlbnNpdmUgc29sdXRpb24gZm9yIHRlc3QgYXV0b21hdGlvbiwgcHJvdmlkaW5nIGEgY29tcGxldGUgc2V0IG9mIHRlc3RpbmcgYWN0aXZpdGllcy4gSXQgY2VudHJhbGl6ZXMsIHNwZWNpYWxpemVzLCBhbmQgYWJzdHJhY3RzIHRoZSB3b3JrIG9mIHRlc3RlcnMuIEluIHRoZSB0ZXN0aW5nIGZyYW1ld29yaywgdGhlIHdvcmsgb2YgdGVzdGVycyBpcyBhcyBzaG93biBpbiBGaWd1cmUgMjoKCjEuICoqVGVzdCBEZXNpZ24qKjogVGVzdGVycyB1c2UgdmFyaW91cyB0ZXN0IGRlc2lnbiBtZXRob2RzIHN1Y2ggYXMgZXF1aXZhbGVuY2UgY2xhc3MgcGFydGl0aW9uaW5nLCBib3VuZGFyeSB2YWx1ZSBhbmFseXNpcywgYW5kIGNhdXNlLWVmZmVjdCBncmFwaGluZyB0byBjcmVhdGUgZGVzaWduIHBsYW5zIGFuZCB0ZXN0IGNhc2VzLCBhbmQgdXBsb2FkIHRoZSB0ZXN0IGNhc2VzIHRvIHRoZSB0ZXN0aW5nIGZyYW1ld29yay4KMi4gKipSZXN1bHQgQW5hbHlzaXMqKjogQW5hbHl6ZSB0aGUgdGVzdCByZXN1bHRzIGZlZWRiYWNrIGZyb20gZXhlY3V0aW5nIHRoZSB0ZXN0IGNhc2VzIGluIHRoZSB0ZXN0aW5nIGZyYW1ld29yay4KClRvIHJlbGlldmUgdGVzdGVycyBmcm9tIHRoZSBjb21wbGV4aXR5IG9mIHZhcmlvdXMgdGVzdGluZyBhY3RpdmkuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgrmiJHmg7PmkrDlhpnkuIDnr4fmnLrlmajlrabkuaDlnKjmmbrog73liLbpgKDotKjph4/mjqfliLbkuK3nmoTlupTnlKjnoJTnqbborrrmlofvvIzlh4blpIfmipXnqL/jgIrmmbrog73liLbpgKDjgIvmnJ/liIrjgILorrrmlofnqoHlh7rmnLrlmajlrabkuaDnrpfms5XlnKjlt6XkuJrlnLrmma/kuIvnmoTmlLnov5vliJvmlrDngrnlkozlrp7pmYXlt6XnqIvlupTnlKjmlYjmnpzjgILor7fmjInnhafjgIrmmbrog73liLbpgKDjgIvmnJ/liIrmoLzlvI/opoHmsYLvvIzluK7miJHlhpnkuIDkuKrorrrmloflpKfnurLjgILlj6/ku6Xlj4LogIPku6XkuIvojIPmlofntKDmnZDjgILln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLYgIOiigeiKrCAgIOWNl+S6rOacuueUteiBjOS4muaKgOacr+WtpumZouiHquWKqOWMluW3peeoi+ezuyAgIOaRmOimge+8muWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItuaYr+W9k+WJjeW3peS4mueUn+S6p+S4reWFs+azqOeahOeDreeCuemihuWfn+OAguacrOaWh+ezu+e7n+WcsOaOouiuqOS6huWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueahOWFs+mUruaKgOacr+WSjOS4u+imgea1geeoi++8jOaPkOWHuuS6huWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueahOW6lOeUqOetlueVpe+8jOWMheaLrOWfuuS6juaZuuiDveS8oOaEn+WZqOeahOWunuaXtui0qOmHj+ebkea1i+OAgeWfuuS6jumihOa1i+WIhuaekOeahOaVhemanOajgOa1i+S4jumihOitpuOAgeWfuuS6jui/nOeoi+ebkeaOp+eahOWIhuW4g+W8j+i0qOmHj+aOp+WItu+8jOS7peWPiuWfuuS6juefpeivhuWbvuiwseeahOefpeivhuaOqOeQhuS4juWGs+etlu+8jOS7peS+m+WPguiAg+OAgiAg5Z+66YeR77yaIDIwMjPlubTluqbmsZ/oi4/pq5jmoKHigJzpnZLok53lt6XnqIvigJ3otYTliqkgOyAyMDIz5bm05bqm5rGf6IuP6auY5qCh5ZOy5a2m56S+5Lya56eR5a2m56CU56m26aG555uu56CU56m25oiQ5p6c77yIMjAyM1NKWUIwODI277yJIDsg5Y2X5Lqs5py655S16IGM5Lia5oqA5pyv5a2m6Zmi56eN5a2Q5Z+66YeR6aG555uu56CU56m25oiQ5p6c77yITEQyMDIzMDHvvIkgICDlhbPplK7or43vvJrmnLrmorDmmbrog73liLbpgKA76LSo6YeP5o6n5Yi2O+a3seW6puWtpuS5oDvmlbDmja7lpITnkIY75a6e5pe255uR5rWLICDkvZzogIXnroDku4vvvJroooHoiqzvvIgxOTgz4oCU77yJ77yM5aWz77yM56GV5aOr77yM6K6y5biI77yM5Li76KaB56CU56m25pa55ZCR55S15rCU6Ieq5Yqo5YyWICDmlLbnqL/ml6XmnJ/vvJoyMDIzLTA3LTI1ICBEZWVwIGxlYXJuaW5nLWJhc2VkIHF1YWxpdHkgY29udHJvbCBmb3IgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBvZiBtYWNoaW5lcnkgIFlVQU4gRmVuICBEZXBhcnRtZW50IG9mIEF1dG9tYXRpb24gRW5naW5lZXJpbmcsIE5hbmppbmcgSW5zdGl0dXRlIG9mIE1lY2hhbmljYWwgYW5kIEVsZWN0cmljYWwgVGVjaG5vbG9neSAgQWJzdHJhY3TvvJpRdWFsaXR5IGNvbnRyb2wgb2YgbWVjaGFuaWNhbCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIGJhc2VkIG9uIGRlZXAgbGVhcm5pbmcgaXMgYSBob3QgYXJlYSBvZiBjb25jZXJuIGluIGN1cnJlbnQgaW5kdXN0cmlhbCBwcm9kdWN0aW9uLiBUaGlzIHBhcGVyIHN5c3RlbWF0aWNhbGx5IGRpc2N1c3NlcyB0aGUga2V5IHRlY2hub2xvZ2llcyBhbmQgbWFpbiBwcm9jZXNzZXMgb2YgZGVlcCBsZWFybmluZy1iYXNlZCBtZWNoYW5pY2FsIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgcXVhbGl0eSBjb250cm9sLCBhbmQgcHV0cyBmb3J3YXJkIHRoZSBhcHBsaWNhdGlvbiBzdHJhdGVnaWVzIG9mIGRlZXAgbGVhcm5pbmctYmFzZWQgbWVjaGFuaWNhbCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHF1YWxpdHkgY29udHJvbCwgaW5jbHVkaW5nIHJlYWwtdGltZSBxdWFsaXR5IG1vbml0b3JpbmcgYmFzZWQgb24gaW50ZWxsaWdlbnQgc2Vuc29ycywgZmF1bHQgZGV0ZWN0aW9uIGFuZCBlYXJseSB3YXJuaW5nIGJhc2VkIG9uIHByZWRpY3RpdmUgYW5hbHl0aWNzLCBkaXN0cmlidXRlZCBxdWFsaXR5IGNvbnRyb2wgYmFzZWQgb24gcmVtb3RlIG1vbml0b3JpbmcgYW5kIGRpc3RyaWJ1dGVkIHF1YWxpdHkgY29udHJvbCwgYXMgd2VsbCBhcyBrbm93bGVkZ2UgcmVhc29uaW5nIGFuZCBkZWNpc2lvbi1tYWtpbmcgYmFzZWQgb24ga25vd2xlZGdlIGdyYXBoLCBmb3IgcmVmZXJlbmNlLiBLZXkgd29yZHPvvJpNZWNoYW5pY2FsIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgOyBRdWFsaXR5IGNvbnRyb2wgOyBEZWVwIGxlYXJuaW5nIDsgRGF0YSBwcm9jZXNzaW5nIDsgUmVhbC10aW1lIG1vbml0b3JpbmcgUmVjZWl2ZWTvvJoyMDIzLTA3LTI1ICAwIOW8leiogCDpmo/nnYDmnLrmorDmmbrog73liLbpgKDmioDmnK/nmoTkuI3mlq3lj5HlsZXvvIzliLbpgKDooYzkuJrlr7nkuqflk4HotKjph4/nmoTopoHmsYLkuZ/otormnaXotorpq5jjgILkvKDnu5/nmoTotKjph4/mjqfliLbmlrnms5XlnKjpnaLlr7nlpKfop4TmqKHmlbDmja7lkozlpI3mnYLnlJ/kuqfov4fnqIvml7bpnaLkuLTnnYDmjJHmiJjvvIzlm6DmraTpnIDopoHlvJXlhaXmlrDnmoTmioDmnK/miYvmrrXmnaXop6PlhrPov5nkupvpl67popjjgILmt7HluqblrabkuaDkvZzkuLrkurrlt6Xmmbrog73poobln5/nmoTph43opoHliIbmlK/vvIzlnKjlm77lg4/jgIHor63pn7Plkozoh6rnhLbor63oqIDlpITnkIbnrYnpoobln5/lj5blvpfkuobmmL7okZfnmoTmiJDmnpzvvIzlubbkuJTlnKjotKjph4/mjqfliLbpoobln5/kuZ/lhbfmnInlub/pmJTnmoTlupTnlKjliY3mma/jgILmnKzmlofml6jlnKjpgJrov4fln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnoJTnqbbvvIzmj5DkvpvkuIDnp43mlrDnmoTop6PlhrPmlrnmoYjmnaXmlLnlloTkvKDnu5/nmoTotKjph4/mjqfliLbmlrnms5XjgIIgMSDln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTlhbPplK7mioDmnK8gMS4xIOa3seW6puWtpuS5oOeul+azleWfuuehgCDmt7HluqblrabkuaDmmK/kuIDnp43ku6Xkurrlt6XnpZ7nu4/nvZHnu5zkuLrln7rnoYDnmoTmnLrlmajlrabkuaDmlrnms5XvvIzlroPpgJrov4flpJrlsYLmrKHnmoTnpZ7nu4/nvZHnu5znu5PmnoTmnaXlr7nmlbDmja7ov5vooYzlrabkuaDlkozooajnpLrjgILmt7HluqblrabkuaDnrpfms5Xln7rnoYDljIXmi6zku6XkuIvlh6DkuKrlhbPplK7opoHntKDjgIIg6aaW5YWI77yM56We57uP572R57uc5qih5Z6L5piv5rex5bqm5a2m5Lmg566X5rOV55qE5qC45b+D44CC5a6D55Sx5aSa5Liq56We57uP5YWD57uE5oiQ55qE5bGC5qyh57uT5p6E77yM5q+P5Liq56We57uP5YWD6YO95Lul5Yqg5p2D5ZKM55qE5pa55byP5o6l5pS26L6T5YWl77yM54S25ZCO57uP6L+H6Z2e57q/5oCn5r+A5rS75Ye95pWw6L+b6KGM6L2s5o2i77yM6L6T5Ye65Yiw5LiL5LiA5bGC44CC6YCa5bi477yM5rex5bqm5a2m5Lmg5Lit5L2/55So55qE56We57uP572R57uc5qih5Z6L5YyF5ous5Y2356ev56We57uP572R57uc77yIQ05O77yJ44CB5b6q546v56We57uP572R57uc77yIUk5O77yJ5ZKM5Y+Y5o2i5Zmo572R57uc77yIVHJhbnNmb3JtZXLvvInnrYnjgILlhbbmrKHvvIzmt7HluqblrabkuaDnrpfms5XnmoTlrabkuaDov4fnqIvmmK/pgJrov4flj43lkJHkvKDmkq3nrpfms5Xov5vooYznmoTjgILlj43lkJHkvKDmkq3nrpfms5XpgJrov4forqHnrpfovpPlh7rkuI7nnJ/lrp7lgLzkuYvpl7TnmoTor6/lt67vvIzlubblsIbor6/lt67ku47ovpPlh7rlsYLpgJDlsYLlkJHliY3kvKDmkq3vvIzmm7TmlrDnpZ7nu4/nvZHnu5zkuK3nmoTmnYPph43lkozlgY/nva7vvIzku6XmnIDlsI/ljJbor6/lt65bMV3jgILmraTlpJbvvIzmt7HluqblrabkuaDnrpfms5Xov5jpnIDopoHpgInmi6nlkIjpgILnmoTmjZ/lpLHlh73mlbDmnaXluqbph4/ovpPlh7rnu5PmnpzlkoznnJ/lrp7lgLzkuYvpl7TnmoTlt67lvILjgILluLjnlKjnmoTmjZ/lpLHlh73mlbDljIXmi6zlnYfmlrnor6/lt67vvIhNU0XvvInjgIHkuqTlj4nnhrXmjZ/lpLHlh73mlbDnrYnjgILmnIDlkI7vvIzmt7HluqblrabkuaDnrpfms5Xov5jpnIDopoHpgInmi6nlkIjpgILnmoTkvJjljJbnrpfms5XmnaXmm7TmlrDnpZ7nu4/nvZHnu5zkuK3nmoTlj4LmlbDjgILluLjnlKjnmoTkvJjljJbnrpfms5XljIXmi6zpmo/mnLrmoq/luqbkuIvpmY3vvIhTR0TvvInjgIFBZGFt5LyY5YyW566X5rOV562J77yM5a6D5Lus6IO95aSf5pyJ5pWI5Zyw6LCD5pW05Y+C5pWw77yM5o+Q6auY5qih5Z6L55qE5oCn6IO944CCIDEuMiDmlbDmja7ph4fpm4bkuI7pooTlpITnkIbmioDmnK8g5pWw5o2u6YeH6ZuG5LiO6aKE5aSE55CG5oqA5pyv5Zyo5rex5bqm5a2m5Lmg5Lit5piv6Z2e5bi46YeN6KaB55qE5LiA5q2l77yM5a6D5Li76KaB5YyF5ous5pWw5o2u5pS26ZuG44CB5pWw5o2u5riF5rSX44CB5pWw5o2u6L2s5o2i5ZKM5pWw5o2u5aKe5by6562J6L+H56iL44CCIOmmluWFiO+8jOaVsOaNruaUtumbhuaYr+aMh+S7juWItumAoOi/h+eoi+S4reiOt+WPluebuOWFs+eahOi0qOmHj+aOp+WItuaVsOaNruOAgui/meS6m+aVsOaNruWPr+S7peWMheaLrOS8oOaEn+WZqOmHh+mbhueahOeJqeeQhuS/oeWPt+OAgeW3peiJuuWPguaVsOOAgeinhuinieWbvuWDj+etieOAguaVsOaNruaUtumbhueahOi0qOmHj+WSjOacieaViOaAp+ebtOaOpeW9seWTjeWIsOWQjue7reaooeWei+eahOiuree7g+WSjOaAp+iDveOAguWFtuasoe+8jOaVsOaNrua4hea0l+aYr+aMh+WvuemHh+mbhuWIsOeahOWOn+Wni+aVsOaNrui/m+ihjOWOu+WZquOAgee8uuWkseWAvOWhq+WFheOAgeW8guW4uOWAvOWkhOeQhuetieaTjeS9nO+8jOS7pea2iOmZpOaVsOaNruS4reeahOWZquWjsOWSjOW5suaJsO+8jOS/neivgeaVsOaNrueahOWHhuehruaAp+WSjOWujOaVtOaAp+OAguaVsOaNrui9rOaNouaYr+WwhuWOn+Wni+aVsOaNrui9rOaNouS4uua3seW6puWtpuS5oOeul+azleiDveWkn+WkhOeQhueahOW9ouW8j+OAguS+i+Wmgu+8jOWvueS6juWbvuWDj+aVsOaNru+8jOWPr+S7pei/m+ihjOWbvuWDj+mihOWkhOeQhuaTjeS9nO+8jOWmguiwg+aVtOWkp+Wwj+OAgeijgeWJquOAgeaXi+i9rOetieOAguWvueS6juaVsOWAvOWei+aVsOaNru+8jOWPr+S7pei/m+ihjOW9kuS4gOWMluaIluagh+WHhuWMluWkhOeQhu+8jOWwhuaVsOaNrue8qeaUvuWIsOS4gOWumueahOiMg+WbtOWGheOAguacgOWQju+8jOaVsOaNruWinuW8uuaYr+mAmui/h+S4gOezu+WIl+eahOaVsOaNruaJqeWFheaWueazle+8jOeUn+aIkOabtOWkmueahOiuree7g+agt+acrOOAguS+i+Wmgu+8jOWvueS6juWbvuWDj+aVsOaNru+8jOWPr+S7pei/m+ihjOmaj+acuue/u+i9rOOAgeaXi+i9rOOAgee8qeaUvuetieaTjeS9nO+8jOWinuWKoOaVsOaNrueahOWkmuagt+aAp+WSjOaVsOmHj++8jOaPkOmrmOaooeWei+eahOazm+WMluiDveWKm+OAgiAxLjMg54m55b6B5o+Q5Y+W5LiO6KGo56S65a2m5LmgIOeJueW+geaPkOWPluS4juihqOekuuWtpuS5oOaYr+a3seW6puWtpuS5oOS4reeahOWFs+mUrueOr+iKgu+8jOWug+iDveWkn+S7juWOn+Wni+aVsOaNruS4reaPkOWPluWHuuWFt+acieWMuuWIhuiDveWKm+eahOeJueW+ge+8jOW5tuWwhuWFtuihqOekuuS4uuS4gOS4quS9jue7tOeahOWQkemHj+OAgiDlnKjmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbkuK3vvIznibnlvoHmj5Dlj5blkozooajnpLrlrabkuaDlj6/ku6Xku47ljp/lp4vnmoTkvKDmhJ/lmajkv6Hlj7fmiJblm77lg4/mlbDmja7kuK3mj5Dlj5blh7rku6PooajotKjph4/nibnlvoHnmoTlhbPplK7kv6Hmga/vvIznlKjkuo7liKTmlq3kuqflk4HnmoTlkIjmoLzmgKfjgIIg5a+55LqO5Zu+5YOP5pWw5o2u77yM5Y+v5Lul5L2/55So5Y2356ev56We57uP572R57uc77yIQ05O77yJ6L+b6KGM54m55b6B5o+Q5Y+W44CCQ05O6IO95aSf6YCa6L+H5LiA57O75YiX55qE5Y2356ev44CB5rGg5YyW5ZKM6Z2e57q/5oCn5r+A5rS7562J5pON5L2c77yM5LuO5Zu+5YOP5Lit5o+Q5Y+W5Ye65YW35pyJ5bGA6YOo5ZKM5YWo5bGA5L+h5oGv55qE54m55b6B44CC6L+Z5Lqb54m55b6B5Y+v5Lul6KGo56S65Zu+5YOP55qE57q555CG44CB5b2i54q25ZKM6L6557yY562J54m55b6B77yM55So5LqO5Yik5pat5Lqn5ZOB6KGo6Z2i55qE57y66Zm344CB5b2i54q25YGP5beu562JWzJd44CCIOWvueS6juS8oOaEn+WZqOS/oeWPt+aVsOaNru+8jOWPr+S7peS9v+eUqOW+queOr+elnue7j+e9kee7nO+8iFJOTu+8ieaIluWPmOaNouWZqOe9kee7nO+8iFRyYW5zZm9ybWVy77yJ6L+b6KGM54m55b6B5o+Q5Y+W44CCUk5O6IO95aSf5a+55pe26Ze05bqP5YiX5pWw5o2u6L+b6KGM5bu65qih77yM5bm25o2V5o2J5Yiw5YW25Lit55qE5pe25bqP5L6d6LWW5YWz57O744CC6ICMVHJhbnNmb3JtZXLliJnog73lpJ/lr7nkuI3lkIzkvKDmhJ/lmajkv6Hlj7fkuYvpl7TnmoTlhbPns7vov5vooYzlu7rmqKHvvIzmj5Dlj5blh7rlhajlsYDkuIrnmoTnibnlvoHooajnpLrjgIIgMS40IOaooeWei+S8mOWMluS4juaooeWei+iuree7gyDmqKHlnovkvJjljJblkozmqKHlnovorq3nu4PmmK/mt7HluqblrabkuaDkuK3oh7PlhbPph43opoHnmoTkuIDmraXvvIzlroPmtonlj4rliLDpgInmi6nlkIjpgILnmoTmqKHlnovmnrbmnoTjgIHmjZ/lpLHlh73mlbDlkozkvJjljJbnrpfms5XvvIzku6Xlj4rlr7nmqKHlnovov5vooYzmnInmlYjnmoTorq3nu4PlkozosIPkvJjjgIIg6YCJ5oup5ZCI6YCC55qE5qih5Z6L5p625p6E5piv5qih5Z6L5LyY5YyW55qE6aaW6KaB5Lu75Yqh44CC5Zyo5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi25Lit77yM5Y+v5Lul5qC55o2u5YW35L2T5Lu75Yqh55qE54m554K56YCJ5oup6YCC5ZCI55qE56We57uP572R57uc57uT5p6E77yM5aaCQ05O44CBUk5O5oiWVHJhbnNmb3JtZXLnrYnjgILlkIzml7bvvIzov5jpnIDopoHogIPomZHmqKHlnovnmoTmt7HluqbjgIHlrr3luqblkozov57mjqXmlrnlvI/nrYnotoXlj4LmlbDnmoTorr7nva7vvIzku6XlhYXliIblj5HmjKXmqKHlnovnmoTooajovr7og73lipvjgIIg5o2f5aSx5Ye95pWw55qE6YCJ5oup5LiO5qih5Z6L55qE6K6t57uD55uu5qCH5a+G5YiH55u45YWz44CC5Zyo6LSo6YeP5o6n5Yi25Lit77yM5bi455So55qE5o2f5aSx5Ye95pWw5YyF5ous5Z2H5pa56K+v5beu77yITVNF77yJ44CB5Lqk5Y+J54a15o2f5aSx5Ye95pWw562J44CC5ZCI55CG6YCJ5oup5o2f5aSx5Ye95pWw5Y+v5Lul5pyJ5pWI5Zyw5byV5a+85qih5Z6L5a2m5Lmg55uu5qCH54m55b6B77yM5bm25o+Q6auY5qih5Z6L55qE6aKE5rWL5oCn6IO944CCIOS8mOWMlueul+azleeahOmAieaLqeWSjOWPguaVsOiwg+S8mOWvueS6juaooeWei+eahOiuree7g+aViOaenOiHs+WFs+mHjeimgeOAguW4uOeUqOeahOS8mOWMlueul+azleWMheaLrOmaj+acuuair+W6puS4i+mZje+8iFNHRO+8ieOAgUFkYW3kvJjljJbnrpfms5XnrYnjgILov5nkupvkvJjljJbnrpfms5Xog73lpJ/pgJrov4forqHnrpfmoq/luqblubbmm7TmlrDmqKHlnovlj4LmlbDvvIzkuI3mlq3kvJjljJbmqKHlnovnmoTmgKfog73jgILmraTlpJbvvIzov5jpnIDopoHlr7nlrabkuaDnjofjgIHmraPliJnljJbns7vmlbDlkozmibnph4/lpKflsI/nrYnotoXlj4LmlbDov5vooYzosIPkvJjvvIzku6Xojrflvpfmm7Tlpb3nmoTmqKHlnovmgKfog73jgIIgMiDln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTkuLvopoHmtYHnqIsgMi4xIOaVsOaNruaUtumbhuS4jumihOWkhOeQhiDln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTnrKzkuIDmraXmmK/mlbDmja7mlLbpm4bkuI7pooTlpITnkIbjgILlnKjov5nkuIDpmLbmrrXvvIzpnIDopoHmlLbpm4blubbmlbTnkIbkuI7nlJ/kuqfov4fnqIvlkozkuqflk4HotKjph4/nm7jlhbPnmoTmlbDmja7jgILov5nkupvmlbDmja7lj6/ku6XljIXmi6zkvKDmhJ/lmajmlbDmja7jgIHlt6Xoibrlj4LmlbDjgIHkuqflk4Hmo4DmtYvnu5PmnpznrYnjgIIg5pWw5o2u5pS26ZuG55qE6L+H56iL6ZyA6KaB6ICD6JmR5pWw5o2u55qE5YeG56Gu5oCn5ZKM5a6M5pW05oCn44CC5ZCI6YCC55qE5Lyg5oSf5Zmo5ZKM6K6+5aSH6KKr55So5p2l5a6e5pe25pS26ZuG5pWw5o2u77yM56Gu5L+d5pWw5o2u5YW35pyJ6auY6LSo6YeP5ZKM6auY57K+5bqm44CC5ZCM5pe277yM5Lmf6KaB56Gu5L+d5pWw5o2u5pS26ZuG55qE6aKR546H5ZKM5pe26Ze054K55YW35pyJ5Luj6KGo5oCn77yM5Lul5L6/5YWo6Z2i5LqG6Kej55Sf5Lqn6L+H56iL44CCIOWcqOaVsOaNrumihOWkhOeQhumYtuaute+8jOWvueaUtumbhuWIsOeahOaVsOaNrui/m+ihjOa4hea0l+OAgeetm+mAieWSjOS/ruato++8jOS7peWOu+mZpOW8guW4uOWAvOWSjOWZquWjsO+8jOW5tui/m+ihjOaVsOaNruinhOiMg+WMluWSjOagh+WHhuWMlu+8jOS/neivgeaVsOaNrueahOS4gOiHtOaAp+WSjOWPr+avlOaAp+OAguatpOWklu+8jOWcqOaciee8uuWkseWAvOeahOaDheWGteS4i++8jOWPr+S7peS9v+eUqOaPkuWAvOetieaWueazlei/m+ihjOaVsOaNrueahOWhq+ihpeOAgiAyLjIg5p6E5bu65rex5bqm5a2m5Lmg5qih5Z6LIOaehOW7uua3seW6puWtpuS5oOaooeWei+aYr+WunueOsOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueahOaguOW/g+atpemqpOOAguWcqOi/meS4gOmYtuaute+8jOmcgOimgemAieaLqemAguWQiOeahOa3seW6puWtpuS5oOeul+azleWSjOaetuaehO+8jOW5tuagueaNrumXrumimOeahOeJueeCuei/m+ihjOaooeWei+eahOiuvuiuoeWSjOS8mOWMluOAgiDpppblhYjvvIzmoLnmja7otKjph4/mjqfliLbnmoTnm67moIflkozpnIDmsYLvvIzpgInmi6nlkIjpgILnmoTmt7HluqblrabkuaDnrpfms5XvvIzlpoLljbfnp6/npZ7nu4/nvZHnu5zvvIhDTk7vvInjgIHlvqrnjq/npZ7nu4/nvZHnu5zvvIhSTk7vvInjgIHnlJ/miJDlr7nmipfnvZHnu5zvvIhHQU7vvInnrYnjgILmoLnmja7mlbDmja7nmoTnibnngrnlkozpl67popjnmoTlpI3mnYLluqbvvIzpgInmi6nlkIjpgILnmoTnvZHnu5zmnrbmnoTlkozlsYLmlbDjgILlhbbmrKHvvIzov5vooYzmlbDmja7nmoTliJLliIbvvIzlsIbmlbDmja7pm4bliIbkuLrorq3nu4Ppm4bjgIHpqozor4Hpm4blkozmtYvor5Xpm4bjgILorq3nu4Ppm4bnlKjkuo7mqKHlnovnmoTorq3nu4Plj4LmlbDvvIzpqozor4Hpm4bnlKjkuo7mqKHlnovnmoTosIPkvJjlkozpgInmi6nmnIDkvbPmqKHlnovvvIzmtYvor5Xpm4bnlKjkuo7or4TkvLDmqKHlnovnmoTmgKfog73lkozms5vljJbog73lipvjgILmnIDlkI7vvIzov5vooYzmqKHlnovnmoTorq3nu4PlkozkvJjljJbjgILkvb/nlKjorq3nu4Ppm4blr7nmqKHlnovov5vooYzlj43lpI3ov63ku6PlkozkvJjljJbvvIzpgJrov4fkvJjljJbnrpfms5XlkozmjZ/lpLHlh73mlbDvvIzosIPmlbTmqKHlnovlj4LmlbDvvIzmj5Dpq5jmqKHlnovnmoTpooTmtYvlh4bnoa7mgKflkozms5vljJbog73liptbM13jgILlnKjorq3nu4PnmoTov4fnqIvkuK3vvIzlj6/ku6Xph4fnlKjmlbDmja7lop7lvLrmioDmnK/mnaXmianlhYXorq3nu4Ppm4bvvIzlop7liqDmqKHlnovnmoTpsoHmo5LmgKfjgIIgMi4zIOWunuaXtuebkea1i+S4juWPjemmiOacuuWItiDpgJrov4flrp7ml7bnm5HmtYvnlJ/kuqfov4fnqIvkuK3nmoTmlbDmja7lkozotKjph4/mjIfmoIfvvIzlj4rml7blj5HnjrDlvILluLjlkozotKjph4/pl67popjvvIzlubbph4flj5bnm7jlupTnmoTlj43ppojmjqrmlr3jgIIg5Zyo5a6e5pe255uR5rWL6Zi25q6177yM5L2/55So6K6t57uD5aW955qE5rex5bqm5a2m5Lmg5qih5Z6L5a+55a6e5pe25pWw5o2u6L+b6KGM6aKE5rWL5ZKM5YiG57G777yM6K+G5Yir5Ye65byC5bi45ZKM5LiN6Imv6LaL5Yq/44CC6L+Z6ZyA6KaB5Zyo57O757uf5Lit6ZuG5oiQ5ZCE6aG55Lyg5oSf5Zmo5ZKM55uR5rWL6K6+5aSH77yM6YCa6L+H5a6e5pe25pWw5o2u55qE6YeH6ZuG5ZKM5Lyg6L6T77yM5a6e546w5a+555Sf5Lqn6L+H56iL55qE5a6e5pe255uR5rWL44CCIOS4gOaXpuajgOa1i+WIsOW8guW4uOaIlui0qOmHj+mXrumimO+8jOWPiuaXtui/m+ihjOWPjemmiOWSjOaOp+WItuOAguezu+e7n+WPr+S7pemAmui/h+iHquWKqOWMluiuvuWkh+OAgeacuuWZqOS6uuaIluW3peS6uueahOW5sumihOadpeWunueOsOi0qOmHj+mXrumimOeahOS/ruato+WSjOaOp+WItuOAguWPjemmiOacuuWItui/mOWPr+S7peWwhumXrumimOS/oeaBr+S8oOmAkue7meebuOWFs+S6uuWRmO+8jOS7peS+v+i/m+ihjOi/m+S4gOatpeeahOWIhuaekOWSjOWGs+etlu+8jOmBv+WFjeexu+S8vOmXrumimOeahOWGjeasoeWPkeeUn+OAgiAz5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE5bqU55So562W55WlIDMuMSDln7rkuo7mmbrog73kvKDmhJ/lmajnmoTlrp7ml7botKjph4/nm5HmtYsg5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi25Zyo5a6e5pe26LSo6YeP55uR5rWL5pa56Z2i6YeH55So5pm66IO95Lyg5oSf5Zmo55qE562W55Wl44CC5pm66IO95Lyg5oSf5Zmo6ZuG5oiQ5LqG5YWI6L+b55qE5Lyg5oSf5oqA5pyv5ZKM5rex5bqm5a2m5Lmg566X5rOV77yM6YCa6L+H5a6e5pe26YeH6ZuG5ZKM5YiG5p6Q55Sf5Lqn6L+H56iL5Lit55qE5pWw5o2u77yM5a6e546w5a+55Lqn5ZOB6LSo6YeP55qE55uR5rWL5ZKM6K+E5Lyw44CCIOmmluWFiO+8jOaZuuiDveS8oOaEn+WZqOWPr+S7peWunuaXtumHh+mbhueUn+S6p+i/h+eoi+S4reeahOWQhOenjeWPguaVsOaVsOaNru+8jOWmgua4qeW6puOAgeWOi+WKm+OAgeaMr+WKqOetieOAgui/meS6m+aVsOaNrue7j+i/h+S8oOaEn+WZqOWGhemDqOeahOa3seW6puWtpuS5oOeul+azleWkhOeQhu+8jOWPr+S7peeUqOS6juWunuaXtuebkea1i+S6p+WTgeeahOWQhOmhuei0qOmHj+aMh+agh++8jOS+i+WmguWwuuWvuOeyvuW6puOAgeihqOmdouWFiea0geW6puetieOAgiDlhbbmrKHvvIzln7rkuo7mt7HluqblrabkuaDnmoTmmbrog73kvKDmhJ/lmajog73lpJ/lrabkuaDlubbliIbmnpDkuI3lkIzlt6XlhrXkuIvnmoTmqKHlvI/lkozop4TlvovjgILpgJrov4flr7nlpKfph4/mlbDmja7nmoTlrabkuaDvvIzkvKDmhJ/lmajlj6/ku6Xlh4bnoa7lnLDliKTmlq3mmK/lkKblrZjlnKjotKjph4/pl67popjvvIzlubblj4rml7bnu5nlh7rpooTorablkozmj5DphpLvvIzluK7liqnkvIHkuJrlj4rml7bph4flj5bmjqrmlr3ku6Xpgb/lhY3otKjph4/pl67popjnmoTlj5HnlJ/jgIIg5q2k5aSW77yM5pm66IO95Lyg5oSf5Zmo6L+Y5Y+v5Lul5LiO5py65Zmo5Lq65oiW5YW25LuW6Ieq5Yqo5YyW6K6+5aSH6L+b6KGM6IGU5Yqo77yM5a6e546w5a6e5pe26LSo6YeP55uR5rWL5LiO5o6n5Yi255qE6Zet546v44CC5LiA5pem5Y+R546w6LSo6YeP5byC5bi477yM5pm66IO95Lyg5oSf5Zmo5Y+v5Lul6YCa6L+H572R57uc5LiO55Sf5Lqn57q/5LiK55qE5YW25LuW6K6+5aSH6YCa5L+h77yM5Y+K5pe26L+b6KGM6LCD5pW05ZKM5L+u5q2j77yM56Gu5L+d5Lqn5ZOB6LSo6YeP55qE56iz5a6a5oCn5ZKM5LiA6Ie05oCn44CCIDMuMiDln7rkuo7pooTmtYvliIbmnpDnmoTmlYXpmpzmo4DmtYvkuI7pooToraYg5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi25Zyo5pWF6Zqc5qOA5rWL5LiO6aKE6K2m5pa56Z2i6YeH55So6aKE5rWL5YiG5p6Q55qE562W55Wl44CC6YCa6L+H5YiG5p6Q5Y6G5Y+y5pWw5o2u5ZKM5a6e5pe25pWw5o2u77yM57O757uf5Y+v5Lul6aKE5rWL6K6+5aSH6L+Q6KGM5Lit5Y+v6IO95Y+R55Sf55qE5pWF6Zqc77yM5bm25o+Q5YmN6L+b6KGM6aKE6K2m77yM5Lul6YG/5YWN55Sf5Lqn5Lit55qE6LSo6YeP6Zeu6aKY44CCIOmmluWFiO+8jOa3seW6puWtpuS5oOaooeWei+WPr+S7peWtpuS5oOiuvuWkh+i/kOihjOi/h+eoi+S4reeahOWQhOenjeaooeW8j+WSjOinhOW+i+OAgumAmui/h+WvueWkp+mHj+WOhuWPsuaVsOaNrueahOiuree7g++8jOezu+e7n+WPr+S7peivhuWIq+WHuuS4jeWQjOaVhemanOaooeW8j+eahOeJueW+ge+8jOW7uueri+aVhemanOmihOa1i+aooeWei+OAguW9k+WunuaXtuaVsOaNruS4jumihOa1i+aooeWei+S4jeespuaXtu+8jOezu+e7n+WPr+S7peWIpOaWreWPr+iDveWtmOWcqOaVhemanO+8jOW5tuWPkeWHuumihOitpuS/oeWPt+OAgiDlhbbmrKHvvIzpooTmtYvliIbmnpDlj6/ku6Xln7rkuo7lpJrnp43mlbDmja7mupDvvIzljIXmi6zorr7lpIfmlbDmja7jgIHnjq/looPmlbDmja7jgIHkvpvlupTpk77mlbDmja7nrYnjgILpgJrov4fnu7zlkIjliIbmnpDov5nkupvmlbDmja7vvIzns7vnu5/lj6/ku6Xmm7Tlh4bnoa7lnLDpooTmtYvmlYXpmpznmoTlj5HnlJ/vvIzlubblj4rml7bph4flj5bnm7jlupTnmoTmjqrmlr3vvIzkvovlpoLlgZzmnLrnu7Tkv67jgIHmm7TmjaLpm7bpg6jku7bnrYnvvIzku6Xpgb/lhY0uLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2UgaGVscCBtZSB3cml0ZSBhbiBhYnN0cmFjdCBmb3IgYSBwYXBlciBvbiBjb250YWluZXIgdGVjaG5vbG9neS4gVGhlIG90aGVyIHBhcnRzIG9mIHRoZSBwYXBlciBhcmUgYXMgZm9sbG93czogKipSZXNlYXJjaCBvbiBDbG91ZCBQbGF0Zm9ybSBOZXR3b3JrIEFyY2hpdGVjdHVyZSBCYXNlZCBvbiBDb250YWluZXIgVGVjaG5vbG9neSoqCgowIEludHJvZHVjdGlvbiAgCkluIGNsb3VkIGNvbXB1dGluZyBlbnZpcm9ubWVudHMsIG9wdGltaXppbmcgbmV0d29yayBhcmNoaXRlY3R1cmUgaXMgY3J1Y2lhbCBmb3IgZW5oYW5jaW5nIHRoZSBwZXJmb3JtYW5jZSBvZiBjbG91ZCBzZXJ2aWNlc1sxXS4gQ29udGFpbmVyIHRlY2hub2xvZ3ksIHdpdGggaXRzIGxpZ2h0d2VpZ2h0IGFuZCBlZmZpY2llbnQgY2hhcmFjdGVyaXN0aWNzLCBvZmZlcnMgbmV3IHBlcnNwZWN0aXZlcyBmb3IgdGhlIG5ldHdvcmsgYXJjaGl0ZWN0dXJlIG9mIGNsb3VkIHBsYXRmb3Jtc1syLTRdLiBUaGlzIHN0dWR5IGZvY3VzZXMgb24gdGhlIGFwcGxpY2F0aW9uIG9mIGNvbnRhaW5lciB0ZWNobm9sb2d5IGluIGNsb3VkIHBsYXRmb3JtIG5ldHdvcmsgYXJjaGl0ZWN0dXJlLCBhaW1pbmcgdG8gc29sdmUgaXNzdWVzIHN1Y2ggYXMgbmV0d29yayBpc29sYXRpb24sIHNjYWxhYmlsaXR5LCBhbmQgc2VjdXJpdHkgcHJvYmxlbXMgcHJlc2VudCBpbiB0cmFkaXRpb25hbCB2aXJ0dWFsaXphdGlvbiBlbnZpcm9ubWVudHMuIFRoZSBkZXNpZ24gb2YgY29udGFpbmVyIG5ldHdvcmsgYXJjaGl0ZWN0dXJlIG11c3QgbWVldCB0aGUgZHluYW1pYyBhbmQgZWxhc3RpYyByZXF1aXJlbWVudHMgb2YgY2xvdWQgc2VydmljZXMgd2hpbGUgZW5zdXJpbmcgdGhlIGVmZmljaWVuY3kgYW5kIHNlY3VyaXR5IG9mIG5ldHdvcmsgY29tbXVuaWNhdGlvbi4gVGhpcyByZXNlYXJjaCBleHBsb3JlcyB0aGUga2V5IHRlY2hub2xvZ2llcyBvZiBjb250YWluZXIgbmV0d29ya3MsIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gbmV0d29yayBpc29sYXRpb24gbWVjaGFuaXNtcywgbG9hZCBiYWxhbmNpbmcgc3RyYXRlZ2llcywgc2VydmljZSBkaXNjb3ZlcnksIGFuZCBzZWN1cml0eSBoYXJkZW5pbmcgbWVhc3VyZXMuICAKCjEgQ29udGFpbmVyIE5ldHdvcmsgQXJjaGl0ZWN0dXJlIERlc2lnbiAgCjEuMSBEZXNpZ24gQ29uY2VwdCAgClRoZSBjb3JlIG9mIGNvbnRhaW5lciBuZXR3b3JrIGFyY2hpdGVjdHVyZSBkZXNpZ24gaXMgdG8gYWNoaWV2ZSBlZmZpY2llbnQsIGZsZXhpYmxlLCBhbmQgc2VjdXJlIG5ldHdvcmsgY29tbXVuaWNhdGlvbi4gSW4gY2xvdWQgcGxhdGZvcm1zLCBjb250YWluZXJzLCBhcyBhIGxpZ2h0d2VpZ2h0IHZpcnR1YWxpemF0aW9uIHRlY2hub2xvZ3ksIHJlcXVpcmUgYSBuZXR3b3JrIGRlc2lnbiB0aGF0IHNhdGlzZmllcyB0aGUgbmVlZHMgb2YgcmFwaWQgZGVwbG95bWVudCBhbmQgZHluYW1pYyBzY2FsYWJpbGl0eSBpbiBhIG1pY3Jvc2VydmljZXMgYXJjaGl0ZWN0dXJlLiBUaGlzIHNlY3Rpb24gd2lsbCBkZWx2ZSBpbnRvIHRoZSBkZXNpZ24gY29uY2VwdCBvZiBjb250YWluZXIgbmV0d29yayBhcmNoaXRlY3R1cmUsIGluY2x1ZGluZyBuZXR3b3JrIGlzb2xhdGlvbiwgc2VydmljZSBkaXNjb3ZlcnksIGxvYWQgYmFsYW5jaW5nLCBhbmQgc2VjdXJpdHkgc3RyYXRlZ2llcy4gIApOZXR3b3JrIGlzb2xhdGlvbiBpcyBlc3NlbnRpYWwgZm9yIGVuc3VyaW5nIHNlY3VyZSBjb21tdW5pY2F0aW9uIGJldHdlZW4gY29udGFpbmVycy4gVHVubmVsIHRlY2hub2xvZ2llcyBzdWNoIGFzIFZYTEFOIG9yIFNUVCBjYW4gYmUgdXNlZCB0byBpbXBsZW1lbnQgbmV0d29yayBpc29sYXRpb24gYmV0d2VlbiBkaWZmZXJlbnQgdGVuYW50cy4gTWVhbndoaWxlLCBEb2NrZXLigJlzIG5ldHdvcmsgcGx1Z2lucyAoZS5nLiwgQ2FsaWNvIG9yIEZsYW5uZWwpIGNhbiBwcm92aWRlIGVhY2ggY29udGFpbmVyIHdpdGggYW4gaW5kZXBlbmRlbnQgbmV0d29yayBzdGFjay4gU2VydmljZSBkaXNjb3ZlcnkgaXMgYW4gaW50ZWdyYWwgcGFydCBvZiBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZS4gIAoKMS4yIE5ldHdvcmsgQ29tcG9uZW50cyBhbmQgRnVuY3Rpb25zICAKVGhlIGRlc2lnbiBvZiBjb250YWluZXIgbmV0d29yayBhcmNoaXRlY3R1cmUgZm9jdXNlcyBvbiBidWlsZGluZyBhbiBlZmZpY2llbnQsIHNjYWxhYmxlLCBhbmQgc2VjdXJlIG5ldHdvcmsgZW52aXJvbm1lbnQgdG8gc3VwcG9ydCBjb250YWluZXJpemVkIGRlcGxveW1lbnQgb24gY2xvdWQgcGxhdGZvcm1zLiBUaGUgY29yZSBjb21wb25lbnRzIGluY2x1ZGUgbmV0d29yayBpbnRlcmZhY2UgY29udHJvbGxlcnMsIHNlcnZpY2UgZGlzY292ZXJ5IG1lY2hhbmlzbXMsIGxvYWQgYmFsYW5jZXJzLCBhbmQgc2VjdXJpdHkgcG9saWNpZXMuIFRoZSBuZXR3b3JrIGludGVyZmFjZSBjb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgbWFuYWdpbmcgY29udGFpbmVyIG5ldHdvcmtzLCBpbnRlcmFjdGluZyB3aXRoIHRoZSBjb250YWluZXIgcnVudGltZSB2aWEgdGhlIEFwcGxpY2F0aW9uIFByb2dyYW1taW5nIEludGVyZmFjZSAoQVBJKSB0byBlbmFibGUgZHluYW1pYyBuZXR3b3JrIGNvbmZpZ3VyYXRpb24uIFRoZSBzZXJ2aWNlIGRpc2NvdmVyeSBtZWNoYW5pc20gYWxsb3dzIGNvbnRhaW5lcnMgdG8gY29tbXVuaWNhdGUgdmlhIHNlcnZpY2UgbmFtZXMgcmF0aGVyIHRoYW4gSVAgYWRkcmVzc2VzIGJ5IHJlZ2lzdGVyaW5nIHNlcnZpY2UgaW5zdGFuY2VzIGFuZCBpbnN0YW5jZSBpbmZvcm1hdGlvbiwgZW5hYmxpbmcgZHluYW1pYyBzZXJ2aWNlIHJlZ2lzdHJhdGlvbiBhbmQgZGlzY292ZXJ5LiAgCkxvYWQgYmFsYW5jZXJzIGFyZSBkaXN0cmlidXRlZCBhY3Jvc3MgdGhlIG5ldHdvcmsgYW5kIGFsbG9jYXRlIHJlcXVlc3RzIHRvIGFwcHJvcHJpYXRlIGNvbnRhaW5lciBpbnN0YW5jZXMgYmFzZWQgb24gcmVhbC10aW1lIHRyYWZmaWMgYW5kIGhlYWx0aCBjaGVjayByZXN1bHRzLCBlbnN1cmluZyBoaWdoIGF2YWlsYWJpbGl0eSBhbmQgcmVzcG9uc2l2ZW5lc3Mgb2Ygc2VydmljZXMuIFNlY3VyaXR5IHBvbGljaWVzIHByb3RlY3QgZGF0YSB0cmFuc21pc3Npb24gYmV0d2VlbiBjb250YWluZXJzIGJ5IGltcGxlbWVudGluZyBuZXR3b3JrIGlzb2xhdGlvbiwgYWNjZXNzIGNvbnRyb2wsIGFuZCBlbmNyeXB0ZWQgY29tbXVuaWNhdGlvbi4gVGFibGUgMSBsaXN0cyB0aGUgcGVyZm9ybWFuY2UgbWV0cmljcyBvZiBkaWZmZXJlbnQgbG9hZCBiYWxhbmNpbmcgYWxnb3JpdGhtcywgZGVtb25zdHJhdGluZyB0aGUgcGVyZm9ybWFuY2Ugb2YgUm91bmQgUm9iaW4sIFJhbmRvbSwgYW5kIExlYXN0IENvbm5lY3Rpb25zIGFsZ29yaXRobXMgaW4gdmFyaW91cyBzY2VuYXJpb3MuICAKClRhYmxlIDE6IFBlcmZvcm1hbmNlIE1ldHJpY3Mgb2YgRGlmZmVyZW50IExvYWQgQmFsYW5jaW5nIEFsZ29yaXRobXMgIAoKfCBBbGdvcml0aG0gVHlwZSB8IEF2ZXJhZ2UgUmVzcG9uc2UgVGltZSAobXMpIHwgUmVzb3VyY2UgVXRpbGl6YXRpb24gKCUpIHwgIAp8LS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfCAgCnwgUm91bmQgUm9iaW4gICAgfCA1MCAgICAgICAgICAgICAgICAgICAgICAgICB8IDgwICAgICAgICAgICAgICAgICAgICAgICB8ICAKfCBSYW5kb20gICAgICAgICB8IDc1ICAgICAgICAgICAgICAgICAgICAgICAgIHwgNzUgICAgICAgICAgICAgICAgICAgICAgIHwgIAp8IExlYXN0IENvbm5lY3Rpb25zIHwgNDUgICAgICAgICAgICAgICAgICAgICB8IDg1ICAgICAgICAgICAgICAgICAgICAgICB8ICAKCjEuMyBJc29sYXRpb24gYW5kIFNlY3VyaXR5IG9mIENvbnRhaW5lciBOZXR3b3JrcyAgClRoZSBpc29sYXRpb24gYW5kIHNlY3VyaXR5IG9mIGNvbnRhaW5lciBuZXR3b3JrcyBhcmUgY3J1Y2lhbCBmb3IgZW5zdXJpbmcgdGhlIHN0YWJsZSBvcGVyYXRpb24gb2YgY2xvdWQgcGxhdGZvcm1zLiBDb250YWluZXIgdGVjaG5vbG9neSBhY2hpZXZlcyBuZXR3b3JrIGlzb2xhdGlvbiB0aHJvdWdoIG5hbWVzcGFjZXMgYW5kIG5ldHdvcmsgcG9saWNpZXMsIHByZXZlbnRpbmcgdW5uZWNlc3NhcnkgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGNvbnRhaW5lcnMsIHRoZXJlYnkgcmVkdWNpbmcgc2VjdXJpdHkgcmlza3MuIE5ldHdvcmsgcG9saWNpZXMgY29udHJvbCBpbmNvbWluZyBhbmQgb3V0Z29pbmcgdHJhZmZpYyB0byBjb250YWluZXJzIHRocm91Z2ggaXB0YWJsZXMgcnVsZXMgb3IgdGhpcmQtcGFydHkgc29sdXRpb25zIChzdWNoIGFzIENhbGljbyksIGVuYWJsaW5nIGZpbmUtZ3JhaW5lZCBhY2Nlc3MgY29udHJvbC4gIApBZGRpdGlvbmFsbHksIGVuY3J5cHRpb24gdGVjaG5vbG9neSBpbiBjb250YWluZXIgbmV0d29ya3MgZW5zdXJlcyB0aGUgc2VjdXJpdHkgb2YgZGF0YSB0cmFuc21pc3Npb24uIFRoZSBUcmFuc3BvcnQgTGF5ZXIgU2VjdXJpdHkgKFRMUykgcHJvdG9jb2wgaXMgd2lkZWx5IHVzZWQgdG8gZXN0YWJsaXNoIHNlY3VyZSBjb21tdW5pY2F0aW9uIGNoYW5uZWxzIGJldHdlZW4gY29udGFpbmVycywgZW5zdXJpbmcgdGhlIGludGVncml0eSBhbmQgcHJpdmFjeSBvZiBkYXRhIGR1cmluZyB0cmFuc21pc3Npb24uICAKVG8gcXVhbnRpZnkgdGhlIGVmZmVjdCBvZiBuZXR3b3JrIGlzb2xhdGlvbiwgdGhpcyBwYXBlciB1c2VzIGFuIGlzb2xhdGlvbiBlZmZpY2llbmN5IGZvcm11bGEsIGFzIHNob3duIGluIGVxdWF0aW9uICgxKS4gIArwnZyCPfCdkZnwnZC/w5cxMDAlIOKAgygxKSAgCndoZXJlIM63IGlzIHRoZSBpc29sYXRpb24gZWZmaWNpZW5jeSwgbCBpcyB0aGUgaWxsZWdhbCB0cmFmZmljIHN1Y2Nlc3NmdWxseSBibG9ja2VkLCBhbmQgTCBpcyB0aGUgdG90YWwgaWxsZWdhbCB0cmFmZmljLiAgCgoyIENsb3VkIFBsYXRmb3JtIE5ldHdvcmsgQXJjaGl0ZWN0dXJlIEltcGxlbWVudGF0aW9uICAKMi4xIE5ldHdvcmsgQ29tcG9uZW50IEltcGxlbWVudGF0aW9uIFRlY2hub2xvZ2llcyAgCktleSB0ZWNobm9sb2dpZXMgZm9yIGltcGxlbWVudGluZyBjbG91ZCBwbGF0Zm9ybSBuZXR3b3JrIGFyY2hpdGVjdHVyZSBpbmNsdS4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6ClBsZWFzZSBoZWxwIG1lIHJldmlzZSB0aGUgaW50cm9kdWN0aW9uIG9mIHRoaXMgcGFwZXIgb24gc21hcnQgY2l0aWVzIGFuZCBleHBhbmQgaXQgYSBiaXQgbW9yZSwgc3VjaCBhcyBhZGRpbmcgdGhlIHJlc2VhcmNoIGJhY2tncm91bmQsIHJlc2VhcmNoIHNpZ25pZmljYW5jZSwgZXRjLiBUaGUgb3JpZ2luYWwgZnVsbCB0ZXh0IG9mIHRoZSBwYXBlciBpcyBhcyBmb2xsb3dzOiAqKlJlc2VhcmNoIG9uIHRoZSBDb25zdHJ1Y3Rpb24gUGxhbiBvZiBOZXcgU21hcnQgQ2l0aWVzKiogIApBYnN0cmFjdDogVGhlIGNvbnN0cnVjdGlvbiBvZiBzbWFydCBjaXRpZXMgbm90IG9ubHkgY29uY2VybnMgdGhlIGFjY3VyYWN5IG9mIHVyYmFuIHBsYW5uaW5nIGFuZCBkZWNpc2lvbi1tYWtpbmcgYnV0IGFsc28gZGlyZWN0bHkgaW1wYWN0cyByZXNpZGVudHMnIGhhcHBpbmVzcyBhbmQgc2F0aXNmYWN0aW9uLCBzZXJ2aW5nIGFzIGEga2V5IGluZGljYXRvciBmb3IgbWVhc3VyaW5nIHRoZSBxdWFsaXR5IG9mIHVyYmFuIGRldmVsb3BtZW50LiBUaGlzIHBhcGVyIGFpbXMgdG8gY29tYmluZSB0aGUgaW5ub3ZhdGl2ZSBwcmFjdGljZXMgaW4gZGF0YSBzaGFyaW5nLCBnb3Zlcm5tZW50IHNlcnZpY2VzLCB1cmJhbiBtYW5hZ2VtZW50LCBhbmQgb3RoZXIgYXJlYXMgZnJvbSBhZHZhbmNlZCBjaXRpZXMgc3VjaCBhcyBTaGFuZ2hhaSBhbmQgSGFuZ3pob3UsIHByb3Bvc2luZyBhIGZyYW1ld29yayBhbmQgY29uc3RydWN0aW9uIGlkZWFzIGZvciBzbWFydCBjaXR5IGRldmVsb3BtZW50LCB3aXRoIHRoZSBnb2FsIG9mIHByb21vdGluZyBzY2llbnRpZmljIGFuZCBwcmVjaXNlIHNvY2lhbCBnb3Zlcm5hbmNlIGFuZCBlbmhhbmNpbmcgdGhlIGludGVsbGlnZW5jZSBhbmQgY29udmVuaWVuY2Ugb2YgZ292ZXJubWVudCBzZXJ2aWNlcy4gIApLZXl3b3Jkczogc21hcnQgY2l0eTsgdXJiYW4gb3BlcmF0aW9uOyBkYXRhIHNoYXJpbmc7IGNvbGxhYm9yYXRpdmUgYXBwbGljYXRpb25zICAKClRoZSBjb25zdHJ1Y3Rpb24gb2Ygc21hcnQgY2l0aWVzIGVtcGhhc2l6ZXMgdGhlIGNyaXRpY2FsIHJvbGUgb2YgY29tbXVuaWNhdGlvbiB0ZWNobm9sb2d5IGluZnJhc3RydWN0dXJlIGludmVzdG1lbnQgYW5kIHRoZSBhcHBsaWNhdGlvbiBvZiBuZXcgdGVjaG5vbG9naWVzIGluIHRoZSB1cmJhbiBkZXZlbG9wbWVudCBwcm9jZXNzIFsxXS4gSW4gcmVjZW50IHllYXJzLCB0aGUgbmF0aW9uYWwgYW5kIGxvY2FsIGdvdmVybm1lbnRzIGhhdmUgaW50cm9kdWNlZCBhIHNlcmllcyBvZiBwb2xpY3kgZG9jdW1lbnRzIGFpbWVkIGF0IHByb21vdGluZyBzdXN0YWluYWJsZSB1cmJhbiBkZXZlbG9wbWVudCB0aHJvdWdoIGRpZ2l0YWwgdHJhbnNmb3JtYXRpb24uIEJhc2VkIG9uIHRoZSBzdWNjZXNzZnVsIGV4cGVyaWVuY2VzIG9mIGFkdmFuY2VkIGNpdGllcywgdGhpcyBwYXBlciBmb2N1c2VzIG9uIHRoZSB0aHJlZSBjb3JlIG9wZXJhdGlvbnMgb2Yg4oCcdW5pZmllZCBtYW5hZ2VtZW50LCB1bmlmaWVkIHNlcnZpY2UsIGFuZCB1bmlmaWVkIGNvbGxhYm9yYXRpb27igJ0gYW5kIHByb3Bvc2VzIGNvcnJlc3BvbmRpbmcgaW5zdGl0dXRpb25hbCBhbmQgbWVjaGFuaXNtIHN1cHBvcnQgbWVhc3VyZXMuIFRoZSBhaW0gaXMgdG8gcHJvdmlkZSBlZmZlY3RpdmUgcGF0aHdheXMgZm9yIHNvbHZpbmcgY29tbW9uIHByb2JsZW1zIGluIGN1cnJlbnQgc21hcnQgY2l0eSBjb25zdHJ1Y3Rpb24sIHN1Y2ggYXMgZGF0YSBzaWxvcywgaW50ZXItZGVwYXJ0bWVudGFsIGNvbGxhYm9yYXRpb24gZGlmZmljdWx0aWVzLCBhbmQgaW5zdWZmaWNpZW50IGRlY2lzaW9uLW1ha2luZyBzdXBwb3J0LiBJdCBzZWVrcyB0byBwcm9tb3RlIHRoZSBpbnRlZ3JhdGlvbiBvZiBnb3Zlcm5tZW50IHBsYXRmb3JtcywgdGhlIHJlbGVhc2Ugb2YgZGF0YSByZXNvdXJjZSB2YWx1ZSwgYWdpbGUgY2FwYWJpbGl0aWVzLCBlZmZpY2llbnQgY29vcmRpbmF0aW9uIGluIGRpZ2l0YWwgZ292ZXJuYW5jZSwgYW5kIGltcHJvdmVkIHF1YWxpdHkgYW5kIGNvbnRyb2xsYWJpbGl0eSBpbiBzZWN1cml0eSBhbmQgb3BlcmF0aW9uYWwgbWFuYWdlbWVudCBbMl0uICAKCjEuIFByb2JsZW1zICAKQ2hpbmHigJlzIHNtYXJ0IGNpdHkgY29uc3RydWN0aW9uIGhhcyBnb25lIHRocm91Z2ggc2V2ZXJhbCBzdGFnZXM6IHRoZSBpbmR1c3RyeSBhcHBsaWNhdGlvbi1kcml2ZW4gZGlnaXRhbCBjaXR5LCBlbWVyZ2luZyB0ZWNobm9sb2d5LWRyaXZlbiBzbWFydCBjaXR5IGRldmVsb3BtZW50IFszXSwgYW5kIHRoZSBkaWdpdGFsIGdvdmVybm1lbnQgdHJhbnNpdGlvbiBmcm9tIGUtZ292ZXJubWVudCBhbmQgZGlnaXRhbCBnb3Zlcm5hbmNlIHRvIGEgbmV3IHN0YWdlIG9mIGNvb3JkaW5hdGVkIGFuZCBpbm5vdmF0aXZlIG1hbmFnZW1lbnQgWzRdLiBMb2NhbCBkaWdpdGFsIGNvbnN0cnVjdGlvbiBpcyBpbiBhIHJhcGlkIGRldmVsb3BtZW50IHBoYXNlLCBidXQgZHVlIHRvIGRpZmZlcmVuY2VzIGluIGVjb25vbWljIGZvdW5kYXRpb24sIHRlY2hub2xvZ2ljYWwgbGV2ZWxzLCBhbmQgcmVzb3VyY2UgZW5kb3dtZW50LCBjb25zdHJ1Y3Rpb24gcHJvZ3Jlc3MgYW5kIHJlc3VsdHMgdmFyeS4gRGVzcGl0ZSBzb21lIGFjaGlldmVtZW50cywgY29tbW9uIHByb2JsZW1zIHN0aWxsIHBlcnNpc3QuICAKClRoZSBwaGVub21lbm9uIG9mIGRhdGEgc2lsb3MgaXMgc2V2ZXJlLiBBbHRob3VnaCB2YXJpb3VzIHJlZ2lvbnMgaGF2ZSBidWlsdCBkYXRhLXNoYXJpbmcgb3BlbiBwbGF0Zm9ybXMgYW5kIHByb3ZpZGVkIHNvbWUgZ292ZXJubWVudCBkYXRhIHNoYXJpbmcgd2luZG93cywgdGhlIHdpbGxpbmduZXNzIHRvIHNoYXJlIGRhdGEgaXMgd2VhayBpbiBtYW55IGRlcGFydG1lbnRzIG9yIHRoZXkgaGF2ZSBhIHN0cm9uZyBzZW5zZSBvZiBkYXRhIG93bmVyc2hpcC4gVGhpcyBsZWFkcyB0byBpbnN1ZmZpY2llbnQgZGF0YSBzaGFyaW5nIGluIHRlcm1zIG9mIHZvbHVtZSwgcmVhbC10aW1lIGF2YWlsYWJpbGl0eSwgYW5kIGFjY3VyYWN5LCBhbmQgZmFpbHMgdG8gdHVybiB0aGUgYnVzaW5lc3MgZGF0YSBhY2N1bXVsYXRlZCBieSBkZXBhcnRtZW50cyBpbnRvIGNpdHkgZGF0YSBhc3NldHMuIE9uIHRoZSBvdGhlciBoYW5kLCBkdWUgdG8gdGhlIGxhY2sgb2YgZGVlcCBsZWFybmluZywga25vd2xlZGdlIGdyYXBocywgZGVjaXNpb24gc3VwcG9ydCwgYW5kIG90aGVyIGZvdW5kYXRpb25hbCBkYXRhIHZhbHVlLWFkZGVkIHByb2R1Y3RzLCB0aGUgYXBwbGljYXRpb24gdmFsdWUgYW5kIHBvdGVudGlhbCBlbmVyZ3kgb2YgZGF0YSBoYXZlIG5vdCBiZWVuIGZ1bGx5IHJlbGVhc2VkLCBsaW1pdGluZyBpdHMgcm9sZSBpbiBpbXByb3ZpbmcgdXJiYW4gZ292ZXJuYW5jZSBlZmZlY3RpdmVuZXNzLCBvcHRpbWl6aW5nIHB1YmxpYyBzZXJ2aWNlcywgYW5kIHByb21vdGluZyBlY29ub21pYyBhbmQgc29jaWFsIGRldmVsb3BtZW50LiAgCgpDcm9zcy1kZXBhcnRtZW50YWwgY29sbGFib3JhdGlvbiBpcyBkaWZmaWN1bHQuIFRoZXJlIGlzIGFuIG92ZXJhbGwgdGVuZGVuY3kgdG8gZm9jdXMgb24gYnVzaW5lc3MgcmF0aGVyIHRoYW4gY29sbGFib3JhdGlvbiwgYW5kIGEgbGFjayBvZiBldmVudC1jZW50ZXJlZCwgc2VydmljZS1vcmllbnRlZCB1cmJhbiBvcGVyYXRpb25hbCBjb29yZGluYXRpb24gbWVjaGFuaXNtcy4gVGhpcyByZXN1bHRzIGluIGRlcGFydG1lbnRzIHN0aWNraW5nIHRvIHRoZWlyIG93biB3b3JrIGFuZCBmYWlsaW5nIHRvIGNyZWF0ZSBhbiBlZmZlY3RpdmUgdW5pZmllZCBnb2FsLW9yaWVudGVkIGFuZCBjb2xsYWJvcmF0aXZlIGNvbnNlbnN1cywgbWFraW5nIGl0IGRpZmZpY3VsdCB0byBmb3JtIGEgcmFwaWQtcmVzcG9uc2UgYW5kIGVmZmljaWVudCB1cmJhbiBnb3Zlcm5hbmNlIGFuZCBwdWJsaWMgc2VydmljZSBzeXN0ZW0uIFRoaXMgaXMgZXNwZWNpYWxseSB0cnVlIGluIHNvY2lhbCBnb3Zlcm5hbmNlLCB3aGVyZSBicmVha3Rocm91Z2ggYWNoaWV2ZW1lbnRzIGFyZSBsYWNraW5nLiAgCgpTdXBlcnZpc2lvbiBhbmQgYXNzZXNzbWVudCBtZWNoYW5pc21zIGFyZSBpbmFkZXF1YXRlLiBJbiB0ZXJtcyBvZiBidXNpbmVzcyBwZXJmb3JtYW5jZSwgdGhlcmUgaXMgYSBsYWNrIG9mIGVmZmljaWVudCBpbmZvcm1hdGlvbi1iYXNlZCBtb25pdG9yaW5nIG1ldGhvZHMgYW5kIGxvbmctdGVybSBhc3Nlc3NtZW50IG1lY2hhbmlzbXMuIEl0IGlzIGRpZmZpY3VsdCB0byB0cmFjayBhbmQgYW5hbHl6ZSBzb2NpYWwgZ292ZXJuYW5jZSBhbmQgcHVibGljIHNlcnZpY2UgcHJvY2Vzc2VzIGFuZCByZXN1bHRzIGNvbXByZWhlbnNpdmVseSwgY29udGludW91c2x5LCBhbmQgZGVlcGx5LCBoaW5kZXJpbmcgdGhlIGRpc2NvdmVyeSBvZiBwb3RlbnRpYWwgaXNzdWVzIGFuZCB0aGUgYWRqdXN0bWVudCBvZiBtZWFzdXJlcywgd2hpY2ggaXMgbm90IGNvbmR1Y2l2ZSB0byB0aGUgc3RhYmxlIGltcHJvdmVtZW50IGFuZCBjb250aW51b3VzIG9wdGltaXphdGlvbiBvZiBidXNpbmVzcyBwZXJmb3JtYW5jZSBxdWFsaXR5LiAgCgpUaHJvdWdoIHRvcC1sZXZlbCBkZXNpZ24sIGNsYXJpZnlpbmcgdGhlIGJvdW5kYXJpZXMgb2YgcmlnaHRzIGFuZCByZXNwb25zaWJpbGl0aWVzLCBzdHJlbmd0aGVuaW5nIHRoZSByZS1lbmdpbmVlcmluZyBvZiBnb3Zlcm5hbmNlIGJ1c2luZXNzIHByb2Nlc3NlcyBiYXNlZCBvbiBpbmZvcm1hdGlvbiBzaGFyaW5nLCBhbmQgc3RhbmRhcmRpemluZyB1cmJhbiBldmVudCBjbGFzc2lmaWNhdGlvbiBhbmQgcmVzcG9uc2UgcGxhbnMsIHdlIGNhbiBidWlsZCB0aGUgZm91bmRhdGlvbiBmb3IgdXJiYW4gZ292ZXJuYW5jZSBidXNpbmVzcyBjb2xsYWJvcmF0aW9uLCBmdXJ0aGVyIGVuaGFuY2UgcmVzcG9uc2Ugc3BlZWQgYW5kIGRpc3Bvc2FsIGNhcGFiaWxpdGllcywgYW5kIHByb21vdGUgdGhlIGRldmVsb3BtZW50IGFuZCBpbm5vdmF0aW9uIG9mIGdvdmVybmFuY2UgYW5kIHNlcnZpY2Ugc3lzdGVtcy4gIAoKMi4gQ29uc3RydWN0aW9uIFBsYW4gIAoyLjEgQ29uc3RydWN0aW9uIElkZWFzICAKU3RyZW5ndGhlbiB0b3AtbGV2ZWwgZGVzaWduIGFuZCBjb29yZGluYXRlZCBjb25zdHJ1Y3Rpb24uIEZyb20gYSBtYWNybyBwZXJzcGVjdGl2ZSwgLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgd3JpdGUgYW4gaW50cm9kdWN0aW9uIGZvciBhIHBhcGVyIG9uIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUuIFRoZSBvdGhlciBwYXJ0cyBvZiB0aGUgcGFwZXIgYXJlIGFzIGZvbGxvd3MgQXBwbGljYXRpb24gUmVzZWFyY2ggb2YgQ2xvdWQtTmF0aXZlIEFyY2hpdGVjdHVyZSBDb21wdXRpbmcgUGxhdGZvcm0gaW4gTWVkaWNhbCBJbWFnaW5nIEVkdWNhdGlvbgoKMSBDbG91ZC1OYXRpdmUgQXJjaGl0ZWN0dXJlIENvbXB1dGluZyBQbGF0Zm9ybSAgCjEuMSBDbG91ZC1OYXRpdmUgQ29uY2VwdCAgClRoZSBjb25jZXB0IG9mIGNsb3VkLW5hdGl2ZSByZXByZXNlbnRzIGEgbmV3IHBhcmFkaWdtIGluIG1vZGVybiBzb2Z0d2FyZSBkZXZlbG9wbWVudCwgZGVwbG95bWVudCwgYW5kIG1haW50ZW5hbmNlLCBmb2N1c2luZyBvbiBidWlsZGluZyBhcHBsaWNhdGlvbnMgdGhhdCBjYW4gcnVuIGVmZmljaWVudGx5IGluIGNsb3VkIGVudmlyb25tZW50cy4gVGhlIGNvcmUgb2YgdGhpcyBhcHByb2FjaCBpcyBlbnN1cmluZyB0aGF0IGFwcGxpY2F0aW9ucyBmdWxseSBsZXZlcmFnZSB0aGUgZWxhc3RpY2l0eSwgc2NhbGFiaWxpdHksIGFuZCBhdXRvbWF0aW9uIGFkdmFudGFnZXMgcHJvdmlkZWQgYnkgY2xvdWQgY29tcHV0aW5nLiBCeSBhZG9wdGluZyBhZHZhbmNlZCB0ZWNobm9sb2dpZXMgc3VjaCBhcyBjb250YWluZXJpemF0aW9uLCBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZSwgRGV2T3BzIHByYWN0aWNlcywgYW5kIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24vY29udGludW91cyBkZXBsb3ltZW50IChDSS9DRCksIGNsb3VkLW5hdGl2ZSBhcHBsaWNhdGlvbnMgY2FuIGJlIHJhcGlkbHkgZGVwbG95ZWQsIGZsZXhpYmx5IHNjYWxlZCBhY2NvcmRpbmcgdG8gZGVtYW5kLCBhY2hpZXZlIGVmZmljaWVudCBvcGVyYXRpb25zIG1hbmFnZW1lbnQsIGFuZCBhY2NlbGVyYXRlIHByb2R1Y3QgaXRlcmF0aW9uIGFuZCB1cGdyYWRlcy4gVGhlIHByb21vdGlvbiBvZiB0aGlzIHBhcmFkaWdtIGhhcyBtYWRlIHNvZnR3YXJlIGRldmVsb3BtZW50IGFuZCBvcGVyYXRpb25zIG1vcmUgZmxleGlibGUgYW5kIGVmZmljaWVudCwgYWRhcHRpbmcgdG8gdGhlIHJhcGlkbHkgY2hhbmdpbmcgZGVtYW5kcyBvZiB0aGUgY2xvdWQgY29tcHV0aW5nIGVyYS4gIAoKMS4yIENsb3VkLU5hdGl2ZSBBcmNoaXRlY3R1cmUgIAoxLjIuMSBDb21wb25lbnRzIG9mIENsb3VkLU5hdGl2ZSBBcmNoaXRlY3R1cmUgIApDbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlIGNvbnNpc3RzIG9mIHNldmVyYWwga2V5IGNvbXBvbmVudHMgdGhhdCBjb2xsYWJvcmF0ZSB0byBwcm92aWRlIGFuIGVmZmljaWVudCwgcmVsaWFibGUsIGFuZCBzY2FsYWJsZSBydW50aW1lIGVudmlyb25tZW50IGZvciBhcHBsaWNhdGlvbnMuIFRoZXNlIGluY2x1ZGUgbWljcm9zZXJ2aWNlcywgY29udGFpbmVyaXphdGlvbiwgY29udGludW91cyBpbnRlZ3JhdGlvbi9jb250aW51b3VzIGRlcGxveW1lbnQgKENJL0NEKSwgYW5kIERldk9wcywgYW1vbmcgb3RoZXJzLiAgCjEpIE1pY3Jvc2VydmljZXM6IFRoZSBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZSBicmVha3MgZG93biBsYXJnZSBhcHBsaWNhdGlvbnMgaW50byBzbWFsbGVyIHRhc2tzIGFuZCBpbmRpdmlkdWFsIHNlcnZpY2VzLiBWYXJpb3VzIGJ1c2luZXNzIG9wZXJhdGlvbnMgcnVuIGluIHRoZWlyIG93biBwcm9jZXNzZXMgYW5kIGludGVyYWN0IHRocm91Z2ggbGlnaHR3ZWlnaHQgY29tbXVuaWNhdGlvbiBwcm90b2NvbHMuICAKMikgQ29udGFpbmVyaXphdGlvbjogVGhpcyBpcyB0aGUgY29ybmVyc3RvbmUgb2YgY2xvdWQtbmF0aXZlIGFyY2hpdGVjdHVyZS4gQnkgZGVwbG95aW5nIHRoZSBzeXN0ZW0gZW52aXJvbm1lbnQsIGFwcGxpY2F0aW9ucywgYW5kIHJlbGF0ZWQgZGVwZW5kZW5jaWVzIGluIGNvbnRhaW5lcnMsIGl0IGVuc3VyZXMgdGhhdCBhcHBsaWNhdGlvbnMgYXJlIGZ1bGx5IHBvcnRhYmxlIGFjcm9zcyBkaWZmZXJlbnQgZGVwbG95bWVudCBlbnZpcm9ubWVudHMuICAKMykgQ29udGludW91cyBJbnRlZ3JhdGlvbi9Db250aW51b3VzIERlcGxveW1lbnQgKENJL0NEKTogSW4gY2xvdWQtbmF0aXZlIGFyY2hpdGVjdHVyZSwgQ0kvQ0QgZW5hYmxlcyByYXBpZCByZXNwb25zZSB0byBjaGFuZ2VzIGluIGRlbWFuZCwgaW1wcm92aW5nIGRldmVsb3BtZW50IGVmZmljaWVuY3kgYW5kIHByb2R1Y3QgcXVhbGl0eSB0aHJvdWdoIGF1dG9tYXRlZCBidWlsZGluZywgdGVzdGluZywgYW5kIGRlcGxveW1lbnQgcHJvY2Vzc2VzLiAgCjQpIERldk9wczogRGV2T3BzIGlzIHByaW1hcmlseSByZXNwb25zaWJsZSBmb3IgdGhlIGNvb3JkaW5hdGlvbiBhbmQgY29sbGFib3JhdGlvbiBiZXR3ZWVuIG9wZXJhdGlvbnMgYW5kIGRldmVsb3BtZW50IHdpdGhpbiB0aGUgcGxhdGZvcm0sIHNldHRpbmcgdXAgc3RhbmRhcmRpemVkIGFuZCBhdXRvbWF0ZWQgcHJvY2Vzc2VzIHRvIGFjaGlldmUgZWZmaWNpZW50IGl0ZXJhdGlvbiwgcmFwaWQgb3BlcmF0aW9ucywgYW5kIGNvbnRpbnVvdXMgaW1wcm92ZW1lbnQuICAKCjEuMi4yIEFkdmFudGFnZXMgb2YgQ2xvdWQtTmF0aXZlIEFyY2hpdGVjdHVyZSAgCkNvbXBhcmVkIHRvIHRyYWRpdGlvbmFsIGFyY2hpdGVjdHVyZSwgY2xvdWQtbmF0aXZlIGFyY2hpdGVjdHVyZSBoYXMgdGhlIGZvbGxvd2luZyBjaGFyYWN0ZXJpc3RpY3M6IGVsYXN0aWMgc2NhbGluZywgaGlnaCBhdmFpbGFiaWxpdHksIGVmZmljaWVudCBvcGVyYXRpb25zLCByYXBpZCBpdGVyYXRpb24sIGFuZCBjb3N0IHJlZHVjdGlvbiwgYXMgb3V0bGluZWQgYmVsb3c6ICAKMSkgRWxhc3RpYyBTY2FsaW5nOiBDbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIGNhbiByYXBpZGx5IGFuZCBmbGV4aWJseSBzY2FsZSB0byBhY2NvbW1vZGF0ZSBjaGFuZ2VzIGluIGJ1c2luZXNzIGRlbWFuZCB0aHJvdWdoIGNvbnRhaW5lcml6YXRpb24gYW5kIG1pY3Jvc2VydmljZXMgYXJjaGl0ZWN0dXJlLiAgCjIpIEhpZ2ggQXZhaWxhYmlsaXR5OiBDbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIGFyZSBoaWdobHkgYXZhaWxhYmxlIGFuZCByZXNpbGllbnQsIGNhcGFibGUgb2YgcmFwaWQgcmVjb3ZlcnkgaW4gdGhlIGV2ZW50IG9mIGZhaWx1cmUuICAKMykgRWZmaWNpZW50IE9wZXJhdGlvbnM6IENsb3VkLW5hdGl2ZSBhcHBsaWNhdGlvbnMgY2FuIGF1dG9tYXRlIG9wZXJhdGlvbnMsIGluY2x1ZGluZyBhdXRvbWF0ZWQgYnVpbGRpbmcsIGRlcGxveW1lbnQsIG1vbml0b3JpbmcsIGFuZCBhbGVydHMuICAKNCkgUmFwaWQgSXRlcmF0aW9uOiBDbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIHByaW1hcmlseSB1c2UgRGV2T3BzIGFuZCBhZ2lsZSBkZXZlbG9wbWVudCBtZXRob2RzLCBlbmFibGluZyByYXBpZCBpdGVyYXRpb24gYW5kIHVwZGF0ZXMuICAKNSkgQ29zdCBSZWR1Y3Rpb246IENsb3VkLW5hdGl2ZSBhcHBsaWNhdGlvbnMgbWFrZSBmdWxsIHVzZSBvZiBjbG91ZCBwbGF0Zm9ybSByZXNvdXJjZXMsIGVmZmVjdGl2ZWx5IHJlZHVjaW5nIGNvc3RzLiAgCgoxLjMgQ2xvdWQtTmF0aXZlIFJlc2VhcmNoIGFuZCBUZWFjaGluZyBQbGF0Zm9ybSBGcmFtZXdvcmsgIApUaGlzIHBhcGVyIHByb3Bvc2VzIGEgZGVzaWduIHNjaGVtZSBmb3IgYSB0ZWFjaGluZyBhbmQgcmVzZWFyY2ggY29tcHV0aW5nIHBsYXRmb3JtIGJhc2VkIG9uIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUsIGFzIHNob3duIGluIEZpZ3VyZSAxLiBJdCBpbmNsdWRlcyBLdWJlcm5ldGVzIChLOFMpIGNvbXBhdGliaWxpdHksIGRpc3RyaWJ1dGVkIHN0b3JhZ2UsIHRhc2sgcXVldWVzLCBhdXRvbWF0ZWQgb3BlcmF0aW9ucywgYW5kIHJlc291cmNlIHNjaGVkdWxpbmcuICAKCkZpZ3VyZSAxOiBDbG91ZC1OYXRpdmUgQXJjaGl0ZWN0dXJlIFRlYWNoaW5nIGFuZCBSZXNlYXJjaCBDb21wdXRpbmcgUGxhdGZvcm0gIApUaGUgcHJvcG9zZWQgY2xvdWQtbmF0aXZlIGFyY2hpdGVjdHVyZSB0ZWFjaGluZyBhbmQgcmVzZWFyY2ggY29tcHV0aW5nIHBsYXRmb3JtIGlzIGEgbXVsdGktdXNlciBwYXJhbGxlbCBjb21wdXRpbmcgcGxhdGZvcm0gY2VudGVyZWQgb24gc3R1ZGVudCByZXNlYXJjaCBhbmQgdGVhY2hpbmcgc2NlbmFyaW9zLiBJdCBwcm92aWRlcyBmdWxsLXN0YWNrIElUIGF1dG9tYXRpb24gb3BlcmF0aW9ucyBjYXBhYmlsaXRpZXMsIHNpbXBsaWZ5aW5nIHRoZSB3b3JrZmxvdyBvZiB0ZWFjaGluZyBhbmQgcmVzZWFyY2gsIGFuZCBwcm92aWRlcyBhIHVzZXItZnJpZW5kbHkgZ3VpZGVkIGludGVyZmFjZSB0aGF0IGVtcG93ZXJzIGluc3RydWN0b3JzIHRvIHF1aWNrbHkgYnVpbGQgYSBwb3dlcmZ1bCBhbmQgZmVhdHVyZS1yaWNoIGNvbnRhaW5lciBjbG91ZCBwbGF0Zm9ybSBmb3Igc3R1ZGVudHMuICAKCkZpZ3VyZSAyOiBDbG91ZC1OYXRpdmUgVGVhY2hpbmcgYW5kIFJlc2VhcmNoIFBsYXRmb3JtIEZyYW1ld29yayAgCkZyb20gRmlndXJlIDIsIHdlIGNhbiBzZWUgdGhhdCB0aGlzIHBsYXRmb3JtIGludGVncmF0ZXMgYSBwb3dlcmZ1bCBHUFUgY2x1c3RlciB0byBwcm92aWRlIGVmZmljaWVudCBkYXRhIHByb2Nlc3NpbmcgYW5kIHZpc3VhbGl6YXRpb24gY2FwYWJpbGl0aWVzLCBzdXBwb3J0aW5nIGluLWRlcHRoIHJlc2VhcmNoIGFuZCB0ZWFjaGluZyBvZiBtZWRpY2FsIGltYWdpbmcuIFRoZSBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZSBlbnN1cmVzIHRoYXQgdGhlIHBsYXRmb3JtIGhhcyBzdHJvbmcgb3Blbm5lc3MgYW5kIHNjYWxhYmlsaXR5LiBUaGUgdXNlciBjZW50ZXIgZW5zdXJlcyB0aGUgc2VjdXJlIGFuZCBvcmRlcmx5IHVzZSBvZiByZXNvdXJjZXMuIEFkZGl0aW9uYWxseSwgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIEdQVSBwaHlzaWNhbCBtYWNoaW5lcyBhbmQgV2luZG93cyB2aXJ0dWFsIG1hY2hpbmVzLCBtZWV0aW5nIGRpdmVyc2Ugc29mdHdhcmUgbmVlZHMuIE92ZXJhbGwsIHRoZSBwbGF0Zm9ybSBwcm92aWRlcyBzb2xpZCB0ZWNobmljYWwgc3VwcG9ydCBmb3IgdGVhY2hpbmcgYW5kIHJlc2VhcmNoIGluIHRoZSBmaWVsZCBvZiBtZWRpY2FsIGltYWdpbmcsIHByb21vdGluZyB0aGUgY29udGludW91cyBkZXZlbG9wbWVudCBvZiB0aGUgZmllbGQuICAKCjIuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2UgaGVscCBtZSB3cml0ZSBhbiBpbnRyb2R1Y3Rpb24gZm9yIGFuIEludGVybmV0IG9mIFRoaW5ncyAoSW9UKSBzZWN1cml0eSBwYXBlciBiYXNlZCBvbiB0aGUgY29udGVudCBJIHByb3ZpZGUsIGV4cGxhaW5pbmcgdGhlIGluY3JlYXNpbmdseSBzZXJpb3VzIHNlY3VyaXR5IHRocmVhdHMgcG9zZWQgYnkgSW9UIGRldmljZXMuIFByb3ZpZGUgYSBkZXRhaWxlZCBleHBsYW5hdGlvbiBvZiB0aGUgdGVjaG5pY2FsIGZlYXR1cmVzIG9mIGN1cnJlbnQgbWFpbnN0cmVhbSBwcm90ZWN0aW9uIHNvbHV0aW9ucyAoc3VjaCBhcyBmaXJtd2FyZSBoYXJkZW5pbmcsIGFjY2VzcyBjb250cm9sLCBldGMuKSBhbmQgdGhlIGxpbWl0YXRpb25zIGVuY291bnRlcmVkIGluIHByYWN0aWNhbCBhcHBsaWNhdGlvbnMuIE5hdHVyYWxseSwgbGVhZCBpbnRvIHRoZSBpbm5vdmF0aXZlIHBvaW50cyBhbmQgYWR2YW50YWdlcyBvZiB0aGUgbmV3IHByb3RlY3Rpb24gbWV0aG9kIEkgcHJvcG9zZS4gIApBcyBhIGZyb250bGluZSByZXNlYXJjaGVyIGFuZCBkZXZlbG9wbWVudCBlbmdpbmVlciBpbiBJb1Qgc2VjdXJpdHksIEkgYW0gZGVlcGx5IGF3YXJlIG9mIHRoZSBpbmNyZWFzaW5nIHNlY3VyaXR5IGNoYWxsZW5nZXMgaW4gdGhlIEluZHVzdHJpYWwgSW50ZXJuZXQgb2YgVGhpbmdzIChJSW9UKSBlbnZpcm9ubWVudC4gSW4gYWN0dWFsIHByb2plY3RzLCBJIGhhdmUgYmVlbiBpbnZvbHZlZCBpbiB0aGUgc2VjdXJpdHkgYXNzZXNzbWVudCBhbmQgcHJvdGVjdGlvbiBkZXZlbG9wbWVudCBvZiBzZXZlcmFsIGluZHVzdHJpYWwgY29udHJvbCBzeXN0ZW1zLCBhbmQgaGF2ZSBlbmNvdW50ZXJlZCBzb21lIGNoYWxsZW5naW5nIHNlY3VyaXR5IGluY2lkZW50cy4gRm9yIGV4YW1wbGUsIGluIGEgdHlwaWNhbCBpbmR1c3RyaWFsIG1vbml0b3Jpbmcgc3lzdGVtLCB3ZSBkaXNjb3ZlcmVkIGFuIGF0dGFjayBtZXRob2Qgd2hlcmUgYW4gYXR0YWNrZXIgZXhwbG9pdGVkIGEgZGV2aWNlIGZpcm13YXJlIHZ1bG5lcmFiaWxpdHkgdG8gaW50ZXJmZXJlIHdpdGggdGhlIGluZHVzdHJpYWwgcHJvZHVjdGlvbiBwcm9jZXNzLCBjYXVzaW5nIHByb2R1Y3Rpb24gZG93bnRpbWUgYW5kIGRhdGEgbGVha2FnZS4gU3VjaCBjYXNlcyBoaWdobGlnaHQgdGhlIGltcG9ydGFuY2Ugb2Ygc2VjdXJpdHkgcHJvdGVjdGlvbiBmb3IgSW9UIGRldmljZXMgYW5kIGhhdmUgbWFkZSBtZSByZWFsaXplIHRoZSBsaW1pdGF0aW9ucyBvZiB0cmFkaXRpb25hbCBzZWN1cml0eSBtZWFzdXJlcyBpbiBkZWFsaW5nIHdpdGggdGhlc2Ugc3BlY2lmaWMgYXR0YWNrIHNjZW5hcmlvcy4KClRocm91Z2ggeWVhcnMgb2YgcHJhY3RpY2FsIGV4cGVyaWVuY2UsIEkgaGF2ZSBmb3VuZCB0aGF0IGFsdGhvdWdoIHRoZXJlIGFyZSBzb21lIHByb3RlY3Rpb24gc29sdXRpb25zIG9uIHRoZSBtYXJrZXQsIHN1Y2ggYXMgZmlybXdhcmUgaGFyZGVuaW5nLCBhY2Nlc3MgY29udHJvbCwgYW5kIGVuY3J5cHRlZCB0cmFuc21pc3Npb24sIHRoZXkgZmFjZSBtYW55IGNoYWxsZW5nZXMgaW4gcHJhY3RpY2FsIGFwcGxpY2F0aW9ucy4gRm9yIGluc3RhbmNlLCB3aGlsZSBmaXJtd2FyZSBoYXJkZW5pbmcgZWZmZWN0aXZlbHkgaW1wcm92ZXMgZGV2aWNlIHNlY3VyaXR5LCBpdCBvZnRlbiBpbmNyZWFzZXMgdGhlIGNvc3QgYW5kIGNvbXBsZXhpdHkgb2YgdGhlIGRldmljZSwgYW5kIHRoZSBoYXJkZW5lZCBkZXZpY2VzIGhhdmUgc2xvdyByZXNwb25zZSB0aW1lcyB3aGVuIGZhY2luZyBuZXcgdHlwZXMgb2YgYXR0YWNrczsgYWNjZXNzIGNvbnRyb2wgc29sdXRpb25zLCB3aGlsZSBlZmZlY3RpdmVseSByZXN0cmljdGluZyB1bmF1dGhvcml6ZWQgYWNjZXNzLCBhcmUgY29zdGx5IHRvIGltcGxlbWVudCwgY29tcGxleCB0byBjb25maWd1cmUsIGFuZCBkaWZmaWN1bHQgdG8gYWRhcHQgdG8gdGhlIGR5bmFtaWMgaW5kdXN0cmlhbCBlbnZpcm9ubWVudC4gVGhyb3VnaCB0aGVzZSBwZXJzb25hbCBleHBlcmllbmNlcywgSSBkZWVwbHkgcmVhbGl6ZSB0aGF0IGN1cnJlbnQgcHJvdGVjdGl2ZSBtZWFzdXJlcyBhcmUgZmFyIGZyb20gbWVldGluZyB0aGUgaGlnaCBzZWN1cml0eSByZXF1aXJlbWVudHMgaW4gdGhlIGluZHVzdHJpYWwgSW9UIGZpZWxkLgoKQmFzZWQgb24gbXkgYWNjdW11bGF0ZWQgZXhwZXJpZW5jZSBpbiBJSW9UIHNlY3VyaXR5LCB0aGlzIHBhcGVyIHByb3Bvc2VzIGEgbmV3IHByb3RlY3RpdmUgbWV0aG9kIGFpbWVkIGF0IG92ZXJjb21pbmcgdGhlIGxpbWl0YXRpb25zIG9mIGV4aXN0aW5nIHRlY2hub2xvZ2llcyBhbmQgaW1wcm92aW5nIHRoZSBzZWN1cml0eSBhbmQgYWRhcHRhYmlsaXR5IG9mIElvVCBkZXZpY2VzLiBPdXIgYXBwcm9hY2ggY29tYmluZXMgKiptdWx0aS1sYXllciBkeW5hbWljIG1vbml0b3JpbmcqKiB3aXRoIGFuICoqYWRhcHRpdmUgcmVzcG9uc2UgbWVjaGFuaXNtKiosIGFuYWx5emluZyBkZXZpY2UgYmVoYXZpb3IgYW5kIG5ldHdvcmsgdHJhZmZpYyBpbiByZWFsIHRpbWUgdG8gYXV0b21hdGljYWxseSBpZGVudGlmeSBhbmQgYmxvY2sgcG90ZW50aWFsIHNlY3VyaXR5IHRocmVhdHMuIFVubGlrZSB0cmFkaXRpb25hbCBzdGF0aWMgcHJvdGVjdGlvbiBtZWFzdXJlcywgdGhpcyBhcHByb2FjaCBjYW4gZmxleGlibHkgYWRqdXN0IHByb3RlY3Rpb24gc3RyYXRlZ2llcyBiYXNlZCBvbiBhY3R1YWwgY29uZGl0aW9ucywgc2lnbmlmaWNhbnRseSByZWR1Y2luZyBmYWxzZSBwb3NpdGl2ZSByYXRlcyBhbmQgaW1wcm92aW5nIHByb3RlY3Rpb24gZWZmaWNpZW5jeS4gQWRkaXRpb25hbGx5LCB3ZSBoYXZlIGludHJvZHVjZWQgYSAqKmJsb2NrY2hhaW4tYmFzZWQqKiBkZXZpY2UgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIHRvIGVuc3VyZSB0aGUgcmVsaWFiaWxpdHkgb2YgZGV2aWNlIGlkZW50aXRpZXMgYW5kIHRoZSB0cmFuc3BhcmVuY3kgb2YgY29tbXVuaWNhdGlvbiBwcm9jZXNzZXMsIGFkZHJlc3NpbmcgdGhlIGNvbW1vbiBzZWN1cml0eSByaXNrcyBhc3NvY2lhdGVkIHdpdGggZGV2aWNlIGlkZW50aXR5IGF1dGhlbnRpY2F0aW9uLiAKClRoZXNlIGlubm92YXRpb25zIG1ha2Ugb3VyIHByb3RlY3Rpb24gbWV0aG9kIG5vdCBvbmx5IHBlcmZvcm0gZXhjZWxsZW50bHkgaW4gcmVzcG9uZGluZyB0byBrbm93biB0aHJlYXRzIGJ1dCBhbHNvIGVmZmVjdGl2ZWx5IGRlYWwgd2l0aCBlbWVyZ2luZyB0eXBlcyBvZiBhdHRhY2tzLCBmaWxsaW5nIHRoZSBnYXAgaW4gZmxleGliaWxpdHkgYW5kIGFkYXB0YWJpbGl0eSBpbiBjdXJyZW50IHRlY2hub2xvZ2ljYWwgc29sdXRpb25zLgp1c2VyOgpQbGVhc2UgaGVscCBtZSBjaGVjayBhbmQgaW1wcm92ZSB0aGUgaW50cm9kdWN0aW9uIG9mIHRoaXMgcGFwZXIgb24gYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3ksIGV4cGFuZGluZyB0aGUgcmVzZWFyY2ggYmFja2dyb3VuZCBhbmQgcHJvdmlkaW5nIGEgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhlIHBhaW4gcG9pbnRzIGFuZCBzb2x1dGlvbnMsICoqSW5ub3ZhdGlvbiBvZiBUcnVuayBMb2dpc3RpY3MgQXV0b25vbW91cyBEcml2aW5nIFRlY2hub2xvZ3kgYW5kIEV2b2x1dGlvbiBvZiBCdXNpbmVzcyBNb2RlbHMqKgoKQWJzdHJhY3Q6IEF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGhhcyBmaXJzdCBiZWVuIGltcGxlbWVudGVkIGluIHRoZSB0cnVuayBsb2dpc3RpY3MgZmllbGQuIFRoZSByaXNlIG9mIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGJyaW5ncyBuZXcgZGV2ZWxvcG1lbnQgb3Bwb3J0dW5pdGllcyB0byB0aGUgdHJ1bmsgbG9naXN0aWNzIGluZHVzdHJ5LiBUcnVuayBsb2dpc3RpY3MgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3kgaXMgYmVjb21pbmcgbWF0dXJlIGFuZCBoYXMgYmVndW4gdG8gZXhwbG9yZSBjb21tZXJjaWFsaXphdGlvbiBtb2RlbHMuIEJ5IGFuYWx5emluZyB0aGUgc3BlY2lmaWMgc2NlbmFyaW9zIGFuZCBjaGFyYWN0ZXJpc3RpY3Mgb2YgdHJ1bmsgbG9naXN0aWNzLCB0aGUga2V5IHRlY2hub2xvZ2llcyBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgaW4gdHJ1bmsgbG9naXN0aWNzIGFyZSBpZGVudGlmaWVkLCBhbmQgcmVjb21tZW5kYXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZ1bmN0aW9uIGFuZCBzeXN0ZW0gZGVzaWduIG9mIHRydW5rIHZlaGljbGVzLiBCYXNlZCBvbiB0aGUgbWFya2V0IGRlbWFuZCBvZiB0cnVuayBsb2dpc3RpY3MsIHRoaXMgYXJ0aWNsZSBwcm9tb3RlcyB0aGUgY29tbWVyY2lhbGl6YXRpb24gZXZvbHV0aW9uIG9mIHRydW5rIGxvZ2lzdGljcyBiYXNlZCBvbiB0aGUgaW5ub3ZhdGlvbiBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neS4KCktleXdvcmRzOiB0cnVuayBsb2dpc3RpY3M7IGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5OyBidXNpbmVzcyBtb2RlbHM7IHRlY2hub2xvZ2ljYWwgcm91dGVzCgpUaGUgdHJhZGl0aW9uYWwgbG9naXN0aWNzIG9wZXJhdGlvbiBtb2RlbCBoYXMgcHJvYmxlbXMgc3VjaCBhcyBoaWdoIGxhYm9yIGNvc3QsIGhpZ2ggY29zdHMsIGxvdyBlZmZpY2llbmN5LCBsb25nIGRlbGl2ZXJ5IHRpbWUsIGFuZCBoaWRkZW4gc2FmZXR5IGhhemFyZHMuIFRocm91Z2ggdGhlIGltcHJvdmVtZW50IG9mIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5LCB0aGUgZGVmZWN0cyBvZiB0aGUgdHJhZGl0aW9uYWwgbG9naXN0aWNzIG9wZXJhdGlvbiBtb2RlbCBjYW4gYmUgYmV0dGVyIGFkZHJlc3NlZC4gVGhlcmVmb3JlLCB0aGUgY29udGludW91cyBkZXZlbG9wbWVudCBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBicmluZ3MgbmV3IGRldmVsb3BtZW50IG9wcG9ydHVuaXRpZXMgdG8gdGhlIGxvZ2lzdGljcyBpbmR1c3RyeS4gQXQgcHJlc2VudCwgZG9tZXN0aWMgYW5kIGZvcmVpZ24gcmVzZWFyY2ggaXMgbW9zdGx5IGxpbWl0ZWQgdG8gdGhlIGFuYWx5c2lzIG9mIHNwZWNpZmljIHNjZW5hcmlvcyBvbiB0cnVuayByb2FkcywgbGFja2luZyBhIHN5c3RlbWF0aWMgYW5hbHlzaXMgb2YgdmFyaW91cyBhcHBsaWNhdGlvbiBzY2VuYXJpb3MgdGhhdCB0cnVuayBhdXRvbm9tb3VzIGxvZ2lzdGljcyB2ZWhpY2xlcyBtYXkgZmFjZS4gVGhpcyBhcnRpY2xlIGFpbXMgdG8gYWRkcmVzcyBrZXkgaXNzdWVzIGluIHZpc3VhbCBwZXJjZXB0aW9uLCBwb3NpdGlvbmluZywgYW5kIG90aGVyIGNyaXRpY2FsIHRlY2hub2xvZ2llcyBmb3IgdHJ1bmsgYXV0b25vbW91cyBsb2dpc3RpY3MgdmVoaWNsZXMgdGhyb3VnaCBpbi1kZXB0aCByZXNlYXJjaCBhbmQgaW5ub3ZhdGlvbiBvbiB0aGVpciB1bmlxdWUgc2NlbmFyaW9zIGFuZCB0ZWNobm9sb2dpZXMsIGFuZCBwcm92aWRlIG5ldyBpZGVhcyBmb3IgdGhlIHByYWN0aWNhbCBhcHBsaWNhdGlvbiBvZiB0cnVuayBsb2dpc3RpY3MgYnVzaW5lc3MgbW9kZWxzLgoKMS4gKipJbm5vdmF0aW9uIG9mIFRydW5rIExvZ2lzdGljcyBBdXRvbm9tb3VzIERyaXZpbmcgVGVjaG5vbG9neSBhbmQgQnVzaW5lc3MgTW9kZWwgQXJjaGl0ZWN0dXJlKioKClRoZSByZXNlYXJjaCBvbiB0aGUgaW5ub3ZhdGlvbiBvZiB0cnVuayBsb2dpc3RpY3MgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3kgYW5kIHRoZSBldm9sdXRpb24gb2YgYnVzaW5lc3MgbW9kZWxzIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzOiBjb25zdHJ1Y3RpbmcgYSBmbGV4aWJsZSBhdXRvbm9tb3VzIGRyaXZpbmcgbW9kZSwgdHJ1bmsgbG9naXN0aWNzIGNsb3VkIGRhdGEgaW50ZWxsaWdlbmNlIGFuZCBhdXRvbm9tb3VzIGRyaXZpbmcgaW50ZWdyYXRpb24sIGFuZCB0aGUgdGVjaG5pY2FsIHJvdXRlIG9mIHRoZSB0cnVuayBsb2dpc3RpY3MgYXV0b25vbW91cyBkcml2aW5nIGJ1c2luZXNzIG1vZGVsLCBhcyBzaG93biBpbiBGaWd1cmUgMS4KCioqRmlndXJlIDEqKjogVHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGlubm92YXRpb24gYW5kIGJ1c2luZXNzIG1vZGVsIGFyY2hpdGVjdHVyZQoKQmFzZWQgb24gZXhpc3RpbmcgdGVjaG5vbG9naWVzLCB0aGUgbGF0ZXN0IHRlY2hub2xvZ2llcyBhcmUgaW50ZWdyYXRlZCB0byB1cGdyYWRlIHRoZSB0ZWNobm9sb2d5LiBUaGUgZXhwbG9yYXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGlubm92YXRpb24gYW5kIGJ1c2luZXNzIG1vZGVscyB3aWxsIHByb2NlZWQgZnJvbSB0aHJlZSBhc3BlY3RzOiBmaXJzdGx5LCBjb25zdHJ1Y3RpbmcgYSBmbGV4aWJsZSBhdXRvbm9tb3VzIGRyaXZpbmcgbW9kZSwgd2hpY2ggaW5jbHVkZXMgdGhlIGRlc2lnbiBvZiBtdWx0aXBsZSBkcml2aW5nIG1vZGVzLCBkZXZlbG9wbWVudCBvZiBpbnRlbGxpZ2VudCBkZWNpc2lvbi1tYWtpbmcgbW9kdWxlcywgaW1wcm92ZW1lbnQgb2YgdmVoaWNsZSBwZXJjZXB0aW9uIHRlY2hub2xvZ2llcywgYW5kIG9wdGltaXphdGlvbiBvZiBhcnRpZmljaWFsIGludGVsbGlnZW5jZSBhbGdvcml0aG1zLCBjb250aW51b3VzbHkgaW1wcm92aW5nIHRoZSBleGlzdGluZyB0cnVuayBsb2dpc3RpY3MgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3ksIGVuaGFuY2luZyBpdHMgYXBwbGljYWJpbGl0eSBhbmQgdW5pdmVyc2FsaXR5OyBzZWNvbmRseSwgYWNoaWV2aW5nIHRoZSBpbnRlZ3JhdGlvbiBvZiB0cnVuayBsb2dpc3RpY3MgY2xvdWQgZGF0YSBpbnRlbGxpZ2VuY2UgYW5kIGF1dG9ub21vdXMgZHJpdmluZywgd2hpY2ggaW5jbHVkZXMgY2xvdWQgZGF0YSBvcHRpbWl6YXRpb24gYW5kIHRoZSBpdGVyYXRpb24gb2YgY2xvdWQgY29tcHV0aW5nIGRhdGEgaW50ZWxsaWdlbmNlIOKAnHN1cHBvcnTigJ0gdGVjaG5vbG9neSwgaW1wcm92aW5nIHZlaGljbGUgdmFsdWUgdGhyb3VnaCBjb21wdXRpbmcgcG93ZXIgc2VydmljZXMsIGFuZCBmb3JtaW5nIGludGVsbGlnZW50IGRyaXZpbmc7IHRoaXJkbHksIHN0dWR5aW5nIHRoZSB0ZWNobmljYWwgcm91dGUgb2YgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyBidXNpbmVzcyBtb2RlbHMsIGluY2x1ZGluZyB0aGUgdXBncmFkaW5nIG9mIGludGVsbGlnZW50IG1vbml0b3JpbmcgYW5kIG1hbmFnZW1lbnQgc3lzdGVtcywgdGhlIGludGVncmF0aW9uIG9mIHZlaGljbGUgbmV0d29ya3MgYW5kIFYyWCwgYW5kIHRoZSBpdGVyYXRpb24gb2YgY2xvdWQgY29tcHV0aW5nIGRhdGEgaW50ZWxsaWdlbmNlICJzdXBwb3J0IiB0ZWNobm9sb2d5LiBCeSBpbnRlZ3JhdGluZyBhbmQgcmVmb3JtaW5nIHRoZSB0ZWNobm9sb2d5IG9mIHRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgYnVzaW5lc3MgbW9kZWxzLCB0aGUgZGV2ZWxvcG1lbnQgb2YgdGhlIGluZHVzdHJ5IGNhbiBiZSBhY2NlbGVyYXRlZCwgcmVzb3VyY2UgdXRpbGl6YXRpb24gZWZmaWNpZW5jeSBpbXByb3ZlZCwgYW5kIGVjb25vbWljIGJlbmVmaXRzIHByb21vdGVkLgoKMi4gKipEZXNpZ24gb2YgVHJ1bmsgTG9naXN0aWNzIEF1dG9ub21vdXMgRHJpdmluZyBUZWNobm9sb2d5IElubm92YXRpb24gTW9kZWwqKgoKMi4xICoqQ29uc3RydWN0aW5nIGEgRmxleGlibGUgQXV0b25vbW91cyBEcml2aW5nIE1vZGUqKgoKMi4xLjEgKipEZXNpZ24gb2YgTXVsdGlwbGUgRHJpdmluZyBNb2RlcyoqCgpUcnVuayBsb2dpc3RpY3MgdmVoaWNsZXMgYXJlIGRlc2lnbmVkIHdpdGggdmFyaW91cyBkcml2aW5nIG1vZGVzIGJhc2VkIG9uIGRpZmZlcmVudCBkZWxpdmVyeSBsb2NhdGlvbnMgYW5kIHJvYWQgY29tcGxleGl0aWVzLCBhcyB3ZWxsIGFzIGRpZmZlcmVudCBkcml2aW5nIHNjZW5hcmlvcyBhbmQgcmVxdWlyZW1lbnRzIHRvIHJlZHVjZSBjb3N0cyBhbmQgaW1wcm92ZSBlZmZpY2llbmN5LiBUaGUgYXV0b25vbW91cyBkcml2aW5nIG1vZGUgY2FuIGNob29zZSB0aGUgb3B0aW1hbCBkcml2aW5nIHJvdXRlIGJhc2VkIG9uIGRpZmZlcmVudCBzaXR1YXRpb25zLiBGb3IgZXhhbXBsZSwgaW4gdGhlIGNhc2Ugb2YgdHJhZmZpYyBjb25nZXN0aW9uIG9uIHVyYmFuIHJvYWRzLCBhIGxvdy1zcGVlZCBkZWNlbGVyYXRpb24gdHJhbnNwb3J0IG1vZGUgY2FuIGJlIHVzZWQgdG8gcmVkdWNlIHZlaGljbGUgZW5lcmd5IGNvbnN1bXB0aW9uIGFuZCBkcml2aW5nIG5vaXNlOyBvbiBoaWdod2F5cyBvciBvcGVuIHJvYWRzIGluIHN1YnVyYmFuIGFyZWFzLCBhIGhpZ2gtc3BlZWQgdHJhbnNwb3J0IG1vZGUgaXMgcmVxdWlyZWQgdG8gaW1wcm92ZSB0cmFuc3BvcnRhdGlvbiBlZmZpY2llbmN5LgoKMi4xLjIgKipEZXZlbG9wbWVudCBvZiBJbnRlbGxpZ2VudCBEZWNpc2lvbi1NYWtpbmcgTW9kdWxlcyoqCgpJbiBvcmRlciB0byBkZWxpdmVyIGdvb2RzIG9uIHRpbWUgYW5kIGltcHJvdmUgY3VzdG9tZXIgc2F0aXNmYWN0aW9uLCBpbnRlbGxpZ2VudCBkZWNpc2lvbi1tYWtpbmcgbW9kdWxlcyBhcmUgcmVxdWlyZWQuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgoqKlJlc2VhcmNoIG9uIHRoZSBQcmFjdGljZSBvZiBJbmR1c3RyaWFsIEludGVybmV0IFNlY3VyaXR5IENhcGFiaWxpdHkgQ29uc3RydWN0aW9uIGluIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMqKiAgCgojIyMgMS4gRGVzaWduIG9mIEluZHVzdHJpYWwgSW50ZXJuZXQgU2VjdXJpdHkgRnVuY3Rpb25hbCBBcmNoaXRlY3R1cmUgZm9yIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMgIAoKQmFzZWQgb24gY3liZXJzZWN1cml0eSByZWd1bGF0aW9ucywgdGhlIG9wZXJhdGlvbmFsIGNoYXJhY3RlcmlzdGljcyBvZiBwb3dlciBlbnRlcnByaXNlcywgYW5kIG5hdGlvbmFsIGluZHVzdHJ5IHJlZ3VsYXRvcnkgcHJhY3RpY2VzLCBwb3dlciBwcm9kdWN0aW9uIGVudGVycHJpc2VzIGhhdmUgZXN0YWJsaXNoZWQgYSB0YXJnZXRlZCBpbmR1c3RyaWFsIGludGVybmV0IHNlY3VyaXR5IHByb3RlY3Rpb24gc3lzdGVtLiBUaGlzIHN5c3RlbSBhaW1zIHRvIHByb21vdGUgdGhlIGludGVsbGlnZW50IHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBwb3dlciBpbmR1c3RyeSB3aGlsZSBlbnN1cmluZyBmdWxsIGNvbXBsaWFuY2UgYW5kIGVmZmljaWVudCBzZWN1cml0eSB0aHJvdWdoIGEgdHdvLXRpZXIsIHRocmVlLWxheWVyIGFyY2hpdGVjdHVyZSBvZiB0aGUgaW5kdXN0cmlhbCBpbnRlcm5ldCBzZWN1cml0eSBzZXJ2aWNlIHBsYXRmb3JtIChVQ1NQKSBbMV0uICAKClRoaXMgcGxhdGZvcm0gaW50ZWdyYXRlcyByZXNvdXJjZXMgZnJvbSB1cHN0cmVhbSBhbmQgZG93bnN0cmVhbSBwb3dlciBwcm9kdWN0aW9uIGVudGVycHJpc2VzLCByZWd1bGF0b3J5IGFnZW5jaWVzLCBhbmQgc2VydmljZSBwcm92aWRlcnMsIGZvcm1pbmcgYSBjb2xsYWJvcmF0aXZlIHNlY3VyaXR5IG9wZXJhdGlvbiBhbmQgbWFpbnRlbmFuY2UgbWVjaGFuaXNtLiBJdCBvZmZlcnMgb25lLXN0b3AgY3liZXJzZWN1cml0eSBzZXJ2aWNlcyB0byBhZGRyZXNzIHZhcmlvdXMgc2VjdXJpdHkgY2hhbGxlbmdlcyBmYWNlZCBieSBwb3dlciBlbnRlcnByaXNlcyBkdXJpbmcgZGlnaXRhbCB0cmFuc2Zvcm1hdGlvbi4gIAoKVUNTUCBpcyBhIHBsYXRmb3JtIGRlZGljYXRlZCB0byBpbmR1c3RyaWFsIGludGVybmV0IG1vbml0b3JpbmcgYW5kIHBlcmNlcHRpb24uIEl0IHNlYW1sZXNzbHkgY29ubmVjdHMgd2l0aCBuYXRpb25hbCBzdXBlcnZpc29yeSBtYW5hZ2VtZW50IHN5c3RlbXMgYW5kIHJlbGV2YW50IG5hdGlvbmFsIHBsYXRmb3JtcyB3aGlsZSBhY3RpdmVseSBwYXJ0aWNpcGF0aW5nIGluIHRocmVhdCBpbnRlbGxpZ2VuY2Ugc2hhcmluZyBhbmQgZW5mb3JjaW5nIGhpZ2ggc3RhbmRhcmRzIG9mIHJlZ3VsYXRvcnkgY29tcGxpYW5jZS4gSXRzIGZ1bmN0aW9uYWwgYXJjaGl0ZWN0dXJlIGRlc2lnbiBpcyBzaG93biBpbiAqKkZpZ3VyZSAxKiouIFRoZSBjb3JlIGZ1bmN0aW9ucyBpbmNsdWRlIGJ1dCBhcmUgbm90IGxpbWl0ZWQgdG86ICAKCi0gQXNzZXQgZGV0ZWN0aW9uICAKLSBUcmFmZmljIGFuZCByaXNrIGFuYWx5c2lzICAKLSBTaXR1YXRpb24gYXNzZXNzbWVudCAgCi0gRWFybHkgd2FybmluZyBzeXN0ZW1zICAKLSBFbWVyZ2VuY3kgcmVzcG9uc2UgIAoKVGhlc2UgZnVuY3Rpb25zIGNvbGxlY3RpdmVseSBjb250cmlidXRlIHRvIGEgZGVlcGVyIHVuZGVyc3RhbmRpbmcgYW5kIHZpc3VhbGl6YXRpb24gb2YgaW5kdXN0cmlhbCBuZXR3b3JrIHNlY3VyaXR5IGNvbmRpdGlvbnMsIGVuc3VyaW5nIHJlYWwtdGltZSBpZGVudGlmaWNhdGlvbiBhbmQgd2FybmluZyBvZiBwb3RlbnRpYWwgdGhyZWF0cywgcmlza3MsIGFuZCB2dWxuZXJhYmlsaXRpZXMsIHRodXMgcHJvdmlkaW5nIHN0cm9uZyBzdXBwb3J0IGZvciBwb3dlciBlbnRlcnByaXNlcycgY3liZXJzZWN1cml0eSBtYW5hZ2VtZW50LiAgCgoqKkZpZ3VyZSAxOiBPdmVyYWxsIEZ1bmN0aW9uYWwgQXJjaGl0ZWN0dXJlIERlc2lnbiBvZiBJbmR1c3RyaWFsIEludGVybmV0IFNlY3VyaXR5IENhcGFiaWxpdHkgZm9yIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMqKiAgCgpJbiB0aGUgaW5kdXN0cmlhbCBuZXR3b3JrIHNlY3VyaXR5IHJpc2sgbW9uaXRvcmluZyBhbmQgYW5hbHlzaXMgc3lzdGVtLCBzZWN1cml0eSBzdHJhdGVnaWVzIGFyZSBkZXNpZ25lZCB0byBzdXBwb3J0IHBvd2VyIGVudGVycHJpc2VzIGluIGFsaWduaW5nIHdpdGggTmF0aW9uYWwgU3RhbmRhcmQgMi4wLiBUaGlzIGVuc3VyZXMgc2VjdXJpdHkgaW4gbmV0d29yayBib3VuZGFyaWVzLCBjb21tdW5pY2F0aW9uLCBhcHBsaWNhdGlvbnMsIGFuZCBkYXRhIGxheWVycy4gVGhlIHN5c3RlbSBhZGhlcmVzIHRvIGluZHVzdHJ5IHNlY3VyaXR5IG5vcm1zLCBhaW1pbmcgZm9yIHJpc2sgY2xhcml0eSwgdmlzdWFsaXphdGlvbiwgYW5kIGNvbnRyb2xsYWJpbGl0eSB0byBlbmhhbmNlIHRoZSBjeWJlcnNlY3VyaXR5IG1hbmFnZW1lbnQgY2FwYWJpbGl0aWVzIG9mIHBvd2VyIGVudGVycHJpc2VzIFsyXS4gIAoKRm9yIG9mZmljZSBhcmVhIHNlY3VyaXR5IGRlc2lnbiwgaW5mb3JtYXRpb24gY29sbGVjdGlvbiwgYXNzZXQgY29udHJvbCwgYW5kIGF1ZGl0aW5nIHRhc2tzIGFyZSBjb3ZlcmVkIHRvIHByb3ZpZGUgcmVhbC10aW1lIG1vbml0b3JpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSB1bmlmaWVkIHNlY3VyaXR5IHBsYXRmb3JtIGFuZCBzdXBwb3J0IHBsYXRmb3JtIHNlcnZpY2VzLiBBdCB0aGUgY3JpdGljYWwgaW5kdXN0cmlhbCBjb250cm9sIGVkZ2UgbGF5ZXIsIGEgbGF5ZXJlZCBhbmQgZG9tYWluLXNlcGFyYXRlZCBzdHJhdGVneSBpcyBhZG9wdGVkLCBpbnRlZ3JhdGluZyBtdWx0aXBsZSBzZWN1cml0eSB0ZWNobm9sb2dpZXMgdG8gcmVpbmZvcmNlIG5ldHdvcmsgYm91bmRhcnkgcHJvdGVjdGlvbiBiZXR3ZWVuIGRldmljZXMgYW5kIGNvbnRyb2wgc3lzdGVtcy4gIAoKSW4gaW5kdXN0cmlhbCBjb250cm9sIGVxdWlwbWVudCwgcG93ZXIgZW50ZXJwcmlzZXMgaW1wbGVtZW50IHN0cmljdCBpZGVudGl0eSB2ZXJpZmljYXRpb24gYW5kIGFjY2VzcyBjb250cm9sLCB1dGlsaXppbmcgaGFyZHdhcmUtdW5pcXVlIGlkZW50aWZpZXJzIHRvIGVuc3VyZSBsZWdpdGltYXRlIG5ldHdvcmsgYWNjZXNzIGFuZCBydWxlLWJhc2VkIGRhdGEgaW50ZXJhY3Rpb24gY29udHJvbC4gKipGaWd1cmUgMioqIGlsbHVzdHJhdGVzIHRoZSBpbmR1c3RyaWFsIGludGVybmV0IGRhdGEgZmxvdyBhbmQgY3J5cHRvZ3JhcGhpYyBlbXBvd2VybWVudCBpbiBwb3dlciBwcm9kdWN0aW9uIGVudGVycHJpc2VzLiAgCgpTZWN1cml0eSBtZWFzdXJlcyBpbiB0aGUgY29udHJvbCBwcm9jZXNzIGluY2x1ZGU6ICAKCi0gU3RyZW5ndGhlbmluZyBwcm90b2NvbCBzZWN1cml0eSAgCi0gU29mdHdhcmUgaGFyZGVuaW5nICAKLSBDb21tYW5kIGF1ZGl0aW5nICAKLSBGYXVsdCBwcm90ZWN0aW9uICAKCkFsbCB1c2VycyBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQsIGFkZGl0aW9uYWwgYXV0aGVudGljYXRpb24gc3RlcHMgYXJlIHJlcXVpcmVkIGR1cmluZyBjb21tdW5pY2F0aW9uIHRvIHByZXZlbnQgdW5hdXRob3JpemVkIHNlc3Npb25zLCBlbmNyeXB0aW9uIGlzIHVzZWQgdG8gcHJvdGVjdCBkYXRhIHRyYW5zbWlzc2lvbiwgYW5kIHNvZnR3YXJlIHZ1bG5lcmFiaWxpdGllcyBhcmUgcHJvbXB0bHkgcGF0Y2hlZCBvciBtaXRpZ2F0ZWQuIENvbW1hbmQgYXVkaXRpbmcgcHJldmVudHMgc2VjdXJpdHkgaW5jaWRlbnRzLCBlbnN1cmluZyBjb21wcmVoZW5zaXZlIHByb3RlY3Rpb24gZm9yIGluZHVzdHJpYWwgaW50ZXJuZXQgc2VjdXJpdHkuICAKCioqRmlndXJlIDI6IEluZHVzdHJpYWwgSW50ZXJuZXQgRGF0YSBGbG93IGFuZCBDcnlwdG9ncmFwaGljIEVtcG93ZXJtZW50IGluIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMqKiAgCgojIyMgMi4gRGVwbG95bWVudCBQbGFuIGZvciBJbmR1c3RyaWFsIEludGVybmV0IFNlY3VyaXR5IENhcGFiaWxpdHkgaW4gUG93ZXIgUHJvZHVjdGlvbiBFbnRlcnByaXNlcyAgCgpGb3IgcG93ZXIgcHJvZHVjdGlvbiBlbnRlcnByaXNlcywgVUNTUCBpcyBhIGNvbXByZWhlbnNpdmUsIG11bHRpLWxheWVyZWQgc2VjdXJpdHkgcHJvdGVjdGlvbiBzeXN0ZW0uIEl0cyBmdW5kYW1lbnRhbCBjb21wb25lbnRzIGluY2x1ZGUgbXVsdGlwbGUgbGF5ZXJzIHN1Y2ggYXMgdGhlICoqaW5mcmFzdHJ1Y3R1cmUgbGF5ZXIqKiBhbmQgdGhlICoqc3lzdGVtIGNvbXBvbmVudCBsYXllcioqLCB3aGljaCBjb2xsYWJvcmF0ZSB0byBlbnN1cmUgbmV0d29yayBzZWN1cml0eSBhY3Jvc3MgdGhlIHBvd2VyIHN5c3RlbSBbM10uICAKCi0gKipJbmZyYXN0cnVjdHVyZSBMYXllcioqOiBFZmZpY2llbnQgcmVzb3VyY2UgYW5kIGRldmljZSBjb21wdXRpbmcgdG8gcHJvdmlkZSBhIHNvbGlkIHRlY2hub2xvZ2ljYWwgZm91bmRhdGlvbiBmb3IgdGhlIGVudGlyZSBzeXN0ZW0uICAKLSAqKlN5c3RlbSBDb21wb25lbnRzIGFuZCBGdW5jdGlvbmFsIFNlcnZpY2UgTGF5ZXIqKjogVUNTUCBzZXJ2ZXMgYXMgdGhlIGNvcmUsIGNvdmVyaW5nIG5pbmUgbWFqb3IgY29tcG9uZW50cywgaW5jbHVkaW5nIHNlY3VyZSBkYXRhIHN0b3JhZ2UsIGRhdGEgaW50ZWdyYXRpb24sIGFuZCBkYXRhIGNsdXN0ZXIgbm9kZXMuIFRoZXNlIGNvbXBvbmVudHMgZW5hYmxlIGVmZmljaWVudCBkYXRhIHByb2Nlc3NpbmcgYW5kIHByZWNpc2Ugc2VjdXJpdHkgc3RyYXRlZ2llcyB0byByYXBpZGx5IHJlc3BvbmQgdG8gc2VjdXJpdHkgdGhyZWF0cy4gIAotICoqU2l0dWF0aW9uIERpc3BsYXkgTGF5ZXIqKjogTGFyZ2Utc2NhbGUgc2l0dWF0aW9uYWwgbW9uaXRvcmluZyBzY3JlZW5zIHByb3ZpZGUgcmVhbC10aW1lIHZpc3VhbGl6YXRpb24gb2YgZml2ZSBtYWpvciBzZWN1cml0eSBzaXR1YXRpb25zLCBlbmFibGluZyBzZWN1cml0eSBwZXJzb25uZWwgdG8gZ3Jhc3AgdGhlIGN1cnJlbnQgc2VjdXJpdHkgc3RhdHVzIGF0IGEgZ2xhbmNlLiAgCgpBZGRpdGlvbmFsbHksIFVDU1Agb2ZmZXJzIHR3byBjcml0aWNhbCBidXNpbmVzcyBmdW5jdGlvbnM6ICAKCjEuICoqQWR2YW5jZWQgUGVyc2lzdGVudCBUaHJlYXQgKEFQVCkgRGV0ZWN0aW9uKiogIAoyLiAqKkN5YmVyc2VjdXJpdHkgU2l0dWF0aW9uIE1vbml0by4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6ClJlc2VhcmNoIG9uIHRoZSBEZXZlbG9wbWVudCBvZiBTbWFydCBBZ3JpY3VsdHVyZSBpbiBTdXFpYW4gQ2l0eSBpbiB0aGUgTmV3IEVyYSDigJMgQSBDYXNlIFN0dWR5IG9mIFRpYW53YSBTbWFydCBJbmR1c3RyaWFsIFBhcmsKCkFic3RyYWN0OiBXaXRoIHRoZSBhcnJpdmFsIG9mIHRoZSBkaWdpdGFsIGVyYSwgc21hcnQgYWdyaWN1bHR1cmUgaGFzIGdyYWR1YWxseSBiZWNvbWUgYSBob3QgdG9waWMuIEl0IHBsYXlzIGFuIGltcG9ydGFudCByb2xlIGluIGltcHJvdmluZyBsYWJvciBlZmZpY2llbmN5LCBlbmhhbmNpbmcgcHJvZHVjdGl2aXR5IHF1YWxpdHksIG9wdGltaXppbmcgcmVzb3VyY2UgYWxsb2NhdGlvbiwgYW5kIHByb21vdGluZyBlbnZpcm9ubWVudGFsIHByb3RlY3Rpb24uIEl0IGhhcyBiZWNvbWUgYW4gaW1wb3J0YW50IGRldmVsb3BtZW50IGNvbmNlcHQgZm9yIGltcGxlbWVudGluZyB0aGUgcnVyYWwgcmV2aXRhbGl6YXRpb24gc3RyYXRlZ3kgYW5kIGEgcG93ZXJmdWwgdG9vbCBmb3IgYnVpbGRpbmcg4oCcbmV3IGFncmljdWx0dXJlLCBuZXcgY291bnRyeXNpZGUsIG5ldyBmYXJtZXJz4oCdIGluIHRoZSBuZXcgZXJhLiBJbiB0aGlzIHJlZ2FyZCwgaG93IHRvIHVzZSAiSW50ZXJuZXQgKyIgdGVjaG5vbG9neSB0byBpbmplY3Qgc21hcnQgImdlbmVzIiBpbnRvIGFncmljdWx0dXJhbCBtb2Rlcm5pemF0aW9uIGhhcyBiZWNvbWUgdGhlIGZvY3VzIG9mIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCB3b3JrIGluIHZhcmlvdXMgcmVnaW9ucy4gVGFraW5nIHRoZSBhZ3JpY3VsdHVyYWwgZGV2ZWxvcG1lbnQgb2YgVGlhbndhIFNtYXJ0IEluZHVzdHJpYWwgUGFyayBpbiBTdXFpYW4gQ2l0eSwgSmlhbmdzdSBQcm92aW5jZSwgYXMgYW4gZXhhbXBsZSwgdGhpcyBwYXBlciBleHBsb3JlcyB0aGUgcG9zaXRpdmUgc2lnbmlmaWNhbmNlIGFuZCB2YWx1YWJsZSBleHBlcmllbmNlIHByb3ZpZGVkIGJ5IHRoZSBkZXZlbG9wbWVudCBvZiBzbWFydCBhZ3JpY3VsdHVyZSBpbiBTdXFpYW4gQ2l0eSBmb3IgdGhlIGVudGlyZSBhZ3JpY3VsdHVyYWwgZGV2ZWxvcG1lbnQgaW4gTm9ydGhlcm4gSmlhbmdzdSBQcm92aW5jZSB0aHJvdWdoIGZpZWxkIHN1cnZleXMgYW5kIHJlc2VhcmNoLgoKS2V5d29yZHM6IFNtYXJ0IEFncmljdWx0dXJlOyBSdXJhbCBSZXZpdGFsaXphdGlvbjsgVGlhbndhIFNtYXJ0IEluZHVzdHJpYWwgUGFyawoKVGhlIHJlcG9ydCBvZiB0aGUgMjB0aCBOYXRpb25hbCBDb25ncmVzcyBvZiB0aGUgQ29tbXVuaXN0IFBhcnR5IG9mIENoaW5hIGVtcGhhc2l6ZXM6IFdlIG11c3QgYWRoZXJlIHRvIHByaW9yaXRpemluZyBhZ3JpY3VsdHVyYWwgYW5kIHJ1cmFsIGRldmVsb3BtZW50LCBhbmQgbWFrZSBpbXBvcnRhbnQgZGVwbG95bWVudHMgZm9yIGNvbXByZWhlbnNpdmVseSBwcm9tb3RpbmcgcnVyYWwgcmV2aXRhbGl6YXRpb24sIGFjY2VsZXJhdGluZyB0aGUgY29uc3RydWN0aW9uIG9mIGEgc3Ryb25nIGFncmljdWx0dXJhbCBjb3VudHJ5LCBhbmQgY2xhcmlmeWluZyB0aGUgZ3JlYXQgZ29hbHMgZm9yIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBpbiB0aGUgbmV3IGVyYSBhbmQgbmV3IGpvdXJuZXksIHBvaW50aW5nIG91dCB0aGUgZGlyZWN0aW9uIGZvciB0aGUgbW9kZXJuaXphdGlvbiBvZiBydXJhbCBkZXZlbG9wbWVudCBpbiBDaGluYSBhbmQgdGhlIGZ1bmRhbWVudGFsIHdvcmsgdG8gZm9sbG93LiBJbiB0aGUgbmV3IGVyYSwgb25seSBieSBjb21iaW5pbmcgInRlY2hub2xvZ3kiIHdpdGggImFncmljdWx0dXJlLCIgZW1wb3dlcmluZyBhZ3JpY3VsdHVyZSB3aXRoIHRlY2hub2xvZ3ksIGFuZCBwcm9tb3RpbmcgdGhlIGRldmVsb3BtZW50IGFuZCBjb25zdHJ1Y3Rpb24gb2Ygc21hcnQgYWdyaWN1bHR1cmUgY2FuIHdlIHVsdGltYXRlbHkgYWNoaWV2ZSB0aGUgZWZmZWN0IG9mICIxKzE+Mi4iCgoxLiBUaGUgQ29uY2VwdCBhbmQgQ29ubm90YXRpb24gb2YgU21hcnQgQWdyaWN1bHR1cmUgIApTaW5jZSBhbmNpZW50IHRpbWVzLCBDaGluYSBoYXMgYmVlbiBhIGxhcmdlIGFncmljdWx0dXJhbCBjb3VudHJ5LCB3aXRoIGEgbGFyZ2UgcHJvcG9ydGlvbiBvZiBydXJhbCBwb3B1bGF0aW9uLCBhbmQgYWdyaWN1bHR1cmUgaGFzIHBsYXllZCBhIHNpZ25pZmljYW50IHJvbGUgaW4gdGhlIG5hdGlvbmFsIGVjb25vbXkuIFdpdGggdGhlIGVzdGFibGlzaG1lbnQgb2YgdGhlIFBlb3BsZSdzIFJlcHVibGljIG9mIENoaW5hIGFuZCB0aGUgZGV2ZWxvcG1lbnQgb2YgdGhlIHJlZm9ybSBhbmQgb3BlbmluZy11cCBwb2xpY3ksIHRoZSBDaGluZXNlIGVjb25vbXkgaGFzIHJhcGlkbHkgc29hcmVkLCB0aGUgdGVydGlhcnkgaW5kdXN0cnkgaGFzIHJpc2VuLCBhbmQgaGFzIGNvbnN0YW50bHkgaW1wYWN0ZWQgdGhlIG9sZCBlY29ub21pYyBzdHJ1Y3R1cmUuIFRoZSBwcm9wb3J0aW9uIG9mIGFncmljdWx0dXJhbCBlY29ub215IGhhcyBjb250aW51ZWQgdG8gZGVjbGluZSwgYW5kIHRoZSBtYWluIHNvY2lhbCBjb250cmFkaWN0aW9uIGhhcyBzaGlmdGVkIHRvIHRoZSBjb250cmFkaWN0aW9uIGJldHdlZW4gdGhlIHBlb3BsZSdzIGdyb3dpbmcgZGVtYW5kIGZvciBhIGJldHRlciBsaWZlIGFuZCB1bmJhbGFuY2VkIGFuZCBpbnN1ZmZpY2llbnQgZGV2ZWxvcG1lbnQuIEluIHJlc3BvbnNlLCBvbmx5IGJ5IGNvbnN0YW50bHkgaW1wcm92aW5nIHByb2R1Y3Rpdml0eSBhbmQgbGFib3IgZWZmaWNpZW5jeSBjYW4gd2UgZnVydGhlciBtZWV0IHRoZSBsaXZpbmcgbmVlZHMgb2YgdGhlIHBlb3BsZSBhbmQgYWNoaWV2ZSB0aGUgIlR3byBDZW50ZW5hcnkgR29hbHMuIiAgClNtYXJ0IGFncmljdWx0dXJlIHJlZmVycyB0byBpbnRlbGxpZ2VudCBhZ3JpY3VsdHVyYWwgdGVjaG5vbG9neSwgd2hpY2ggaW52b2x2ZXMgYSBzZXJpZXMgb2YgYWdyaWN1bHR1cmFsIHByb2R1Y3Rpb24gYWN0aXZpdGllcyBjYXJyaWVkIG91dCBieSBhZ3JpY3VsdHVyYWwgcHJvZHVjZXJzIHVzaW5nIEludGVybmV0IG9mIFRoaW5ncyAoSW9UKSB0ZWNobm9sb2dpZXMuIFRocm91Z2ggbW9iaWxlIHBob25lcywgY29tcHV0ZXJzLCBhbmQgb3RoZXIgZGV2aWNlcywgYWdyaWN1bHR1cmFsIHByb2R1Y3Rpb24gcHJvY2Vzc2VzIGFyZSBjb250cm9sbGVkIGFuZCBtb25pdG9yZWQsIGFsbG93aW5nIGZvciBwcmVjaXNpb24gbWFuYWdlbWVudCBvZiBhZ3JpY3VsdHVyYWwgcHJvZHVjdGlvbiBhbmQgdWx0aW1hdGVseSBvYnRhaW5pbmcgY29ycmVzcG9uZGluZyBwcm9kdWN0aW9uIGRhdGEuIEFzIGFuIGVtZXJnaW5nIGFncmljdWx0dXJhbCBwcm9kdWN0aW9uIGNvbmNlcHQgaW50ZWdyYXRlZCB3aXRoIElvVCB0ZWNobm9sb2d5LCB0aGUgZGV2ZWxvcG1lbnQgb2Ygc21hcnQgYWdyaWN1bHR1cmUgb2Z0ZW4gc2VydmVzIGFzIGFuIGltcG9ydGFudCByZWZlcmVuY2UgZm9yIHRoZSBsZXZlbCBvZiBhZ3JpY3VsdHVyYWwgZGV2ZWxvcG1lbnQgaW4gYSByZWdpb24uIFRoZSBkZWdyZWUgb2YgaW50ZWxsaWdlbmNlIGFuZCBtZWNoYW5pemF0aW9uIGluIGEgcmVnaW9uIGlzIG9mIGdyZWF0IGltcG9ydGFuY2UgaW4gYXNzZXNzaW5nIHRoZSBhZ3JpY3VsdHVyYWwgZGV2ZWxvcG1lbnQgc3RhdHVzIG9mIHRoYXQgYXJlYS4gIApBcyBhbiBpbXBvcnRhbnQgY29tcG9uZW50IG9mIHRoZSBzbWFydCBlY29ub215LCBzbWFydCBhZ3JpY3VsdHVyZSBmdWxseSB1dGlsaXplcyBtb2Rlcm4gaW5mb3JtYXRpb24gdGVjaG5vbG9neSB0byBzZXJ2ZSB0cmFkaXRpb25hbCBhZ3JpY3VsdHVyZSwgcHJvdmlkaW5nIHByZWNpc2UgcGxhbnRpbmcsIHZpc3VhbCBkeW5hbWljIG1vbml0b3JpbmcsIGFuZCBpbnRlbGxpZ2VudCBkZWNpc2lvbi1tYWtpbmcgZm9yIGFncmljdWx0dXJhbCBwcm9kdWN0aW9uLiBUaGUgZGV2ZWxvcG1lbnQgb2Ygc21hcnQgYWdyaWN1bHR1cmUgbm90IG9ubHkgYWRkcmVzc2VzIHJ1cmFsIGVtcGxveW1lbnQgaXNzdWVzIGJ1dCBhbHNvIGVmZmVjdGl2ZWx5IGltcHJvdmVzIHRoZSBhZ3JpY3VsdHVyYWwgZWNvbG9naWNhbCBlbnZpcm9ubWVudCwgZW5oYW5jZXMgYWdyaWN1bHR1cmFsIHByb2R1Y3Rpdml0eSwgYW5kIHJlc29sdmVzIHRoZSBpc3N1ZSBvZiBhIHNob3J0YWdlIG9mIGRyaXZpbmcgZm9yY2UgaW4gYWdyaWN1bHR1cmUuIFByb21vdGluZyBhZ3JpY3VsdHVyYWwgYW5kIHJ1cmFsIG1vZGVybml6YXRpb24gcmVxdWlyZXMgdGhlIGFzc2lzdGFuY2Ugb2Ygc21hcnQgYWdyaWN1bHR1cmUgYW5kIGlzIGEga2V5IHBhcnQgb2YgYWNjZWxlcmF0aW5nIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSBzdHJvbmcgYWdyaWN1bHR1cmFsIGNvdW50cnkuCgoyLiBPdmVydmlldyBvZiBSdXJhbCBEZXZlbG9wbWVudCBJc3N1ZXMgaW4gTm9ydGhlcm4gSmlhbmdzdSBhbmQgQW5hbHlzaXMgb2YgQ2F1c2VzICAKVGhlIE5vcnRoZXJuIEppYW5nc3UgcmVnaW9uIGlzIGxvY2F0ZWQgaW4gb25lIG9mIENoaW5hJ3MgdGhyZWUgbWFqb3IgcGxhaW5zIOKAlCB0aGUgbWlkZGxlIGFuZCBsb3dlciBZYW5ndHplIFJpdmVyIHBsYWluLiBJdCBiZW5lZml0cyBmcm9tIGl0cyBsb2NhdGlvbiBhbG9uZyB0aGUgcml2ZXIsIHdpdGggZmF2b3JhYmxlIGdlb2dyYXBoaWNhbCBjb25kaXRpb25zLCBhbmQgaXMga25vd24gYXMgdGhlICJHcmFuYXJ5IG9mIHRoZSBXb3JsZC4iIEhvd2V2ZXIsIHdpdGggdGhlIGFkdmFuY2VtZW50IG9mIHRpbWUsIHRoZSBhY2NlbGVyYXRpb24gb2YgdXJiYW5pemF0aW9uIGFjcm9zcyB0aGUgc29jaWV0eSwgYW5kIHRoZSBmdXJ0aGVyIGRldmVsb3BtZW50IG9mIHRoZSB0ZXJ0aWFyeSBpbmR1c3RyeSwgcGFydGljdWxhcmx5IGluIHRoZSBzb3V0aGVybiBKaWFuZ3N1IHJlZ2lvbiwgaGF2ZSBpbXBhY3RlZCB0aGUgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IGluIE5vcnRoZXJuIEppYW5nc3UuICAKMi4xIEFjY2VsZXJhdGVkIExvc3Mgb2YgUHJvZHVjdGl2aXR5IGFuZCBTZXZlcmUgUnVyYWwgSG9sbG93aW5nLiAgClNpbmNlIHRoZSByZWZvcm0gYW5kIG9wZW5pbmctdXAsIGVzcGVjaWFsbHkgd2l0aCB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNvY2lhbGlzdCBtYXJrZXQgZWNvbm9teSwgdGhlcmUgaGF2ZSBiZWVuIG1vcmUgZGV2ZWxvcG1lbnQgb3Bwb3J0dW5pdGllcyBhbmQgaW4uLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2Ugd3JpdGUgYW4gaW50cm9kdWN0aW9uIGNoYXB0ZXIgZm9yIGEgbWVkaWNhbCBpbWFnaW5nIGFuYWx5c2lzIHRoZXNpcywgd2l0aCBhIHdvcmQgY291bnQgcmVxdWlyZW1lbnQgb2YgMjAwMC0yNTAwIHdvcmRzLiBUaGUgZm9sbG93aW5nIGlzIHRoZSBtYWluIHRleHQgb2YgbXkgdGhlc2lzOiAqKlJlc2VhcmNoIFByb2dyZXNzIG9mIE1lZGljYWwgSW1hZ2UgQW5hbHlzaXMgQmFzZWQgb24gRGVlcCBDb252b2x1dGlvbmFsIE5ldHdvcmtzKioKCjEuIE92ZXJ2aWV3IG9mIERlZXAgQ29udm9sdXRpb25hbCBOZXVyYWwgTmV0d29ya3MgIApUaGUgaHVtYW4gYnJhaW4gaXMgdGhlIGluZm9ybWF0aW9uIHByb2Nlc3NpbmcgY2VudGVyLCBjb250cm9sbGluZyBodW1hbiBiZWhhdmlvciBhbmQgdGhvdWdodC4gVG8gc3R1ZHkgdGhlIHN0cnVjdHVyZSBhbmQgZnVuY3Rpb24gb2YgdGhlIGh1bWFuIGJyYWluJ3MgbmVydm91cyBzeXN0ZW0sIGJpb2xvZ2ljYWwgbmV1cmFsIG5ldHdvcmtzIHdlcmUgcHJvcG9zZWQuIEluc3BpcmVkIGJ5IHRoaXMsIGNvbXB1dGVyIHJlc2VhcmNoZXJzIGludHJvZHVjZWQgYXJ0aWZpY2lhbCBuZXVyYWwgbmV0d29ya3MgdG8gc2ltdWxhdGUgdGhlIHN0cnVjdHVyZSBhbmQgZnVuY3Rpb25pbmcgb2YgdGhlIGh1bWFuIGJyYWlu4oCZcyBuZXJ2b3VzIHN5c3RlbS4gIApGcm9tIGFuIGluZm9ybWF0aW9uIHByb2Nlc3NpbmcgcGVyc3BlY3RpdmUsIGFuIGFydGlmaWNpYWwgbmV1cmFsIG5ldHdvcmsgaXMgYSBjb21wbGV4IG1hdGhlbWF0aWNhbCBtb2RlbCB0aGF0IGNvbm5lY3RzIGEgbGFyZ2UgbnVtYmVyIG9mIG1hdGhlbWF0aWNhbCBmdW5jdGlvbnMgaW4gdGhlIGZvcm0gb2YgbmV1cm9ucy4gVGhlIHRyYW5zbWlzc2lvbiBvZiBpbmZvcm1hdGlvbiBiZXR3ZWVuIG5ldXJvbnMgaXMgc2ltaWxhciB0byB0aGUgdHJhbnNmZXIgb2YgaG9ybW9uZXMgYmV0d2VlbiBhZGphY2VudCBuZXJ2ZSBjZWxscyBpbiB0aGUgYnJhaW4uIFRoZSBudW1iZXIgb2YgbmV1cm9ucywgdGhlIGNvbm5lY3Rpb24gbWV0aG9kLCBpbnRlcm5hbCBwYXJhbWV0ZXJzLCBhbmQgYWN0aXZhdGlvbiBmdW5jdGlvbnMgZGlmZmVyIHRvIGZvcm0gdmFyaW91cyBuZXVyYWwgbmV0d29yayBzdHJ1Y3R1cmVzLiBUaGUgc2ltcGxlc3QgdHlwZSBvZiBhcnRpZmljaWFsIG5ldXJhbCBuZXR3b3JrIGlzIGNhbGxlZCBhIHNpbmdsZS1sYXllciBwZXJjZXB0cm9uLCBjb25zaXN0aW5nIG9mIG9uZSBpbnB1dCBsYXllciwgb25lIGhpZGRlbiBsYXllciwgYW5kIG9uZSBvdXRwdXQgbGF5ZXIsIGFzIHNob3duIGluIEZpZ3VyZSAxLiBCZWNhdXNlIHRoaXMgc3RydWN0dXJlIGlzIHRvbyBzaW1wbGUgdG8gaGFuZGxlIGNvbXBsZXggY29tcHV0YXRpb25zLCBpdHMgYXBwbGljYXRpb24gaXMgbGltaXRlZC4gIApNdWx0aWxheWVyIG5ldXJhbCBuZXR3b3JrcywgYWxzbyBrbm93biBhcyBtdWx0aS1sYXllciBwZXJjZXB0cm9ucyAoTUxQKSwgaGF2ZSBtdWx0aXBsZSBoaWRkZW4gbGF5ZXJzIGFuZCBhcmUgdmFsdWFibGUgYXJ0aWZpY2lhbCBuZXVyYWwgbmV0d29ya3MgZm9yIHByYWN0aWNhbCBhcHBsaWNhdGlvbnMuIFRoZSBtb3N0IHR5cGljYWwgbXVsdGlsYXllciBuZXVyYWwgbmV0d29yayBtb2RlbCBpcyB0aGUgYmFja3Byb3BhZ2F0aW9uIChCUCkgbmV1cmFsIG5ldHdvcmsgaW52ZW50ZWQgYnkgUnVtZWxoYXJ0IGV0IGFsLiAgCgpGaWd1cmUgMTogU2luZ2xlLUxheWVyIE5ldXJvbiBTdHJ1Y3R1cmUgIAoKV2l0aCB0aGUgYWR2YW5jZW1lbnQgb2YgY29tcHV0ZXIgcG93ZXIgYW5kIG1hdGhlbWF0aWNhbCBsb2dpYywgbXVsdGlsYXllciBuZXVyYWwgbmV0d29yayBzdHJ1Y3R1cmVzIGhhdmUgYmVjb21lIGluY3JlYXNpbmdseSBjb21wbGV4IGFuZCBkaXZlcnNlLiBEZWVwIGxlYXJuaW5nIGFsZ29yaXRobXMgcmVwcmVzZW50ZWQgYnkgQ05OcyBmdXJ0aGVyIGV4cGFuZCB0aGUgZGVwdGggYW5kIGJyZWFkdGggb2YgY29tcHV0ZXIgYWxnb3JpdGhtcyBzaW11bGF0aW5nIGh1bWFuIGNvZ25pdGl2ZSBkb21haW5zLiBBcyBzaG93biBpbiBGaWd1cmUgMiwgYSB0eXBpY2FsIENOTiBzdHJ1Y3R1cmUgY29uc2lzdHMgb2Ygb25lIGlucHV0IGxheWVyLCBvbmUgb3V0cHV0IGxheWVyLCBzZXZlcmFsIGNvbnZvbHV0aW9uYWwgbGF5ZXJzLCBwb29saW5nIGxheWVycywgYW5kIGZ1bGx5IGNvbm5lY3RlZCBsYXllcnMuIFRoaXMgbmV0d29yayBzdHJ1Y3R1cmUgcGVyZm9ybXMgYmV0dGVyIHRoYW4gdHJhZGl0aW9uYWwgbXVsdGlsYXllciBuZXVyYWwgbmV0d29ya3MgaW4gY29tcHV0ZXIgdmlzaW9uIHRhc2tzIGJlY2F1c2UgY29udm9sdXRpb25hbCBsYXllcnMgYW5kIHBvb2xpbmcgbGF5ZXJzIGNhbiByZWR1Y2UgdGhlIG51bWJlciBvZiB3ZWlnaHQgcGFyYW1ldGVycyB0aGF0IG5lZWQgdG8gYmUgdHJhaW5lZCBieSB1c2luZyBwYXJhbWV0ZXIgc2hhcmluZyBhbmQgcGFydGlhbCBkaXNjYXJkaW5nIG1ldGhvZHMuIFRoaXMgcmVkdWNlcyBuZXR3b3JrIGNvbXBsZXhpdHksIGVhc2VzIHRoZSBjb21wdXRhdGlvbmFsIGxvYWQsIGFuZCBlbmFibGVzIENOTnMgd2l0aCB0aGUgc2FtZSBkZXB0aCB0byBoYXZlIHN0cm9uZ2VyIGRhdGEgcHJvY2Vzc2luZyBhbmQgZmVhdHVyZSBleHRyYWN0aW9uIGNhcGFiaWxpdGllcyB0aGFuIG11bHRpLWxheWVyIHBlcmNlcHRyb25zLiAgCkdlbmVyYXRpdmUgQWR2ZXJzYXJpYWwgTmV0d29ya3MgKEdBTnMpIGFyZSB0aGUgbW9zdCB3aWRlbHkgYXBwbGllZCBjb252b2x1dGlvbmFsIG5ldXJhbCBuZXR3b3JrcyBpbiByZWNlbnQgeWVhcnMuIFVubGlrZSBjbGFzc2ljIENOTiBtb2RlbHMgc3VjaCBhcyBBbGV4TmV0LCBWR0csIGFuZCBSZXNOZXQsIEdBTiBjb25zaXN0cyBvZiB0d28gaW5kZXBlbmRlbnQgbmV0d29yayBtb2RlbHM6IGEgZ2VuZXJhdG9yIGFuZCBhIGRpc2NyaW1pbmF0b3IsIGFzIHNob3duIGluIEZpZ3VyZSAzLiBJbiBtb3N0IGNhc2VzLCBib3RoIHRoZSBnZW5lcmF0b3IgYW5kIGRpc2NyaW1pbmF0b3IgYXJlIGltcGxlbWVudGVkIHdpdGggQ05Ocy4gVGhleSBhY3QgbGlrZSBhZHZlcnNhcmllczogYm90aCBpbmRlcGVuZGVudCBhbmQgY29tcGxlbWVudGFyeSwgY29tcGV0aW5nIHdpdGggZWFjaCBvdGhlciBhbmQgZW5oYW5jaW5nIGVhY2ggb3RoZXIncyBwZXJmb3JtYW5jZS4gIApUaGUgR0FOLCBjb25zaXN0aW5nIG9mIHR3byBtb2RlbHMsIGluaGVyZW50bHkgaGFzIHNlbGYtZGlzY3JpbWluYXRpb24sIHNlbGYtb3B0aW1pemF0aW9uLCBhbmQgc3Ryb25nIGdlbmVyYWxpemF0aW9uIGFiaWxpdGllcywgYWNoaWV2aW5nIGdvb2QgcmVzdWx0cyBpbiBpbWFnZSByZWNvbnN0cnVjdGlvbiBhbmQgZ2VuZXJhdGlvbi4gRnVydGhlcm1vcmUsIGltcHJvdmVkIEdBTiBtb2RlbHMgc3VjaCBhcyBDb25kaXRpb25hbCBHZW5lcmF0aXZlIEFkdmVyc2FyaWFsIE5ldHdvcmtzIChDR0FOKSBhbmQgQ3ljbGUgR2VuZXJhdGl2ZSBBZHZlcnNhcmlhbCBOZXR3b3JrcyAoQ3ljbGUgR0FOKSBwcm92aWRlIG5ldyBzb2x1dGlvbnMgZm9yIGNvbXBsZXggY29tcHV0ZXIgdmlzaW9uIHRhc2tzLgoKMi4gQXBwbGljYXRpb25zIG9mIENOTnMgaW4gTWVkaWNhbCBJbWFnZSBQcm9jZXNzaW5nICAKMi4xIEltYWdlIFNlZ21lbnRhdGlvbiAgCkltYWdlIHNlZ21lbnRhdGlvbiBpbnZvbHZlcyBkaXZpZGluZyB0aGUgdGFyZ2V0IGltYWdlIGludG8gcmVnaW9ucyBvZiBpbnRlcmVzdCwgc3VjaCBhcyBkaXNlYXNlZCBvcmdhbnMsIHRpc3N1ZXMsIGFuZCB0dW1vcnMuIE1vc3QgbWVkaWNhbCBpbWFnZXMgYXJlIGdyYXlzY2FsZSwgYW5kIHRoZXkgb2Z0ZW4gc3VmZmVyIGZyb20gdW5ldmVuIGdyYXlzY2FsZSBkaXN0cmlidXRpb24sIHNpZ25pZmljYW50IG5vaXNlLCBhbmQgdW5jbGVhciBvciBjaGFuZ2luZyBib3VuZGFyaWVzIG9mIHRpc3N1ZXMgYW5kIG9yZ2FucywgbWFraW5nIHRoZW0gZGlmZmljdWx0IHRvIGludGVycHJldCBhbmQgdW5kZXJzdGFuZCBmb3Igbm9uLXByb2Zlc3Npb25hbHMuIFRyYWRpdGlvbmFsIGltYWdlIHNlZ21lbnRhdGlvbiBtZXRob2RzIHByaW1hcmlseSB1c2UgbG9jYWwgcGh5c2ljYWwgZmVhdHVyZXMgc3VjaCBhcyBjb2xvciwgdGV4dHVyZSwgYW5kIG1vcnBob2xvZ3kgZm9yIHJlZ2lvbi1iYXNlZCBhbmQgYm91bmRhcnktYmFzZWQgc2VnbWVudGF0aW9uLiBDb21tb24gbWV0aG9kcyBpbmNsdWRlIGNsdXN0ZXJpbmcgYWxnb3JpdGhtcyBpbiB0cmFkaXRpb25hbCBtYWNoaW5lIGxlYXJuaW5nLCBzdWNoIGFzIGZ1enp5IEMtbWVhbnMgKEZDTSkgZm9yIG1hZ25ldGljIHJlc29uYW5jZSBpbWFnZSAoTVJJKSBzZWdtZW50YXRpb24sIEstbWVhbnMgY2x1c3RlcmluZyBhbmQgV2F0ZXJzaGVkIGFsZ29yaXRobXMgZm9yIGltYWdlIHNlZ21lbnRhdGlvbiwgYW5kIFN1cHBvcnQgVmVjdG9yIE1hY2hpbmUgKFNWTSktYmFzZWQgaW1hZ2Ugc2VnbWVudGF0aW9uLCBhbW9uZyBvdGhlcnMuIFRoZXNlIG1ldGhvZHMgbWFpbmx5IHV0aWxpemUgbG9jYWwgcGh5c2ljYWwgaW5mb3JtYXRpb24gYW5kIGRvIG5vdCBmdWxseSB1dGlsaXplIHRoZSBzZW1hbnRpYyBpbmZvcm1hdGlvbiBjb250YWluZWQgaW4gdGhlIGltYWdlIGl0c2VsZi4KCkZpZ3VyZSAyOiBUeXBpY2FsIENvbnZvbHV0aW9uYWwgTmV1cmFsIE5ldHdvcmsgU3RydWN0dXJlICAKRmlndXJlIDM6IEJhc2ljIEZyYW1ld29yayBvZiBHZW5lcmF0aXZlIEFkdmVyc2FyaWFsIE5ldHdvcmtzICAKCkNOTnMsIHdpdGggdGhlaXIgbXVsdGktbm9kZSBhbmQgbXVsdGktbGF5ZXJlZCBzdHJ1Y3R1cmUsIGhhdmUgdGhlIGFiaWxpdHkgdG8gYXV0b21hdGljYWxseSBleHRyYWN0IGRlZXAgZmVhdHVyZXMgZnJvbSBpbnB1dCBkYXRhLCBtYWtpbmcgdGhlbSBtb3JlIHN1aXRhYmxlIGZvciBpbWFnZSBjbGFzc2lmaWNhdGlvbiBvciByZWdyZXNzaW9uIHRhc2tzLiBUaGFua3MgdG8gdGhlIGFkdmVudCBvZiBGdWxseSBDb252b2x1dGlvbmFsIE5ldHdvcmtzIChGQ05zKSwgaW1hZ2Ugc2VnbWVudGF0aW9uIHRhc2tzIGhhdmUgZm91bmQgbmV3IHNvbHV0aW9ucy4gRkNOcyByZXBsYWNlIHRoZSBmaW5hbCBmdWxseSBjb25uZWN0ZWQgbGF5ZXJzIG9mIHRoZSBjbGFzc2ljYWwgQ05OIG1vLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgd3JpdGUgYSB0ZWNobmljYWwgcG9kY2FzdCAoMTAwMOKAkzIwMDAgd29yZHMpIGludHJvZHVjaW5nIHRoZSBtYWluIGNvbnRyaWJ1dGlvbnMgb2YgdGhlIEFwYWNoZSBQT0kgb3Blbi1zb3VyY2UgdGVjaG5vbG9neSBsaWJyYXJ5Lgp1c2VyOgoqKlNpbXVsYXRpb24gTW9kZWwgRGVzaWduIGFuZCBDb25uZWN0aXZpdHkgUmVhbGl6YXRpb24gb2YgRGlnaXRhbCBUd2luIGluIFNtYXJ0IEZhY3RvcnkqKgoKQWJzdHJhY3Q6IEJhc2VkIG9uIHRoZSBkaXNjcmV0ZSBtYW51ZmFjdHVyaW5nIHNtYXJ0IGZhY3RvcnkgZXhwZXJpbWVudGFsIHBsYXRmb3JtLCB0aGlzIHBhcGVyIGRlZXBseSBhbmFseXplcyBpdHMgc3lzdGVtIGFyY2hpdGVjdHVyZS4gSXQgdXNlcyBGbGV4U2ltIDNEIG1vZGVsaW5nIHRlY2hub2xvZ3kgdG8gYnVpbGQgYSB2aXJ0dWFsIGltYWdlIG9mIHRoZSBzbWFydCBmYWN0b3J5LCBhbmQgYWNoaWV2ZXMgcmVhbC10aW1lIGluZm9ybWF0aW9uIGZsb3cgYW5kIGJpZGlyZWN0aW9uYWwgaW50ZXJhY3Rpb24gYmV0d2VlbiB0aGUgcGh5c2ljYWwgZW50aXR5IGFuZCB0aGUgdmlydHVhbCBtb2RlbCB0aHJvdWdoIGEgU29ja2V0IGNvbW11bmljYXRpb24gbWVjaGFuaXNtLiBUaGUgZGlnaXRhbCB0d2luIHN5c3RlbSBvZiB0aGUgc21hcnQgZmFjdG9yeSBpcyBzdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQsIHByb3ZpZGluZyBpbm5vdmF0aXZlIGlkZWFzIGFuZCBlbXBpcmljYWwgcmVmZXJlbmNlcyBmb3IgZGlnaXRhbCB0d2luIHByYWN0aWNlcy4KCkZ1bmQ6IE5pbmdibyBDaXR5ICJTY2llbmNlIGFuZCBUZWNobm9sb2d5IElubm92YXRpb24gWW9uZ2ppYW5nIDIwMzUiIE1ham9yIEFwcGxpY2F0aW9uIERlbW9uc3RyYXRpb24gUGxhbiDigJQgUmVzZWFyY2ggYW5kIEFwcGxpY2F0aW9uIG9mIHRoZSBDb21tYW5kIGFuZCBEaXNwYXRjaCBEZWNpc2lvbi1NYWtpbmcgU3lzdGVtIEJhc2VkIG9uIERpZ2l0YWwgVHdpbiBQbGF0Zm9ybSBmb3IgTW9sZCBJbmR1c3RyaWFsIFBhcmsgKFByb2plY3QgTm86IDIwMjRaMDA3KQoKS2V5d29yZHM6IFNtYXJ0IGZhY3Rvcnk7IGRpZ2l0YWwgdHdpbiBzaW11bGF0aW9uIHRlY2hub2xvZ3kKCkludHJvZHVjdGlvbjogSW4gcmVjZW50IHllYXJzLCB3aXRoIHRoZSBjb250aW51b3VzIGRldmVsb3BtZW50IG9mIHByb2R1Y3Rpdml0eSwgQ2hpbmHigJlzIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkgaGFzIGdyYWR1YWxseSB0cmFuc2Zvcm1lZCBmcm9tIHRyYWRpdGlvbmFsIG1hbnVmYWN0dXJpbmcgdG8gaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZy4gSW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBoYXMgYmVjb21lIGFuIGltcG9ydGFudCBwYXRoIHRvIGxlYWQgdGhlIHVwZ3JhZGluZyBhbmQgZGV2ZWxvcG1lbnQgb2YgdGhlIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkuIEludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgaXMgbm90IG9ubHkgdGhlIGVuZ2luZSBmb3IgdGhlIHRyYW5zZm9ybWF0aW9uIGFuZCB1cGdyYWRpbmcgb2YgdGhlIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkgYnV0IGFsc28gdGhlIGtleSB0byBwcm9tb3RpbmcgaGlnaC1xdWFsaXR5IGVjb25vbWljIGRldmVsb3BtZW50LiBCeSBpbnRyb2R1Y2luZyBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHRlY2hub2xvZ3ksIENoaW5h4oCZcyBtYW51ZmFjdHVyaW5nIGluZHVzdHJ5IGNhbiBhY2hpZXZlIGEgZnVuZGFtZW50YWwgY2hhbmdlIGluIHRoZSBtb2RlIG9mIHByb2R1Y3Rpb24sIHRyYW5zZm9ybWluZyBmcm9tIGxhYm9yLWludGVuc2l2ZSB0byB0ZWNobm9sb2d5LWludGVuc2l2ZSwgaW1wcm92aW5nIHRoZSBjb3JlIGNvbXBldGl0aXZlbmVzcyBhbmQgaW50ZXJuYXRpb25hbCBzdGF0dXMgb2YgdGhlIGluZHVzdHJ5LiBBdCB0aGUgc2FtZSB0aW1lLCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHByb21vdGVzIHRoZSBkZWVwIGludGVncmF0aW9uIG9mIG1hbnVmYWN0dXJpbmcgYW5kIGluZm9ybWF0aW9uIHRlY2hub2xvZ3ksIGRyaXZpbmcgdGhlIGVtZXJnZW5jZSBvZiBuZXcgYnVzaW5lc3MgZm9ybXMgYW5kIG1vZGVscywgaW5qZWN0aW5nIG5ldyB2aXRhbGl0eSBpbnRvIGVjb25vbWljIGRldmVsb3BtZW50LiBJbiBzbWFydCBtYW51ZmFjdHVyaW5nLCB0aGUgZGlnaXRhbCB0d2luIHNpbXVsYXRpb24gdGVjaG5vbG9neSBvZiBzbWFydCBmYWN0b3JpZXMgaXMgcGxheWluZyBhbiBpbmNyZWFzaW5nbHkgaW1wb3J0YW50IHJvbGUuIFRoZSBkaWdpdGFsIHR3aW4gc2ltdWxhdGlvbiB0ZWNobm9sb2d5IG9mIHRoZSBzbWFydCBmYWN0b3J5IGNhbiBhY2hpZXZlIGRlZXAgaW50ZWdyYXRpb24gYW5kIGFjY3VyYXRlIG1hcHBpbmcgYmV0d2VlbiB0aGUgcGh5c2ljYWwgd29ybGQgYW5kIHRoZSB2aXJ0dWFsIHdvcmxkLiBJdCBub3Qgb25seSBzaW11bGF0ZXMgcHJvZHVjdGlvbiBwcm9jZXNzZXMsIGVxdWlwbWVudCBvcGVyYXRpb24sIGFuZCBwcm9kdWN0aW9uIGxpbmUgb3B0aW1pemF0aW9uIGluIGFkdmFuY2UgdG8gZWZmZWN0aXZlbHkgYXZvaWQgcmlza3MgYW5kIGNvc3Qgd2FzdGUgaW4gYWN0dWFsIG9wZXJhdGlvbnMgYnV0IGFsc28gY29uZHVjdHMgY291bnRsZXNzIGl0ZXJhdGlvbnMgaW4gdGhlIHZpcnR1YWwgZW52aXJvbm1lbnQsIGFjY2VsZXJhdGluZyBwcm9kdWN0IGlubm92YXRpb24gY3ljbGVzLCBwcm92aWRpbmcgZGVjaXNpb24gc3VwcG9ydCBmb3IgbWFuYWdlcnMsIG9wdGltaXppbmcgcmVzb3VyY2UgYWxsb2NhdGlvbiwgYW5kIGltcHJvdmluZyBwcm9kdWN0aW9uIGVmZmljaWVuY3kgYW5kIGZsZXhpYmlsaXR5LiBJbiBjb25jbHVzaW9uLCB0aGUgZGlnaXRhbCB0d2luIHNpbXVsYXRpb24gdGVjaG5vbG9neSBvZiBzbWFydCBmYWN0b3JpZXMgaXMgYSBrZXkgZm9yY2UgaW4gZHJpdmluZyB0aGUgdHJhbnNmb3JtYXRpb24gb2YgbWFudWZhY3R1cmluZyB0byBpbnRlbGxpZ2VudCBhbmQgZWZmaWNpZW50IHN5c3RlbXMuCgoxLiBDb3JlIENvbXBvbmVudHMgb2YgRGlnaXRhbCBUd2luICAKSW4gdGhlIGN1cnJlbnQgd2F2ZSBvZiBpbmR1c3RyaWFsIHRyYW5zZm9ybWF0aW9uIGFuZCB1cGdyYWRpbmcsIHNtYXJ0IGZhY3RvcmllcyBhbmQgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBhcmUgbGVhZGluZyBwcm9mb3VuZCBjaGFuZ2VzIGluIHRoZSBpbmR1c3RyaWFsIHNlY3Rvci4gQXMgYSBtb2RlbCBvZiB0aGUgZnVzaW9uIG9mIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkgbWFuYWdlbWVudCB3aXNkb20gYW5kIGFkdmFuY2VkIHRlY2hub2xvZ3ksIHNtYXJ0IGZhY3RvcmllcyByZWx5IG9uIGZyb250aWVyIHRlY2hub2xvZ2llcyBzdWNoIGFzIHRoZSBJbnRlcm5ldCBvZiBUaGluZ3MsIGF1dG9tYXRpb24sIG5ldHdvcmsgY29tbXVuaWNhdGlvbiwgYW5kIGFydGlmaWNpYWwgaW50ZWxsaWdlbmNlIHRvIGJ1aWxkIGEgaGlnaGx5IGludGVncmF0ZWQgZWNvc3lzdGVtIG9mIHBlb3BsZSwgbWFjaGluZXMsIG1hdGVyaWFscywgYW5kIHRoZSBlbnZpcm9ubWVudC4gVGhpcyBzeXN0ZW0gbm90IG9ubHkgYWNoaWV2ZXMgaW50ZWdyYXRpb24gb2YgcHJvZHVjdGlvbiBhbmQgbWFuYWdlbWVudCBidXQgYWxzbyBsYXlzIGEgc29saWQgZm91bmRhdGlvbiBmb3IgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIHNtYXJ0IHN1cHBseSBjaGFpbi4gSG93ZXZlciwgdGhlIGVmZmljaWVudCBvcGVyYXRpb24gYW5kIG1hbmFnZW1lbnQgb2Ygc21hcnQgZmFjdG9yaWVzIHJlbHkgb24gdGhlIGRlZXAgaW52b2x2ZW1lbnQgb2Ygc2ltdWxhdGlvbiB0ZWNobm9sb2d5IHRvIGV2YWx1YXRlIGFuZCBvcHRpbWl6ZSB0aGVpciBjb21wbGV4IHN5c3RlbXMuIFRoZSBsaW1pdGF0aW9uIG9mIHRyYWRpdGlvbmFsIHNpbXVsYXRpb24gdGVjaG5vbG9neSBsaWVzIGluIGl0cyAib2ZmbGluZSIgbmF0dXJlLCB3aGljaCBtYWtlcyBpdCBkaWZmaWN1bHQgdG8gcmVmbGVjdCB0aGUgZHluYW1pYyBjaGFuZ2VzIG9mIHRoZSBwaHlzaWNhbCBzeXN0ZW0gaW4gcmVhbC10aW1lIGFuZCBmYWlscyB0byBtZWV0IHRoZSByZWFsLXRpbWUgbW9uaXRvcmluZyBhbmQgcHJlY2lzZSBkZWNpc2lvbi1tYWtpbmcgbmVlZHMgb2Ygc21hcnQgZmFjdG9yaWVzLgoKQWdhaW5zdCB0aGlzIGJhY2tncm91bmQsIGRpZ2l0YWwgdHdpbiB0ZWNobm9sb2d5IGVtZXJnZWQgYXMgYSBrZXkgZm9yY2UgZHJpdmluZyB0aGUgZGV2ZWxvcG1lbnQgb2Ygc21hcnQgZmFjdG9yaWVzIGFuZCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nLiBEaWdpdGFsIHR3aW5zIGNyZWF0ZSBhbiBhY2N1cmF0ZSB2aXJ0dWFsIGltYWdlIG9mIHRoZSBwaHlzaWNhbCBlbnRpdHksIGVuYWJsaW5nIHNlYW1sZXNzIGludGVncmF0aW9uIGFuZCByZWFsLXRpbWUgaW50ZXJhY3Rpb24gYmV0d2VlbiB0aGUgcGh5c2ljYWwgd29ybGQgYW5kIHRoZSBkaWdpdGFsIHdvcmxkLiBBIGRpZ2l0YWwgdHdpbiBjb25zaXN0cyBvZiB0aHJlZSBtYWluIHBhcnRzOiB0aGUgcGh5c2ljYWwgZW50aXR5IGluIHRoZSBwaHlzaWNhbCBzcGFjZSwgdGhlIHZpcnR1YWwgZW50aXR5IGluIHRoZSB2aXJ0dWFsIHNwYWNlLCBhbmQgdGhlIGRhdGEgYW5kIGluZm9ybWF0aW9uIGV4Y2hhbmdlIGludGVyZmFjZSBiZXR3ZWVuIHRoZSBwaHlzaWNhbCBhbmQgdmlydHVhbCBzcGFjZXMuIERpZ2l0YWwgdHdpbnMgY2FuIG5vdCBvbmx5IHJlY2VpdmUgcmVhbC10aW1lIGRhdGEgZnJvbSBwaHlzaWNhbCBlbnRpdGllcyB0byBkcml2ZSBzaW11bGF0aW9uIGFuZCBkeW5hbWljIGFkanVzdG1lbnRzIG9mIHZpcnR1YWwgbW9kZWxzIGJ1dCBhbHNvIGZlZWQgYmFjayBvcHRpbWl6YXRpb24gc3RyYXRlZ2llcyBmcm9tIHRoZSB2aXJ0dWFsIHdvcmxkIHRvIHRoZSBwaHlzaWNhbCB3b3JsZCwgZ3VpZGluZyB0aGUgcHJlY2lzZSBleGVjdXRpb24gb2YgYWN0dWFsIHByb2R1Y3Rpb24gcHJvY2Vzc2VzLiBUaGUgY29yZSBvZiBkaWdpdGFsIHR3aW5zIGxpZXMgaW4gdGhlaXIgYmlkaXJlY3Rpb25hbCBkeW5hbWljIG1hcHBpbmcgYW5kIGludGVyYWN0aW9uIG1lY2hhbmlzbXMsIHdoaWNoIGJyZWFrIGRvd24gdGhlIGJvdW5kYXJpZXMgYmV0d2VlbiB0aGUgcGh5c2ljYWwgYW5kIGRpZ2l0YWwgd29ybGRzLCBjcmVhdGluZyBhIGNsb3NlZC1sb29wIGNvbnRyb2wgc3lzdGVtIGZvciBjb21wcmVoZW5zaXZlIHBlcmNlcHRpb24sIHJlYWwtdGltZSBhbmFseXNpcywgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nLCBhbmQgcHJlY2lzZSBleGVjdXRpb24uIFRocm91Z2ggdGhlIGRlZXAgaW50ZWdyYXRpb24gb2YgcGh5cy4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CkkgYW0gd3JpdGluZyBhIHJlcG9ydCBvbiBhbiBvcHRpY2FsIGZpYmVyIGNvbW11bmljYXRpb24gZXhwZXJpbWVudC4gQ291bGQgeW91IHBsZWFzZSBoZWxwIG1lIHdyaXRlIHRoZSB0aGVvcnkgc2VjdGlvbj8gVXNlIHNpbXBsZSBsYW5ndWFnZSB0byBleHBsYWluIHRoZSB0aGVvcnkgb2Ygb3B0aWNhbCBmaWJlciBjb21tdW5pY2F0aW9uLiBUaGUgbGVuZ3RoIHNob3VsZCBiZSBiZXR3ZWVuIDEwMDAgYW5kIDE1MDAgd29yZHMuIFRoZSBrZXkgdG9waWNzIHRvIGJlIGNvdmVyZWQgaW5jbHVkZTogdGhlIGJhc2ljIHByaW5jaXBsZXMgb2Ygb3B0aWNhbCBmaWJlciBjb21tdW5pY2F0aW9uLCB0aGUgdHJhbnNtaXNzaW9uIGNoYXJhY3RlcmlzdGljcyBvZiBvcHRpY2FsIGZpYmVycywgc2lnbmFsIG1vZHVsYXRpb24gYW5kIGRlbW9kdWxhdGlvbiBtZXRob2RzLCBhbmQgY29yZSBjb25jZXB0cyBzdWNoIGFzIGZpYmVyIGxvc3MgYW5kIGRpc3BlcnNpb24uCnVzZXI6CuaIkeimgeWGmeS4gOevh+OAiuaVsOWtl+WtqueUn+aKgOacr+WcqOaZuuiDveWItumAoOS4reeahOW6lOeUqOeglOeptuOAi++8jOivt+agueaNruaJgOaPkOS+m+eahOWPguiAg+iuuuaWh+ebuOWFs+i1hOaWmee7k+WQiOS7peS4i+ivpue7huimgeaxguW4ruaIkeWGmeebuOWFs+W3peS9nOmDqOWIhuOAggog5YaF5a6557uT5p6E6KaB5rGC77yaCi0g5qaC6L+w5pWw5a2X5a2q55Sf5oqA5pyv55qE5Y+R5bGV5Y6G56iL5ZKM5Z+65pys5qaC5b+1Ci0g57O757uf5qKz55CG5pm66IO95Yi26YCg6aKG5Z+f5pWw5a2X5a2q55Sf55qE5Li76KaB5bqU55So5Zy65pmvCi0g6YeN54K55YiG5p6Q5bel56iL5a6e6Le15Lit55qE5YWz6ZSu5oqA5pyv6Zq+54K5Ci0g6K+m57uG6K6o6K6655uu5YmN5bel56iL6JC95Zyw6Z2i5Li055qE5Li76KaB5oyR5oiY77yI5oqA5pyv44CB5oiQ5pys44CB5qCH5YeG5YyW562J5pa56Z2i77yJCi0g5a+55pyq5p2l5Y+R5bGV6LaL5Yq/6L+b6KGM5bGV5pybCgrmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnovkuI7lhbPplK7mioDmnK/noJTnqbYgIOm9kOWkqeazkyDvvIwg6buE5rW35bOwIO+8jCDmm7nkuZAg77yMIOW8oOeskeeruSAgIOWMl+S6rOenkeaKgOWkp+WtpiAg77yMICDkuK3lm73nlLXnp5HlpKfmlbDmja7noJTnqbbpmaLmnInpmZDlhazlj7ggIO+8jCAg5aSq5p6B6K6h566X5py66IKh5Lu95pyJ6ZmQ5YWs5Y+4ICAg5pGY6KaB77ya5Li65o6o5Yqo5Yi26YCg5Lia5pWw5a2X5YyW44CB5pm66IO95YyW6L2s5Z6L5Y2H57qn77yM5o+Q5Ye65pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6L77yM5YyF5ZCr5qaC5b+15qih5Z6L6KaB5rGC44CB5qaC5b+15qih5Z6L5p625p6E44CB5qaC5b+15qih5Z6L5YeG56Gu5oCn5ZKM5Y+v6Z2g5oCn5L+d6Zqc5pa55rOVNOS4que7tOW6pu+8jOWcqOivpeamguW/teaooeWei+WfuuehgOS4iuS7i+e7jeS6huaZuuiDveWItumAoOaVsOWtl+WtqueUn+aKgOacr+aetuaehO+8jOWIhuaekOS6huaVsOWtl+WtqueUn+W7uuaooeOAgeS7v+ecn+WSjOaVsOaNruWIhuaekOetieWFs+mUruaKgOacr++8jOW5tuWvueacquadpeaKgOacr+WPkeWxlei/m+ihjOS6huWxleacm+OAgiAg5YWz6ZSu6K+N77ya5pm66IO95Yi26YCgO+amguW/teaooeWeizvmlbDlrZflrarnlJ/lrp7kvZMgIOaUtueov+aXpeacn++8mjIwMjQtMDMtMjkgIFJlc2VhcmNoIG9uIEludGVsbGlnZW50IE1hbnVmYWN0dXJpbmcgRGlnaXRhbCBUd2luIENvbmNlcHR1YWwgTW9kZWwgYW5kIEtleSBUZWNobm9sb2dpZXMgIEFic3RyYWN077yaVG8gcHJvbW90ZSB0aGUgZGlnaXRhbCB0cmFuc2Zvcm1hdGlvbiBhbmQgdXBncmFkaW5nIG9mIHNtYXJ0IG1hbnVmYWN0dXJpbmcsYSBjb25jZXB0dWFsIG1vZGVsIG9mIHRoZSBkaWdpdGFsIHR3aW4gZm9yIHNtYXJ0IG1hbnVmYWN0dXJpbmcgaXMgcHJvcG9zZWQuSXQgaW5jbHVkZXMgZm91ciBkaW1lbnNpb25zOnJlcXVpcmVtZW50cyBvZiB0aGUgY29uY2VwdHVhbCBtb2RlbCxhcmNoaXRlY3R1cmUgb2YgdGhlIGNvbmNlcHR1YWwgbW9kZWwsYW5kIG1ldGhvZHMgdG8gZW5zdXJlIHRoZSBhY2N1cmFjeSBhbmQgcmVsaWFiaWxpdHkgb2YgdGhlIGNvbmNlcHR1YWwgbW9kZWwuQmFzZWQgb24gdGhpcyBjb25jZXB0dWFsIG1vZGVsLHRoZSB0ZWNobmljYWwgZnJhbWV3b3JrIG9mIHRoZSBkaWdpdGFsIHR3aW4gZm9yIHNtYXJ0IG1hbnVmYWN0dXJpbmcgaXMgaW50cm9kdWNlZC5LZXkgdGVjaG5vbG9naWVzIHN1Y2ggYXMgZGlnaXRhbCB0d2luIG1vZGVsaW5nLHNpbXVsYXRpb24sYW5kIGRhdGEgYW5hbHlzaXMgYXJlIGFuYWx5emVkLGFuZCBmdXR1cmUgdGVjaG5vbG9naWNhbCBkZXZlbG9wbWVudHMgYXJlIHByb3NwZWN0ZWQuIEtleSB3b3Jkc++8mmludGVsbGlnZW5jZSBtYW51ZmFjdHVyaW5nIDsgY29uY2VwdHVhbCBtb2RlbCA7IGRpZ2l0YWwgdHdpbiBlbnRpdHkgUmVjZWl2ZWTvvJoyMDI0LTAzLTI5ICAwIOW8leiogCDmmbrog73liLbpgKDmmK/mlrDotKjnlJ/kuqflipvlvaLmiJDlkozlj5HlsZXnmoTph43opoHpqbHliqjlipvvvIzmmK/lt6XkuJo0LjAvNS4w55qE5qC45b+D77yM5Lul5Y+K5o6o5Yqo5a6e546w6auY5pWI44CB54G15rS744CB57u/6Imy44CB5pm66IO955qE55Sf5Lqn5pa55byPWzFd44CC5pWw5a2X5a2q55Sf5oqA5pyv5L2c5Li65pm66IO95Yi26YCg55qE5YWz6ZSu5oqA5pyv5LmL5LiA77yM6YCa6L+H5p6E5bu654mp55CG6K6+5aSH5LiO6Jma5ouf5qih5Z6L5LmL6Ze055qE5a6e5pe25pig5bCE5ZKM5ZCM5q2l77yM5Li65Yi26YCg5Lia55qE5pm66IO95YyW44CB6auY5pWI5YyW5o+Q5L6b5pyJ5Yqb5pSv5oyB77yM5o6o5Yqo5Yi26YCg5Lia55qE6L2s5Z6L5Y2H57qn44CCIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+aYr+WcqOeOsOS7o+S8oOaEn+aKgOacr+OAgee9kee7nOaKgOacr+OAgeiHquWKqOWMluaKgOacr+OAgeaLn+S6uuWMluaZuuiDveaKgOacr+etieaKgOacr+eahOWfuuehgOS4iu+8jOmAmui/h+aZuuiDveWMlueahOaEn+efpeOAgeS6uuacuuS6pOS6kuOAgeWGs+etluWSjOaJp+ihjOaKgOacr++8jOWvueS6p+WTgeOAgeWItumAoOi/h+eoi+aIluaVtOS4quW3peWOgui/m+ihjOiZmuaLn+S7v+ecn++8jOWunueOsOiuvuiuoei/h+eoi+OAgeWItumAoOi/h+eoi+OAgeeuoeeQhui/h+eoi+WSjOWItumAoOijheWkh+aZuuiDveWMlu+8jOaPkOmrmOWItumAoOS8geS4muS6p+WTgeeglOWPkeOAgeWItumAoOWSjOeuoeeQhuaViOeOh++8jOaYr+S/oeaBr+aKgOacr+OAgeaZuuiDveaKgOacr+S4juijheWkh+WItumAoOaKgOacr+eahOa3seW6puiejeWQiOS4jumbhuaIkFsyLTRd44CC5L6L5aaC77yM5Zyo5Lqn5ZOB6K6+6K6h5pa56Z2i77yM6YCa6L+H5pWw5a2X5a2q55Sf5p6E5bu65Lqn5ZOB6Jma5ouf5qih5Z6L77yM6L+b6KGM5Lqn5ZOB5oCn6IO95Lu/55yf5ZKM5LyY5YyW6K6+6K6h77yM5o+Q6auY5Lqn5ZOB6K6+6K6h6LSo6YeP5ZKM5pWI546H77yb5Zyo55Sf5Lqn5Yi26YCg5pa56Z2i77yM5a6e5pe255uR5o6n55Sf5Lqn6L+H56iL77yM6aKE5rWL6K6+5aSH5pWF6Zqc77yM5LyY5YyW55Sf5Lqn5rWB56iL77yM6ZmN5L2O55Sf5Lqn5oiQ5pys77yb5Zyo5L6b5bqU6ZO+566h55CG5pa56Z2i77yM5Z+65LqO5pWw5a2X5a2q55Sf5a6e546w5L6b5bqU6ZO+5pWw5o2u55qE6ZuG5oiQ5ZKM5YWx5Lqr77yM5LyY5YyW6LWE5rqQ6YWN572u77yM5o+Q6auY5L6b5bqU6ZO+5Y2P5ZCM5pWI546H44CCIOacrOaWh+mmluWFiOS7i+e7jeS6huaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWei+WSjOaKgOacr+ahhuaetu+8m+WFtuasoe+8jOmYkOi/sOS6huaZuuiDveWItumAoOaVsOWtl+WtqueUn+WFs+mUruaKgOacr++8jOacgOWQju+8jOWvueacquadpeaKgOacr+WPkeWxlei/m+ihjOWxleacm+OAgiAxIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWeiyAxLjEg5qaC5b+15qih5Z6L6KaB5rGCIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWeiyjku6XkuIvnroDnp7DigJzmpoLlv7XmqKHlnovigJ0p5piv5Zyo5pWw5a2X56m66Ze05a6e546w54mp55CG5a6e5L2T5Y+K6L+H56iL55qE5bGe5oCn44CB5pa55rOV44CB6KGM5Li6562J54m55oCn55qE5pWw5a2X5YyW5bu65qih77yM5piv5a+55a6e5L2T5a+56LGh5aSW6YOo5b2i5oCB44CB5YaF6YOo5py655CG5ZKM6L+Q6KGM5YWz57O7562J55qE5pW05L2T5oq96LGh5o+P6L+w44CC5qaC5b+15qih5Z6L5Li76KaB5bqU5ruh6Laz5aaC5LiL6KaB5rGC77yaICgxKeaMgee7rei/reS7o+abtOaWsFs1XeOAgiDlnKjnlJ/kuqfov4fnqIvkuK3vvIzlkITnsbvnlJ/kuqfmlbDmja7lrp7ml7blj5jljJbvvIzmpoLlv7XmqKHlnovlupTog73moLnmja7niannkIblrp7kvZPnmoTov5DooYznirbmgIHlkozlj43ppojkv6Hmga/mjIHnu63mm7TmlrDov63ku6PvvIzkv53mjIHkuI7niannkIblrp7kvZPnmoTlkIzmraXjgIIgKDIp6Jma5a6e5Lqk5LqS5pig5bCE44CCIOaUr+aMgeiZmuaLn+epuumXtOS4jueJqeeQhuepuumXtOeahOS6pOS6ku+8jOiZmuaLn+epuumXtOaXouiDveWunuaXtuWPjeaYoOWItumAoOi/h+eoi+eJqeeQhuepuumXtOeKtuaAge+8jOabtOW6lOiDvemAmui/h+aVsOaNruiejeWQiOOAgeWIhuaekOOAgeS8mOWMluOAgeaOp+WItueJqeeQhuepuumXtOeahOi/kOihjOOAgiAoMynlpJrmupDmlbDmja7pqbHliqjjgIIg5Yi26YCg6L+H56iL5raJ5Y+K5pWw5o2u57G75Z6L5LyX5aSa77yM5bqU6IO96J6N5ZCI5aSa5rqQ5byC5p6E5pWw5o2u77yM5YyF5ous5a6e5pe25Lyg5oSf5Zmo5pWw5o2u5ZKM5Y6G5Y+y5pWw5o2u77yM5Lul5o+Q6auY5qaC5b+15qih5Z6L55qE5YeG56Gu5oCn44CCICg0KeiHqumAguW6lOWPguaVsOiwg+aVtOOAgiDmpoLlv7XmqKHlnovog73moLnmja7kuI3lkIzlupTnlKjlnLrmma/mlK/mjIHoh6rpgILlupTosIPmlbTlj4LmlbDorr7nva7vvIzku6Xmj5Dpq5jmpoLlv7XmqKHlnovlnKjkuI3lkIznjq/looPkuIvnmoTpgILnlKjmgKfjgIIgKDUp6L+t5Luj5LyY5YyW5Yaz562WWzZd44CCIOe7k+WQiOiZmuaLn+S7v+ecn+S4juaVsOaNruWIhuaekO+8jOaUr+aMgei/reS7o+S8mOWMluWGs+etlu+8jOi+heWKqeWunueOsOeUn+S6p+ezu+e7n+eahOaZuuiDveWMluOAgiAxLjIg5qaC5b+15qih5Z6L5p625p6EIOacrOaWh+aPkOWHuueUseeJqeeQhuWunuS9k+OAgeacjeWKoeWunuS9k+OAgeaVsOWtl+WtqueUn+WunuS9k+OAgeaVsOaNruWunuS9k+WSjOWQhOmDqOWIhumXtOeahOi/nuaOpeWunuS9k+e7hOaIkOeahOS6lOe7tOaVsOWtl+WtqueUn+aooeWei+OAguWfuuS6juaWh+eMrls3Xe+8jOmSiOWvueaZuuiDveWItumAoOmihuWfn+eJueeCue+8jOaPkOWHuuWmguWbvjHmiYDnpLrmpoLlv7XmqKHlnovmnrbmnoTjgIIgKDEp54mp55CG5a6e5L2TIOWbvjEg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6L5p625p6EICDniannkIblrp7kvZPmmK/ln7rnoYDvvIzlr7nmmbrog73liLbpgKDnmoTmr4/kuIDkuKrmlbDlrZflrarnlJ/lupTnlKjlnLrmma/vvIzlj6/ku6Xov5vkuIDmraXliJLliIbljZXlhYPnuqfjgIHns7vnu5/nuqflkozlpI3mnYLns7vnu5/nuqfnrYnkuI3lkIznspLluqblsYLmrKFbOF3jgILkvovlpoLvvIzmlbTkuKrmmbrog73lt6XljoLnmoTmlbDlrZflrarnlJ/vvIzovabpl7TnlJ/kuqfnur/lj6/kvZzkuLrljZXlhYPnuqfvvIznlJ/kuqfnur/miYDlnKjovabpl7Tlj6/kvZzkuLrns7vnu5/nuqfvvIzogIzmlbTkuKrlt6XljoLliJnkvZzkuLrlpI3mnYLns7vnu5/nuqfjgILlpoLmnpzku6Xovabpl7TkuLrmlbDlrZflrarnlJ/lr7nosaHvvIzliJnlj6/lsIbmnoTmiJDnlJ/kuqfnur/nmoTorr7lpIfkvZzkuLrljZXlhYPnuqfvvIzlrp7njrDljZXkuKrorr7lpIfnmoTnm5HmtYvjgIHmlYXpmpzpooTmtYvlkozpooTorabku6Xlj4rnu7TmiqRbOV3vvJvnlJ/kuqfnur/kvZzkuLrns7vnu5/nuqfvvIzlr7nnlJ/kuqfov5vooYzosIPluqbjgIHov5vluqbmjqfliLblkozkuqflk4HotKjph4/mjqfliLbvvJvmlbTkuKrovabpl7TliJnkvZzkuLrlpI3mnYLns7vnu5/nuqfvvIzlr7nmlbTkuKrovabpl7TnlJ/kuqfov5DooYzov5vooYznm5HmtYvkuI7osIPluqbkvJjljJbjgIIgKDIp5pWw5a2X5a2q55Sf5a6e5L2TIOaVsOWtl+WtqueUn+WunuS9k+agueaNrueJqeeQhuWunuS9k+eahOS4jeWQjOWxguasoeWSjOeJueeCue+8jOS7juS4jeWQjOaXtumXtOWSjOepuumXtOWwuuW6puWvueeJqeeQhuWunuS9k+i/m+ihjOaPj+i/sO+8jOWMheaLrOWHoOS9leaooeWei+OAgeeJqeeQhuaooeWei+OAgeinhOWImeaooeWei+WSjOihjOS4uuaooeWei+etiVsxMF3vvIzmlK/mjIHkuqflk4HmlbDlrZflrarnlJ/jgIHnlJ/kuqfmlbDlrZflrarnlJ/jgIHorr7lpIfmlbDlrZflrarnlJ/vvIzotK/nqb/mlbTkuKrmmbrog73liLbpgKDkuqflk4HnlJ/lkb3lkajmnJ/nrqHnkIbku7flgLzpk77jgIIg5Yeg5L2V5qih5Z6L5o+P6L+w54mp55CG5a6e5L2T5aaC5bel5Y6C44CB6L2m6Ze044CB55Sf5Lqn57q/44CB6K6+5aSH5oiW6K6+5aSH5YWD5Zmo5Lu2562J55qE5b2i54q244CB5bC65a+444CB5L2N572u44CB56m66Ze05biD5bGA5oiW6KOF6YWN5YWz57O7562J77yM5LiA6Iis5YW35pyJ5pe256m65LiA6Ie05oCn77yM5bi455So6L2v5Lu25bel5YW36YCa6L+H5LiJ57u05bu65qih5pa55byP5Yib5bu644CCIOeJqeeQhuaooeWei+WcqOWHoOS9leaooeWei+WfuuehgOS4iuWinuWKoOeJqeeQhuWunuS9k+eahOeJqeeQhuWxnuaAp+OAgee6puadn+WSjOeJueW+geetie+8jOWmgue7k+aehOOAgea1geS9k+OAgeeUteWcuuOAgeejgeWcuuW7uuaooeS7v+ecn+etie+8jOWPr+S7juW+ruinguWSjOWuj+inguetieS4jeWQjOWwuuW6pumAmui/h+S4gOS6m+W3peWFt+i9r+S7tui/m+ihjOaVsOWtpui/keS8vOaooeaLn+WSjOWIu+eUu+OAgiDooYzkuLrmqKHlnovmj4/ov7DkuI3lkIzlsYLmrKHjgIHkuI3lkIzml7bnqbrkuIvniannkIblrp7kvZPlnKjlhoXlpJbpg6jkuI3lkIzkvZznlKjlm6DntKDlkozkvZznlKjmnLrliLbkuIvnmoTooYzkuLrlkozooYzkuLrmvJTljJbvvIzmmK/kuIDkuKrlpI3mnYLnmoTov4fnqIvvvIzlj6/ph4fnlKjpqazlsJTlj6/lpKvpk77jgIHmnInpmZDnirbmgIHmnLrnrYnov5vooYzmj4/ov7DjgIIg6KeE5YiZ5qih5Z6L5o+P6L+w6aKG5Z+f44CB5YeG5YiZ44CB55+l6K+G5ZKM57uP6aqM77yM5L6L5aaC6K6+5aSH5pON5L2c6KeE56iL44CB6K6+5aSH6LCD5LyY5Y+C5pWw44CB55Sf5Lqn57q/6L+Q6KGM566h55CG6KeE5YiZ44CB54mp5paZ5oqV5pS+5qCH5YeG562J77yM6ZqP552A6KeE5YiZ55qE5aKe5Yqg5ZKM5ryU5YyW77yM5L2/5pWw5a2X5a2q55Sf5a6e5L2T6YCQ5riQ5b2i5oiQ5a6e5pe25Yik5pat44CB6Ieq5LyY5YyW44CB6Ieq5qCh5q2j5ZKM6aKE5rWL562J6IO95Yqb77yM5a+554mp55CG5a6e5L2T6L+b6KGM5o6n5Yi25ZKM6L+Q6KGM5oyH5a+844CC6KeE5YiZ5qih5Z6L5Y+v5Lul6YCa6L+H5pW05ZCI546w5pyJ55+l6K+G5bqT77yM5bm257uT5ZCI5py65Zmo5a2m5Lmg5oqA5pyv5p2l5Y+R5o6Y5paw55qE6KeE5YiZ77yM5LuO6ICM5p6E5bu65ZKM5a6M5ZaE44CC6YCa6L+H6Jma5ouf546w5a6eKFZSKeWSjOWinuW8uueOsOWunihBUinnrYnmioDmnK/lr7nlh6DkvZXmqKHlnovjgIHniannkIbmqKHlnovjgIHooYzkuLrmqKHlnovlkozop4TliJnmqKHlnovnrYnov5vooYzpm4bmiJDjgIHono3lkIjlkozkuIDoh7TmgKfmoKHmoLjvvIzlubbkuI7niannkIblrp7kvZPomZrlrp7lj6DliqDlj4rono3lkIjmmL7npLrvvIzmj5Dpq5jmlbDlrZflrarnlJ/kvZPnmoTnnJ/lrp7mgKfjgIHmsonmtbjmgKflkozkuqTkupLmgKfjgIIgKDMp5pyN5Yqh5a6e5L2TIOacjeWKoeWunuS9k+WvueaVsOaNruOAgeaooeWei+OAgeeul+azleetiei/m+ihjOacjeWKoeWMluWwgeijhe+8jOS4uuaVsOWtl+WtqueUn+WunueOsOaPkOS+m+acjeWKoeaUr+aMgeOAguagueaNruacjeWKoeexu+Wei++8jOWPr+WIhuS4uuaVsOaNruacjeWKoeOAgeS7v+ecn+acjeWKoeOAgeS4muWKoeacjeWKoeetieOAguaVsOaNruacjeWKoeWMheaLrOaVsOaNrumHh+mbhuOAgeWtmOWCqOOAgea4hea0l+OAgeWFs+iBlOOAgeiejeWQiOOAgeaMluaOmOOAgeaOpeWFpeOAgeiuv+mXruetieWQhOexu+aVsOaNrueuoeeQhuOAgeWkhOeQhuS4juiuv+mXruacjeWKoe+8m+S7v+ecn+acjeWKoeWMheaLrOW7uuaooeS7v+ecn+OAgeS7v+ecn+aooeWei+e7hOijheOAgeS7v+ecn+aooeWei+iejeWQiOOAgeS7v+ecn+aooeWei+euoeeQhuetieOAguS4muWKoeacjeWKoeWvueaVsOWtl+WtqueUn+W6lOeUqOi/h+eoi+S4remdouWQkeS4jeWQjOWItumAoOmihuWfn+OAgeS4jeWQjOWxguasoeeUqOaIt+a7oei2s+WQhOexu+WItumAoOS4muWKoemcgOaxgueahOacjeWKoei/m+ihjOWwgeijhe+8jOS7peWQhOexu+i9r+S7tuW9ouW8j+WtmOWcqO+8jOWMheaLrOmdouWQkeeOsOWcuuaTjeS9nOS6uuWRmOeahOacjeWKoeOAgemdouWQkeeuoeeQhuWGs+etluS6uuWRmOeahOacjeWKoeetie+8jOaMiemcgOS9v+eUqOOAgeeBtea0u+e7hOWQiO+8jOWunueOsOWQhOexu+WItumAoOS4muWKoeiDveWKm+OAgiAoNCnmlbDmja7lrp7kvZMg5pWw5o2u5a6e5L2T6ZuG5oiQ6J6N5ZCI5L+h5oGv5pWw5o2u44CB54mp55CG5pWw5o2u77yM5ruh6Laz5L+h5oGv56m66Ze05LiO54mp55CG56m66Ze055qE5LiA6Ie05oCn6ZyA5rGC77yM5Li65pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5o+Q5L6b5YWo6KaB57Sg44CB5YWo5rWB56iL5ZKM5YWo5Lia5Yqh55qE5pWw5o2u5pSv5oyB44CCIOeJqeeQhuaVsOaNruWMheaLrOWPjeaYoOWQhOexu+eJqeeQhuWunuS9k+inhOagvOOAgeWKn+iDveOAgeaAp+iDveOAgeWFs+ezu+etieeahOmdmeaAgeWxnuaAp+aVsOaNruS4juWPjeaYoOeJqeeQhuWunuS9k+i/kOihjOeKtuWGteOAgeaAp+iDveOAgeeOr+Wig+WPguaVsOetieeahOWKqOaAgei/h+eoi+aVsOaNru+8jOi/meS6m+aVsOaNrumAmui/h+mihOiuvueahOagh+WHhuWAvOWSjOWQhOexu+S8oOaEn+WZqOmHh+mbhueahOaVsOaNrui/m+ihjOiuvuWumuWSjOiOt+WPluOAgiDkv6Hmga/mlbDmja7ljIXmi6zmlbDlrZflrarnlJ/mqKHlnovmlbDmja7jgIHnn6Xor4bmlbDmja7jgIHnlJ/kuqfliLbpgKDkuJrliqHmlbDmja7nrYnjgILmqKHlnovmlbDmja7lj43mmKDmlbDlrZflrarnlJ/lrp7kvZPlh6DkvZXmqKHlnovjgIHniannkIbmqKHlnovjgIHooYzkuLrmqKHlnovlkozop4TliJnmqKHlnovnrYnlrarnlJ/mqKHlnovmlbDvvJvnn6Xor4bmlbDmja7ljIXmi6zlkITnsbvliLbpgKDkuJrliqHmoIflh4bkuI7op4TliJnjgIHnlJ/kuqfnn6Xor4bjgIHkuJPlrrbnn6Xor4bnrYnvvJvnlJ/kuqfliLbpgKDkuJrliqHmlbDmja7ljIXmi6znlJ/kuqfnrqHnkIbjgIHkuqflk4HnrqHnkIbjgIHnianmlpnnrqHnkIbjgIHosIPluqbnrqHnkIbjgIHkvIHkuJrnrqHnkIbnrYnmlbDmja7jgIIgKDUp6L+e5o6l5a6e5L2TIOi/nuaOpeWunuS9k+WunueOsOeJqeeQhuWunuS9k+OAgeaVsOWtl+WtqueUn+WunuS9k+OAgeacjeWKoeWunuS9k+S7peWPiuaVsOaNruWunuS9k+S5i+mXtOeahOaZrumAguWMluW3peS4muS6kuiBlO+8jOaUr+aMgeiZmuWunuWunuaXtuS6kuiBlOS4juiejeWQiFsxMV3jgILpgJrov4flkITnp43kvKDmhJ/lmajjgIHltYzlhaXlvI/ns7vnu5/nrYnlr7nniannkIblrp7kvZPmlbDmja7ov5vooYzlrp7ml7bph4fpm4blubbkvKDovpPliLDlrarnlJ/mlbDmja7lrp7kvZPvvIznu4/ov4flrarnlJ/mlbDmja7lrp7kvZPlpITnkIblkI7nmoTpgJrov4fnm7jlupTnmoTljY/orq7kvKDovpPlj43ppojnu5nniannkIblrp7kvZPvvIzlrp7njrDniannkIblrp7kvZPnmoTov5DooYzkvJjljJbjgILniannkIblrp7kvZPlrp7ml7bmlbDmja7pgJrov4fljY/orq7kvKDovpPliLDmlbDlrZflrarnlJ/lrp7kvZPvvIzov5vooYzmlbDlrZflrarnlJ/mqKHlnovnmoTomZrlrp7kuIDoh7TmgKfmoKHmraPvvIzmlbDlrZflrarnlJ/lrp7kvZPku7/nnJ/liIbmnpDnrYnmlbDmja7ovazljJbkuLrmjqfliLbmjIfku6TkvKDovpPliLDniannkIblrp7kvZPvvIzlr7nniannkIblrp7kvZPov5vooYzlrp7ml7bkuqTkupLmjqfliLbjgILniannkIblrp7kvZPjgIHmlbDlrZflrarnlJ/lrp7kvZPlkozmlbDmja7lrp7kvZPkuI7mnI3liqHlrp7kvZPlrp7ml7bov57mjqXvvIzov5vooYzmlbDmja7jgIHmqKHlnovjgIHkuJrliqHmnI3liqHnmoTlrp7ml7borr/pl67kuI7kvJjljJbjgIIgMS4zIOamguW/teaooeWei+WHhuehruaAp+WSjOWPr+mdoOaApyDmpoLlv7XmqKHlnovnmoTlh4bnoa7mgKflkozlj6/pnaDmgKfmmK/mlbDlrZflrarnlJ/mioDmnK/lupTnlKjkuo7mmbrog73liLbpgKDnmoTlhbPplK7jgILlj6/pgJrov4flpoLkuIvmiYvmrrXkv53pmpzmpoLlv7XmqKHlnovnmoTlh4bnoa7mgKflkozlj6/pnaDmgKfjgIIgKDEp5pWw5o2u6J6N5ZCI44CCIOmbhuaIkOS4jeWQjOadpea6kOaVsOaNru+8jOmAmui/h+aXtuepuuWvuem9kOOAgeagvOW8j+Wvuem9kOetieaVsOaNruiejeWQiOeahOaWueW8j++8jOaPkOmrmOaVsOaNrueahOWHhuehruaAp+WSjOS4gOiHtOaAp+OAgiAoMinnsr7noa7lu7rmqKHjgIIg6YeH55So57K+56Gu5pWw5a2m5qih5Z6L5ZKM566X5rOV77yM5qih5ouf54mp55CG5a6e5L2T55qE6KGM5Li677yM5L2/5qaC5b+15qih5Z6L6IO95aSf5YeG56Gu5Y+N5pig54mp55CG5a6e5L2T55qE54m55oCn44CCICgzKeamguW/teaooeWei+agoeWHhuOAgiDlr7nmlbDlrZflrarnlJ/lrp7kvZPlkozniannkIblrp7kvZPov5vooYzmlbDmja7lkIzmraXmgKflkozkuIDoh7TmgKfmo4Dmn6XvvIznoa7kv53mlbDmja7lkIzmraXlkozkuIDoh7TjgIIgKDQp6Zet546v5Y+N6aaI44CCIOavlOi+g+aVsOWtl+WtqueUn+aooeWei+eahOi+k+WHuuS4jueJqeeQhuWunuS9k+eahOWunumZheaAp+iDveW3ruW8gu+8jOWQkeaooeWei+S+neaNruW3ruW8guaDheWGtei/m+ihjOaooeWei+iwg+aVtO+8jOW7uueri+aooeWei+S4jueJqeeQhuWunuS9k+eahOmXreeOr+WPjemmiOacuuWItuOAgiAoNSnmpoLlv7XmqKHlnovmjIHnu63oh6rlrabkuaDlkozkvJjljJbjgIIg6YCa6L+H5Lq65bel5pm66IO9562J5oqA5pyv77yM6L+b6KGM5qaC5b+15qih5Z6L5oyB57ut6Ieq6LCD5pW05ZKM6Ieq5LyY5YyW77yM5oyB57ut5o+Q6auY5qih5Z6L6aKE5rWL5ZKM5YiG5p6Q6IO95Yqb44CCICg2KeamguW/teaooeWei+a1i+ivleWSjOmqjOivgeOAgiDov5vooYzkuI3lkIzlnLrmma/kuIvmpoLlv7XmqKHlnovlh4bnoa7mgKflkozlj6/pnaDmgKfmtYvor5Xlkozpqozor4HjgIIgKDcp5a6J5YWo5oCn5L+d5oqk44CCIOehruS/neamguW/teaooeWei+aVsOaNruWuieWFqO+8jOmYsuatouaVsOaNruazhOmcsuWSjOevoeaUueOAgiAyIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+aKgOacr+aetuaehCDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mioDmnK/mnrbmnoTmj4/ov7Dkuobmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnovkuI3lkIzlrp7kvZPkuYvpl7TkuqTkupLnmoTmioDmnK/lrp7njrDnu5PmnoTjgIIg5aaC5Zu+MuaJgOekuu+8jOeJqeeQhuWxgua2ieWPiuWItumAoOmihuWfn+S6uuWRmOOAgeiuvuWkh+OAgeeJqeaWmeOAgeW3peiJuuOAgeeOr+Wig+etieeUn+S6p+imgee0oOOAguS4jeWQjOWItumAoOmihuWfn+eahOeJqeeQhuWunuS9k+acieaJgOS4jeWQjOOAguS+i+Wmgu+8jOmSoumTgeWGtueCvOWKoOW3peS8geS4mu+8jOeJqeeQhuWunuS9k+acieWGtueCvOmrmOeCieOAgeefv+efs+OAgemTuOS7tuOAgeWGtueCvOaOp+WItuezu+e7n+etie+8m+iIueiItuWItumAoOS8geS4mu+8jOeJqeeQhuWunuS9k+acieiIueiItuWOn+Wei+OAgeiIueiItumDqOS7tuOAgeW+heS/ruiIueiItuetieOAgiDlm74yIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+aKgOacr+aetuaehCAg5oSf55+l5Lyg6L6T5bGC5o+Q5L6b54mp55CG5bGC5LiN5ZCM5bGC5qyh5LmL6Ze055qE5LqS6YCa44CCIOaVsOaNruWxguWMheaLrOeJqeeQhuWunuS9k+eahOWQhOexu+mdmeaAgeWSjOWKqOaAgeaVsOWtl+WMluS/oeaBr+OAgiDmqKHlnovlsYLlkozmnI3liqHlsYLkuLrlupTnlKjlsYLmj5DkvpvlkITnsbvmnI3liqHvvIzljIXmi6zmqKHlnovmnI3liqHjgIHmlbDmja7mnI3liqHjgIHku7/nnJ/mnI3liqHlkozkuJrliqHmnI3liqHnrYnjgIIg5bqU55So5bGC5Yip55So5LiK6L+w5ZCE5bGC6IO95Yqb77yM54G15rS75p6E5bu65pm66IO95Yi26YCg5LiN5ZCM6aKG5Z+f44CB5LiN5ZCM57KS5bqm55qE5pWw5a2X5a2q55Sf5a6e5L2T77yM5L6L5aaC55Sf5Lqn6L+H56iL5pWw5a2X5a2q55Sf44CB6K6+5aSH5pWw5a2X5a2q55Sf44CB5bel6Im65LyY5YyW5pWw5a2X5a2q55Sf562J77yM6KaG55uW5Lqn5ZOB55Sf5ZG95ZGo5pyf566h55CG5YWo5Lu35YC86ZO+5ZKM5Yi26YCg5YWo5rWB56iL6ZO+44CCIDMg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5YWz6ZSu5oqA5pyvIDMuMSDmlbDlrZflrarnlJ/lu7rmqKHmioDmnK8g5bu65qih5qC55o2u6KKr5Lu/55yf5a+56LGh5oiW57O757uf55qE5p6E5oiQ6KaB57Sg44CB6L+Q5Yqo6KeE5b6L44CB57qm5p2f5p2h5Lu25ZKM54mp55CG54m55oCn562J77yM5bu656uL5b2i5byP5YyW55qE5LiO54mp55CG5a6e5L2T55u45a+55bqU55qE6Jma5ouf5pWw5a2X5a2q55Sf5a6e5L2T5qih5Z6L77yM5Y+N5pig54mp55CG5a6e5L2T55qE5aSW6KeC44CB5YaF6YOo55qE54m55oCn44CB57uT5p6E5ZKM6KGM5Li644CC5YW35L2T5Zyo5pm66IO95Yi26YCg6aKG5Z+f77yM5bu65qih5oqA5pyv5piv6ZKI5a+55Yi26YCg5Lit55qE6L295L2TKOWmguaVsOaOp+acuuW6iinjgIHliLbpgKDov4fnqIso5aaC5Yqg5bel6L+H56iL5Lit55qE54Ot44CB5Yqb562JKeWSjOiiq+WKoOW3peWvueixoSjlpoLooqvliLbpgKDnmoTpo57mnLop562J77yM5bqU55So5py65qKw44CB54mp55CG44CB5Yqb5a2m44CB6K6h566X5py65ZKM5pWw5a2m562J55+l6K+G77yM5a+55bu65qih5a+56LGh55qE5LiA56eN6L+R5Ly86KGo6L6+44CCIOaVsOWtl+WtqueUn+WunuS9k+aooeWei+WcqOiMg+WbtOS4iu+8jOacieWFqOWxgOe7k+aehOaooeWeiyjkvovlpoLlt6XljoLlhajnlJ/kuqfnur8p44CB5bGA6YOo57uT5p6E5qih5Z6LKOWmguafkOS4gOi9pumXtOeUn+S6p+ijhee9rinjgIHkuqflk4Hnu5PmnoTmqKHlnovlkoznlJ/kuqforqHliJLosIPluqbmqKHlnovnrYnvvJvlnKjmlrnms5XkuIrvvIzmnInmlbDlrabop6PmnpDmqKHlnoso5aaC54q25oCB56m66Ze05qih5Z6LKeOAgeWbvuekuuKAlOino+WQiOaooeWeiyjlpoJQZXRyaee9keaooeWeiynnrYnvvJvlnKjlip/og73kuIrvvIzmnInnu5PmnoTmj4/ov7DmqKHlnovjgIHns7vnu5/liIbmnpDmqKHlnovjgIHns7vnu5/orr7orqHlrp7mlr3mqKHlnovlkozns7vnu5/ov5DooYznrqHnkIbmqKHlnovnrYnjgIIg5bu65qih55qE5Li76KaB6L+H56iL5YyF5ous5Yi26YCg5pWw5o2u6YeH6ZuG5LiO6ZuG5oiQ44CB5qih5Z6L5Yib5bu644CB5a6e5pe25pWw5o2u5ZCM5q2l44CB6Zet546vLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKSSBhbSBhIGdyYWR1YXRlIHN0dWRlbnQgaW4gdGhlIGZpZWxkIG9mIGNyeXB0b2dyYXBoeSBhbmQgbmVlZCB0byB3cml0ZSBhIHBhcGVyIG9uIHRoZSBhcHBsaWNhdGlvbiBvZiBxdWFudHVtIGNvbXB1dGluZyBpbiBjcnlwdG9ncmFwaHkuIFBsZWFzZSBwcm92aWRlIHRoZSBjb250ZW50IGZvciB0aGUgcmVsYXRlZCB3b3JrIHNlY3Rpb24gb2YgdGhlIHBhcGVyLCB3aXRoIGEgZm9jdXMgb246Ci0gVGhyZWF0IGFuYWx5c2lzIG9mIFNob3IncyBhbGdvcml0aG0gb24gZXhpc3RpbmcgY3J5cHRvZ3JhcGhpYyBzeXN0ZW1zCi0gTGF0ZXN0IHJlc2VhcmNoIHByb2dyZXNzIG9uIG1haW5zdHJlYW0gcG9zdC1xdWFudHVtIGNyeXB0b2dyYXBoeSB0ZWNobmlxdWVzIChsYXR0aWNlLWJhc2VkIGNyeXB0b2dyYXBoeSwgbXVsdGl2YXJpYXRlIGNyeXB0b2dyYXBoeSwgaGFzaC1iYXNlZCBzaWduYXR1cmVzLCBldGMuKQotIERldGFpbGVkIGRpc2N1c3Npb24gb2YgdGhlIGxhdGVzdCBwcm9ncmVzcyBpbiB0aGUgTklTVCBwb3N0LXF1YW50dW0gY3J5cHRvZ3JhcGh5IHN0YW5kYXJkaXphdGlvbiBwcm9qZWN0LCBlc3BlY2lhbGx5IHRoZSB0ZWNobmljYWwgZGV0YWlscyBvZiB0aGUgZmlyc3QgYmF0Y2ggb2Ygc2VsZWN0ZWQgYWxnb3JpdGhtcyBpbiAyMDIyCi0gU3BlY2lmaWMgZXhhbXBsZXMgb2YgdGhlIGNvbW1lcmNpYWxpemF0aW9uIG9mIHBvc3QtcXVhbnR1bSBjcnlwdG9ncmFwaHkgYnkgbWFqb3IgdGVjaG5vbG9neSBjb21wYW5pZXMgKEdvb2dsZSwgSUJNLCBldGMuKQp1c2VyOgpUaGlzIGlzIGEgcmVwb3J0IG9uIHRoZSB0ZW5zaWxlIGV4cGVyaW1lbnQgb2YgbWF0ZXJpYWwgbWVjaGFuaWNzLCAqKk1hdGVyaWFsKioKCjEuIFNhbXBsZSBJbmZvcm1hdGlvbgoKICAgIE1hdGVyaWFsIE5hbWU6IExvdyBDYXJib24gU3RlZWwgIAogICAgU2FtcGxlIFNoYXBlOiBSb3VuZCBCYXIgIAogICAgU2FtcGxlIERpYW1ldGVyOiAxMCBtbSAgCiAgICBTYW1wbGUgTGVuZ3RoOiAxMDAgbW0gIAogICAgU2FtcGxlIElEOiBBLTAxICAKCjIuIFRlc3RpbmcgRXF1aXBtZW50CgogICAgVGVzdGluZyBNYWNoaW5lIE5hbWU6IElOU1RST04gNTU2OSBUZW5zaWxlIFRlc3RpbmcgTWFjaGluZSAgCiAgICAgICAgTWF4aW11bSBMb2FkOiAxMDAga04gIAogICAgICAgIFRlbnNpbGUgU3BlZWQ6IDIgbW0vbWluICAKICAgICAgICBEaXNwbGFjZW1lbnQgUmVzb2x1dGlvbjogMC4wMDEgbW0gIAogICAgICAgIFN0cmFpbiBNZWFzdXJlbWVudCBTeXN0ZW06IEhpZ2gtUHJlY2lzaW9uIERpc3BsYWNlbWVudCBTZW5zb3IgIAogICAgICAgIENvbnRyb2wgU3lzdGVtOiBEaWdpdGFsIENvbnRyb2wgU3lzdGVtLCBzdXBwb3J0cyByZWFsLXRpbWUgZGlzcGxheSBvZiBmb3JjZS1kaXNwbGFjZW1lbnQgY3VydmUgYW5kIGRhdGEgcmVjb3JkaW5nICAKCjMuIEV4cGVyaW1lbnQgUHJvY2VzcwoKICAgIFNhbXBsZSBQcmVwYXJhdGlvbjogIAogICAgICAgIEluc3BlY3QgdGhlIHNhbXBsZSBzdXJmYWNlIGZvciBjcmFja3Mgb3IgZGVmZWN0cywgZW5zdXJpbmcgdGhlIHN1cmZhY2UgaXMgc21vb3RoLiAgCiAgICAgICAgTWVhc3VyZSB0aGUgaW5pdGlhbCBkaWFtZXRlciBvZiB0aGUgc2FtcGxlIHRvIGJlIDEwLjAgbW0gYW5kIHRoZSBsZW5ndGggdG8gYmUgMTAwIG1tIHVzaW5nIGNhbGlwZXJzLiAgCgogICAgVGVzdGluZyBQcm9jZXNzOiAgCiAgICAgICAgSW5zdGFsbCB0aGUgc2FtcGxlIGluIHRoZSB0ZXN0aW5nIG1hY2hpbmUgZ3JpcHMsIGVuc3VyaW5nIHN5bW1ldHJpYyBsb2FkaW5nLiAgCiAgICAgICAgU3RhcnQgdGhlIHRlbnNpbGUgdGVzdGluZyBtYWNoaW5lLCBzZXQgdGhlIHRlbnNpbGUgc3BlZWQgdG8gMiBtbS9taW4sIGFuZCBiZWdpbiBsb2FkaW5nLiAgCgo0LiBFeHBlcmltZW50YWwgUmF3IERhdGEKCiAgICBTdHJlc3MgKE1QYSkgICBTdHJhaW4gKG1tL21tKSAgIExvYWQgKGtOKSAgIERlZm9ybWF0aW9uIChtbSkgIAogICAgMCAgICAgICAgICAgICAwICAgICAgICAgICAgICAgIDAgICAgICAgICAgIDAgIAogICAgNTAgICAgICAgICAgICAwLjAwMiAgICAgICAgICAgIDAuNSAgICAgICAgIDAuMiAgCiAgICAxMDAgICAgICAgICAgIDAuMDA0ICAgICAgICAgICAgMS4wICAgICAgICAgMC40ICAKICAgIDE1MCAgICAgICAgICAgMC4wMDYgICAgICAgICAgICAxLjUgICAgICAgICAwLjYgIAogICAgMjAwICAgICAgICAgICAwLjAwOCAgICAgICAgICAgIDIuMCAgICAgICAgIDAuOCAgCiAgICAyNTAgICAgICAgICAgIDAuMDEwICAgICAgICAgICAgMi41ICAgICAgICAgMS4wICAKICAgIDMwMCAgICAgICAgICAgMC4wMTIgICAgICAgICAgICAzLjAgICAgICAgICAxLjIgIAogICAgMzUwICAgICAgICAgICAwLjAxNSAgICAgICAgICAgIDMuNSAgICAgICAgIDEuNCAgCiAgICA0MDAgICAgICAgICAgIDAuMDE4ICAgICAgICAgICAgNC4wICAgICAgICAgMS42ICAKICAgIDQ1MCAgICAgICAgICAgMC4wMjAgICAgICAgICAgICA0LjUgICAgICAgICAxLjggIAogICAgNTAwICAgICAgICAgICAwLjAyMiAgICAgICAgICAgIDUuMCAgICAgICAgIDIuMCAgCiAgICA1MTAgICAgICAgICAgIDAuMDIzICAgICAgICAgICAgNS4xICAgICAgICAgMi4xICAKCjUuIFRoZW9yZXRpY2FsIENhbGN1bGF0aW9uCgogICAgWWllbGQgU3RyZW5ndGggKM+DX3kpICAKICAgIFRoZSB5aWVsZCBzdHJlbmd0aCBvZiB0aGUgc3RyZXNzLXN0cmFpbiBjdXJ2ZSBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGV4cGVyaW1lbnRhbCBkYXRhLCBhc3N1bWluZyB0aGUgeWllbGQgcG9pbnQgYXMgdGhlIHBvaW50IGJlZm9yZSB0aGUgc3RyZXNzIHJlYWNoZXMgaXRzIG1heGltdW0gdmFsdWUuICAKICAgICAgICBNYXhpbXVtIFN0cmVzcyDPg19tYXggPSA1MTAgTVBhICAKICAgICAgICBZaWVsZCBTdHJlbmd0aCDPg195ID0gMjUwIE1QYSAoVGhlb3JldGljYWwgVmFsdWUpICAKCiAgICBUZW5zaWxlIFN0cmVuZ3RoICjPg19iKSAgCiAgICBUaGUgdGVuc2lsZSBzdHJlbmd0aCBpcyB0aGUgc3RyZXNzIGF0IHRoZSBtYXhpbXVtIGxvYWQgcG9pbnQgZHVyaW5nIHN0cmV0Y2hpbmcuICAKICAgICAgICBUaGVvcmV0aWNhbCBWYWx1ZSDPg19iID0gNTEwIE1QYSAgCgogICAgRWxvbmdhdGlvbiBBZnRlciBGcmFjdHVyZSAoQSkgIAogICAgQWNjb3JkaW5nIHRvIHRoZSBmb3JtdWxhOiAgCiAgICBBID0gKGxfZiAtIGxfMCkgLyBsXzAgw5cgMTAwJSAgCiAgICBXaGVyZSwgbF9mIGlzIHRoZSBsZW5ndGggb2YgdGhlIHNhbXBsZSBhZnRlciBmcmFjdHVyZSwgYW5kIGxfMCBpcyB0aGUgb3JpZ2luYWwgbGVuZ3RoLiAgCiAgICBBc3N1bWUgdGhlIGxlbmd0aCBhZnRlciBmcmFjdHVyZSBpcyBsX2YgPSAxMDIgbW0sICAKICAgIEEgPSAoMTAyIC0gMTAwKSAvIDEwMCDDlyAxMDAlID0gMiUgIAogICAgICAgIEVsb25nYXRpb24gQWZ0ZXIgRnJhY3R1cmU6IDIlICAKCiAgICBFbGFzdGljIE1vZHVsdXMgKEUpICAKICAgIFRoZSBlbGFzdGljIG1vZHVsdXMgY2FuIGJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgc2xvcGUgb2YgdGhlIGluaXRpYWwgbGluZWFyIHNlY3Rpb24gb2YgdGhlIHN0cmVzcy1zdHJhaW4gY3VydmU6ICAKICAgIEUgPSDPgyAvIM61ICAKICAgIFRha2luZyBzdHJlc3MgYXMgMTAwIE1QYSBhbmQgc3RyYWluIGFzIDAuMDA0OiAgCiAgICBFID0gMTAwIE1QYSAvIDAuMDA0ID0gMjUsMDAwIE1QYSA9IDI1IEdQYSAgCiAgICAgICAgRWxhc3RpYyBNb2R1bHVzIEUgPSAyNSBHUGEgKFRoZW9yZXRpY2FsIFZhbHVlKSAgCgo2LiBBbmFseXNpcyBvZiBFeHBlcmltZW50YWwgUmVzdWx0cwoKICAgIFlpZWxkIFN0cmVuZ3RoIG9mIHRoZSBNYXRlcmlhbDogVGhlIGV4cGVyaW1lbnRhbCByZXN1bHQgc2hvd3MgdGhhdCB0aGUgeWllbGQgc3RyZW5ndGggb2YgdGhlIHNhbXBsZSBpcyAyNTAgTVBhLCB3aGljaCBpcyBjbG9zZSB0byB0aGUgdGhlb3JldGljYWwgdmFsdWUgYW5kIG1lZXRzIGV4cGVjdGF0aW9ucy4gIAogICAgVGVuc2lsZSBTdHJlbmd0aDogVGhlIG1heGltdW0gc3RyZXNzIHJlYWNoZXMgNTEwIE1QYSwgbXVjaCBoaWdoZXIgdGhhbiB0aGUgeWllbGQgc3RyZW5ndGgsIGluZGljYXRpbmcgc3Ryb25nIHRlbnNpbGUgY2FwYWJpbGl0eSBvZiB0aGUgbWF0ZXJpYWwuICAKICAgIEVsb25nYXRpb24gQWZ0ZXIgRnJhY3R1cmU6IFRoZSAyJSBlbG9uZ2F0aW9uIGFmdGVyIGZyYWN0dXJlIHNob3dzIHRoYXQgdGhlIG1hdGVyaWFsIGhhcyBhIGNlcnRhaW4gZGVncmVlIG9mIGR1Y3RpbGl0eSwgbWFraW5nIGl0IHN1aXRhYmxlIGZvciBhcHBsaWNhdGlvbnMgdGhhdCByZXF1aXJlIHN1YnN0YW50aWFsIHBsYXN0aWMgZGVmb3JtYXRpb24uICAKICAgIEVsYXN0aWMgTW9kdWx1czogVGhlIGVsYXN0aWMgbW9kdWx1cyBpcyAyNSBHUGEsIGluZGljYXRpbmcgaGlnaCByaWdpZGl0eSwgY29uc2lzdGVudCB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpY3Mgb2YgbG93IGNhcmJvbiBzdGVlbC4gIAoKNy4gQ29uY2x1c2lvbgoKICAgIFRoaXMgdGVuc2lsZSB0ZXN0IHZlcmlmaWVkIHRoZSB5aWVsZCBzdHJlbmd0aCwgdGVuc2lsZSBzdHJlbmd0aCwgYW5kIGR1Y3RpbGl0eSBvZiBsb3cgY2FyYm9uIHN0ZWVsLiBDb21wYXJpbmcgd2l0aCB0aGUgdGhlb3JldGljYWwgdmFsdWVzLCB0aGUgZXhwZXJpbWVudGFsIHJlc3VsdHMgYXJlIGluIGxpbmUgd2l0aCB0aGUgYmFzaWMgcHJpbmNpcGxlcyBvZiBtYXRlcmlhbCBtZWNoYW5pY3MsIHByb3ZpbmcgdGhhdCB0aGlzIG1hdGVyaWFsIGhhcyBnb29kIG1lY2hhbmljYWwgcHJvcGVydGllcyBhbmQgaXMgc3VpdGFibGUgZm9yIHVzZSBpbiBzdHJ1Y3R1cmFsIGNvbXBvbmVudHMgdGhhdCBiZWFyIGxhcmdlIGxvYWRzLi4gUGxlYXNlIHdyaXRlIGEgZGlzY3Vzc2lvbiBzZWN0aW9uIG9mIGFwcHJveGltYXRlbHkgMzAwMCB3b3JkcyBiYXNlZCBvbiB0aGlzIHJlcG9ydC4gRnJvbSB0aGUgdGhyZWUgZGltZW5zaW9ucyBvZiB0aGVvcmV0aWNhbCBmb3VuZGF0aW9uLCBleHBlcmltZW50YWwgcHJvY2VzcywgYW5kIGRhdGEgYW5hbHlzaXMsIGVsYWJvcmF0ZSBvbiB0aGUgcmVhc29ucyBmb3IgdGhlIGRldmlhdGlvbiBiZXR3ZWVuIHRoZSBleHBlcmltZW50YWwgcmVzdWx0cyBhbmQgdGhlIHRoZW9yZXRpY2FsIHZhbHVlcy4gRm9yIGVhY2ggZGV2aWF0aW9uIHJlYXNvbiwgcHJvcG9zZSBzcGVjaWZpYyBhbmQgZmVhc2libGUgaW1wcm92ZW1lbnQgbWVhc3VyZXMsIGluY2x1ZGluZyBpbnN0cnVtZW50IHNlbGVjdGlvbiwgb3B0aW1pemF0aW9uIG9mIGV4cGVyaW1lbnRhbCBzdGVwcywgZGF0YSBwcm9jZXNzaW5nIG1ldGhvZHMsIGV0Yy4KdXNlcjoK5YW35L2T5Luq5Zmo5Z6L5Y+355qE5oqA5pyv5omL5YaM5oiW6K+05piO5Lmm77yaCuaXpeeri1NVODAxMOWei+WPt1NFTQoxIOW8gOacugrlvIDlvaLosoznlLXohJHvvJrmiZPlvIDlvqrnjq/msLTigJTigJRkaXNwbGF55oyJ6ZKu5Yiw4puU77iP4oCU4oCUIOS8muiHquWKqOW8gOacuuKAlOKAlOeCueWHu+eUqOaItyBzdTgwMTAg5rKh5pyJ5a+G56CBIO+8iOWmguaenOWcqOW8gOacuuS5i+WQjuS4jeWwj+W/g+aKiui9r+S7tuWFs+aOieS6hueCueWHu+eUteiEkeW3puS4i+inkuW8gOWni++8jOeCueWHu3BjLXNlbeWwseWPr+S7peaJk+W8gOi9r+S7tu+8iQoK5byA6IO96LCx55S16ISR77ya54K55Ye76IO96LCx55S16ISR5Li75py66IOM5ZCO55qE6buR6Imy5oyJ6ZKu5Yiw4puU77iP4oCU4oCU5omT5byA5Li75py64oCU4oCU5omT5byA5pi+56S65bGP5byA5YWz4oCU4oCU5omT5byA6L2v5Lu277yIIOeUqOaIt1NVODAxMC1FRFMg5rKh5pyJ5a+G56CB77yJQVp0ZWMKCuavj+asoeW8gOacuuWQjumcgOimgeajgOafpe+8mgoK6auY5YCN5LiL5p+l55yL5piv5ZCm5oqK56OB5oCn5qih5byP5YWz5LqG77ya54K55Ye7c2V0dXDigJTigJTli77pgInkuIrno4HmgKfmqKHlvI8K5qOA5p+l55S15Y6L5piv5LiN5pivM2t277ya54K55Ye76L2v5Lu25bem5LiK6KeS6buR6Imy5pyJ55S15Y6L55qE6YOo5YiGCmZsYXNoaW5n5LiA5LiL77ya54K55Ye75bem5LiK6KeS6buR6Imy5qGG4oCU4oCU54K55Ye7Zmxhc2hpbmfigJTigJTngrnlh7tleGVjdXRl4oCU4oCU5Zyo5Lik5Y+w55S16ISR5Lit6Ze055qE5pys5a2Q5LiK6K6w5b2V55S15rWB5pWw5YC85ZKM5b2T5pel5byA5aeL5pe26Ze0CuiusOW9lUlQ5pWw5YC877ya54K55Ye75Y+z5LiL6KeSbWFpbnRl4oCU4oCU5Zyo5LiK6Z2i55qE5pys5a2Q5LiK6K6w5b2V5LiJ5LiqSVDmlbDlgLwK5q2k5pe25Y+v5Lul6aG65L6/5omT5byA5bCP6KeG6aKR55qE5oyJ6ZKuCu+8iOazqO+8mjMsNOS4pOmhueavj+WkqTXngrnkuZ/pnIDopoHmk43kvZzkuIDmrKHvvIkKCjIg5Yi25qC3CuehruWumueUqOaIt+a1i+eahOaYr+aWremdoui/mOaYr+ihqOmdou+8muW5s+mdouWPsCDmn7Hplb8g77yb5pat6Z2i5Y+wIOafseefreOAggoK5qC35ZOB5Y+w5pyJ5Lik5Liq77yM5LiA5Liq5aSn55qE77yM5LiA5Liq5bCP55qE77yM6K6p55So5oi36Ieq5bex6YCJ5oup6ZyA6KaB55qE44CCCgrlhbPkuo7lr7znlLXog7bvvJrnuqLoibLlr7znlLXog7bpgILlkIjnsonmnKvoja/lk4HnlKjvvIzku7fmoLzotLXvvJvok53oibLlr7znlLXog7bpgILlkIjpmaTnsonmnKvlpJblhbbku5bmoLflk4HvvIzku7fmoLzkvr/lrpzvvIzog73nnIvliLDlrZTjgIIKCuagt+WTgeWPsOS4iui0tOWlveWvvOeUteiDtuWQju+8jOWGjei0tOWlveeUqOaIt+aJgOacieeahOW+hea1i+agt+WTgeOAggoKMyDplYDph5EK5byA5py677yaIHN3aXRjaCBvbuKAlOKAlCBGRkIgb27igJTigJRwb3dlciBvbuKblO+4j+KAlOKAlEJMbG9r77yMIG9wZW4g77yI5q+P5aSp5LiA5p2l5Y+v5Lul5YWI57uZ6ZWA6YeR5Luq5omT5byA77yJCgrlhbPmnLrvvJrngrnlh7tTdGFydOaKveecn+epuuKAlOKAlOaKveWIsEUwIFBh4oCU4oCUQkxsb2vovazliqjliLBjbG9zZeKAlOKAlOeCueWHu+aYvuekuuWxj3N0b3DigJTigJRwb3dlcm9mZuKAlOKAlCBGRkIgb2Zm4oCU4oCUc3dpdGNoIG9mZgoK5YWz5LqO5Za36YeRCgrllrfnmoTlhbblrp7mmK/piZEKCuWWt+mHkSDomb3nhLborr7nva7nmoTmmK80MHPjgIE2MHPvvIzkvYbmmK/lrp7pmYXkuIropoE4LjnliIbpkp/vvIzlm6DkuLropoFhaXLvvIxldmFj77ybCgrllrfph5Hms6jmhI/ngrnvvJrkuIDkuKrmmK/mlbDlrZfopoHlr7nlh4bvvJvkuozmmK/pk77mnaHkuI3opoHljaHliLDph4zpnaLljrvvvJsKCuWWt+mHkeWujOaIkOeahOagh+W/l+aYr+mVgOmHkeS7queahOmch+WKqOWjsOWBnOatouOAggoKNCDnoazku7bov5vmoLcK5Y+v5Lul5Zyo5qC35ZOB5Y+w5LiK55So6K6w5Y+356yU5qCH6K6w5LiA5LiL56ys5LiA5Liq5qC35ZOB55qE5L2N572u44CCCgrmi6fntKfljp/niYfvvIzorqnljp/niYflkozplIHlrprlmajmiJDkuLrmlbTkvZPigJTigJTmiormoLflk4Hlj7DmlL7liLDlubPpnaLlj7DmiJbogIXmlq3pnaLlj7DplIHlrprlmajkuIrigJTigJTpobrml7bpkojmi6fntKfmoLflk4Hlj7DigJTigJTmnInkuKTkuKrlsI/lrZTnmoTmnJ3lkJHoh6rlt7HigJTigJTlsIbkuK3pl7TnmoTljp/niYfpgIbml7bpkojmlrnlkJHnqI3lvq7mi6fmnb7kuIDngrnngrnvvIjpobrlhbPpgIblvIDvvInigJTigJQg5peL6L2s5qC35ZOB5Y+w77yM6LCD5pW06ZSB5a6a5Zmo6J665q+N55qE6auY5bqm77yI6aG65pe26ZKI6ZmN5L2O77yM6YCG5pe26ZKI5Y2H6auY77yJ77yM5L2/5b6X5qC35ZOB5Y+w55qE6YeP6auY5q+U5rWL6auY5Luq56iN5b6u5L2OMS0ybW3vvIjms6jvvJrlpoLmnpzmmK/no4HmgKfmoLflk4HvvIzpnIDopoHnm7jlt64zLTRtbe+8ieKAlOKAlOWQjOaXtuS5n+mcgOimgeehruS/neeUqOaIt+eahOesrOS4gOS4quagt+WTgeWcqOW3puS4iuinkuaWueWQkeKAlOKAlOmhuuaXtumSiOaLp+e0p+S4remXtOWOn+eJh+KAlOKAlOeUqOa0l+iAs+eQg+WQueS4gOWQueagt+WTgeihqOmdoueahOiEj+S4nOilv++8jOi2heWbm+WRqOWQue+8jOS4jeimgeS6kuebuOaxoeafk+agt+WTge+8jOacneWcsOmdouWQue+8jOS4jeimgeWvueedgOahjOmdouWQueaxoeafk+ahjOmdouOAggoK6LW35aeL54q25oCB77yaY2xvc2UgZXZlYwoK54K55Ye7YWly5Zyo5Lqk5o2i5LuT6YeM5rOo5YWl56m65rCU4oCU4oCU5omL5Yqo5oqK5Lqk5o2i5LuT5ouJ5Ye65p2l4oCU4oCU5pS+5LiK5Yi25aSH5aW955qE5qC35ZOB5Y+w5ZCM5pe2bG9ja+S4gOS4i+KAlOKAlOaKiuS6pOaNouS7k+mAgei/m+WOu+KAlOKAlOeCueWHu2V2YWPmir3nnJ/nqbrigJTigJTngrnlh7tvcGVu5omT5byA6Iix6Zeo4oCU4oCU5o6o6L+b5Y675qC35ZOB5p2G5Yiw5pyA6YeM6Z2i55u05YiweGPok53nga/kuq7otbfigJTigJR1bmxvY2vmoLflk4Hmi4nlh7rmoLflk4HmnYbliLDmnIDov5znq6/lkKzliLDnoLDnmoTkuIDlo7DkuI3mlL7miYvigJTigJTngrnlh7tjbG9zZeWFs+mXreS7k+mXqOKAlOKAlOadvuW8gOaLieedgOagt+WTgeadhueahOaJiwoKNSDova/ku7bosIPmlbQK5aaC5p6c5b6F5rWL5qC35ZOB5piv56OB5oCn5qC35ZOB77yM6L2v5Lu2c2V0dXDno4HmgKfmqKHlvI/li77pgInkuIrvvIzlkIzkuIDkuKrkurrnmoTmoLflk4HnlKjlrozkuoborrDlvpfopoHlj5bmtojli77pgInvvIHvvIEKCuWmguaenOaYr+aAleawp+WMlueahOagt+WTgSDkuIDlrpropoHlv6vpgJ/mk43kvZzvvIHvvIEKCueCueWHu+i9r+S7tuW3puS4iuinkm9u5omT5byA55S15Y6L77yI5q2k5pe26ZyA6KaB56iN5b6u562J5LiA5Lya5YS/77yJ4oCU4oCU6LCD5pW05Yiw5L2O5YCN5qih5byPTE3igJTigJTmib7liLDnrKzkuIDkuKrmoLflk4Hotbflp4vkvY3nva4o5aSn5qC35ZOB5Y+wOuacgOW3pui+ue+8iC0xNyww77yJIOW3puS4iuinku+8iC0xNyw177yJ77yb5bCP5qC35ZOB5Y+w77yIIC0xMiww77yJKeKAlOKAlOWIh+aNouWIsOmrmOWAjeS4i+KAlOKAlOiwg+WIsAoKMTBr5bem5Y+z77yI5bel5L2c6Led56a75Li6OOW3puWPs++8ieKAlOKAlOi+ueaUvuWkp+i+ueeyl+iwg+eEtuWQjuWGjee7huiwg+WIsOWwveWPr+iDvea4healmuKAlOKAlOWGjUJBbGlnbuKAlOKAlOKRoCDvuI94eeiwg+eUteWtkOadn+WxheS4reKAlOKAlOKRoXh56LCD5YWJ6ZiR5bGF5Lit77yM5Yiw5LiN5bem5Y+z5pmD77yM6YeM5aSW6ZyH5Yqo5Li65q2i4oCU4oCU4pGi4pGjIO+4j++4j+iwg+eahOaYr+WDj+aVo++8jOiwg+WIsOS4jeW3puWPs+aZg++8jOWPmOaIkOmHjOWklumch+WKqOS4uuatouKAlOKAlOeCueWHu3JlZDHlsI/nqpflj6PvvIxmaW5l57uG6LCD77yM5YaNIHh56LCD5pW05Yiw55S76Z2i5riF5pmw77yM5YaNZmluZee7huiwg+KAlOKAlOS6pOe7meeUqOaIt+a1i+ivlQoK5YWz5LqO5peL6L2s5Zu+5YOP77yM5Yu+6YCJcm90YXRpb24g5Y2z5Y+v6L+b6KGM6LCD5pW044CCCgo2IOiDveiwsQrms6jvvJrmiZPog73osLHlsI/op4bpopHlv4XpobvopoHlhbPmjonvvIEKCui+k+WFpei+k+WHuuiuoeaVsOeOh+mDveimgSAyMDAw5Lul5LiK77yM5YW25a6eMTUwMOS5n+ihjO+8jOWmguaenOWPquacieWHoOeZvuWwseaciemXrumimOS6hu+8jOWZqumfs+S8muW+iOWkmu+8gQoK5aaC5p6c55So5oi36ZyA6KaB5omT6IO96LCx77yM6K6p55So5oi36Ieq5bex55So56yU6K6w5b2V5LiL5oOz6KaB5omT6IO96LCx55qE5L2N572u77ybCgrlt6bovrnnlLXohJHvvJrngrnlh7vova/ku7blt6bkuIrop5Lpu5HoibLpg6jliIbvvIznlLXljovosIPmlbTliLAxNS4wa1bigJTigJTosIPmlbTlt6XkvZzot53nprvvvJrog73osLHpnIDopoHnmoTlt6XkvZzot53nprvkuLoxNW1t77yM5aaC5p6c5q2k5pe25b2i6LKM5Zu+5pi+56S65bel5L2c6Led56a75Li6eO+8jOWPs+S+p3rkuIvmlrnmmL7npLrlt6XkvZzot53nprvkuLp577yM5YiZ6ZyA6KaB5omL5Yqo5Zyo6L2v5Lu25Y+z5L6neuS4i+aWuei+k+WFpeW3peS9nOi3neemu++8iDE1LXgree+8ieKAlOKAlOWcqHjjgIF555qE5L2N572u5omL5Yqo6L6T5YWl55So5oi36K6w5b2V55qE5b6F5omT6IO96LCx55qE5L2N572u77yM56Gu5a6a4oCU4oCU6LCD5pW05aW95Yiw5ZCI6YCC55qE5pS+5aSn5YCN5pWw77ybCgrlj7PovrnnlLXohJHvvJrmiZPlvIDog73osLHova/ku7bvvIzlpoLmnpzmnInkuIrkuIDkuKrkurrpgZfnlZnnmoTmlbDmja7vvIzngrnlh7vlj5bmtojvvIzkuI3opoHngrnigJzmmK/igJ3miJbigJzlkKbigJ3vvIzkvJropobnm5bmjonkuIrkuIDkuKrkurrnmoTmlbDmja7igJTigJTpobnnm67lj6blrZjkuLrvvIzmib7liLDnlKjmiLfnmoTkuKrkurrmlofku7blpLnigJTigJTkvp3mrKHngrnlh7vikaDpnaLliIbluIPlm77ikaHmiavmj4/lm77lg48t5byA5aeL4pGi6YeH6ZuG5YiG5biD5Zu+5pWw5o2uLeW8gOWni+KRo+aehOW7uuWIhuW4g+WbvuaVsOaNruKRpOehruiupOWFg+e0oOKRpee8lui+keWIl+KAlOKAlOmdouenr+iuoeaVsOWIsOi+vjI1dyvml7blsLHlj6/ku6Xli77pgInlj7PkvqfljLox55qE5pa55qGG5Y+v5Lul5YGc5LqG4oCU4oCU5re75Yqg5oiW6ICF5Yig6Zmk5YWD57Sg77ya54K55Ye74oCc6K6h566X5oiQ5YiG4oCdIO+8jOeCueWHu+KAnOe8lui+keWIlyDigJ3vvIzlj6rli77pgIl3dCXjgIF3dCVzaWdtYeOAgeWOn+WtkOeZvuWIhuavlOi/meS4ieS4quWwseihjOKAlOKAlOmdouWIhuW4g+WbvuaooeW8j+S4i++8jOWPs+mUruaKpeWRiu+8jOi/veWKoOKAlOKAlHBvaW50SUTmqKHlvI/kuIvvvIzlj7PplK7miqXlkYrvvIzngrnlh7vov73liqDigJTigJTkv53lrZjlpb3mlofku7bigJTigJTmib7kuIvkuIDkuKrkvY3nva7miZPog73osLHmiJbogIXnu5PmnZ/igJTigJTlnKh1cGxvYWQgZGF0YeaWh+S7tuWkueS4i++8jOaWsOW7uueUqOaIt+mihOe6pue8luWPt+WRveWQjeeahOaWh+S7tuWkue+8jOWmgjI0MjQyMu+8iOatpOaWh+S7tuWkuemHjOmdouWPquiDveaUvuWNleS4quaWh+S7tuaIluiAheWOi+e8qeWMhe+8ie+8jOaKiuaWh+S7tuaUvuWIsOivpeaWh+S7tuWkueS4i+OAguazqO+8muaJk+WujOiDveiwse+8jOiDveiwseWIh+aNouWIsOW9ouiyjO+8jOS4gOWumuaKiueUteWOi+iwg+WbnuWIsDNrViEKNyDmjaLmoLflk4EK54K55Ye76L2v5Lu255qEaG9tZei/m+ihjOWkjeS9jeKAlOKAlOeCueWHu29mZuWFs+mXreeUteWOi+KAlOKAlOeCueWHu29wZW7miZPlvIDkuqTmjaLku5Ppl6jigJTigJTmjqjov5vmoLflk4HmnYbliLDmnIDph4zpnaLnm7TliLB4Y+etieS6rui1t+KAlOKAlGxvY2vplIHkvY/moLflk4Hlj7DigJTigJTmi4nlh7rmoLflk4HmnYbliLDmnIDlpJbpnaLkuI3opoHmnb7miYvvvIzmi4nliLDkvY3kvJrlkKzliLDlo7Dpn7PigJTigJTngrnlh7tjbG9zZeWFs+mXreS6pOaNouS7k+mXqO+8jOmXqOWFs+S4iuS6huWGjeadvuaJi+KAlOKAlOeCueWHu2FpcuiuqeS6pOaNouS7k+i/m+epuuawlO+8jOWujOaIkOWQjmFpcueBr+S4jemXqu+8jOWPmOaIkOm7hOiJsu+8jOW5tuS4lOacieWjsOmfs+aPkOekuuKAlOKAlOaLieW8gOS6pOaNouS7k+KAlOKAlOW3puaJi+aJtuS9j+agt+WTgeWPsO+8jOWPs+aJi3VubG9ja+agt+WTgeadhu+8jOW3puaJi+WPluS4i+agt+WTgeWPsO+8jOaKiuS6pOaNouS7k+aOqOi/m+WOu+KAlOKAlOaKiuS4i+S4gOS4quS6uueahOagt+WTgeWPsOaUvuWIsOmUgeWumuWZqOS4iuOAggoKOCDkuIrkvKDmlbDmja4K5YWz5o6J5b2i6LKM5oiW6ICF6IO96LCx77yI5YWzU0VN6L2v5Lu277yaZmlsZS1leGl0LW9rIO+8ieeahOi9r+S7tuKAlOKAlOWcqOS4u+acuuS4iuaPkuWFpee9keWNoeKAlOKAlOetieW+hXdpZmnov57mjqXliLAyLjRHSHrigJTigJTlj4zlh7vpu4ToibLnmoR1cGxvYWTova/ku7bigJTigJTngrnlh7vkuIrkvKDvvIjkuI3pnIDopoHlhajpgInvvInigJTigJTnrYnlvoXkuIrkvKDlrozmr5XigJTigJTlhbPmjol1cGxvYWTova/ku7bjgIIKCjkg5YWz5py6CuWFs+iDveiwseeUteiEke+8muWFs+aYvuekuuWxj+KAlOKAlOWFs+S4u+acuuWQjumdoueahOm7keiJsuaMiemSruWIsDDnmoTkvY3nva7vvJsK5YWz5b2i6LKM55S16ISR77ya5YWz5pi+56S65bGP4oCU4oCU5YWzZGlzcGxheeKAlOKAlOWFs+W+queOr+awtOOAggoxMCDlhbbku5bvvIjlhbPkuo7lj7DlvI/vvIkK5qC35ZOB5Y+w77ya56qE55qE5LiA5L6n5pyd5ZCR6Ieq5bex77yM6ZyA6KaB55So55m96Imy5p2/6YeP6auY77yM55S16ISR6L6T5YWl5pWw5o2u5q+U5a6e6ZmF5qC35ZOB5Y+w6auY5bqm6auYMW1t77ybCgrova/ku7bvvJrikaDliKDpmaTmjonkuIrkuIDkuKrkurrnmoTlm77niYfvvIzngrlyZW1vdmXvvIzkuI3opoHngrlkZWxldGXvvIzlnLrlj5HlsITlj6/ku6XngrlkZWxldGXvvJvikaHlhbPkuo7ml4vovazlm77lg4/vvIzlj7DlvI/li77pgIlvbu+8jOWcuuWPkeWwhOWLvumAiXJvdGF0aW9u77ybCgrnvZHljaHvvJrlj7DlvI/nmoTlvaLosozlkozlnLrlj5HlsITnmoTlvaLosozjgIHog73osLHlhbHnlKjkuIDkuKrnvZHljaHvvIzlj7DlvI/nmoTog73osLHljZXni6zkuIDkuKrnvZHljaHvvJsKCuiDveiwse+8muWPsOW8j+mcgOimgeWcqOiDveiwseeUteiEkeWPs+S4i+inkuaJi+WKqOi+k+WFpeaUvuWkp+WAjeeOh+OAgeW3peS9nOi3neemu+OAgeeUteWOi++8jOWcuuWPkeWwhOS4jemcgOimgeOAggrluIPpsoHlhYtEOCBYUkQKMS7lvIDmnLrlh4blpIfvvJrpppblhYjmj5LlhaXnlLXmupDnur/vvIzmj5LkuIrpkqXljJnlubbmi6jliLBPTuS9jee9ru+8jOetieW+heWxj+W5leS6rui1t+W5tuWHuueOsOiPnOWNleeVjOmdouOAguWQjOaXtu+8jOivt+ehruS/nVXnm5jvvIjnlKjkuo7nlJ/miJDlsYDln5/nvZHvvInlt7Lmj5LlhaXkuJTkuI3pnIDopoHmi5TkuIvvvIznhLblkI7ov57mjqXmoLflk4HmjK/ojaHlmajjgIIKMi7moLflk4HlpITnkIbvvJrku47moLflk4HkuIrliK7lj5bpgILph4/nsonmnKvvvIjnuqY1MG1n77yJ5bm26L+H562b44CC5L2/55So5Yiu5Yu65bCG57KJ5pyr6YCB5YWl5qC35ZOB5rGg77yM5LmL5ZCO56uW55u05oyv6I2h5Zmo6K6p57KJ5pyr6Ieq54S26JC95YWl6YCa6YGT5YaF44CCCjMu6ZyH6I2h6YCB5qC377ya6KOF5aW95oyv6I2h5Zmo5ZCO77yM5Zyo5Li76I+c5Y2V55WM6Z2i6YCJ5oup4oCcU0hBS0XigJ3lvIDlp4vpnIfojaHvvIzlsIbmoLflk4HpgIHlhaXmoLflk4HmsaDlhoXjgILmoLnmja7pnIDopoHpgInmi6nmjK/ojaHlipvluqbvvIzlvZPmoLflk4Hln7rmnKzlrozlhajov5vlhaXmoLflk4HmsaDlkI7vvIzlgZzmraLpnIfojaHjgIIKNC7ova/ku7blronoo4XkuI7mlbDmja7liIbmnpDvvJpYUkTmlbDmja7liIbmnpDova/ku7blkI3kuLrigJxYUG93ZGVy4oCd77yM5a6J6KOF56iL5bqP5L2N5LqO5Luq5Zmo6Ieq5bim55qEVeebmOS4reOAguWwhuWuieijheeoi+W6j+aLt+i0neiHs+iHquW3seeahOiuvuWkh+W5tui/m+ihjOWuieijhe+8jOWuieijheWujOaIkOWQjumcgOimgea/gOa0u+i9r+S7tuOAguS5i+WQjuWuieijheaVsOaNruW6k++8jOW5tuWwhuWQhOexu+aVsOaNruW6k+aLt+i0neiHs+i9r+S7tuWuieijheebruW9leeahOaMh+WumuaWh+S7tuWkueOAguaJk+W8gOi9r+S7tuWQju+8jOmAieaLqeWImuWImuWuieijheeahOaVsOaNruW6k++8jOW8gOWni+WIhuaekOaVsOaNruOAggo1LuWFs+acuuS4jua4heeQhu+8muS9v+eUqOaMr+iNoeWZqOmch+iNoeWKn+iDveWwhuagt+WTgeeyieacq+aMr+WHuu+8jOW/heimgeaXtueUqOWOi+e8qeawlOaequaIluieuuS4neWIgOa4heeQhuagt+WTgeaxoOOAguWcqOS7quWZqOiPnOWNleagj+S4remAieaLqeKAnHNodXQgZG93buKAneWFs+mXreacuuWZqO+8jOeEtuWQjuaLp+WKqOmSpeWMmeiHs09GRuS9jee9ru+8jOacgOWQjuaLlOWHuuaMr+iNoeWZqOe6v+WPiueUtea6kOe6v+OAggror7fnoa7kv53mjInnhafkuIrov7DmraXpqqTmraPnoa7mk43kvZzku6rlmajvvIzku6Xojrflvpflh4bnoa7nmoTliIbmnpDnu5PmnpzjgIIKCgrnsbvkvLzku6rlmajnmoTmoIflh4bmk43kvZzop4TnqIsoU09QKeaooeadv++8mgrmoIflh4YKCkEu5qC55o2u546v5aKD55qE5rSB5YeA56iL5bqm77yM5Y+v5a6a5pyf77yI5LiA6IisMu+9njPkuKrmnIjvvInlsIbnspfmu6TluIPmi4bkuIvmuIXmtJfkuojku6Xmm7TmjaLvvJsKCkIu5a6a5pyf77yI5LiA6Iis5Li65LiA5ZGo77yJ5a+56LaF5YeA5bel5L2c5Y+w546v5aKD6L+b6KGM54Gt6I+M77yM5ZCM5pe277yM57uP5bi455So57qx5biD5rK+5LiK6YWS57K+5oiW5LiZ6YWu5pyJ5py65rq25YmC5bCG57Sr5aSW5p2A6I+M54Gv5aSW6KGo6Z2i5o+p5pOm5bmy5YeA77yM5L+d5oyB6KGo6Z2i5riF5rSB77yM5ZCm5YiZ5Lya5b2x5ZON5p2A6I+M5pWI5p6c77ybCgpDLuW9k+WKoOWkp+mjjuacuueUteWOi+S4jeiDveS9v+aTjeS9nOmjjumAn+i+vuWIsDAuMzJtL3Pml7bvvIzlv4Xpobvmm7TmjaLpq5jmlYjnqbrmsJTov4fmu6TlmajvvJsKCkQu5pu05o2i6auY5pWI56m65rCU6L+H5ruk5Zmo5pe25Y+v5omT5byA6aG255uW77yM5pu05o2i5pe25bqU5rOo5oSP6L+H5ruk5Zmo5LiK55qE566t5aS05qCH5b+X77yM566t5aS05oyH5ZCR5Y2z5Li65bGC5rCU5rWB5rWB5ZCR77ybCgpFLuabtOaNoumrmOaViOepuuawlOi/h+a7pOawlOWQju+8jOW6lOeUqOWwmOWfg+eykuWtkOiuoeaVsOWZqOajgOafpeWbm+WRqOi+ueahhuWvhuWwgeaYr+WQpuiJr+Wlve+8jOiwg+iKgumjjuacuueUteWOi++8jOS9v+aTjeS9nOW5s+Wdh+mjjumAn+S/neaMgeWcqDAuMzLvvZ4wLjQ4bS9z6IyD5Zu05YaF77yM5YaN5pyJ55SoWTA5LTTlnovlsJjln4PnspLlrZDorqHmlbDlmajmo4Dmn6XmtIHlh4DluqbjgIIKCuaTjeS9nOinhOeoi++8mgoKQS7kvb/nlKjlt6XkvZzlj7Dml7bvvIzlupTmj5DliY0x5bCP5pe25byA5py677yM5ZCM5pe25byA5ZCv57Sr5aSW54Gt6I+M54Gv77yM5aSE55CG5pON5L2c5Yy65YaF6KGo6Z2i56ev57Sv55qE5b6u55Sf54mp77yM5LiJ5Y2B5YiG6ZKf5ZCO5YWz6Zet5p2A6I+M54Gv77ybCgpCLuaWsOWuieijheeahOaIlumVv+acn+acquS9v+eUqOeahOW3peS9nOWPsO+8jOS9v+eUqOWJjeW/hemhu+WvueW3peS9nOWPsOWSjOWRqOWbtOeOr+Wig+WFiOeUqOi2heWHgOecn+epuuWQuOWwmOWZqOaIlueUqOS4jeS6p+eUn+e6pOe7tOeahOW3peWFt+i/m+ihjOa4hea0geW3peS9nOWPsO+8jOWGjemHh+eUqOiNr+eJqeeBreiPjOazleWSjOe0q+Wklue6v+eBreiPjOazlei/m+ihjOeBreiPjOWkhOeQhu+8mwoKQy7mk43kvZzljLrlhoXkuI3lhYHorrjlrZjmlL7kuI3lv4XopoHnmoTnianlk4HvvIzku6Xkv53mjIHmk43kvZzljLrnmoTmtIHlh4DmsJTmtYHmtYHlnovkuI3lj5flubLmibDvvJsKCkQu5pON5L2c5Yy65YaF5bqU5bC96YeP6YG/5YWN5L2c5piO5pi+5omw5Lmx5rCU5rWB5rWB5Z6L55qE5Yqo5L2c77ybRS7mk43kvZzljLrlhoXnmoTkvb/nlKjmuKnluqbkuI3lvpflpKfkuo42MOKEg+OAggoKCn3lrp7pqozlrqTlt7LmnInnmoTmk43kvZzop4TojIPmlofmoaPvvJoKCgrkuIDjgIHlrp7pqozlrqTlrojliJkKCjHjgIHov5vlhaXlrp7pqozlrqTlt6XkvZzml7bvvIzlv4Xpobvnqb/lt6XkvZzmnI3vvIznprvlvIDlrp7pqozlrqTml7blupTohLHkuIvjgILlt6XkvZzmnI3lupTnu4/luLjkv53mjIHmlbTmtIHvvIznpoHmraLnqb/lt6XkvZzmnI3ov5vlhaXlhazlhbHlnLrmiYDjgILlnKjov5vooYzku7vkvZXmnInlj6/og73norDkvKTjgIHliLrmv4DmiJbng6fkvKTnnLznnZvnmoTlt6XkvZzml7bvvIzlv4XpobvmiLTpmLLmiqTnnLzplZzjgILnu4/luLjmjqXop6bmtZPphbjjgIHmtZPnorHnmoTlt6XkvZzkurrlkZjvvIzlupTmiLTog7bluIPmiYvlpZflj4rlt6XkvZzluL3vvIzor5XmoLfliqDlt6Xmk43kvZzml7bkuI3lvpfmiLTmiYvlpZfjgIIKCjLjgIHnpoHmraLlnKjlrp7pqozlrqTlhoXlkLjng5/lj4rlkIPkuJzopb/jgILkuI3lh4bkvb/nlKjor5Xpqozlmajnmr/kvZzojLbmna/miJbppJDlhbfvvIzkuI3lvpfnlKjlmLTlt7Tlk4HlsJ3lkbPpgZPnmoTmlrnms5XmnaXpibTliKvmnKrnn6XnianjgIIKCjPjgIHlt6XkvZzlrozmr5XlkI7nprvlvIDlrp7pqozlrqTml7blupTnlKjogqXnmoLmtJfmiYvjgIIKCjTjgIHlrp7pqozlrqTlgZzmraLkvpvnlLXjgIHkvpvmsLTml7blupTlsIbmsLTmupDjgIHnlLXmupDlvIDlhbPlhajpg6jlhbPkuIrvvIzku6XpmLLmgaLlpI3kvpvnlLXjgIHkvpvmsLTml7bnlLHkuo7lvIDlhbPmnKrlhbPogIzlj5HnlJ/kuovmlYXjgILnprvlvIDlrp7pqozlrqTml7blupTmo4Dmn6Xpl6jjgIHnqpfjgIHmsLTjgIHnlLXjgIHmsJTmmK/lkKblronlhajlj4rlhbPpl63jgIIKCjXjgIHlrp7pqozlrqTlhoXnmoTmr4/nk7bor5XliYLlv4XpobvotLTmnInmmI7mmL7nmoTkuI7or5XliYLnm7jnrKbnmoTmoIfnrb7jgIHlubbmoIfmmI7or5XliYLlkI3np7DjgIHmtZPluqblj4rphY3liLbml6XmnJ/miJbmoIflrprml6XmnJ/jgIIKCjbjgIHpq5jmuKnniankvZPvvIjkvovlpoLliJrnlLHpq5jmuKnngonkuK3lj5blh7rnmoTlnanln5rlkoznk7foiJ/opoHmlL7lnKjlubLlh4DnmoTogJDngavnn7Pmo4nmnb/vvInkuIrmiJbnk7fnm5jkuK3pmYTov5HkuI3lvpfmnInmmJPnh4PnianjgILpnIDnp7Dph4/nmoTlnanln5rlvoXnqI3lhrflkI7mlrnlj6/np7voh7PlubLnh6XlmajkuK3lhrfljbTjgIIKCjfjgIHmk43kvZzml7bkvJrkuqfnlJ/mnInlrrPmsJTkvZPjgIHng5/pm77miJbnsonlsJjml7bvvIzlv4XpobvlnKjoia/lpb3nmoTpgJrpo47mn5zlhoXov5vooYzjgIIKCjjjgIHlrp7pqozlrqTnmoTku6rlmajlnKjmnKrmjozmj6Hlronlhajmk43kvZzop4TnqIvliY3kuI3lvpfpmo/mhI/liqjnlKjjgIIKCuS6jOOAgeeUteWZqOOAgeaYk+eHg+OAgeaYk+eIhgoK77yI5LiA77yJ55S15Zmo5a6J5YWo5pON5L2c6KeE56iLCgox44CB5a6e6aqM5a6k5YaF5LiN5b6X5pyJ6KO46Zyy55qE55S157q/44CB6Ze45YiA5byA5YWz5bqU5a6M5YWo5ZCI5LiK5oiW5pat5byA77yM5Lul6Ziy5q2i5o6l6Kem5LiN5aW95Lqn55Sf54Gr6Iqx6L+b6ICM5byV6LW35piT54eD54mp55qE54iG54K477yM5ouU5LiL5o+S5aS05pe25bqU55So5omL5o2P5L2P5o+S5aS05YaN5ouU77yM5LiN5b6X5omv5ouJ55S157q/44CCCgoy44CB5ZCE56eN55S15Zmo6K6+5aSH5Y+K55S157q/5bqU5aeL57uI5L+d5oyB5bmy54el77yM5LiN5b6X5rW45rm/77yM5Lul6Ziy55+t6Lev5byV6LW354Gr54G+5oiW54On5Z2P55S15Zmo6K6+5aSH44CCCgoz44CBIOWQhOexu+eUteWZqOiuvuWkh+WPkeeUn+W8guW4uOaIluaVhemanOaXtu+8jOW6lOWPiuaXtuaWreeUte+8jOeUseS4k+S4muS6uuWRmOajgOS/ruOAggoKNOOAgSDkv53pmankuJ3nhpTmlq3ml7bvvIzlupTmn6XmuIXljp/lm6DvvIzkuI3lvpfku7vmhI/lop7liqDmiJbliqDnspfkv53pmankuJ3vvIzmm7TkuI3lvpfku6Xpk5zkuJ3ku6Pmm7/jgIIKCu+8iOS6jO+8ieawp+awlOOAgea2suWMluawlOeTtueahOWuieWFqOS9v+eUqOinhOeoiwoKMeOAgeawp+awlOOAgea2suWMluawlOaYr+W8uueDiOeahOWKqeeHg+awlOS9k++8jOawp+awlOOAgea2suWMluawlOeTtuS4gOWumuimgeS4pemYsuS4juayueiEguaOpeinpuOAguW8gOWQr+awp+awlOOAgea2suWMluawlOeTtueahOaJs+aJi+S4jeW+l+ayvuacieayueiEguOAggoKMuOAgeaQrOi/kOawp+awlOOAgea2suWMluawlOeTtuaXtu+8jOW6lOWFiOijheS4iuWuieWFqOW4ve+8jOS4jeWPr+S9v+awlOS9k+WPl+WIsOmch+WKqOaIluaSnuWHu++8jOS7pemYsuatoueIhueCuOOAggoKM+OAgeW9k+awp+awlOOAgea2suWMluawlOeTtuS4uuerluebtOaUvue9ruaXtu+8jOW/hemhu+WbuuWumuaLtOeJouOAggoKNOOAgeawp+awlOOAgea2suWMluawlOeTtuS4jeW+l+S4jueUtee6v+aOpeinpu+8jOS5n+S4jeW+l+aUvuWcqOmdoOi/keWKoOeDreWZqOOAgeaYjueBq+aIluaaluawlOmZhOi/ke+8jOS7peWPiumYs+WFieebtOWwhOeahOWcsOaWue+8jOS7pemYsuatouawlOS9k+WPl+eDreiGqOiDgOW8lei1t+eIhueCuOOAggoKNeOAgeW8gOWQr+WOi+WKm+ihqOmYgOmXqOaXtuimgee8k+aFou+8jOawlOa1geS4jeWPr+WkquW/q++8jOS7pemYsuWGsuWdj+S7quWZqOaIluW8lei1t+edgOeBq++8jOeIhueCuOOAggoK5LiJ44CB54Gt54Gr5LiO5oCl5pWRCgrvvIjkuIDvvInnga3ngasKCjHjgIHlrp7pqozlrqTlpLHngavlkI7vvIzkuIDlrpropoHmsonnnYDjgIHkuI3opoHmg4rmhYzvvIzopoHmoLnmja7otbfngavljp/lm6DkuI7ngavlir/lpKflsI/vvIzlj4rml7bph4flj5bku6XkuIvmjqrmlr3vvJoKCjLjgIHnq4vljbPlhbPmjonnlLXmupDjgIHmsJTmupDlj4rpgJrpo47mnLoKCjPjgIHlsIblrqTlhoXmmJPnh4PjgIHmmJPniIbnianvvIjkvovlpoLljovnvKnmsJTnk7bvvInlsI/lv4PmkKznprvngavmupDvvIzms6jmhI/mkKzliqjml7bliIfkuI3lj6/norDmkp7vvIzku6XlhY3lvJXotbfmm7TlpKfngavngb7jgIIKCjTjgIHov4XpgJ/pgInnlKjpgILlvZPnmoTnga3ngavlmajvvIzlsIbliJrotbfnmoTngavmiZHnga3jgILms6jmhI/kuI3opoHnlKjmsLTmnaXmiZHnga3kuI3murbkuo7msLTnmoTmsrnnsbvku6Xlj4rlhbbku5bmnInmnLrmurbliYLnrYnlj6/nh4PnianjgIIKCjXjgIHlj4rml7bmiqXorabvvJrlronlhajkv53ljavnlLXor53vvJowODcxLTY1OTM3MTEwIOeBq+itpueUteivnTExOeOAggoKNuOAgei6q+S4iuiho+acjeedgOeBq+aXtu+8jOWIh+S4jeWPr+S7u+aEj+i3keWKqOOAguW6lOeUqOefs+ajieavr+ijueWcqOi6q++8jOS7pemalOe7neepuuawlOiAjOeBreeBq+OAguWmguaXoOefs+ajieavr+aIluiWhOavr+aXtu+8jOWPr+WwseWcsOi6uuS4i+aJk+a7muS7peeBreeBq+OAggoKN+OAgeWunumqjOWupOW6lOijheWkh+W/heimgeeahOeBreeBq+iuvuWkh+OAggoKLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKV3JpdGUgYW4gYWJzdHJhY3QgZm9yIHRoaXMgcGFwZXIgb24gdGhlIGRlc2lnbiBvZiBhIHNvZnR3YXJlIHRlc3RpbmcgYXV0b21hdGlvbiBmcmFtZXdvcmsgZm9yICoqMS4gSW50cm9kdWN0aW9uKioKClNvIGZhciwgdGhlIHJhcGlkIGRldmVsb3BtZW50IG9mIGluZm9ybWF0aW9uIHRlY2hub2xvZ3kgaGFzIGxlZCB0byB0aGUgYXBwbGljYXRpb24gb2Ygc29mdHdhcmUgcHJvZHVjdHMgaW4gdmFyaW91cyBzZWN0b3JzIG9mIHNvY2lldHkuIE5hdHVyYWxseSwgdGhlIHF1YWxpdHkgb2Ygc29mdHdhcmUgcHJvZHVjdHMgaGFzIGJlY29tZSBhIGNvbW1vbiBmb2N1cyBvZiBhdHRlbnRpb24uIFRvIGVuc3VyZSBwcm9kdWN0IHF1YWxpdHksIHNvZnR3YXJlIHRlc3Rpbmcgd2lsbCByZW1haW4gYW4gZWZmZWN0aXZlIG1ldGhvZCBmb3Igc29mdHdhcmUgcHJvZHVjdCBxdWFsaXR5IGFzc3VyYW5jZSBmb3IgYSBsb25nIHRpbWUgaW4gdGhlIGZ1dHVyZS4gQXV0b21hdGVkIHRlc3RpbmcgaXMgYSB3aWRlbHkgZGlzY3Vzc2VkIGRpcmVjdGlvbiBpbiB0b2RheSdzIHNvZnR3YXJlIHRlc3RpbmcgaW5kdXN0cnkuIEN1cnJlbnRseSwgcGVyZm9ybWFuY2UgdGVzdGluZyBhdXRvbWF0aW9uIGlzIHRoZSBtb3N0IG1hdHVyZSBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgaW5kdXN0cnkuIEFzIGZvciBzeXN0ZW0gdGVzdGluZyBhdXRvbWF0aW9uLCBpbmNsdWRpbmcgVUkgdGVzdGluZyBhdXRvbWF0aW9uLCB1bml0IHRlc3RpbmcgYXV0b21hdGlvbiwgYW5kIGZ1bmN0aW9uYWwgdGVzdGluZyBhdXRvbWF0aW9uLCBhbHRob3VnaCBwb3dlcmZ1bCB0aGlyZC1wYXJ0eSBzb2Z0d2FyZSB0ZXN0aW5nIHRvb2xzIHN1Y2ggYXMgUVRQLCBXSU5SVU5ORVIsIGFuZCBTRUxFTklVTSBjYW4gYmUgdXNlZCBhcyBzb2x1dGlvbnMsIGluIHByYWN0aWNlLCBjb21wYW5pZXMgZmluZCBpdCBkaWZmaWN1bHQgdG8gc3VjY2Vzc2Z1bGx5IGltcGxlbWVudCB0ZXN0IGF1dG9tYXRpb24gcmVseWluZyBvbiBhIHNpbmdsZSB0b29sLiBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoZSBsYWNrIG9mIGEgY29tcGxldGUgc2V0IG9mIHRlc3QgYXV0b21hdGlvbiBzb2x1dGlvbnMsIGkuZS4sIHRoZSBhYnNlbmNlIG9mIGEgdGVzdGluZyBmcmFtZXdvcmsuIFRoZXJlZm9yZSwgbW9yZSBtYW5wb3dlciBpcyBvZnRlbiByZXF1aXJlZCB0byBsZWFybiBob3cgdG8gdXNlIHRoZSB0b29scywgd3JpdGUgY29tcGxleCB0ZXN0IHNjcmlwdHMsIG1hbnVhbGx5IG9idGFpbiB0ZXN0IHJlc3VsdHMgYW5kIGFuYWx5emUgdGhlbSwgYW5kIGRlYWwgd2l0aCB0aGUgZGFtYWdlIGNhdXNlZCBieSBjaGFuZ2VzIGluIHByb2plY3QgcGVyc29ubmVsLiBIZW5jZSwgYnVpbGRpbmcgYSBjb21wbGV0ZSB0ZXN0IGF1dG9tYXRpb24gZnJhbWV3b3JrIGlzIGFuIGluZXZpdGFibGUgdHJlbmQuIAoKQW4gYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3JrIGlzIGEgY29tcHJlaGVuc2l2ZSBzb2x1dGlvbiBmb3IgdGVzdCBhdXRvbWF0aW9uLCBwbGF5aW5nIGEga2V5IHJvbGUgaW4gdGhlIHNwZWNpZmljIHdvcmsgb2Ygc29mdHdhcmUgdGVzdCBhdXRvbWF0aW9uLiBUaGUgaW5kdXN0cnkgaXMgYWN0aXZlbHkgY29uc3RydWN0aW5nIGF1dG9tYXRlZCB0ZXN0aW5nIGZyYW1ld29ya3MgdGFpbG9yZWQgdG8gdGhlIG5lZWRzIG9mIHRoZWlyIHJlc3BlY3RpdmUgY29tcGFuaWVzLiBDb21tb25seSBtZW50aW9uZWQgYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3JrcyBpbiB0aGUgaW5kdXN0cnkgaW5jbHVkZSBkYXRhLWRyaXZlbiBhdXRvbWF0ZWQgdGVzdGluZyBmcmFtZXdvcmtzLCBrZXl3b3JkLWRyaXZlbiB0ZXN0aW5nIGZyYW1ld29ya3MsIGFuZCB0YWJsZS1kcml2ZW4gYXV0b21hdGVkIHRlc3RpbmcgZnJhbWV3b3Jrcy4gVGhlc2UgdGVzdGluZyBmcmFtZXdvcmtzIGltcHJvdmUgdGVzdGluZyBlZmZpY2llbmN5IGluIGNlcnRhaW4gc3RhZ2VzIG9mIHNvZnR3YXJlIHRlc3RpbmcsIGJ1dCBhbHNvIGludHJvZHVjZSBvdGhlciBpc3N1ZXMuIFRoaXMgYXJ0aWNsZSBhcmd1ZXMgdGhhdCB0ZXN0aW5nIGZyYW1ld29ya3Mgc2hvdWxkIG5vdCBiZSBkZXNpZ25lZCBmb3Igc3BlY2lmaWMgdGVzdGluZyBhY3Rpdml0aWVzIGJ1dCBzaG91bGQgYmUgY2F0ZWdvcml6ZWQgYWNjb3JkaW5nIHRvIGRldmVsb3BtZW50IHR5cGVzLCB3aGljaCBpcyBhIG1vcmUgcmVhc29uYWJsZSBhcHByb2FjaC4gVGhpcyBwYXBlciBwcm9wb3NlcyBhIHRlc3QgZnJhbWV3b3JrIHN1aXRhYmxlIGZvciBpdGVyYXRpdmUgZGV2ZWxvcG1lbnQuCgoqKjIuIERlc2lnbiBvZiB0aGUgU29mdHdhcmUgVGVzdGluZyBBdXRvbWF0aW9uIEZyYW1ld29yayBCYXNlZCBvbiBJdGVyYXRpdmUgU29mdHdhcmUgRGV2ZWxvcG1lbnQqKgoKKioyLjEgU29mdHdhcmUgVGVzdCBBdXRvbWF0aW9uKioKCkN1cnJlbnRseSwgc29mdHdhcmUgdGVzdCBhdXRvbWF0aW9uIHJlZmVycyB0byB0aGUgdXNlIG9mIHByb2dyYW0gZXhlY3V0aW9uIHRvIHJlcGxhY2UgbWFudWFsIHRlc3RpbmcsIHRodXMgcmVkdWNpbmcgbWFudWFsIHdvcmtsb2FkIGFuZCBpbXByb3ZpbmcgdGVzdGluZyBlZmZpY2llbmN5LiBBdXRvbWF0ZWQgdGVzdGluZyBmcmFtZXdvcmtzIGFyZSBjb21wcmVoZW5zaXZlIHNvbHV0aW9ucyB0aGF0IGFjaGlldmUgaGlnaC1lZmZpY2llbmN5LCBoaWdoLXF1YWxpdHkgYXV0b21hdGVkIHRlc3RpbmcuIEl0ZXJhdGl2ZSBkZXZlbG9wbWVudCBpcyBhIGdyYWR1YWwgZGV2ZWxvcG1lbnQgbWV0aG9kIHRoYXQgZGl2aWRlcyB0aGUgZW50aXJlIGRldmVsb3BtZW50IHByb2Nlc3MgaW50byBzZXZlcmFsIGl0ZXJhdGl2ZSBjeWNsZXMsIHdpdGggZWFjaCBjeWNsZSBwcm9kdWNpbmcgYSBydW5uYWJsZSBzb2Z0d2FyZS4gSXRlcmF0aXZlIGRldmVsb3BtZW50IGlzIHRoZSBtb3N0IHN1aXRhYmxlIGRldmVsb3BtZW50IGFjdGl2aXR5IGZvciB0ZXN0IGF1dG9tYXRpb24gYW5kIGNhbiBtYXhpbWl6ZSB0aGUgYmVuZWZpdHMgb2YgYXV0b21hdGVkIHRlc3RpbmcuIAoKSW4gaXRlcmF0aXZlIGRldmVsb3BtZW50LCBlYWNoIHNvZnR3YXJlIGRldmVsb3BtZW50IGN5Y2xlIGFkZHMgbmV3IGZlYXR1cmVzLCB3aGVyZSB0ZXN0ZXJzIGRlc2lnbiB0ZXN0cyBmb3IgdGhlIG5ldyBmZWF0dXJlcywgdHJhbnNpdGlvbiB0byBmdW5jdGlvbmFsIHZlcmlmaWNhdGlvbiwgZXhlY3V0ZSB0ZXN0cyBmb3IgbmV3IGZlYXR1cmVzLCBhbmQgcGVyZm9ybSByZWdyZXNzaW9uIHRlc3RpbmcgZm9yIGlzc3VlcyBkaXNjb3ZlcmVkIGluIHRoZSBwcmV2aW91cyByb3VuZCBvZiB0ZXN0aW5nLiBJbiB0aGVzZSB0ZXN0aW5nIGFjdGl2aXRpZXMsIGFjdGl2aXRpZXMgc3VjaCBhcyB0ZXN0IHZlcmlmaWNhdGlvbiwgbmV3IGZlYXR1cmUgdGVzdGluZywgYW5kIHJlZ3Jlc3Npb24gdGVzdGluZyBhcmUgZWFzeSB0byBhdXRvbWF0ZSBhbmQgc3VpdGFibGUgZm9yIGF1dG9tYXRpb24uIAoKSW4gdGhlIHRlc3RpbmcgcHJvY2VzcyAoYXMgc2hvd24gaW4gRmlndXJlIDEpOgoKMS4gQWZ0ZXIgdmVyc2lvbiB0cmFuc2l0aW9uIHRlc3RpbmcsIGZ1bmN0aW9uYWwgdmVyaWZpY2F0aW9uIGlzIGNvbmR1Y3RlZCBmaXJzdCB0byBwcm92ZSB0aGF0IG5vIG5ldyBzZXJpb3VzIGlzc3VlcyBoYXZlIGJlZW4gaW50cm9kdWNlZCBpbiB0aGUgdHJhbnNpdGlvbmVkIHZlcnNpb24uIEFwcHJvcHJpYXRlIHRlc3QgY2FzZXMgYXJlIHNlbGVjdGVkIGZyb20gdGhlIHNjcmlwdCBsaWJyYXJ5IGZvciB0ZXN0aW5nLgoyLiBSZWdyZXNzaW9uIHRlc3RpbmcgaXMgcGVyZm9ybWVkIGZvciBkZWZlY3RzIGZvdW5kIGluIHRoZSBwcmV2aW91cyBzdGFnZS4gVGhlIHVzZSBvZiBwcmV2aW91cyBzY3JpcHRzIGNhbiBwcmV2ZW50IHRoZSBhcmJpdHJhcmluZXNzIG9mIG1hbnVhbCB0ZXN0aW5nIGFuZCBhY2hpZXZlIGEgY29tcGxldGVseSByZXN0b3JlZCBvbi1zaXRlIHNjZW5hcmlvLgozLiBOZXcgZnVuY3Rpb25hbGl0eSBpcyB0ZXN0ZWQgdXNpbmcgbmV3IHRlc3Qgc2NyaXB0cy4gQWZ0ZXIgdGVzdGluZywgdGhlIG5ldyBmZWF0dXJlIHNjcmlwdHMgYXJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBzY3JpcHQgbGlicmFyeSBmb3IgdGhlIG5leHQgcm91bmQgb2YgdHJhbnNpdGlvbiB0ZXN0aW5nIGFuZCByZWdyZXNzaW9uIHRlc3RpbmcuCgoqKkZpZ3VyZSAxKioKCkNsZWFybHksIHRlc3Qgc2NyaXB0cyBhcmUgcnVuIG11bHRpcGxlIHRpbWVzIHRocm91Z2hvdXQgdGhlIGVudGlyZSBpdGVyYXRpdmUgcHJvY2VzcywgbWFraW5nIHRoZWlyIHVzYWdlIGhpZ2hseSBlZmZpY2llbnQsIHdoaWNoIGRpcmVjdGx5IGltcHJvdmVzIHRoZSBvdXRwdXQtdG8taW5wdXQgcmF0aW8gb2YgYXV0b21hdGVkIHRlc3RpbmcuCgoqKjIuMiBEZXNpZ24gb2YgU29mdHdhcmUgVGVzdGluZyBBdXRvbWF0aW9uIEZyYW1ld29yayoqCgpUaGUgc29mdHdhcmUgdGVzdGluZyBhdXRvbWF0aW9uIGZyYW1ld29yayBpcyBhIGNvbXByZWhlbnNpdmUgc29sdXRpb24gZm9yIHRlc3QgYXV0b21hdGlvbiwgcHJvdmlkaW5nIGEgY29tcGxldGUgc2V0IG9mIHRlc3RpbmcgYWN0aXZpdGllcy4gSXQgY2VudHJhbGl6ZXMsIHNwZWNpYWxpemVzLCBhbmQgYWJzdHJhY3RzIHRoZSB3b3JrIG9mIHRlc3RlcnMuIEluIHRoZSB0ZXN0aW5nIGZyYW1ld29yaywgdGhlIHdvcmsgb2YgdGVzdGVycyBpcyBhcyBzaG93biBpbiBGaWd1cmUgMjoKCjEuICoqVGVzdCBEZXNpZ24qKjogVGVzdGVycyB1c2UgdmFyaW91cyB0ZXN0IGRlc2lnbiBtZXRob2RzIHN1Y2ggYXMgZXF1aXZhbGVuY2UgY2xhc3MgcGFydGl0aW9uaW5nLCBib3VuZGFyeSB2YWx1ZSBhbmFseXNpcywgYW5kIGNhdXNlLWVmZmVjdCBncmFwaGluZyB0byBjcmVhdGUgZGVzaWduIHBsYW5zIGFuZCB0ZXN0IGNhc2VzLCBhbmQgdXBsb2FkIHRoZSB0ZXN0IGNhc2VzIHRvIHRoZSB0ZXN0aW5nIGZyYW1ld29yay4KMi4gKipSZXN1bHQgQW5hbHlzaXMqKjogQW5hbHl6ZSB0aGUgdGVzdCByZXN1bHRzIGZlZWRiYWNrIGZyb20gZXhlY3V0aW5nIHRoZSB0ZXN0IGNhc2VzIGluIHRoZSB0ZXN0aW5nIGZyYW1ld29yay4KClRvIHJlbGlldmUgdGVzdGVycyBmcm9tIHRoZSBjb21wbGV4aXR5IG9mIHZhcmlvdXMgdGVzdGluZyBhY3RpdmkuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgoqKkRlc2lnbiBhbmQgT3B0aW1pemF0aW9uIG9mIEludGVsbGlnZW50IE1hbnVmYWN0dXJpbmcgU3lzdGVtcyBCYXNlZCBvbiBBcnRpZmljaWFsIEludGVsbGlnZW5jZSBUZWNobm9sb2d5KiogIAoKIyMjIDEgQW5hbHlzaXMgb2YgQUkgQXBwbGljYXRpb25zIGluIE1hbnVmYWN0dXJpbmcgIAoKIyMjIyAxLjEgVmlzdWFsIEluc3BlY3Rpb24gYW5kIERlZmVjdCBSZWNvZ25pdGlvbiAgCkluIHRoZSBmaWVsZCBvZiBtYW51ZmFjdHVyaW5nLCB2aXN1YWwgaW5zcGVjdGlvbiBhbmQgZGVmZWN0IHJlY29nbml0aW9uIHRlY2hub2xvZ2llcyBoYXZlIGJlZW4gZGV2ZWxvcGluZyByYXBpZGx5LiBUaGVzZSB0ZWNobm9sb2dpZXMgbGV2ZXJhZ2UgaW1hZ2UgcHJvY2Vzc2luZyBhbmQgbWFjaGluZSB2aXNpb24gcHJpbmNpcGxlcyB0byBlZmZpY2llbnRseSBhbmQgYWNjdXJhdGVseSBpZGVudGlmeSBkZWZlY3RzIG9uIHRoZSBzdXJmYWNlIG9yIGluc2lkZSBvZiBwcm9kdWN0cyB3aXRob3V0IGh1bWFuIGludGVydmVudGlvbiwgZW5zdXJpbmcgcHJvZHVjdCBxdWFsaXR5LiBXaXRoIHRoZSBhcHBsaWNhdGlvbiBvZiBkZWVwIGxlYXJuaW5nIHRlY2hub2xvZ3ksIHRoZSByZWNvZ25pdGlvbiBjYXBhYmlsaXRpZXMgb2YgdmlzdWFsIGluc3BlY3Rpb24gc3lzdGVtcyBoYXZlIGdyZWF0bHkgaW1wcm92ZWQuIFRoZXkgY2FuIGRldGVjdCBldmVuIHRoZSBzbWFsbGVzdCBmbGF3cyBhbmQgb3BlcmF0ZSByZWxpYWJseSBpbiBjb21wbGV4IGluZHVzdHJpYWwgZW52aXJvbm1lbnRzLiAgCgpGb3IgZXhhbXBsZSwgaW4gdGhlIGVsZWN0cm9uaWNzIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnksIHZpc3VhbCBpbnNwZWN0aW9uIHN5c3RlbXMgY2FuIGlkZW50aWZ5IHRpbnkgY3JhY2tzIGFuZCBzb2xkZXJpbmcgaXNzdWVzIG9uIHByaW50ZWQgY2lyY3VpdCBib2FyZHMsIGVuc3VyaW5nIHRoZSBmdW5jdGlvbmFsaXR5IGFuZCBzYWZldHkgb2YgZWxlY3Ryb25pYyBwcm9kdWN0cy4gV2l0aCBpbmNyZWFzZWQgY29tcHV0aW5nIHBvd2VyIGFuZCBvcHRpbWl6ZWQgYWxnb3JpdGhtcywgdmlzdWFsIGluc3BlY3Rpb24gdGVjaG5vbG9neSBoYXMgYWxzbyBtYWRlIHNpZ25pZmljYW50IHByb2dyZXNzIGluIGltcHJvdmluZyBkZXRlY3Rpb24gc3BlZWQgYW5kIGFjY3VyYWN5LiBCeSBwcm9jZXNzaW5nIGxhcmdlIGFtb3VudHMgb2YgaW1hZ2UgZGF0YSBpbiByZWFsIHRpbWUsIHRoZXNlIHN5c3RlbXMgY2FuIHF1aWNrbHkgcHJvdmlkZSBkZXRlY3Rpb24gcmVzdWx0cywgZ3JlYXRseSBlbmhhbmNpbmcgcHJvZHVjdGlvbiBsaW5lIGVmZmljaWVuY3kuICAKCkluIHRoZSBhdXRvbW90aXZlIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnksIHZpc3VhbCBpbnNwZWN0aW9uIHRlY2hub2xvZ3kgaXMgd2lkZWx5IHVzZWQgZm9yIGNoZWNraW5nIHRoZSBxdWFsaXR5IG9mIGNhciBib2R5IGNvYXRpbmdzLCBhY2N1cmF0ZWx5IGlkZW50aWZ5aW5nIGlzc3VlcyBzdWNoIGFzIHVuZXZlbiBjb2F0aW5nIHRoaWNrbmVzcyBhbmQgY29sb3IgaW5jb25zaXN0ZW5jaWVzLiAgCgojIyMjIDEuMiBQcmVkaWN0aXZlIE1haW50ZW5hbmNlIGFuZCBGYXVsdCBEaWFnbm9zaXMgIApQcmVkaWN0aXZlIG1haW50ZW5hbmNlIGFuZCBmYXVsdCBkaWFnbm9zaXMgcGxheSBhIGNydWNpYWwgcm9sZSBpbiBtb2Rlcm4gbWFudWZhY3R1cmluZy4gQnkgbGV2ZXJhZ2luZyBiaWcgZGF0YSBhbmFseXNpcyBhbmQgbWFjaGluZSBsZWFybmluZyBhbGdvcml0aG1zLCB0aGVzZSB0ZWNobm9sb2dpZXMgY2FuIGFjY3VyYXRlbHkgcHJlZGljdCBwb3RlbnRpYWwgZXF1aXBtZW50IGZhaWx1cmVzLCBlbmFibGluZyBwcm9hY3RpdmUgbWFpbnRlbmFuY2UgdG8gcHJldmVudCBwcm9kdWN0aW9uIGRpc3J1cHRpb25zIGFuZCBlY29ub21pYyBsb3NzZXMuIFRoaXMgYXBwcm9hY2ggc2hpZnRzIGZyb20gdHJhZGl0aW9uYWwgcmVhY3RpdmUgbWFpbnRlbmFuY2UgdG8gYSBtb3JlIHByb2FjdGl2ZSBtYWludGVuYW5jZSBzdHJhdGVneSwgZWZmZWN0aXZlbHkgZXh0ZW5kaW5nIGVxdWlwbWVudCBsaWZlc3BhbiBhbmQgaW1wcm92aW5nIHByb2R1Y3Rpb24gZWZmaWNpZW5jeS4gIAoKRm9yIGV4YW1wbGUsIGluIGhlYXZ5IGluZHVzdHJpZXMsIHByZWRpY3RpdmUgbWFpbnRlbmFuY2Ugc3lzdGVtcyBjYW4gbW9uaXRvciBwYXJhbWV0ZXJzIHN1Y2ggYXMgZXF1aXBtZW50IHZpYnJhdGlvbiwgdGVtcGVyYXR1cmUsIGFuZCBzb3VuZCB0byBkZXRlY3QgYW5vbWFsaWVzIGluIHJlYWwgdGltZSBhbmQgaW50ZXJ2ZW5lIGJlZm9yZSBwcm9ibGVtcyBlc2NhbGF0ZS4gV2l0aCBjb250aW51b3VzIGFkdmFuY2VtZW50cyBpbiB0ZWNobm9sb2d5LCBmYXVsdCBkaWFnbm9zaXMgc3lzdGVtcyBoYXZlIHNpZ25pZmljYW50bHkgaW1wcm92ZWQgaW4gcHJlZGljdGlvbiBhY2N1cmFjeSBhbmQgcmVzcG9uc2Ugc3BlZWQuIFRoZXNlIHN5c3RlbXMgYW5hbHl6ZSBoaXN0b3JpY2FsIGFuZCByZWFsLXRpbWUgZGF0YSwgdXRpbGl6aW5nIGNvbXBsZXggYWxnb3JpdGhtIG1vZGVscyB0byBwcmVkaWN0IGVxdWlwbWVudCBmYWlsdXJlcy4gVGhleSBjYW4gZXZlbiBhdXRvbWF0aWNhbGx5IGFkanVzdCBwcm9kdWN0aW9uIHBhcmFtZXRlcnMgYmFzZWQgb24gZXF1aXBtZW50IHN0YXR1cyB0byBlbnN1cmUgdW5pbnRlcnJ1cHRlZCBwcm9kdWN0aW9uLiAgCgpJbiB0aGUgYXV0b21vdGl2ZSBpbmR1c3RyeSwgcHJlZGljdGl2ZSBtYWludGVuYW5jZSBhbmQgZmF1bHQgZGlhZ25vc2lzIHRlY2hub2xvZ2llcyBhcmUgdXNlZCB0byBtb25pdG9yIHRoZSBwZXJmb3JtYW5jZSBvZiBrZXkgY29tcG9uZW50cyBzdWNoIGFzIGVuZ2luZXMgYW5kIHRyYW5zbWlzc2lvbnMsIHByZXZlbnRpbmcgZmFpbHVyZXMgYW5kIGVuc3VyaW5nIGRyaXZpbmcgc2FmZXR5LiAgCgojIyMgMiBEZXNpZ24gb2YgQUktQmFzZWQgSW50ZWxsaWdlbnQgTWFudWZhY3R1cmluZyBTeXN0ZW1zICAKCiMjIyMgMi4xIFN5c3RlbSBBcmNoaXRlY3R1cmUgRGVzaWduICAKU3lzdGVtIGFyY2hpdGVjdHVyZSBkZXNpZ24gaXMgdGhlIGZvdW5kYXRpb24gb2YgQUktYmFzZWQgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBzeXN0ZW1zLiBJdCBpbnZvbHZlcyBwbGFubmluZyB0aGUgZW50aXJlIHByb2R1Y3Rpb24gc3lzdGVtLCBmcm9tIGRhdGEgZmxvdyB0byBjb250cm9sIGxvZ2ljLCBlbnN1cmluZyBlZmZpY2llbnQgY29sbGFib3JhdGlvbiBiZXR3ZWVuIGNvbXBvbmVudHMgYW5kIHRoZSBzeXN0ZW0ncyBhZGFwdGFiaWxpdHkgYW5kIHNjYWxhYmlsaXR5LiBUaGUgaGllcmFyY2hpY2FsIGRlc2lnbiBjb25jZXB0IGludGVncmF0ZXMgYW5kIG9wdGltaXplcyBtYW51ZmFjdHVyaW5nIHJlc291cmNlcyBlZmZlY3RpdmVseS4gIAoKRm9yIGV4YW1wbGUsIHBoeXNpY2FsIGRldmljZXMgYXQgdGhlIGJvdHRvbSBsYXllciBjb21tdW5pY2F0ZSBpbiByZWFsIHRpbWUgd2l0aCB1cHBlci1sYXllciBkZWNpc2lvbi1tYWtpbmcgbW9kdWxlcyB2aWEgc2Vuc29ycy4gVGhlIGRhdGEgcHJvY2Vzc2luZyBsYXllciBhbmFseXplcyB0aGUgY29sbGVjdGVkIGluZm9ybWF0aW9uLCBwcm92aWRpbmcgYSBiYXNpcyBmb3IgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nLiBGaWd1cmUgMSBpbGx1c3RyYXRlcyB0aGUgc3lzdGVtIGFyY2hpdGVjdHVyZSBkZXNpZ24uIFRoaXMgc3RydWN0dXJlZCBhcHByb2FjaCBlbmhhbmNlcyBzeXN0ZW0gc3RhYmlsaXR5IGFuZCBlZmZpY2llbmN5IHdoaWxlIGZhY2lsaXRhdGluZyBtYWludGVuYW5jZSBhbmQgdXBncmFkZXMuICAKCioqRmlndXJlIDE6IFN5c3RlbSBBcmNoaXRlY3R1cmUgRGVzaWduKiogIAoKU3lzdGVtIGFyY2hpdGVjdHVyZSBkZXNpZ24gbXVzdCBhbHNvIGluY29ycG9yYXRlIEFJIHRlY2hub2xvZ2llcywgcmVxdWlyaW5nIGRlc2lnbmVycyB0byBoYXZlIGludGVyZGlzY2lwbGluYXJ5IGtub3dsZWRnZSwgaW5jbHVkaW5nIG1hbnVmYWN0dXJpbmcgcHJvY2Vzc2VzLCBkYXRhIHNjaWVuY2UsIGFuZCBtYWNoaW5lIGxlYXJuaW5nLiBJbiBwcmFjdGljZSwgdGhlIHN5c3RlbSBhcmNoaXRlY3R1cmUgc2hvdWxkIHN1cHBvcnQgY29tcGxleCBhbGdvcml0aG0gb3BlcmF0aW9ucywgc3VjaCBhcyBuZXVyYWwgbmV0d29ya3MgYW5kIGRlZXAgbGVhcm5pbmcgbW9kZWxzLCBlbmFibGluZyBzZWxmLWxlYXJuaW5nIGFuZCBzZWxmLW9wdGltaXphdGlvbiBkdXJpbmcgcHJvZHVjdGlvbi4gVGhpcyBhbGxvd3MgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBzeXN0ZW1zIHRvIGFkYXB0IGZsZXhpYmx5IHRvIHZhcmlvdXMgcHJvZHVjdGlvbiB0YXNrcyBhbmQgbWFya2V0IGNoYW5nZXMgd2hpbGUgY29udGludW91c2x5IGltcHJvdmluZyB0aGVpciBpbnRlbGxpZ2VuY2UgYnkgbGVhcm5pbmcgZnJvbSBwcm9kdWN0aW9uIGRhdGEuICAKCiMjIyMgMi4yIEh1bWFuLU1hY2hpbmUgSW50ZXJmYWNlIChITUkpIERlc2lnbiAgClRoZSBodW1hbi1tYWNoaW5lIGludGVyZmFjZSAoSE1JKSBzZXJ2ZXMgYXMgYSBicmlkZ2UgYmV0d2VlbiBodW1hbiBvcGVyYXRpb24gYW5kIG1hY2hpbmUgZXhlY3V0aW9uIGluIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgc3lzdGVtcy4gSXRzIGludHVpdGl2ZW5lc3MgYW5kIGVhc2Ugb2YgdXNlIGRpcmVjdGx5IGFmZmVjdCBzeXN0ZW0gZWZmaWNpZW5jeS4gQSB3ZWxsLWRlc2lnbmVkIEhNSSBzaW1wbGlmaWVzIGNvbXBsZXggb3BlcmF0aW9ucywgZWZmZWN0aXZlbHkgdHJhbnNsYXRpbmcgaHVtYW4gaW50ZW50aW9ucyBpbnRvIHByZWNpc2UgbWFjaGluZSByZXNwb25zZXMuICAKClVzZXIgZXhwZXJpZW5jZSBpcyBhIHRvcCBwcmlvcml0eSBpbiBITUkgZGVzaWduLCBlbnN1cmluZyBpbnR1aXRpdmUgb3BlcmF0aW9uIGFuZCByZWR1Y2luZyBlcnJvcnMgdGhyb3VnaCBwcm9wZXIgdXNlIG9mIGdyYXBoaWNzLCBpY29ucywgYW5kIGNvbG9ycy4gRm9yIGV4YW1wbGUsIGludHVpdGl2ZSBncmFwaGljYWwgaW50ZXJmYWNlcyBvbiB0b3VjaCBzY3JlZW5zIGhlbHAgb3BlcmF0b3JzIHF1aWNrbHkgaWRlbnRpZnkgc3lzdGVtIHN0YXR1c2VzIGFuZCByZXNwb25kIHRvIGFsZXJ0cywgaW1wcm92aW5nIGVmZmljaWVuY3kgYW5kIHNhZmV0eS4gIAoKV2l0aC4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CioqRGVzaWduIG9mIERpc3RyaWJ1dGVkIEhpZ2gtQ29uY3VycmVuY3kgU3lzdGVtIEFyY2hpdGVjdHVyZSBCYXNlZCBvbiBQb2xhckRCKioKCjAgSW50cm9kdWN0aW9uCgpUaGUgZGVtYW5kIGZvciBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMgaGFzIGJlZW4gZ3Jvd2luZyB3aXRoIHRoZSBjb250aW51b3VzIGRldmVsb3BtZW50IG9mIGludGVybmV0IGFwcGxpY2F0aW9ucy4gQW4gaW1wb3J0YW50IGNoYWxsZW5nZSBpbiB0aGlzIGNvbnRleHQgaXMgaG93IHRvIGRlc2lnbiBhIHBvd2VyZnVsLCByZWxpYWJsZSwgYW5kIHN0YWJsZSBzeXN0ZW0gZnJhbWV3b3JrLiBBcyBhIGhpZ2gtcGVyZm9ybWFuY2UgYW5kIHNjYWxhYmxlIGNsb3VkLW5hdGl2ZSBkaXN0cmlidXRlZCBkYXRhYmFzZSwgUG9sYXJEQiBwcm92aWRlcyBhIG5ldyBwb3NzaWJpbGl0eSBmb3IgYnVpbGRpbmcgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW1zLiBUaGlzIGFydGljbGUgYWltcyB0byBleHBsb3JlIHRoZSBkaXN0cmlidXRlZCBzeXN0ZW0gYXJjaGl0ZWN0dXJlIGRlc2lnbiBiYXNlZCBvbiBQb2xhckRCLCBmb2N1c2luZyBvbiBrZXkgaXNzdWVzIHN1Y2ggYXMgcGVyZm9ybWFuY2UsIGF2YWlsYWJpbGl0eSwgYW5kIGNvbnNpc3RlbmN5LiBJdCBkZWx2ZXMgaW50byB0aGUgUG9sYXJEQiBhcmNoaXRlY3R1cmUsIHN1bW1hcml6ZXMgcHJhY3RpY2FsIGV4cGVyaWVuY2UsIHByb3ZpZGVzIHRlY2huaWNhbCBzdXBwb3J0IGFuZCByZWZlcmVuY2UgZm9yIGFkZHJlc3NpbmcgdGhlIGluY3JlYXNpbmcgYnVzaW5lc3MgZGVtYW5kcywgYW5kIG9mZmVycyBuZXcgaWRlYXMgYW5kIG1ldGhvZHMgZm9yIGRpc3RyaWJ1dGVkIHN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduLgoKMSBJbnRyb2R1Y3Rpb24gdG8gUG9sYXJEQgoKMS4xIEFyY2hpdGVjdHVyZSBPdmVydmlldwoKVGhlIGRpc3RyaWJ1dGVkIHN5c3RlbSBhcmNoaXRlY3R1cmUgZGVzaWduIGJhc2VkIG9uIFBvbGFyREIgaXMgYW4gaW5ub3ZhdGl2ZSBzb2x1dGlvbiB0byBhZGRyZXNzIGxhcmdlLXNjYWxlIGRhdGEgc3RvcmFnZSBhbmQgaGlnaC1jb25jdXJyZW5jeSBhY2Nlc3MgY2hhbGxlbmdlcyBpbiBjbG91ZCBjb21wdXRpbmcgZW52aXJvbm1lbnRzLiBUaGUgY29yZSBmZWF0dXJlIG9mIHRoZSBQb2xhckRCIGFyY2hpdGVjdHVyZSBpcyB0aGUgc2VwYXJhdGlvbiBvZiBzdG9yYWdlIGFuZCBjb21wdXRhdGlvbiwgd2hlcmUgZGlzdHJpYnV0ZWQgZGF0YWJhc2UgY2x1c3RlcnMgYXJlIGJ1aWx0IHVzaW5nIGluZGVwZW5kZW50IGNvbXB1dGUgbm9kZXMgYW5kIHN0b3JhZ2Ugbm9kZXMsIHRodXMgYWNoaWV2aW5nIGhvcml6b250YWwgc2NhbGFiaWxpdHkgYW5kIGVsYXN0aWMgZXhwYW5zaW9uLiBJbiB0aGUgUG9sYXJEQiBhcmNoaXRlY3R1cmUsIHN0b3JhZ2Ugbm9kZXMgYXJlIHJlc3BvbnNpYmxlIGZvciBkYXRhIHBlcnNpc3RlbmNlIHN0b3JhZ2UgYW5kIG1hbmFnZW1lbnQsIHdoaWxlIGNvbXB1dGUgbm9kZXMgaGFuZGxlIFNRTCByZXF1ZXN0cyBhbmQgY29tcHV0YXRpb25hbCBsb2dpYy4gVGhpcyBkaXN0cmlidXRlZCBhcmNoaXRlY3R1cmUgbW9kZWwgYWxsb3dzIFBvbGFyREIgdG8gcHJvdmlkZSBoaWdoLXBlcmZvcm1hbmNlLCBoaWdoLWF2YWlsYWJpbGl0eSwgYW5kIGhpZ2hseSBzY2FsYWJsZSBkYXRhYmFzZSBzZXJ2aWNlcy4gUG9sYXJEQiBhbHNvIGFkb3B0cyBhIHNoYXJlZCBhcmNoaXRlY3R1cmUsIGVuYWJsaW5nIGRhdGEgc2hhcmluZyBhbmQgcmV1c2UgdGhyb3VnaCBhIHNoYXJlZCBzdG9yYWdlIGxheWVyLCB0aGVyZWJ5IHJlZHVjaW5nIHRoZSBzeXN0ZW0ncyBjb3N0IGFuZCBjb21wbGV4aXR5LiBJbiB0ZXJtcyBvZiBhcmNoaXRlY3R1cmFsIGRlc2lnbiwgUG9sYXJEQiBmdWxseSBjb25zaWRlcnMgc3lzdGVtIHNlY3VyaXR5IGFuZCByZWxpYWJpbGl0eSwgb2ZmZXJpbmcgZmVhdHVyZXMgc3VjaCBhcyBkYXRhIGVuY3J5cHRpb24sIGFjY2VzcyBjb250cm9sLCBhbmQgZmF1bHQgcmVjb3ZlcnkgdG8gcHJvdGVjdCB1c2VyIGRhdGEgc2VjdXJpdHkgYW5kIHByaXZhY3kuIFRoZSBQb2xhckRCIGFyY2hpdGVjdHVyZSBvdXRsaW5lcyBhbiBpbm5vdmF0aXZlIGRpc3RyaWJ1dGVkIGRhdGFiYXNlIG1vZGVsLCBwcm92aWRpbmcgbmV3IGlkZWFzIGFuZCBtZXRob2RzIGZvciBidWlsZGluZyBoaWdoLXBlcmZvcm1hbmNlLCBoaWdoLWF2YWlsYWJpbGl0eSBkaXN0cmlidXRlZCBzeXN0ZW1zLgoKMS4yIEZlYXR1cmVzIGFuZCBBZHZhbnRhZ2VzCgpQb2xhckRCIGhhcyBtYW55IG91dHN0YW5kaW5nIGZlYXR1cmVzIGFuZCBhZHZhbnRhZ2VzIHRoYXQgbWFrZSBpdCB0aGUgcHJlZmVycmVkIGRhdGFiYXNlIHNvbHV0aW9uIGZvciBlbnRlcnByaXNlcyBidWlsZGluZyBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMuIFBvbGFyREIgYWRvcHRzIGEgc2hhcmVkIGFyY2hpdGVjdHVyZSwgc2VwYXJhdGluZyBjb21wdXRhdGlvbiBhbmQgc3RvcmFnZSB0byBhY2hpZXZlIGVsYXN0aWMgc2NhbGluZyBhbmQgaGlnaCBwZXJmb3JtYW5jZSwgZWZmZWN0aXZlbHkgc29sdmluZyB0aGUgYm90dGxlbmVjayBpc3N1ZXMgb2YgdHJhZGl0aW9uYWwgZGF0YWJhc2VzLiBQb2xhckRCIHN1cHBvcnRzIG9ubGluZSBob3Jpem9udGFsIHNjYWxpbmcsIGVuYWJsaW5nIG5vZGVzIHRvIGJlIGR5bmFtaWNhbGx5IGFkZGVkIGJhc2VkIG9uIGJ1c2luZXNzIHJlcXVpcmVtZW50cyB3aXRob3V0IGRvd250aW1lIG9yIGRhdGEgbWlncmF0aW9uLCBlbnN1cmluZyBoaWdoIGF2YWlsYWJpbGl0eSBhbmQgc3RhYmlsaXR5LiBQb2xhckRCIGFsc28gZmVhdHVyZXMgaW50ZWxsaWdlbnQgb3B0aW1pemF0aW9uIGFuZCBhdXRvbWF0ZWQgbWFuYWdlbWVudCwgbWFraW5nIGFkYXB0aXZlIGFkanVzdG1lbnRzIGJhc2VkIG9uIHJlYWwtdGltZSBsb2FkIGFuZCBkYXRhIGFjY2VzcyBwYXR0ZXJucyB0byBpbXByb3ZlIHN5c3RlbSBlZmZpY2llbmN5IGFuZCByZXNvdXJjZSB1dGlsaXphdGlvbi4gUG9sYXJEQiBpcyBoaWdobHkgY29tcGF0aWJsZSwgZWFzeSB0byB1c2UsIHN1cHBvcnRzIHN0YW5kYXJkIFNRTCBzeW50YXggYW5kIHByb3RvY29scywgYW5kIGZhY2lsaXRhdGVzIHRoZSBtaWdyYXRpb24gYW5kIGludGVncmF0aW9uIG9mIGV4aXN0aW5nIGFwcGxpY2F0aW9ucywgcmVkdWNpbmcgc3lzdGVtIG1haW50ZW5hbmNlIGFuZCBkZXZlbG9wbWVudCBjb3N0cywgd2hpbGUgaW1wcm92aW5nIGRldmVsb3BtZW50IGVmZmljaWVuY3kgYW5kIHVzZXIgZXhwZXJpZW5jZS4gUG9sYXJEQiBpcyBhbiBpZGVhbCBjaG9pY2UgZm9yIGJ1aWxkaW5nIGRpc3RyaWJ1dGVkIGhpZ2gtY29uY3VycmVuY3kgc3lzdGVtcywgd2l0aCBpdHMgcGVyZm9ybWFuY2UsIHN0YWJpbGl0eSwgYW5kIGVhc2Ugb2YgdXNlIHN0YW5kaW5nIG91dC4KCjIgUmVxdWlyZW1lbnRzIGZvciBEaXN0cmlidXRlZCBIaWdoLUNvbmN1cnJlbmN5IFN5c3RlbSBEZXNpZ24KCjIuMSBQZXJmb3JtYW5jZSBSZXF1aXJlbWVudHMgQW5hbHlzaXMKCldoZW4gZGVzaWduaW5nIGEgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW0sIHBlcmZvcm1hbmNlIGlzIG9uZSBvZiB0aGUgbW9zdCBpbXBvcnRhbnQgY29uc2lkZXJhdGlvbnMuIFBlcmZvcm1hbmNlIHJlcXVpcmVtZW50cyBhbmFseXNpcyBpcyB0aGUga2V5IHByb2Nlc3MgZm9yIGRldGVybWluaW5nIHRoZSBwZXJmb3JtYW5jZSBtZXRyaWNzIGFuZCByZXF1aXJlbWVudHMgdGhhdCB0aGUgc3lzdGVtIG11c3QgbWVldCB3aGVuIHByb2Nlc3NpbmcgbGFyZ2Utc2NhbGUgY29uY3VycmVudCByZXF1ZXN0cy4gVG8gYWNjb21tb2RhdGUgdGhlIGdyb3dpbmcgbnVtYmVyIG9mIHVzZXJzLCB0aGUgc3lzdGVtJ3MgdGhyb3VnaHB1dCBtdXN0IGJlIGR5bmFtaWNhbGx5IHNjYWxhYmxlIHRvIG1lZXQgcGVhayBhY2Nlc3MgcHJlc3N1cmUuIEFub3RoZXIgY3JpdGljYWwgZmFjdG9yIGFmZmVjdGluZyBzeXN0ZW0gcGVyZm9ybWFuY2UgaXMgbGF0ZW5jeSwgd2hpY2ggcmVmZXJzIHRvIHRoZSByZXNwb25zZSB0aW1lIG9mIHRoZSBzeXN0ZW0gaW4gcHJvY2Vzc2luZyByZXF1ZXN0cy4gRm9yIGRpc3RyaWJ1dGVkIHN5c3RlbXMsIHRvIG1pbmltaXplIHRoZSBpbXBhY3Qgb2YgbmV0d29yayBsYXRlbmN5IGFuZCBkYXRhIHRyYW5zbWlzc2lvbiBsYXRlbmN5IG9uIHRoZSBzeXN0ZW0ncyByZXNwb25zZSB0aW1lLCBpdCBpcyBuZWNlc3NhcnkgdG8gYWRvcHQgYXBwcm9wcmlhdGUgbmV0d29yayBhcmNoaXRlY3R1cmVzIGFuZCBkYXRhIGRpc3RyaWJ1dGlvbiBzdHJhdGVnaWVzIHRvIG9wdGltaXplIHN5c3RlbSBwZXJmb3JtYW5jZS4gV2hlbiBkZXNpZ25pbmcgZGlzdHJpYnV0ZWQgaGlnaC1jb25jdXJyZW5jeSBzeXN0ZW1zLCBwZXJmb3JtYW5jZSBtZXRyaWNzIGFuZCByZXF1aXJlbWVudHMgbXVzdCBiZSBjb21wcmVoZW5zaXZlbHkgY29uc2lkZXJlZC4gSW4gYWRkaXRpb24sIHRoZSBzeXN0ZW0ncyBjb25jdXJyZW5jeSBjYXBhYmlsaXR5IGFuZCBsb2FkIGJhbGFuY2luZyBtZWNoYW5pc21zIG11c3QgYmUgY29uc2lkZXJlZCB0byBlbnN1cmUgdGhhdCB0aGUgc3lzdGVtIGNhbiBlZmZlY3RpdmVseSBoYW5kbGUgbGFyZ2Ugdm9sdW1lcyBvZiBjb25jdXJyZW50IHJlcXVlc3RzIGFuZCBtYWludGFpbiBzdGFibGUgb3BlcmF0aW9uIGluIHRoZSBldmVudCBvZiBub2RlIGZhaWx1cmVzIG9yIG5ldHdvcmsgYWJub3JtYWxpdGllcy4gUGVyZm9ybWFuY2UgcmVxdWlyZW1lbnRzIGFuYWx5c2lzIGlzIGEgY3J1Y2lhbCBwYXJ0IG9mIGRlc2lnbmluZyBkaXN0cmlidXRlZCBoaWdoLWNvbmN1cnJlbmN5IHN5c3RlbXMuIEl0IGlzIGVzc2VudGlhbCB0byBmdWxseSBjb25zaWRlciB2YXJpb3VzIHBlcmZvcm1hbmNlIHJlcXVpcmVtZW50cywgc3VjaCBhcyB0aHJvdWdocHV0IHNjYWxhYmlsaXR5LCBsYXRlbmN5IHN0YWJpbGl0eSwgY29uY3VycmVuY3kgY2FwYWJpbGl0eSwgYW5kIGxvYWQgYmFsYW5jaW5nLCB0byBlbnN1cmUgZXhjZWxsZW50IHN5c3RlbSBwZXJmb3JtYW5jZS4KCjIuMiBBdmFpbGFiaWxpdHkgUmVxdWlyZW1lbnRzIEFuYWx5c2lzCgpBbm90aGVyIGNyaXRpY2FsIGRlc2lnbiByZXF1Li4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoK6K+35Li65LiA56+H5o6i6K6o5Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit5bqU55So55qE5a2m5pyv6K665paH5pKw5YaZ5Lit5paH5pGY6KaB77yM6K665paH5YW25LuW6YOo5YiG5aaC5LiLOuS4gOOAgeW8leiogCDoh6oyMDA45bm05Lit5pys6IGq5Zyo5q+U54m55biB6K665Z2b5LiK5Y+R6KGo5ZCN5Li64oCcQml0Y29pbjpBIFBlZXItdG8tUGVlciBFbGVjdHJvbmljIENhc2ggU3lzdGVt4oCdWzFd55qE6K665paH5Lul5p2l77yM5Yy65Z2X6ZO+55qE5qaC5b+16ZqP552A5q+U54m55biB55qE54Gr54iG5Y+X5Yiw5LqG5ZCE5Zu95pS/5bqc5ZKM5a2m6ICF55qE6auY5bqm5YWz5rOo44CC5ZCE5Liq5Zu95a6255u457un5o6o5Ye65raJ5Y+K5Yy65Z2X6ZO+5oqA5pyv55qE57O75YiX5pS/562W5paH5Lu277yM5Yqg6YCf5Yy65Z2X6ZO+55qE5bqU55So6JC95Zyw77yM5L2/5YW25oiQ5Li65byV6aKG5paw5LiA5Luj5L+h5oGv5oqA5pyv55qE5Li76KeS44CC5oiR5Zu95pep5ZyoMjAxNuW5tOWwseWPkeihqOS6hummluS7veOAiuS4reWbveWMuuWdl+mTvuaKgOacr+WSjOW6lOeUqOWPkeWxleeZveearuS5puOAi+OAguOAiueZveearuS5puOAi+ivpue7huS7i+e7jeS6huWMuuWdl+mTvuWcqOWbveWGheWklueahOWPkeWxleeOsOeKtuOAgeW6lOeUqOWcuuaZr+S4juacquadpeWPkeWxleaWueWQkVsyXeOAguWQjOW5tO+8jOWbveWKoemZouWNsOWPkeeahOOAiuKAnOWNgeS4ieS6lOKAneWbveWutuS/oeaBr+WMluinhOWIkuOAi+S4reaYjuehruWwhuWMuuWdl+mTvuaKgOacr+WIl+S4uuaImOeVpeaAp+WJjeayv+aKgOacr1szXeOAgjIwMTnlubQxMOaciDI05pel77yM5Lmg6L+R5bmz5oC75Lmm6K6w5Zyo5Lit5aSu5pS/5rK75bGA56ys5Y2B5YWr5qyh6ZuG5L2T5a2m5Lmg5pe25by66LCD77yM4oCc5oqK5Yy65Z2X6ZO+5L2c5Li65qC45b+D5oqA5pyv6Ieq5Li75Yib5paw6YeN6KaB56qB56C05Y+j77yM5Yqg5b+r5o6o5Yqo5Yy65Z2X6ZO+5oqA5pyv5ZKM5Lqn5Lia5Yib5paw5Y+R5bGV4oCdWzRd77yM6L+b5LiA5q2l5Ye45pi+5LqG5Yy65Z2X6ZO+55qE6YeN6KaB5L2c55So44CCIOWMuuWdl+mTvuaKgOacr+e7meWQhOihjOWQhOS4muW4puadpeS6huaWsOeahOWPkeWxleacuumBh++8jOWFtuW6lOeUqOmAkOa4kOS7jumHkeiejemihuWfn+aJqeWxleWIsOWFtuS7lumihuWfn++8jOS+m+W6lOmTvuWwseaYr+WFtuS4reS5i+S4gOOAgumaj+edgOWMuuWdl+mTvuaKgOacr+eahOS4jeaWreWPkeWxle+8jOS8oOe7n+eahOS+m+W6lOmTvueuoeeQhuaooeW8j+S6n+mhu+WcqOiejeWFpeaWsOaKgOacr+eahOWfuuehgOS4iui/m+ihjOWFqOaWsOeahOWPmOmdqeOAguWboOatpO+8jOenkeWtpuWcsOais+eQhuW5tuaAu+e7k+KAnOWMuuWdl+mTvivkvpvlupTpk77igJ3poobln5/nmoTnoJTnqbbng63ngrnkuI7liY3msr/otovlir/vvIzlhbfmnInph43opoHnmoTnkIborrrlkozlrp7ot7XmhI/kuYnjgILmnKzmlofku6VDaXRlIFNwYWNl5paH54yu6K6h6YeP5YiG5p6Q5Li65oyH5byV77yM5a+55Yy65Z2X6ZO+5oqA5pyv5Zyo5L6b5bqU6ZO+5Lit55qE5bqU55So56CU56m26L+b6KGM6L+w6K+E77yM6YCa6L+H5qKz55CG546w5pyJ5paH54yu77yM5Zyo5piO5pmw5Yy65Z2X6ZO+5oqA5pyv57uZ5L6b5bqU6ZO+5bim5p2l55qE5rex5Yi75Y+Y6Z2p5Y+K5bqU55So546w54q255qE5Z+656GA5LiK77yM5a+55pyq5p2l56CU56m25pa55ZCR6L+b6KGM5bGV5pyb44CCIOS6jOOAgeWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOeglOeptuaWh+eMruiuoemHj+WIhuaekCDkuLrlhajpnaLkuobop6PljLrlnZfpk77mioDmnK/lnKjkvpvlupTpk77kuK3nmoTlupTnlKjnoJTnqbbnjrDnirbvvIzlgJ/liqlDaXRlIFNwYWNl5Y+v6KeG5YyW5YiG5p6Q6L2v5Lu26L+b6KGM5paH54yu5YWx6KKr5byV5YiG5p6Q44CB5YWz6ZSu6K+N5YWx546w5YiG5p6Q44CB5YWz6ZSu6K+N6IGa57G75YiG5p6QWzVd44CC5Lul4oCcYmxvY2tjaGFpbuKAneWSjOKAnHN1cHBseSBjaGFpbuKAneS4uuajgOe0ouS4u+mimOivjeWcqFdlYiBvZiBTY2llbmNl5pWw5o2u5bqT5Lit6L+b6KGM5paH54yu5qOA57Si77yM6K+t56eN6K6+5a6a5Li66Iux6K+t77yM5paH54yu57G75Z6L6YCJ5oup4oCcQXJ0aWNsZeKAneaIluKAnFJldmlld+KAne+8jOajgOe0ouaXtumXtOS4ujIwMjDlubQxMuaciO+8jOaXtumXtOi3qOW6puiuvuS4ujIwMDjigJQyMDIw77yM5YWx5qOA57Si5Yiw6Iux5paH5paH54yuNDU156+H44CCIOmAmui/h+aWh+eMruWFseiiq+W8leWIhuaekO+8jOWPkeeOsOacieS4gOS6m+WvueWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOeglOeptuW9seWTjei+g+Wkp+eahOaWh+eMruOAguWmglN3YW5bNl3lnKgyMDE15bm05Ye654mI5LqG6JGX5L2cQmxvY2tjaGFpbjpCbHVlcHJpbnQgZm9yIGEgTmV3IEVjb25vbXnvvIzorqjorrrkuobmr5TnibnluIHlkozljLrlnZfpk77mioDmnK/nmoTkuInkuKrkuI3lkIzpmLbmrrU65Yy65Z2X6ZO+MS4w44CB5Yy65Z2X6ZO+Mi4w5ZKM5Yy65Z2X6ZO+My4w77yM5bm25o+Q5Ye65Yy65Z2X6ZO+My4w5Zyo6LSn5biB44CB6YeR6J6N44CB56eR5oqA44CB5Z+65Zug57uE5a2m44CB5YGl5bq344CB5a2m5Lmg44CB5a2m5pyv5Ye654mI44CB5byA5Y+R44CB5pWR5o+05ZKM5paH5YyW562J6aKG5Z+f55qE6K+45aSa5bqU55So5YmN5pmv77yM5Li65ZCO57ut56CU56m25aWg5a6a5LqG5Z+656GA44CCS3NoZXRyaVs3XeWcqDIwMTjlubTlj5HooajkuoborrrmlofigJxCbG9ja2NoYWluJ3MgUm9sZXMgaW4gTWVldGluZyBLZXkgU3VwcGx5IENoYWluIE1hbmFnZW1lbnQgT2JqZWN0aXZlc+KAne+8jOS7pemprOWjq+WfuuOAgemYv+mHjOW3tOW3tOOAgeayg+WwlOeOm+etiTEx5a625oiQ5Yqf6L+Q55So5Yy65Z2X6ZO+55qE5Luj6KGo5oCn5LyB5Lia5Li65L6L77yM56CU56m25LqG5Yy65Z2X6ZO+5a+55YWz6ZSu5L6b5bqU6ZO+566h55CG55uu5qCH77yM5aaC5oiQ5pys44CB6LSo6YeP44CB6YCf5bqm44CB5Y+v6Z2g5oCn44CB6aOO6Zmp6ZmN5L2O44CB5Y+v5oyB57ut5oCn5ZKM54G15rS75oCn55qE5b2x5ZON77yM5oyH5Ye65LqG5Yy65Z2X6ZO+5Zyo6aOf5ZOB5L6b5bqU6ZO+44CB5Zu96ZmF54mp5rWB44CB572R57uc5a6J5YWo562J6K+45aSa6aKG5Z+f55qE5bqU55So44CCU2FiZXJpIGV0IGFsLls4XeWcqDIwMTnlubTlj5HooajnmoTorrrmlofigJxCbG9ja2NoYWluIFRlY2hub2xvZ3kgYW5kIEl0cyBSZWxhdGlvbnNoaXBzIHRvIFN1c3RhaW5hYmxlIFN1cHBseSBDaGFpbiBNYW5hZ2VtZW504oCd57O757uf5LuL57uN5LqG5Yy65Z2X6ZO+5Zyo5L6b5bqU6ZO+566h55CG5Lit55qE5bqU55So77yM5bm25LuO57uP5rWO44CB56S+5Lya5ZKM546v5aKD5LiJ5Liq57u05bqm6ZiQ6YeK5LqG5Yy65Z2X6ZO+5Zyo5Y+v5oyB57ut5L6b5bqU6ZO+572R57uc5Lit55qE5LyY5Yq/O+WfuuS6juWvueaWh+eMrueahOWbnumhvu+8jOWwhuWMuuWdl+mTvuaKgOacr+W6lOeUqOmdouS4tOeahOmanOeijeWIhuS4uuWbm+S4quaWuemdojrnu4Tnu4fpl7TjgIHnu4Tnu4flhoXjgIHmioDmnK/lkozlpJbpg6jpmpznoo075pyA5ZCO5o+Q5Ye65LqG5pyq5p2l55qE56CU56m25pa55ZCR5Lul5pyJ5pWI6Kej5Yaz5Yy65Z2X6ZO+55qE5oqA5pyv6Zqc56KN77yM5L2/5Yy65Z2X6ZO+5pu05aW95Zyw5bqU55So5Yiw5L6b5bqU6ZO+566h55CG5Lit44CC6L+Z5Lqb5paH54yu5byV6aKG5LqG5Yy65Z2X6ZO+5Zyo5L6b5bqU6ZO+6aKG5Z+f55qE5bqU55So56CU56m277yM5bm25L2/55u45YWz56CU56m25b6X5Lul5LiN5pat5rex5YyW44CCIOWFs+mUruivjeWFseeOsOWIhuaekOaYvuekuijlpoLooagx5omA56S6Ke+8jOWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOS4u+mimOi+g+Wkmu+8jOS7juWMuuWdl+mTvuOAgeS+m+W6lOmTvuOAgeaZuuiDveWQiOe6puWIsOmjn+WTgeS+m+W6lOmTvuOAgeS+m+W6lOmTvue7qeaViOOAgeW9seWTjeOAgeaMkeaImOOAgeWPr+aMgee7reaAp+etieOAgui/m+S4gOatpemAmui/h+WFs+mUruivjeiBmuexu+WIhuaekCjlpoLooagy5omA56S6KeWPkeeOsO+8jOeglOeptueahOeDreeCueS4u+mimOS4u+imgea2ieWPiuWMuuWdl+mTvuaKgOacr+OAgeWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOmihuWfn+OAgeWvueS+m+W6lOmTvueahOW9seWTjeOAgeacquadpeaMkeaImOetieaWuemdouOAguWfuuS6juatpO+8jOS4i+mdouWwhuWbtOe7leS7peS4i+S6lOS4quaWuemdoumXrumimOWvueeOsOacieaWh+eMrui/m+ihjOi/sOivhDooMSnku4DkuYjmmK/ljLrlnZfpk77mioDmnK8/KDIp5Li65LuA5LmI6KaB5Zyo5L6b5bqU6ZO+5Lit6J6N5YWl5Yy65Z2X6ZO+5oqA5pyvPygzKeWMuuWdl+mTvuaKgOacr+S4u+imgeW6lOeUqOWcqOS+m+W6lOmTvueahOWTquS6m+mihuWfnz8oNCnov5nkupvlupTnlKjnu5nkvpvlupTpk77luKbmnaXku4DkuYjlvbHlk40/KDUp5pyq5p2l6Z2i5Li05ZOq5Lqb5oyR5oiYPyDooagxIOWFs+mUruivjeWFseeOsOWIhuaekCAg6KGoMiDlhbPplK7or43ogZrnsbvnu5PmnpwgIOS4ieOAgeWMuuWdl+mTvuaKgOacr+WcqOS+m+W6lOmTvuS4reeahOW6lOeUqOeglOeptuS4u+mimOeOsOeKtui/sOivhCAo5LiAKeWMuuWdl+mTvuaKgOacrzrmpoLlv7XjgIHkvZznlKjkuI7nsbvlnosg5Yy65Z2X6ZO+5pyA5Yid5L2c5Li65LiA56eN5pSv5oyB5Yqg5a+G6LSn5biB6aKG5Z+f5Lqk5piT55qE5oqA5pyv6ICM5Ye6546wWzFd44CCQ2hyaXN0aWRpcyBhbmQgRGV2ZXRzaW9raW90aXNbOV3lsIbljLrlnZfpk77lrprkuYnkuLrigJzlnKjnvZHnu5zmiJDlkZjkuYvpl7TlpI3liLblkozlhbHkuqvnmoTliIbluIPlvI/mlbDmja7nu5PmnoTigJ3jgIJBbC1TYXFhZiBhbmQgU2VpZGxlclsxMF3liJnlsIbljLrlnZfpk77lrprkuYnkuLrigJzliIbluIPlvI/mlbDlrZfliIbnsbvotKbmiJbkvJrorqHotKbnsL/igJ3jgILlnKjmraTln7rnoYDkuIrvvIxSaXNpdXMgYW5kIFNwb2hyZXJbMTFd5a+55Yy65Z2X6ZO+5oqA5pyv57uZ5Ye65LqG5LiA5Liq6L6D5q2j5byP55qE5a6a5LmJ77yM5Y2z4oCc5Yy65Z2X6ZO+5oqA5pyv5piv5oyH5LiA56eN55So5LqO5Lul5Yqg5a+G5pa55byP5o2V6I635ZKM5a2Y5YKo572R57uc5Y+C5LiO6ICF5LmL6Ze05LiA6Ie055qE44CB5LiN5Y+Y55qE44CB57q/5oCn55qE5LqL5Yqh5pel5b+X55qE5a6M5YWo5YiG5biD5byP57O757uf44CC5Zyo5Yqf6IO95LiK57G75Ly85LqO5YiG5biD5byP5YiG57G76LSm77yM55Sx572R57uc5YaF5omA5pyJ5Y+C5LiO5Lqk5piT55qE5ZCE5pa55LiA6Ie05L+d5a2Y44CB5pu05paw5ZKM6aqM6K+B44CC6K+l5oqA5pyv5Yqg5by65LqG572R57uc6YCP5piO5bqm77yM5bm256Gu5L+d5pyA57uI5Zyo57O757uf6IyD5Zu05YaF5bCx5pW05Liq5Lqk5piT5Y6G5Y+y55qE5pyJ5pWI5oCn6L6+5oiQ5YWx6K+G4oCd44CC5bC9566h57uZ5Ye65LqG6L+Z5Liq5q2j5byP5a6a5LmJ77yM5L2G5pi+54S25Yy65Z2X6ZO+6L+Y5pyJ5LiA5Lqb5YW25LuW54m55b6B77yM5aaC5Y675Lit5b+D44CB5Y675Lit5LuL44CB6Ziy56+h5pS5562J44CC5Zu95YaF5a2m6ICF546L5YWD5Zyw562JWzEyXee7vOi/sOS6huacieWFs+WMuuWdl+mTvuaKgOacr+eahOWGhea2te+8jOWwhuWFtuWIhuS4uuS6lOexuzrkuIDmmK/ln7rkuo7mlbDmja7nmoTop4bop5LlsIbljLrlnZfpk77lrprkuYnkuLrkuIDnp43mlbDmja7nu5PmnoTmiJbmlbDmja7lupM75LqM5piv5Z+65LqO6K6w6LSm55qE6KeG6KeS5bCG5Yy65Z2X6ZO+5a6a5LmJ5Li65LiA56eN5YiG5biD5byP6K6w6LSm55qE5bqV5bGC5oqA5pyvO+S4ieaYr+WfuuS6juWNj+iurueahOinhuinkuWwhuWMuuWdl+mTvuWumuS5ieS4uuS4gOenjeS6kuiBlOe9keWNj+iurjvlm5vmmK/ln7rkuo7mioDmnK/nmoTop4bop5LlsIbljLrlnZfpk77lrprkuYnkuLrkuIDnp43nlLHlpJrnp43mioDmnK/mnoTmiJDnmoTmlrDmioDmnK/mlrnmoYg75LqU5piv5Z+65LqO57uP5rWO55qE6KeG6KeS5bCG5Yy65Z2X6ZO+5a6a5LmJ5Li65LiA56eN5Lu35YC85LqS6IGU572R57uc44CC5LuO5L6b5bqU6ZO+6KeG6KeS5p2l55yL77yM5Yy65Z2X6ZO+5oqA5pyv5Y+v5Lul55CG6Kej5Li65LiO5Lqk5piT55qE5Y675Lit5LuL5YyW55u45YWz77yM5Y2z5peg6aG75Lit5LuL5py65p6E5p2l6aqM6K+B5Lqk5piT5bm25Li65Lqk5piT5o+Q5L6b5Y+v5L+h5bqm55qE5oqA5pyvWzEzXeOAgiDljLrlnZfpk77mioDmnK/kuLvopoHop6PlhrPkuqTmmJPnmoTkv6Hku7vlkozlronlhajpl67popjvvIzpkojlr7nov5nkuKrpl67popjvvIzkuLvopoHmnInlm5vpobnmoLjlv4PmioDmnK/vvIzljIXmi6zliIbluIPlvI/lrZjlgqjjgIHpnZ7lr7nnp7DliqDlr4bjgIHlhbHor4bmnLrliLbjgIHmmbrog73lkIjnuqZbMTQtMTdd44CC5Yy65Z2X6ZO+5oqA5pyv5YW35pyJ5Y675Lit5b+D5YyW44CB5Y675L+h5Lu744CB5YWs5byA6YCP5piO44CB5byA5pS+5oCn44CB6Ziy56+h5pS544CB5Y+v6L+95rqv5oCn44CB5a6J5YWo5Y+v6Z2g562J54m554K5WzE4LTE5XeOAguWMuuWdl+mTvuaKgOacr+eahOi/meS6m+eJueaAp+aEj+WRs+edgOWFtuWwhuWvueS+m+W6lOmTvueuoeeQhuivuOWmguaIkOWRmOWFs+ezu+OAgeWNj+S9nOOAgeS/oeS7u+WSjOWfuuS6juinkuiJsueahOS6keaVj+aNt+aAp+aTjeS9nOaooeWei+eahOWPmOWMluetieaWuemdouS6p+eUn+W9seWTjVsxM13jgILlroPog73mnInmlYjop6PlhrPnvZHnu5zkv6Hmga/kuI3lr7nnp7DvvIzlhbbmnIDkuLrmoLjlv4PnmoTku7flgLzlnKjkuo7lr7nnvZHnu5zkuK3nmoTmr4/kuIDkuKroioLngrnlhYXliIbotYvog73vvIzop6PlhrPkuqTmmJPnmoTkv6Hku7vmnLrliLblkozmv4DlirHmnLrliLbpl67pophbMjBd44CCIOagueaNruivu+WPluWMuuWdl+mTvuOAgeWQkeWMuuWdl+mTvuaPkOS6pOS6pOaYk+W5tuWPguS4juWFseivhua1geeoi+aOp+WItuetieaWuemdoueahOiuv+mXruadg+mZkO+8jOWPr+S7peWwhuWMuuWdl+mTvuWMuuWIhuS4uuS4ieenjeS4u+imgeexu+WeizrlhazmnInpk74ocHVibGljIGJsb2NrY2hhaW4p44CB56eB5pyJ6ZO+KHByaXZhdGUgYmxvY2tjaGFpbinlkozogZTnm5/pk74oY29uc29ydGl1bSBibG9ja2NoYWluKVsxOV3jgILlnKjlhazmnInpk77kuK3vvIzmr4/kuKrkuqTmmJPpg73mmK/lhazlvIDnmoTvvIznlKjmiLflj6/ku6Xkv53mjIHljL/lkI3jgILnvZHnu5zpgJrluLjmnInkuIDkuKrmv4DlirHmnLrliLbmnaXpvJPlirHlj4LkuI7ogIXliqDlhaXnvZHnu5zjgILmr5TnibnluIHlkozku6XlpKrlnYrlsLHmmK/lhazmnInpk77nmoTkvovlrZDjgILlnKjmnInmnYPpmZDorrjlj6/nmoTljLrlnZfpk77kuK3vvIzlj4LkuI7ogIXpnIDopoHojrflvpfliqDlhaXnmoTpgoDor7fmiJborrjlj6/vvIzorr/pl67mnYPpmZDnlLHmiJDlkZjogZTnm58o6IGU55uf6ZO+KeaIluWNleS4que7hOe7hyjnp4HmnInpk74p5o6n5Yi244CC5L6b5bqU6ZO+5bCx5piv5LiA56eN6IGU55uf6ZO+77yM5oiQ5ZGY6YCa6L+H5o6I5p2D5ZCO5omN6IO95Yqg5YWl5LiO6YCA5Ye6572R57uc44CC5Zyo6IGU55uf6ZO+5LiK77yM5L6b5bqU6ZO+5ZCE5Y+C5LiO5pa55YWx5Lqr5LiA5Liq6YCP5piO5Y+v6Z2g55qE5L+h5oGv5bmz5Y+w5ZKM6L+95rqv5rWB56iL77yM5ZCM5pe277yM5ZCE5Y+C5LiO5pa55Lmf5Y+v5Lul5Z+65LqO5Yy65Z2X6ZO+5pWw5o2u5byA5bGV5aaC5L6b5bqU6ZO+6YeR6J6N44CB57K+5YeG6JCl6ZSA562J5pyN5YqhWzIxXeOAgiAo5LqMKeS+m+W6lOmTvuW6lOeUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oCDlhbPkuo7kuLrku4DkuYjopoHlnKjkvpvlupTpk77kuK3lupTnlKjljLrlnZfpk77mioDmnK/vvIzlm73lpJblrabogIXov5DnlKjmioDmnK/mjqXlj5flkozph4fnlKjnkIborrrku6Xlj4rooYzkuLrnkIborrrvvIzku47nu6nmlYjpooTmnJ/jgIHnpL7kvJrlvbHlk43jgIHmnInliKnmnaHku7bjgIHlr7nmioDmnK/nmoTkv6Hku7vjgIHnu4Tnu4fpl7TnmoTkv6Hku7vnrYnmlrnpnaLliIbmnpDkuobkvpvlupTpk77ph4fnlKjljLrlnZfpk77mioDmnK/nmoTpqbHliqjlm6DntKBbMjJd77yM5bm25a+55q+U5YiG5p6Q5LqG5Y2w5bqm5ZKM576O5Zu95oOF5pmv5LiL55qE5beu5byCWzIzXeOAguS+m+W6lOmTvumHh+eUqOWMuuWdl+mTvuaKgOacr+eahOmpseWKqOWboOe0oOWmguWbvjHmiYDnpLrjgIIg5Zu+MSDkvpvlupTpk77ph4fnlKjljLrlnZfpk77mioDmnK/nmoTpqbHliqjlm6DntKAgIOi1hOaWmeadpea6kDrnrJTogIXmoLnmja5GcmFuY2lzY28gYW5kIFN3YW5zb24gKDIwMTgpWzIyXeWPilF1ZWlyb3ogYW5kIFdhbWJhICgyMDE4KVsyM13nmoTnm7jlhbPmlofnjK7mlbTnkIbjgIIgIOmmluWFiO+8jOe7qeaViOmihOacn+aYr+S+m+W6lOmTvuW6lOeUqOWMuuWdl+mTvuaKgOacr+eahOacgOmHjeimgeeahOmpseWKqOWKm+OAguW3suacieeglOeptuihqOaYju+8jOS4quS9k+mHh+e6s+WSjOS9v+eUqOaKgOacr+eahOaEj+aEv+WcqOW+iOWkp+eoi+W6puS4iuWPluWGs+S6jue7qeaViOmihOacn1syNC0yNl3vvIzogIzljLrlnZfpk77mioDmnK/lupTnlKjlr7nkvpvlupTpk77ku47mlYjnjoflkozkuqflk4HotKjph4/liLDlhbPplK7mtYHnqIvnmoTmlLnov5vmlrnpnaLpg73kuqfnlJ/kuoblvojpq5jnmoTpooTmnJ9bN13jgILlhbbmrKHmmK/npL7kvJrlvbHlk43lm6DntKDjgILnpL7kvJrlvbHlk43mmK/mjIfkuKrkvZPlr7nlhbbku5bkurrorqTkuLrlupTor6Xkvb/nlKjmlrDmioDmnK/nmoTph43opoHnqIvluqbnmoTorqTnn6VbMjdd44CC5Yy65Z2X6ZO+5bqU55So5piv5LiA56eN4oCc56S+5Lya5oCn4oCd5oqA5pyv77yM5aaC5p6c6ZqP552A6KeE6IyD5oCn5Y6L5Yqb5ZKM55So5oi34oCc5Li055WM5pWw6YeP4oCd55qE5aKe5Yqg77yM6L+b6ICM5a6e546w572R57uc5pWI5bqU55qE5aKe5Yqg77yM6L+Z56eN5oOF5Ya15LiL5Y+v6IO95Lya5a+86Ie05pu06auY55qE5L2/55So5oSP5oS/WzIyXeOAguWboOatpOS+m+W6lOmTvuaIkOWRmOmXtOeOsOacieWFs+ezu+WvueaYr+WQpumHh+eUqOi3qOe9kee7nOeahOWMuuWdl+mTvuaKgOacr+S8muS6p+eUn+mHjeWkp+W9seWTjeOAguWGjeasoeaYr+S+v+WIqeadoeS7tuWboOe0oOOAguS+v+WIqeadoeS7tuaYr+aMh+KAnOS4quS9k+iupOS4uue7hOe7h+aKgOacr+WfuuehgOiuvuaWvei1luS7peaUr+aMgeezu+e7n+S9v+eUqOeahOeoi+W6puKAnVsyN13jgILlsLHljLrlnZfpk77ogIzoqIDvvIzlsLHmmK/mjIfkuKrkvZPlr7nnu4Tnu4fkuK3lj6/nlKjkuo7mlK/mjIHljLrlnZfpk77kvb/nlKjnmoTotYTmupDnmoTnkIbop6PjgILlt7LmnInnoJTnqbbooajmmI7vvIzljIXmi6zorqHnrpfmnLrjgIHnvZHpgJ/jgIHkuI7lhbbku5bns7vnu5/nmoTpm4bmiJDnrYnlnKjlhoXnmoTkvr/liKnmnaHku7bpg73kvJrlvbHlk43nm7jlhbPmioDmnK/nmoTph4fnurPlkozkvb/nlKhbMjgtMzBd44CC5pyA5ZCO5piv5L+h5Lu75Zug57Sg77yM5YyF5ous5a+55oqA5pyv55qE5L+h5Lu75Lul5Y+K5L6b5bqU6ZO+5Yip55uK55u45YWz6ICF5LmL6Ze055qE5L+h5Lu744CC5oqA5pyv5YWs5L+h5Yqb5Lya5b2x5ZON5Lq65Lus5a+55oqA5pyv55qE5oCB5bqm77yM6L+b6ICM5b2x5ZON5Lq65Lus5L2/55So5oqA5pyv55qE5oSP5oS/44CCVGhhdGNoZXIgZXQgYWwuWzMxXeaMh+WHuu+8jOe8uuS5j+WvuUlU55qE5L+h5Lu75Y+v6IO95a+86Ie055So5oi35Ye65LqO5a+55Y+v6Z2g5oCn5oiW5oCn6IO957y65LmP5L+h5b+D6ICM5YGc5q2i5L2/55So6K+l5oqA5pyv44CC5aaC5p6c55So5oi35oSP6K+G5Yiw5Yy65Z2X6ZO+5oqA5pyv5LiN5a6J5YWo77yM5LuW5Lus5bCG5LiN5Lya5L2/55So6K+l5oqA5pyv44CC5b2T54S277yM6ZqP552A55So5oi35a+55oqA5pyv55qE5LqG6Kej5ZKM5a2m5Lmg6LaK5aSa77yM5LuW5Lus5oul5pyJ55qE57uP6aqM5ZKM55+l6K+G5bCx6LaK5aSa77yM5oqA5pyv5Zyo5LuW5Lus55yL5p2l5bCx6LaK5Y+v5L+h44CC5Zug5q2k77yM5a+55oqA5pyv55qE5L+h5Lu75oiQ5Li65LqG6Kej55So5oi35L2/55So5oSP5oS/55qE5LiA5Liq6YeN6KaB5Zug57Sg44CC5L6b5bqU6ZO+5Yip55uK55u45YWz6ICF5LmL6Ze055qE5L+h5Lu75piv5oyH5L6b5bqU6ZO+572R57uc5Lit5Lik5Liq5oiW5Lik5Liq5Lul5LiK55qE5oiQ5ZGY5LmL6Ze055u45LqS5L6d6LWW5bm257u05oqk5b285q2k5pyf5pyb55qE5oSP5oS/WzIzXeOAguS+m+W6lOmTvuWIqeebiuebuOWFs+iAheS5i+mXtOeahOS/oeS7u+aYr+WwhuWMuuWdl+mTvuaKgOacr+W6lOeUqOS6juS+m+W6lOmTvue9kee7nOS4reeahOWfuuacrOWJjeaPkOOAgiDmraTlpJbvvIzov5jmnInlrabogIXku47kvpvlupTpk77nrqHnkIbnm67moIfop5LluqbliIbmnpDlupTnlKjljLrlnZfpk77mioDmnK/nmoTpqbHliqjlm6DntKDvvIzmr5TlpoLlhYvmnI3kvpvlupTpk77kuK3mlq3kuI7lpI3mnYLmgKdbMzItMzNd77yM56Gu5L+d5Lqn5ZOB55qE5a6J5YWo44CB55yf5a6e44CB5ZCI5rOVWzM0LTM1Xe+8jOS7peWPiuWFrOWFseWuieWFqOS4juWPjeiFkOi0pVszNi0zN13nrYnjgIIgKOS4iSnljLrlnZfpk77lnKjkvpvlupTpk77kuK3nmoTkuLvopoHlupTnlKjpoobln58g5Yy65Z2X6ZO+5oqA5pyv6LW35Yid5Li76KaB5bqU55So5LqO6YeR6J6N6KGM5Lia77yM5LmL5ZCO6YCQ5riQ5ouT5bGV5Yiw5Yac5Lia44CB6Zu25ZSu44CB5Yy755aX44CB5Yi26YCg5Lia5Lul5Y+K6IO95rqQ562J5aSa6KGM5Lia77yM5Zu95YaF5aSW56CU56m25pmu6YGN6K6k5Li654mp5rWB5ZKM5L6b5bqU6ZO+6aKG5Z+f5piv6L+Z6aG55oqA5pyv6IO95aSf5bim5p2l5b275bqV5Y+Y6Z2p55qE5Li76KaB6aKG5Z+f5LmL5LiAWzM4LTQyXeOAgiDpppblhYjvvIzigJzljLrlnZfpk74r5L6b5bqU6ZO+6YeR6J6N4oCd5piv5Zu95YaF5aSW56CU56m255qE54Ot6Zeo6aKG5Z+f44CC5Yy65Z2X6ZO+5oqA5pyv55qE6L+Q55So6IO96Kej5Yaz5Lyg57uf5L6b5bqU6ZO+6YeR6J6N5Lit5L6b5bqU5ZWG5L+h55So5L+h5oGv6K6w5b2V5LiN5YWo44CB5LqM57qn5Lul5LiK55qE5L6b5bqU5ZWG5LiO57uP6ZSA5ZWG6Zq+6I636LS35qy+44CB5Lit5bCP5b6u5LyB5Lia6Zq+6I635o6I5L+h44CB5o6I5L+h6aKd5bqm6Zq+5Lul56Gu6K6k44CB6J6N6LWE5ZCO5bGl57qm44CB5riF566X5rue5ZCO562J6Zeu6aKYWzIxXeOAguWMuuWdl+mTvuWcqOaPkOmrmOS+m+W6lOmTvumHkeiejeihjOS4mueahOmAj+aYjuW6puOAgeaJqeWkp+acjeWKoeWvueixoeOAgeaPkOmrmOaViOeOh+OAgemZjeS9jumjjumZqeOAgeWKoOW8uui1hOmHkea1geeuoeeQhuS4reWFt+acieaYjuaYvuS8mOWKv1s0M13jgILljLrlnZfpk77lnKjlm73lhoXkvpvlupTpk77ph5Hono3lupTnlKjmoYjkvovooajnjrDkuLrku6XmoLjlv4PkvIHkuJrkuLrkuLvlr7znmoTigJxDaGFpbmVkIEZpbmFuY2XigJ3ljLrlnZfpk77ph5Hono3lubPlj7DjgIHku6XmioDmnK/mj5DkvpvmlrnkuLrkuLvlr7znmoTohb7orq/igJzljLrlnZfpk74r5L6b5bqU6ZO+6YeR6J6N6Kej5Yaz5pa55qGI4oCd44CB5Lul6YeR6J6N5py65p6E5Li65Li75a+855qE5bmz5a6J6ZO26KGM5L6b5bqU6ZO+5bqU5pS26LSm5qy+5pyN5Yqh5bmz5Y+w562J5LiJ5Liq5Li76KaB57G75Z6LWzQ0XeOAguWcqOWbveWklu+8jOmHkeiejeenkeaKgOWFrOWPuE9HWURvY3PmnoTlu7rljLrlnZfpk77otLjmmJPph5Hono3lubPlj7BXYXZl77yM5Yip55So5YiG5biD5byP6LSm5pys5a+55paH5Lu25ZKM5ZWG5ZOB5Zyo6L+Q6L6T6L+H56iL5Lit55qE5omA5pyJ5p2D6L+b6KGM566h55CG77yM5pu/5Luj5Lyg57uf55qE5ZCE6aG557q46LSo5Y2V6K+B77yM5Lul5o+Q6auY5Zu96ZmF6LS45piT55qE5Lqk5piT5pWI546H5ZKM5a6J5YWo5oCn77yM5Y676Zmk57qg57q344CB5Lyq6YCg5ZOB5ZKM5LiN5b+F6KaB55qE6aOO6ZmpWzQ0XeOAgiDlhbbmrKHvvIznianmtYHkvpvlupTpk77poobln5/mmK/ljLrlnZfpk77mnIDmnInlupTnlKjliY3mma/nmoTpoobln5/kuYvkuIBbNDVd44CC5Yy65Z2X6ZO+5oqA5pyv55qE5YiG5biD5byP6K6w6LSm54m55oCn6IO95L2/5L6b5bqU6ZO+5LiK55qE5L+h5oGv5L+d5oyB5LiA6Ie077yM5ZCE6IqC54K55oiQ5ZGY5YWx5Lqr5YWs5byA55qE5L+h5oGv6LWE5rqQ77yM5pyJ5Yip5LqO6Kej5Yaz5L+h5oGv5LiN5a+556ew6Zeu6aKYO+aZuuiDveWQiOe6puacuuWItuWPr+WcqOaXoOmcgOesrOS4ieaWueS7i+WFpeeahOaDheWGteS4i+aMieinhOWImeiHquWKqOeUn+aIkOWQiOe6pu+8jOW5tuWcqOa7oei2s+S6pOaYk+adoeS7tuaXtuiHquWKqOaJp+ihjOWQiOe6puadoeasvu+8jOiDveaPkOmrmOWQhOeOr+iKguaUr+S7mOWSjOS6pOaYk+aViOeOh++8jOmBv+WFjei1hOmHkeW7tui/n+mjjumZqTvml7bpl7TmiLPlkozmuq/mupDpmLLkvKrmioDmnK/lj6/lr7nnianmtYHkvpvlupTpk77kuIrnmoTkuqflk4Hov5vooYzlhajpk77ot5/ouKrvvIzlrp7njrDlronlhajjgIHpq5jmlYjjgIHlj6/pnaDnmoTkv6Hmga/kvKDovpM76Z2e5a+556ew5Yqg5a+G5oqA5pyv5Y+v5Lul5L+d6K+B5pWw5o2u5LiN6KKr56+h5pS577yM5pyJ5Yqp5LqO5Lqk5piT5Li76aKY5LmL6Ze05L+h5Lu75YWz57O755qE5bu656uLWzQ2XeOAguWcqOWQhOWbveaUv+W6nOWSjOebuOWFs+S8geS4mueahOaUr+aMgeS4i++8jOS4gOS6m+KAnOWMuuWdl+mTvivnianmtYHkvpvlupTpk77igJ3pobnnm67lvpfku6Xlrp7ot7XvvIzlpoLkuLnpuqboiKrov5Dlhazlj7jpqazlo6vln7rkuI5JQk3nmoTlhajnkIPot6jlooPnianmtYHns7vnu59bNDdd44CB5paw5Yqg5Z2h5YWs5Y+4WW9qZWXnmoTov5DovpPkvJjljJbns7vnu59bNDhd44CB55Ge5aOr5YWs5Y+4TW9kdW3kuI7oi4/pu47kuJblpKflrablkIjkvZzorr7orqHnmoTljLvoja/ov5DovpPns7vnu59bN13jgIHoi7Hlm73lhazlj7hFdmVybGVkZ2Vy5Z+65LqO5Yy65Z2X6ZO+55qE5Lqn5ZOB5p2l5rqQ6aqM6K+B57O757ufWzQ5XeetieOAgui/meS6m+mhueebrueahOaIkOWKn+WunuaWveS4uuWMuuWdl+mTvuW6lOeUqOenr+e0r+S6huWunei0tee7j+mqjOOAgiDmnIDlkI7vvIzljLrlnZfpk77lnKjlhbbku5bpoobln5/kvpvlupTpk77kuIrnmoTlupTnlKjkvZPnjrDkuobljLrlnZfpk77mioDmnK/lupTnlKjnmoTlpJrmoLfmgKfvvIzlhbfkvZPooajnjrDkuLrlnKjlhpzkuqflk4HjgIHpo5/lk4HjgIHljLvoja/jgIHnlLXlipvjgIHlhpvkuovkvpvlupTpk77nrYnkvJflpJrpoobln5/nmoTlhbfkvZPov5DnlKjjgILljLrlnZfpk77lnKjlhpzkuqflk4FbNTBd5ZKM6aOf5ZOBWzUxXeS+m+W6lC4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CkkgbmVlZCB0byB3cml0ZSBhIHJlc2VhcmNoIHBhcGVyIG9uIGFuIEFJLWJhc2VkIG1lZGljYWwgaW1hZ2luZy1hc3Npc3RlZCBkaWFnbm9zaXMgc3lzdGVtLiBQbGVhc2UgaGVscCBtZSBkcmFmdCBhIHBhcGVyIG91dGxpbmUuCnVzZXI6ClBsZWFzZSBoZWxwIG1lIGRyYWZ0IGFuIG91dGxpbmUgZm9yIGEgcmV2aWV3IHBhcGVyIG9uIHRoZSBhcHBsaWNhdGlvbiBvZiBhdWdtZW50ZWQgcmVhbGl0eSB0ZWNobm9sb2d5IGluIGluZHVzdHJpYWwgbWFpbnRlbmFuY2UsIHRhcmdldGluZyBpbmR1c3RyeSBwcm9mZXNzaW9uYWxzLgp1c2VyOgpQbGVhc2UgaGVscCBtZSB3cml0ZSBhbiBvdXRsaW5lIGZvciBhIHJlc2VhcmNoIHBhcGVyIG9uIHRoZSBjb250cm9sIHN5c3RlbSBvZiBzb2Z0IHJvYm90cy4gVGhlIHBhcGVyIG1haW5seSBmb2N1c2VzIG9uIHRoZSBpc3N1ZSBvZiBwcmVjaXNlIGVuZC1lZmZlY3RvciBjb250cm9sIG9mIHNvZnQgcm9ib3RzIGJhc2VkIG9uIHZpc3VhbCBmZWVkYmFjaywgdXNpbmcgUk9TIGFuZCBHYXplYm8gcGxhdGZvcm1zIGZvciBzaW11bGF0aW9uIGV4cGVyaW1lbnRzLCB2ZXJpZnlpbmcgdGhlIGNvbnRyb2wgYWxnb3JpdGhtIG9uIGEgcGh5c2ljYWwgcHJvdG90eXBlLCBhbmQgY29sbGVjdGluZyBleHBlcmltZW50YWwgZGF0YSB1bmRlciB0aHJlZSBkaWZmZXJlbnQgbG9hZCBjb25kaXRpb25zIChubyBsb2FkLCAxMDBnLCAyMDBnKS4gVGhlIHBhcGVyIG5lZWRzIHRvIGNvbXBhcmUgYW5kIGFuYWx5emUgdGhlIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2VzIGJldHdlZW4gUElEIGNvbnRyb2wgYW5kIGFkYXB0aXZlIGNvbnRyb2wgYXBwcm9hY2hlcy4KdXNlcjoKSSBhbSBhIHRyYWZmaWMgY29udHJvbCBzeXN0ZW0gZW5naW5lZXIgYW5kIHdvdWxkIGxpa2UgdG8gd3JpdGUgYSBwYXBlciBvbiB0aGUgdG9waWMgb2YgdXJiYW4gdHJhZmZpYyBzaWduYWwgb3B0aW1pemF0aW9uIGNvbnRyb2wgc3lzdGVtcy4gUGxlYXNlIGhlbHAgbWUgY29tcGxldGUgYW4gb3V0bGluZSBmb3IgdGhlIHBhcGVyLCByZXR1cm5pbmcgaXQgaW4gaGllcmFyY2hpY2FsIGZvcm0uIFRoZSBwYXBlciBzaG91bGQgYmUgYWltZWQgYXQgcHJvZmVzc2lvbmFsIHJlYWRlcnMgaW4gdGhlIGZpZWxkIG9mIHRyYWZmaWMgZW5naW5lZXJpbmcsIHdpdGggYSByaWdvcm91cyBhbmQgcHJvZmVzc2lvbmFsIHdyaXRpbmcgc3R5bGUgdGhhdCBlbXBoYXNpemVzIGVuZ2luZWVyaW5nIHByYWN0aWNlLiBUaGUgZm9sbG93aW5nIHBvaW50cyBuZWVkIHRvIGJlIGhpZ2hsaWdodGVkOiAxKSBJbnRlZ3JhdGluZyBhY3R1YWwgZGVwbG95bWVudCBwcm9qZWN0IGNhc2VzIGFuZCBkYXRhIHRoYXQgSSBhbSByZXNwb25zaWJsZSBmb3I7IDIpIEhpZ2hsaWdodGluZyB0ZWNobmljYWwgaW5ub3ZhdGlvbiwgZXNwZWNpYWxseSBpbXByb3ZlbWVudHMgaW4gYWxnb3JpdGhtIG9wdGltaXphdGlvbiBhbmQgcmVhbC10aW1lIGNvbnRyb2w7IDMpIFRoZSB3cml0aW5nIHN0eWxlIHNob3VsZCBtZWV0IHRoZSBzdWJtaXNzaW9uIHJlcXVpcmVtZW50cyBmb3IgY29yZSBqb3VybmFscy4gIApNeSBwcm9jZXNzIGRvY3VtZW50YXRpb24gYW5kIGZvcm1hdHRpbmcgcmVxdWlyZW1lbnRzIGZvciB0aGUgcGFwZXIgY2FuIGJlIHJlZmVyZW5jZWQgaW46ICoqMS4gRGV0YWlsZWQgVGVjaG5pY2FsIERvY3VtZW50YXRpb24gb2YgdGhlIEFjdHVhbCBEZXBsb3ltZW50IFByb2plY3QsIEluY2x1ZGluZyBTeXN0ZW0gQXJjaGl0ZWN0dXJlLCBBbGdvcml0aG0gRGVzaWduLCBhbmQgSW50ZXJmYWNlIFNwZWNpZmljYXRpb25zOioqICAKClRoZSBzeXN0ZW0gYWRvcHRzIGEgY29udHJvbCBzY2hlbWUgY2VudGVyZWQgYXJvdW5kIHRoZSBBVDg5QzUxIG1pY3JvY29udHJvbGxlci4gSXQgY2FsY3VsYXRlcyB0aGUgZ3JlZW4gYW5kIHJlZCBsaWdodCBkdXJhdGlvbnMgZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zIHVzaW5nIGFuIGFsZ29yaXRobSBhbmQgZGlzcGxheXMgdGhlIGNvdW50ZG93biBvbiBhIGRpZ2l0YWwgZGlzcGxheS4gQXQgdGhlIHNhbWUgdGltZSwgdGhlIHN5c3RlbSBjb250cm9scyB2ZWhpY2xlIHBhc3NhZ2UgYW5kIHN0b3BwaW5nIGJ5IHR1cm5pbmcgdGhlIHRyYWZmaWMgbGlnaHRzIGF0IHRoZSBpbnRlcnNlY3Rpb24gb24gYW5kIG9mZi4gQWRkaXRpb25hbGx5LCB0aGUgc2NoZW1lIGluY2x1ZGVzIGFuIGVtZXJnZW5jeSB2ZWhpY2xlIHBhc3NhZ2UgYnV0dG9uLiBXaGVuZXZlciBhbiBlbWVyZ2VuY3kgdmVoaWNsZSBuZWVkcyB0byBwYXNzLCB0aGUgb3BlcmF0b3IgcHJlc3NlcyB0aGUgYnV0dG9uLCB0dXJuaW5nIGFsbCB0cmFmZmljIGxpZ2h0cyBpbiBib3RoIGVhc3Qtd2VzdCBhbmQgbm9ydGgtc291dGggZGlyZWN0aW9ucyByZWQgd2hpbGUgc291bmRpbmcgYW4gYWxhcm0gdG8gcHJvaGliaXQgcmVndWxhciB2ZWhpY2xlcyBmcm9tIHBhc3NpbmcsIGFsbG93aW5nIHRoZSBlbWVyZ2VuY3kgdmVoaWNsZSB0byBnbyBmaXJzdC4gIAoKVGhlIGludGVyc2VjdGlvbiBjb25zaXN0cyBvZiB0d28gbWFpbiByb2FkcyBjcm9zc2luZyBlYWNoIG90aGVyLCB3aXRoIGVhY2ggcm9hZCBoYXZpbmcgYSBzZXQgb2YgcmVkLCB5ZWxsb3csIGFuZCBncmVlbiB0cmFmZmljIGxpZ2h0cywgYXMgd2VsbCBhcyBhIGxlZnQtdHVybiBpbmRpY2F0b3IuIFRoZXNlIGxpZ2h0cyBkaXJlY3QgdmVoaWNsZXMgZm9yIHNhZmUgcGFzc2FnZTogcmVkIG1lYW5zIHN0b3AsIGdyZWVuIG1lYW5zIGdvLCBhbmQgeWVsbG93IHNlcnZlcyBhcyBhIHdhcm5pbmcgaW5kaWNhdGluZyBhbiBpbW1pbmVudCBjaGFuZ2UgYmV0d2VlbiByZWQgYW5kIGdyZWVuLiBUaGUgZHVyYXRpb24gb2YgdGhlIHllbGxvdyBsaWdodCBpcyBzZXQgYXMgdGhlIHNoYXJlZCBzdG9wcGluZyB0aW1lIGZvciBib3RoIHRoZSBlYXN0LXdlc3QgYW5kIG5vcnRoLXNvdXRoIHJvYWRzLiBUaGUgbGVmdC10dXJuIGluZGljYXRvciBhbGxvd3MgdmVoaWNsZXMgb24gdGhlIG1haW4gcm9hZCB0byBtYWtlIGEgbGVmdCB0dXJuLiAgCgpUaGlzIHN5c3RlbSB1dGlsaXplcyB0aGUgQVQ4OUM1MSBtaWNyb2NvbnRyb2xsZXIgYXMgaXRzIGNvcmUgY29udHJvbCBjb21wb25lbnQuIEl0IGVtcGxveXMgdGltZXJzIHRvIGNvbnRyb2wgdGhlIG9uL29mZiBzdGF0ZXMgb2YgdGhlIHRyYWZmaWMgbGlnaHRzIGNvbm5lY3RlZCB0byB0aGUgUDAgcG9ydCB3aGlsZSBkaXNwbGF5aW5nIHRoZSBjb3VudGRvd24gb24gYW4gOC1zZWdtZW50IGRpZ2l0YWwgZGlzcGxheSBjb25uZWN0ZWQgdG8gdGhlIFAxIGFuZCBQMiBwb3J0cy4gVGhlIGNpcmN1aXQgZGlhZ3JhbSBtYWlubHkgY29uc2lzdHMgb2YgYSBwb3dlciBzdXBwbHkgY2lyY3VpdCwgYSB0cmFmZmljIGxpZ2h0IGRpc3BsYXkgY2lyY3VpdCwgYSB0cmFmZmljIGxpZ2h0IGNvdW50ZG93biB0aW1lciBjaXJjdWl0LCBhbmQgYW4gZW1lcmdlbmN5IGJ1dHRvbiAoSzEpIGNpcmN1aXQuICAKClRoZSBwb3dlciBzdXBwbHkgYWRvcHRzIGEgcmVndWxhdGVkIHBvd2VyIGNpcmN1aXQgdGhhdCBvdXRwdXRzIGEgc3RhYmxlICs1ViBEQyB2b2x0YWdlLiBUaGUgSUMgdXNlcyB0aGUgaW50ZWdyYXRlZCB2b2x0YWdlIHJlZ3VsYXRvciA3ODA1LCBhIHN0YW5kYXJkaXplZCwgd2lkZWx5IHVzZWQgbGluZWFyIHZvbHRhZ2UgcmVndWxhdG9yIHdpdGggYWR2YW50YWdlcyBzdWNoIGFzIHNtYWxsIHNpemUsIGxvdyBjb3N0LCBnb29kIHBlcmZvcm1hbmNlLCBoaWdoIHJlbGlhYmlsaXR5LCBhbmQgZWFzZSBvZiB1c2UuIEl0IGlzIG9uZSBvZiB0aGUgbW9zdCB3aWRlbHkgYXBwbGllZCBtb25vbGl0aGljIGludGVncmF0ZWQgcmVndWxhdG9ycyBpbiByZWd1bGF0ZWQgcG93ZXIgc3VwcGxpZXMuIFdoZW4gdGhlIG91dHB1dCBjdXJyZW50IGlzIHJlbGF0aXZlbHkgaGlnaCwgdGhlIDc4MDUgc2hvdWxkIGJlIGVxdWlwcGVkIHdpdGggYSBoZWF0IHNpbmsuIENhcGFjaXRvciBDMyBzZXJ2ZXMgYXMgdGhlIGlucHV0IGZpbHRlciBjYXBhY2l0b3IsIHdoaWxlIEM1IGFjdHMgYXMgdGhlIG91dHB1dCBmaWx0ZXIgY2FwYWNpdG9yLiAgCgpUaGUgc3lzdGVtIHVzZXMgYSAyMjBWIEFDIHBvd2VyIHNvdXJjZS4gQWZ0ZXIgcGFzc2luZyB0aHJvdWdoIGEgNVYgYWRhcHRlciBhbmQgZmlsdGVyaW5nLCBpdCBmb3JtcyBhIHJlbGF0aXZlbHkgdW5zdGFibGUgREMgdm9sdGFnZSBhdCB0aGUgVmluIGFuZCBHTkQgdGVybWluYWxzIG9mIHRoZSBmaXhlZCB0aHJlZS10ZXJtaW5hbCB2b2x0YWdlIHJlZ3VsYXRvciBMTTc4MDUuIFRoaXMgdm9sdGFnZSBvZnRlbiBmbHVjdHVhdGVzIGR1ZSB0byB2YXJpYXRpb25zIGluIHRoZSBtYWlucyB2b2x0YWdlIG9yIGxvYWQgY2hhbmdlcy4gQWZ0ZXIgTE03ODA1IHJlZ3VsYXRpb24gYW5kIGNhcGFjaXRvciBmaWx0ZXJpbmcsIHRoZSBvdXRwdXQgc2lkZSBvZiB0aGUgcmVndWxhdGVkIHBvd2VyIHN1cHBseSBnZW5lcmF0ZXMgYSBoaWdobHkgYWNjdXJhdGUgYW5kIHN0YWJsZSBEQyB2b2x0YWdlLiAgCgpUaGlzIGRlc2lnbiBhZG9wdHMgQyBsYW5ndWFnZSBhcyB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UuIENvbXBhcmVkIHRvIGFzc2VtYmx5IGxhbmd1YWdlLCBDIGdlbmVyYXRlcyBtYWNoaW5lIGNvZGUgd2l0aCBzaW1pbGFyIGVmZmljaWVuY3kgd2hpbGUgb2ZmZXJpbmcgbXVjaCBiZXR0ZXIgcmVhZGFiaWxpdHkgYW5kIHBvcnRhYmlsaXR5LiBBbHRob3VnaCBhc3NlbWJseSBsYW5ndWFnZSBhbGxvd3MgZm9yIGhpZ2hseSBlZmZpY2llbnQgbWFjaGluZSBjb2RlIGdlbmVyYXRpb24sIGl0IGlzIGRpZmZpY3VsdCB0byByZWFkLCBlc3BlY2lhbGx5IGZvciBjb21wbGV4IHByb2dyYW1zLiBDIGxhbmd1YWdlLCBpbiBtb3N0IGNhc2VzLCBtYXRjaGVzIGFzc2VtYmx5IGxhbmd1YWdlIGluIG1hY2hpbmUgY29kZSBlZmZpY2llbmN5IHdoaWxlIGdyZWF0bHkgc3VycGFzc2luZyBpdCBpbiByZWFkYWJpbGl0eSBhbmQgcG9ydGFiaWxpdHkuIEFkZGl0aW9uYWxseSwgQyBhbGxvd3MgZm9yIGVtYmVkZGVkIGFzc2VtYmx5IGNvZGUgdG8gaGFuZGxlIHJlYWwtdGltZSBjcml0aWNhbCB0YXNrcy4gIAoKRm9yIGRldmVsb3BtZW50IHRpbWUsIG1lZGl1bS10by1sYXJnZSBzb2Z0d2FyZSBwcm9qZWN0cyB3cml0dGVuIGluIEMgZ2VuZXJhbGx5IGhhdmUgYSBzaWduaWZpY2FudGx5IHNob3J0ZXIgZGV2ZWxvcG1lbnQgY3ljbGUgdGhhbiB0aG9zZSB3cml0dGVuIGluIGFzc2VtYmx5LiBDb25zaWRlcmluZyB0aGVzZSBhZHZhbnRhZ2VzLCB0aGlzIGRlc2lnbiB1c2VzIEMgYXMgdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlLiAgCgpUaGUgcHJvZ3JhbW1pbmcgZW52aXJvbm1lbnQgY2hvc2VuIGZvciB0aGlzIHByb2plY3QgaXMgS2VpbCDCtVZpc2lvbiAyLjAuIFRoaXMgc29mdHdhcmUgc3VwcG9ydHMgdmFyaW91cyBNQ1MtNTEgYXJjaGl0ZWN0dXJlIG1pY3JvY29udHJvbGxlcnMgZnJvbSBkaWZmZXJlbnQgbWFudWZhY3R1cmVycywgaW50ZWdyYXRpbmcgZWRpdGluZywgY29tcGlsaW5nLCBhbmQgc2ltdWxhdGlvbiBmdW5jdGlvbmFsaXRpZXMuIEl0IGFsc28gc3VwcG9ydHMgUExNLCBhc3NlbWJseSwgYW5kIEMgcHJvZ3JhbW1pbmcsIGZlYXR1cmluZyBhIHVzZXItZnJpZW5kbHkgaW50ZXJmYWNlIHRoYXQgaXMgZWFzeSB0byBsZWFybi4gS2VpbCDCtVZpc2lvbiBwcm92aWRlcyBhIGNvbnZlbmllbnQgZGVidWdnaW5nIGVudmlyb25tZW50IGluIHRoZSBlYXJseSBzdGFnZXMgb2Ygc29mdHdhcmUgdGVzdGluZyBhbmQgb2ZmZXJzIHN0cm9uZyBzaW11bGF0aW9uIGNhcGFiaWxpdGllcy4gIAoKQ3VycmVudGx5LCB0aGUgbW9zdCBjb21tb24gcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzIGZvciBNQ1MtNTEgbWljcm9jb250cm9sbGVycyBpbmNsdWRlIFBMTSwgYXNzZW1ibHksIGFuZCBDLiBBbW9uZyB0aGVtLCBhc3NlbWJseSBhbmQgQyBhcmUgdGhlIG1vc3Qgd2lkZWx5IHVzZWQuIEFzc2VtYmx5IGxhbmd1YS4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CkkgYW0gY29uZHVjdGluZyByZXNlYXJjaCBvbiBpbnRlbGxpZ2VudCBidWlsZGluZyBlbmVyZ3ktc2F2aW5nIGNvbnRyb2wuIEkgaGF2ZSBhIHNldCBvZiBvcGVyYXRpb25hbCBkYXRhIGZyb20gYW4gb2ZmaWNlIGJ1aWxkaW5nJ3MgYWlyIGNvbmRpdGlvbmluZyBzeXN0ZW0gc3Bhbm5pbmcgNiBtb250aHMsIGluY2x1ZGluZyBtZWFzdXJlZCBkYXRhIHN1Y2ggYXMgaW5kb29yIHRlbXBlcmF0dXJlLCBodW1pZGl0eSwgQ08yIGNvbmNlbnRyYXRpb24sIGVuZXJneSBjb25zdW1wdGlvbiwgYW5kIG9wdGltaXphdGlvbiByZWNvcmRzIG9mIHRoZSBhaXIgY29uZGl0aW9uaW5nIHN5c3RlbSBjb250cm9sIGFsZ29yaXRobSBiYXNlZCBvbiBkZWVwIHJlaW5mb3JjZW1lbnQgbGVhcm5pbmcuIEkgaG9wZSB0byB3cml0ZSBhIHBhcGVyIGZvbGxvd2luZyB0aGUgc3VibWlzc2lvbiBndWlkZWxpbmVzIG9mIHRoZSBqb3VybmFsICpCdWlsZGluZyBhbmQgRW52aXJvbm1lbnQqLiBQbGVhc2UgcHJvdmlkZSBhIGRldGFpbGVkIG91dGxpbmUgZm9yIHRoZSBwYXBlci4KdXNlcjoK5oiR5oOz5pKw5YaZ5LiA56+H5py65Zmo5a2m5Lmg5Zyo5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi25Lit55qE5bqU55So56CU56m26K665paH77yM5YeG5aSH5oqV56i/44CK5pm66IO95Yi26YCg44CL5pyf5YiK44CC6K665paH56qB5Ye65py65Zmo5a2m5Lmg566X5rOV5Zyo5bel5Lia5Zy65pmv5LiL55qE5pS56L+b5Yib5paw54K55ZKM5a6e6ZmF5bel56iL5bqU55So5pWI5p6c44CC6K+35oyJ54Wn44CK5pm66IO95Yi26YCg44CL5pyf5YiK5qC85byP6KaB5rGC77yM5biu5oiR5YaZ5LiA5Liq6K665paH5aSn57qy44CC5Y+v5Lul5Y+C6ICD5Lul5LiL6IyD5paH57Sg5p2Q44CC5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi2ICDoooHoiqwgICDljZfkuqzmnLrnlLXogYzkuJrmioDmnK/lrabpmaLoh6rliqjljJblt6XnqIvns7sgICDmkZjopoHvvJrln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbmmK/lvZPliY3lt6XkuJrnlJ/kuqfkuK3lhbPms6jnmoTng63ngrnpoobln5/jgILmnKzmlofns7vnu5/lnLDmjqLorqjkuobln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTlhbPplK7mioDmnK/lkozkuLvopoHmtYHnqIvvvIzmj5Dlh7rkuobln7rkuo7mt7HluqblrabkuaDnmoTmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTlupTnlKjnrZbnlaXvvIzljIXmi6zln7rkuo7mmbrog73kvKDmhJ/lmajnmoTlrp7ml7botKjph4/nm5HmtYvjgIHln7rkuo7pooTmtYvliIbmnpDnmoTmlYXpmpzmo4DmtYvkuI7pooTorabjgIHln7rkuo7ov5znqIvnm5HmjqfnmoTliIbluIPlvI/otKjph4/mjqfliLbvvIzku6Xlj4rln7rkuo7nn6Xor4blm77osLHnmoTnn6Xor4bmjqjnkIbkuI7lhrPnrZbvvIzku6Xkvpvlj4LogIPjgIIgIOWfuumHke+8miAyMDIz5bm05bqm5rGf6IuP6auY5qCh4oCc6Z2S6JOd5bel56iL4oCd6LWE5YqpIDsgMjAyM+W5tOW6puaxn+iLj+mrmOagoeWTsuWtpuekvuS8muenkeWtpueglOeptumhueebrueglOeptuaIkOaenO+8iDIwMjNTSllCMDgyNu+8iSA7IOWNl+S6rOacuueUteiBjOS4muaKgOacr+WtpumZouenjeWtkOWfuumHkemhueebrueglOeptuaIkOaenO+8iExEMjAyMzAx77yJICAg5YWz6ZSu6K+N77ya5py65qKw5pm66IO95Yi26YCgO+i0qOmHj+aOp+WItjvmt7HluqblrabkuaA75pWw5o2u5aSE55CGO+WunuaXtuebkea1iyAg5L2c6ICF566A5LuL77ya6KKB6Iqs77yIMTk4M+KAlO+8ie+8jOWls++8jOehleWjq++8jOiusuW4iO+8jOS4u+imgeeglOeptuaWueWQkeeUteawlOiHquWKqOWMliAg5pS256i/5pel5pyf77yaMjAyMy0wNy0yNSAgRGVlcCBsZWFybmluZy1iYXNlZCBxdWFsaXR5IGNvbnRyb2wgZm9yIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgb2YgbWFjaGluZXJ5ICBZVUFOIEZlbiAgRGVwYXJ0bWVudCBvZiBBdXRvbWF0aW9uIEVuZ2luZWVyaW5nLCBOYW5qaW5nIEluc3RpdHV0ZSBvZiBNZWNoYW5pY2FsIGFuZCBFbGVjdHJpY2FsIFRlY2hub2xvZ3kgIEFic3RyYWN077yaUXVhbGl0eSBjb250cm9sIG9mIG1lY2hhbmljYWwgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBiYXNlZCBvbiBkZWVwIGxlYXJuaW5nIGlzIGEgaG90IGFyZWEgb2YgY29uY2VybiBpbiBjdXJyZW50IGluZHVzdHJpYWwgcHJvZHVjdGlvbi4gVGhpcyBwYXBlciBzeXN0ZW1hdGljYWxseSBkaXNjdXNzZXMgdGhlIGtleSB0ZWNobm9sb2dpZXMgYW5kIG1haW4gcHJvY2Vzc2VzIG9mIGRlZXAgbGVhcm5pbmctYmFzZWQgbWVjaGFuaWNhbCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIHF1YWxpdHkgY29udHJvbCwgYW5kIHB1dHMgZm9yd2FyZCB0aGUgYXBwbGljYXRpb24gc3RyYXRlZ2llcyBvZiBkZWVwIGxlYXJuaW5nLWJhc2VkIG1lY2hhbmljYWwgaW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBxdWFsaXR5IGNvbnRyb2wsIGluY2x1ZGluZyByZWFsLXRpbWUgcXVhbGl0eSBtb25pdG9yaW5nIGJhc2VkIG9uIGludGVsbGlnZW50IHNlbnNvcnMsIGZhdWx0IGRldGVjdGlvbiBhbmQgZWFybHkgd2FybmluZyBiYXNlZCBvbiBwcmVkaWN0aXZlIGFuYWx5dGljcywgZGlzdHJpYnV0ZWQgcXVhbGl0eSBjb250cm9sIGJhc2VkIG9uIHJlbW90ZSBtb25pdG9yaW5nIGFuZCBkaXN0cmlidXRlZCBxdWFsaXR5IGNvbnRyb2wsIGFzIHdlbGwgYXMga25vd2xlZGdlIHJlYXNvbmluZyBhbmQgZGVjaXNpb24tbWFraW5nIGJhc2VkIG9uIGtub3dsZWRnZSBncmFwaCwgZm9yIHJlZmVyZW5jZS4gS2V5IHdvcmRz77yaTWVjaGFuaWNhbCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIDsgUXVhbGl0eSBjb250cm9sIDsgRGVlcCBsZWFybmluZyA7IERhdGEgcHJvY2Vzc2luZyA7IFJlYWwtdGltZSBtb25pdG9yaW5nIFJlY2VpdmVk77yaMjAyMy0wNy0yNSAgMCDlvJXoqIAg6ZqP552A5py65qKw5pm66IO95Yi26YCg5oqA5pyv55qE5LiN5pat5Y+R5bGV77yM5Yi26YCg6KGM5Lia5a+55Lqn5ZOB6LSo6YeP55qE6KaB5rGC5Lmf6LaK5p2l6LaK6auY44CC5Lyg57uf55qE6LSo6YeP5o6n5Yi25pa55rOV5Zyo6Z2i5a+55aSn6KeE5qih5pWw5o2u5ZKM5aSN5p2C55Sf5Lqn6L+H56iL5pe26Z2i5Li0552A5oyR5oiY77yM5Zug5q2k6ZyA6KaB5byV5YWl5paw55qE5oqA5pyv5omL5q615p2l6Kej5Yaz6L+Z5Lqb6Zeu6aKY44CC5rex5bqm5a2m5Lmg5L2c5Li65Lq65bel5pm66IO96aKG5Z+f55qE6YeN6KaB5YiG5pSv77yM5Zyo5Zu+5YOP44CB6K+t6Z+z5ZKM6Ieq54S26K+t6KiA5aSE55CG562J6aKG5Z+f5Y+W5b6X5LqG5pi+6JGX55qE5oiQ5p6c77yM5bm25LiU5Zyo6LSo6YeP5o6n5Yi26aKG5Z+f5Lmf5YW35pyJ5bm/6ZiU55qE5bqU55So5YmN5pmv44CC5pys5paH5peo5Zyo6YCa6L+H5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi256CU56m277yM5o+Q5L6b5LiA56eN5paw55qE6Kej5Yaz5pa55qGI5p2l5pS55ZaE5Lyg57uf55qE6LSo6YeP5o6n5Yi25pa55rOV44CCIDEg5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE5YWz6ZSu5oqA5pyvIDEuMSDmt7HluqblrabkuaDnrpfms5Xln7rnoYAg5rex5bqm5a2m5Lmg5piv5LiA56eN5Lul5Lq65bel56We57uP572R57uc5Li65Z+656GA55qE5py65Zmo5a2m5Lmg5pa55rOV77yM5a6D6YCa6L+H5aSa5bGC5qyh55qE56We57uP572R57uc57uT5p6E5p2l5a+55pWw5o2u6L+b6KGM5a2m5Lmg5ZKM6KGo56S644CC5rex5bqm5a2m5Lmg566X5rOV5Z+656GA5YyF5ous5Lul5LiL5Yeg5Liq5YWz6ZSu6KaB57Sg44CCIOmmluWFiO+8jOelnue7j+e9kee7nOaooeWei+aYr+a3seW6puWtpuS5oOeul+azleeahOaguOW/g+OAguWug+eUseWkmuS4quelnue7j+WFg+e7hOaIkOeahOWxguasoee7k+aehO+8jOavj+S4quelnue7j+WFg+mDveS7peWKoOadg+WSjOeahOaWueW8j+aOpeaUtui+k+WFpe+8jOeEtuWQjue7j+i/h+mdnue6v+aAp+a/gOa0u+WHveaVsOi/m+ihjOi9rOaNou+8jOi+k+WHuuWIsOS4i+S4gOWxguOAgumAmuW4uO+8jOa3seW6puWtpuS5oOS4reS9v+eUqOeahOelnue7j+e9kee7nOaooeWei+WMheaLrOWNt+enr+elnue7j+e9kee7nO+8iENOTu+8ieOAgeW+queOr+elnue7j+e9kee7nO+8iFJOTu+8ieWSjOWPmOaNouWZqOe9kee7nO+8iFRyYW5zZm9ybWVy77yJ562J44CC5YW25qyh77yM5rex5bqm5a2m5Lmg566X5rOV55qE5a2m5Lmg6L+H56iL5piv6YCa6L+H5Y+N5ZCR5Lyg5pKt566X5rOV6L+b6KGM55qE44CC5Y+N5ZCR5Lyg5pKt566X5rOV6YCa6L+H6K6h566X6L6T5Ye65LiO55yf5a6e5YC85LmL6Ze055qE6K+v5beu77yM5bm25bCG6K+v5beu5LuO6L6T5Ye65bGC6YCQ5bGC5ZCR5YmN5Lyg5pKt77yM5pu05paw56We57uP572R57uc5Lit55qE5p2D6YeN5ZKM5YGP572u77yM5Lul5pyA5bCP5YyW6K+v5beuWzFd44CC5q2k5aSW77yM5rex5bqm5a2m5Lmg566X5rOV6L+Y6ZyA6KaB6YCJ5oup5ZCI6YCC55qE5o2f5aSx5Ye95pWw5p2l5bqm6YeP6L6T5Ye657uT5p6c5ZKM55yf5a6e5YC85LmL6Ze055qE5beu5byC44CC5bi455So55qE5o2f5aSx5Ye95pWw5YyF5ous5Z2H5pa56K+v5beu77yITVNF77yJ44CB5Lqk5Y+J54a15o2f5aSx5Ye95pWw562J44CC5pyA5ZCO77yM5rex5bqm5a2m5Lmg566X5rOV6L+Y6ZyA6KaB6YCJ5oup5ZCI6YCC55qE5LyY5YyW566X5rOV5p2l5pu05paw56We57uP572R57uc5Lit55qE5Y+C5pWw44CC5bi455So55qE5LyY5YyW566X5rOV5YyF5ous6ZqP5py65qKv5bqm5LiL6ZmN77yIU0dE77yJ44CBQWRhbeS8mOWMlueul+azleetie+8jOWug+S7rOiDveWkn+acieaViOWcsOiwg+aVtOWPguaVsO+8jOaPkOmrmOaooeWei+eahOaAp+iDveOAgiAxLjIg5pWw5o2u6YeH6ZuG5LiO6aKE5aSE55CG5oqA5pyvIOaVsOaNrumHh+mbhuS4jumihOWkhOeQhuaKgOacr+WcqOa3seW6puWtpuS5oOS4reaYr+mdnuW4uOmHjeimgeeahOS4gOatpe+8jOWug+S4u+imgeWMheaLrOaVsOaNruaUtumbhuOAgeaVsOaNrua4hea0l+OAgeaVsOaNrui9rOaNouWSjOaVsOaNruWinuW8uuetiei/h+eoi+OAgiDpppblhYjvvIzmlbDmja7mlLbpm4bmmK/mjIfku47liLbpgKDov4fnqIvkuK3ojrflj5bnm7jlhbPnmoTotKjph4/mjqfliLbmlbDmja7jgILov5nkupvmlbDmja7lj6/ku6XljIXmi6zkvKDmhJ/lmajph4fpm4bnmoTniannkIbkv6Hlj7fjgIHlt6Xoibrlj4LmlbDjgIHop4bop4nlm77lg4/nrYnjgILmlbDmja7mlLbpm4bnmoTotKjph4/lkozmnInmlYjmgKfnm7TmjqXlvbHlk43liLDlkI7nu63mqKHlnovnmoTorq3nu4PlkozmgKfog73jgILlhbbmrKHvvIzmlbDmja7muIXmtJfmmK/mjIflr7nph4fpm4bliLDnmoTljp/lp4vmlbDmja7ov5vooYzljrvlmarjgIHnvLrlpLHlgLzloavlhYXjgIHlvILluLjlgLzlpITnkIbnrYnmk43kvZzvvIzku6XmtojpmaTmlbDmja7kuK3nmoTlmarlo7DlkozlubLmibDvvIzkv53or4HmlbDmja7nmoTlh4bnoa7mgKflkozlrozmlbTmgKfjgILmlbDmja7ovazmjaLmmK/lsIbljp/lp4vmlbDmja7ovazmjaLkuLrmt7HluqblrabkuaDnrpfms5Xog73lpJ/lpITnkIbnmoTlvaLlvI/jgILkvovlpoLvvIzlr7nkuo7lm77lg4/mlbDmja7vvIzlj6/ku6Xov5vooYzlm77lg4/pooTlpITnkIbmk43kvZzvvIzlpoLosIPmlbTlpKflsI/jgIHoo4HliarjgIHml4vovaznrYnjgILlr7nkuo7mlbDlgLzlnovmlbDmja7vvIzlj6/ku6Xov5vooYzlvZLkuIDljJbmiJbmoIflh4bljJblpITnkIbvvIzlsIbmlbDmja7nvKnmlL7liLDkuIDlrprnmoTojIPlm7TlhoXjgILmnIDlkI7vvIzmlbDmja7lop7lvLrmmK/pgJrov4fkuIDns7vliJfnmoTmlbDmja7mianlhYXmlrnms5XvvIznlJ/miJDmm7TlpJrnmoTorq3nu4PmoLfmnKzjgILkvovlpoLvvIzlr7nkuo7lm77lg4/mlbDmja7vvIzlj6/ku6Xov5vooYzpmo/mnLrnv7vovazjgIHml4vovazjgIHnvKnmlL7nrYnmk43kvZzvvIzlop7liqDmlbDmja7nmoTlpJrmoLfmgKflkozmlbDph4/vvIzmj5Dpq5jmqKHlnovnmoTms5vljJbog73lipvjgIIgMS4zIOeJueW+geaPkOWPluS4juihqOekuuWtpuS5oCDnibnlvoHmj5Dlj5bkuI7ooajnpLrlrabkuaDmmK/mt7HluqblrabkuaDkuK3nmoTlhbPplK7njq/oioLvvIzlroPog73lpJ/ku47ljp/lp4vmlbDmja7kuK3mj5Dlj5blh7rlhbfmnInljLrliIbog73lipvnmoTnibnlvoHvvIzlubblsIblhbbooajnpLrkuLrkuIDkuKrkvY7nu7TnmoTlkJHph4/jgIIg5Zyo5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi25Lit77yM54m55b6B5o+Q5Y+W5ZKM6KGo56S65a2m5Lmg5Y+v5Lul5LuO5Y6f5aeL55qE5Lyg5oSf5Zmo5L+h5Y+35oiW5Zu+5YOP5pWw5o2u5Lit5o+Q5Y+W5Ye65Luj6KGo6LSo6YeP54m55b6B55qE5YWz6ZSu5L+h5oGv77yM55So5LqO5Yik5pat5Lqn5ZOB55qE5ZCI5qC85oCn44CCIOWvueS6juWbvuWDj+aVsOaNru+8jOWPr+S7peS9v+eUqOWNt+enr+elnue7j+e9kee7nO+8iENOTu+8iei/m+ihjOeJueW+geaPkOWPluOAgkNOTuiDveWkn+mAmui/h+S4gOezu+WIl+eahOWNt+enr+OAgeaxoOWMluWSjOmdnue6v+aAp+a/gOa0u+etieaTjeS9nO+8jOS7juWbvuWDj+S4reaPkOWPluWHuuWFt+acieWxgOmDqOWSjOWFqOWxgOS/oeaBr+eahOeJueW+geOAgui/meS6m+eJueW+geWPr+S7peihqOekuuWbvuWDj+eahOe6ueeQhuOAgeW9oueKtuWSjOi+uee8mOetieeJueW+ge+8jOeUqOS6juWIpOaWreS6p+WTgeihqOmdoueahOe8uumZt+OAgeW9oueKtuWBj+W3ruetiVsyXeOAgiDlr7nkuo7kvKDmhJ/lmajkv6Hlj7fmlbDmja7vvIzlj6/ku6Xkvb/nlKjlvqrnjq/npZ7nu4/nvZHnu5zvvIhSTk7vvInmiJblj5jmjaLlmajnvZHnu5zvvIhUcmFuc2Zvcm1lcu+8iei/m+ihjOeJueW+geaPkOWPluOAglJOTuiDveWkn+WvueaXtumXtOW6j+WIl+aVsOaNrui/m+ihjOW7uuaooe+8jOW5tuaNleaNieWIsOWFtuS4reeahOaXtuW6j+S+nei1luWFs+ezu+OAguiAjFRyYW5zZm9ybWVy5YiZ6IO95aSf5a+55LiN5ZCM5Lyg5oSf5Zmo5L+h5Y+35LmL6Ze055qE5YWz57O76L+b6KGM5bu65qih77yM5o+Q5Y+W5Ye65YWo5bGA5LiK55qE54m55b6B6KGo56S644CCIDEuNCDmqKHlnovkvJjljJbkuI7mqKHlnovorq3nu4Mg5qih5Z6L5LyY5YyW5ZKM5qih5Z6L6K6t57uD5piv5rex5bqm5a2m5Lmg5Lit6Iez5YWz6YeN6KaB55qE5LiA5q2l77yM5a6D5raJ5Y+K5Yiw6YCJ5oup5ZCI6YCC55qE5qih5Z6L5p625p6E44CB5o2f5aSx5Ye95pWw5ZKM5LyY5YyW566X5rOV77yM5Lul5Y+K5a+55qih5Z6L6L+b6KGM5pyJ5pWI55qE6K6t57uD5ZKM6LCD5LyY44CCIOmAieaLqeWQiOmAgueahOaooeWei+aetuaehOaYr+aooeWei+S8mOWMlueahOmmluimgeS7u+WKoeOAguWcqOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItuS4re+8jOWPr+S7peagueaNruWFt+S9k+S7u+WKoeeahOeJueeCuemAieaLqemAguWQiOeahOelnue7j+e9kee7nOe7k+aehO+8jOWmgkNOTuOAgVJOTuaIllRyYW5zZm9ybWVy562J44CC5ZCM5pe277yM6L+Y6ZyA6KaB6ICD6JmR5qih5Z6L55qE5rex5bqm44CB5a695bqm5ZKM6L+e5o6l5pa55byP562J6LaF5Y+C5pWw55qE6K6+572u77yM5Lul5YWF5YiG5Y+R5oyl5qih5Z6L55qE6KGo6L6+6IO95Yqb44CCIOaNn+WkseWHveaVsOeahOmAieaLqeS4juaooeWei+eahOiuree7g+ebruagh+WvhuWIh+ebuOWFs+OAguWcqOi0qOmHj+aOp+WItuS4re+8jOW4uOeUqOeahOaNn+WkseWHveaVsOWMheaLrOWdh+aWueivr+W3ru+8iE1TRe+8ieOAgeS6pOWPieeGteaNn+WkseWHveaVsOetieOAguWQiOeQhumAieaLqeaNn+WkseWHveaVsOWPr+S7peacieaViOWcsOW8leWvvOaooeWei+WtpuS5oOebruagh+eJueW+ge+8jOW5tuaPkOmrmOaooeWei+eahOmihOa1i+aAp+iDveOAgiDkvJjljJbnrpfms5XnmoTpgInmi6nlkozlj4LmlbDosIPkvJjlr7nkuo7mqKHlnovnmoTorq3nu4PmlYjmnpzoh7PlhbPph43opoHjgILluLjnlKjnmoTkvJjljJbnrpfms5XljIXmi6zpmo/mnLrmoq/luqbkuIvpmY3vvIhTR0TvvInjgIFBZGFt5LyY5YyW566X5rOV562J44CC6L+Z5Lqb5LyY5YyW566X5rOV6IO95aSf6YCa6L+H6K6h566X5qKv5bqm5bm25pu05paw5qih5Z6L5Y+C5pWw77yM5LiN5pat5LyY5YyW5qih5Z6L55qE5oCn6IO944CC5q2k5aSW77yM6L+Y6ZyA6KaB5a+55a2m5Lmg546H44CB5q2j5YiZ5YyW57O75pWw5ZKM5om56YeP5aSn5bCP562J6LaF5Y+C5pWw6L+b6KGM6LCD5LyY77yM5Lul6I635b6X5pu05aW955qE5qih5Z6L5oCn6IO944CCIDIg5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE5Li76KaB5rWB56iLIDIuMSDmlbDmja7mlLbpm4bkuI7pooTlpITnkIYg5Z+65LqO5rex5bqm5a2m5Lmg55qE5py65qKw5pm66IO95Yi26YCg6LSo6YeP5o6n5Yi255qE56ys5LiA5q2l5piv5pWw5o2u5pS26ZuG5LiO6aKE5aSE55CG44CC5Zyo6L+Z5LiA6Zi25q6177yM6ZyA6KaB5pS26ZuG5bm25pW055CG5LiO55Sf5Lqn6L+H56iL5ZKM5Lqn5ZOB6LSo6YeP55u45YWz55qE5pWw5o2u44CC6L+Z5Lqb5pWw5o2u5Y+v5Lul5YyF5ous5Lyg5oSf5Zmo5pWw5o2u44CB5bel6Im65Y+C5pWw44CB5Lqn5ZOB5qOA5rWL57uT5p6c562J44CCIOaVsOaNruaUtumbhueahOi/h+eoi+mcgOimgeiAg+iZkeaVsOaNrueahOWHhuehruaAp+WSjOWujOaVtOaAp+OAguWQiOmAgueahOS8oOaEn+WZqOWSjOiuvuWkh+iiq+eUqOadpeWunuaXtuaUtumbhuaVsOaNru+8jOehruS/neaVsOaNruWFt+aciemrmOi0qOmHj+WSjOmrmOeyvuW6puOAguWQjOaXtu+8jOS5n+imgeehruS/neaVsOaNruaUtumbhueahOmikeeOh+WSjOaXtumXtOeCueWFt+acieS7o+ihqOaAp++8jOS7peS+v+WFqOmdouS6huino+eUn+S6p+i/h+eoi+OAgiDlnKjmlbDmja7pooTlpITnkIbpmLbmrrXvvIzlr7nmlLbpm4bliLDnmoTmlbDmja7ov5vooYzmuIXmtJfjgIHnrZvpgInlkozkv67mraPvvIzku6XljrvpmaTlvILluLjlgLzlkozlmarlo7DvvIzlubbov5vooYzmlbDmja7op4TojIPljJblkozmoIflh4bljJbvvIzkv53or4HmlbDmja7nmoTkuIDoh7TmgKflkozlj6/mr5TmgKfjgILmraTlpJbvvIzlnKjmnInnvLrlpLHlgLznmoTmg4XlhrXkuIvvvIzlj6/ku6Xkvb/nlKjmj5LlgLznrYnmlrnms5Xov5vooYzmlbDmja7nmoTloavooaXjgIIgMi4yIOaehOW7uua3seW6puWtpuS5oOaooeWeiyDmnoTlu7rmt7HluqblrabkuaDmqKHlnovmmK/lrp7njrDmnLrmorDmmbrog73liLbpgKDotKjph4/mjqfliLbnmoTmoLjlv4PmraXpqqTjgILlnKjov5nkuIDpmLbmrrXvvIzpnIDopoHpgInmi6npgILlkIjnmoTmt7HluqblrabkuaDnrpfms5XlkozmnrbmnoTvvIzlubbmoLnmja7pl67popjnmoTnibnngrnov5vooYzmqKHlnovnmoTorr7orqHlkozkvJjljJbjgIIg6aaW5YWI77yM5qC55o2u6LSo6YeP5o6n5Yi255qE55uu5qCH5ZKM6ZyA5rGC77yM6YCJ5oup5ZCI6YCC55qE5rex5bqm5a2m5Lmg566X5rOV77yM5aaC5Y2356ev56We57uP572R57uc77yIQ05O77yJ44CB5b6q546v56We57uP572R57uc77yIUk5O77yJ44CB55Sf5oiQ5a+55oqX572R57uc77yIR0FO77yJ562J44CC5qC55o2u5pWw5o2u55qE54m554K55ZKM6Zeu6aKY55qE5aSN5p2C5bqm77yM6YCJ5oup5ZCI6YCC55qE572R57uc5p625p6E5ZKM5bGC5pWw44CC5YW25qyh77yM6L+b6KGM5pWw5o2u55qE5YiS5YiG77yM5bCG5pWw5o2u6ZuG5YiG5Li66K6t57uD6ZuG44CB6aqM6K+B6ZuG5ZKM5rWL6K+V6ZuG44CC6K6t57uD6ZuG55So5LqO5qih5Z6L55qE6K6t57uD5Y+C5pWw77yM6aqM6K+B6ZuG55So5LqO5qih5Z6L55qE6LCD5LyY5ZKM6YCJ5oup5pyA5L2z5qih5Z6L77yM5rWL6K+V6ZuG55So5LqO6K+E5Lyw5qih5Z6L55qE5oCn6IO95ZKM5rOb5YyW6IO95Yqb44CC5pyA5ZCO77yM6L+b6KGM5qih5Z6L55qE6K6t57uD5ZKM5LyY5YyW44CC5L2/55So6K6t57uD6ZuG5a+55qih5Z6L6L+b6KGM5Y+N5aSN6L+t5Luj5ZKM5LyY5YyW77yM6YCa6L+H5LyY5YyW566X5rOV5ZKM5o2f5aSx5Ye95pWw77yM6LCD5pW05qih5Z6L5Y+C5pWw77yM5o+Q6auY5qih5Z6L55qE6aKE5rWL5YeG56Gu5oCn5ZKM5rOb5YyW6IO95YqbWzNd44CC5Zyo6K6t57uD55qE6L+H56iL5Lit77yM5Y+v5Lul6YeH55So5pWw5o2u5aKe5by65oqA5pyv5p2l5omp5YWF6K6t57uD6ZuG77yM5aKe5Yqg5qih5Z6L55qE6bKB5qOS5oCn44CCIDIuMyDlrp7ml7bnm5HmtYvkuI7lj43ppojmnLrliLYg6YCa6L+H5a6e5pe255uR5rWL55Sf5Lqn6L+H56iL5Lit55qE5pWw5o2u5ZKM6LSo6YeP5oyH5qCH77yM5Y+K5pe25Y+R546w5byC5bi45ZKM6LSo6YeP6Zeu6aKY77yM5bm26YeH5Y+W55u45bqU55qE5Y+N6aaI5o6q5pa944CCIOWcqOWunuaXtuebkea1i+mYtuaute+8jOS9v+eUqOiuree7g+WlveeahOa3seW6puWtpuS5oOaooeWei+WvueWunuaXtuaVsOaNrui/m+ihjOmihOa1i+WSjOWIhuexu++8jOivhuWIq+WHuuW8guW4uOWSjOS4jeiJr+i2i+WKv+OAgui/memcgOimgeWcqOezu+e7n+S4rembhuaIkOWQhOmhueS8oOaEn+WZqOWSjOebkea1i+iuvuWkh++8jOmAmui/h+WunuaXtuaVsOaNrueahOmHh+mbhuWSjOS8oOi+k++8jOWunueOsOWvueeUn+S6p+i/h+eoi+eahOWunuaXtuebkea1i+OAgiDkuIDml6bmo4DmtYvliLDlvILluLjmiJbotKjph4/pl67popjvvIzlj4rml7bov5vooYzlj43ppojlkozmjqfliLbjgILns7vnu5/lj6/ku6XpgJrov4foh6rliqjljJborr7lpIfjgIHmnLrlmajkurrmiJblt6XkurrnmoTlubLpooTmnaXlrp7njrDotKjph4/pl67popjnmoTkv67mraPlkozmjqfliLbjgILlj43ppojmnLrliLbov5jlj6/ku6XlsIbpl67popjkv6Hmga/kvKDpgJLnu5nnm7jlhbPkurrlkZjvvIzku6Xkvr/ov5vooYzov5vkuIDmraXnmoTliIbmnpDlkozlhrPnrZbvvIzpgb/lhY3nsbvkvLzpl67popjnmoTlho3mrKHlj5HnlJ/jgIIgM+WfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItueahOW6lOeUqOetlueVpSAzLjEg5Z+65LqO5pm66IO95Lyg5oSf5Zmo55qE5a6e5pe26LSo6YeP55uR5rWLIOWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItuWcqOWunuaXtui0qOmHj+ebkea1i+aWuemdoumHh+eUqOaZuuiDveS8oOaEn+WZqOeahOetlueVpeOAguaZuuiDveS8oOaEn+WZqOmbhuaIkOS6huWFiOi/m+eahOS8oOaEn+aKgOacr+WSjOa3seW6puWtpuS5oOeul+azle+8jOmAmui/h+WunuaXtumHh+mbhuWSjOWIhuaekOeUn+S6p+i/h+eoi+S4reeahOaVsOaNru+8jOWunueOsOWvueS6p+WTgei0qOmHj+eahOebkea1i+WSjOivhOS8sOOAgiDpppblhYjvvIzmmbrog73kvKDmhJ/lmajlj6/ku6Xlrp7ml7bph4fpm4bnlJ/kuqfov4fnqIvkuK3nmoTlkITnp43lj4LmlbDmlbDmja7vvIzlpoLmuKnluqbjgIHljovlipvjgIHmjK/liqjnrYnjgILov5nkupvmlbDmja7nu4/ov4fkvKDmhJ/lmajlhoXpg6jnmoTmt7HluqblrabkuaDnrpfms5XlpITnkIbvvIzlj6/ku6XnlKjkuo7lrp7ml7bnm5HmtYvkuqflk4HnmoTlkITpobnotKjph4/mjIfmoIfvvIzkvovlpoLlsLrlr7jnsr7luqbjgIHooajpnaLlhYnmtIHluqbnrYnjgIIg5YW25qyh77yM5Z+65LqO5rex5bqm5a2m5Lmg55qE5pm66IO95Lyg5oSf5Zmo6IO95aSf5a2m5Lmg5bm25YiG5p6Q5LiN5ZCM5bel5Ya15LiL55qE5qih5byP5ZKM6KeE5b6L44CC6YCa6L+H5a+55aSn6YeP5pWw5o2u55qE5a2m5Lmg77yM5Lyg5oSf5Zmo5Y+v5Lul5YeG56Gu5Zyw5Yik5pat5piv5ZCm5a2Y5Zyo6LSo6YeP6Zeu6aKY77yM5bm25Y+K5pe257uZ5Ye66aKE6K2m5ZKM5o+Q6YaS77yM5biu5Yqp5LyB5Lia5Y+K5pe26YeH5Y+W5o6q5pa95Lul6YG/5YWN6LSo6YeP6Zeu6aKY55qE5Y+R55Sf44CCIOatpOWklu+8jOaZuuiDveS8oOaEn+WZqOi/mOWPr+S7peS4juacuuWZqOS6uuaIluWFtuS7luiHquWKqOWMluiuvuWkh+i/m+ihjOiBlOWKqO+8jOWunueOsOWunuaXtui0qOmHj+ebkea1i+S4juaOp+WItueahOmXreeOr+OAguS4gOaXpuWPkeeOsOi0qOmHj+W8guW4uO+8jOaZuuiDveS8oOaEn+WZqOWPr+S7pemAmui/h+e9kee7nOS4jueUn+S6p+e6v+S4iueahOWFtuS7luiuvuWkh+mAmuS/oe+8jOWPiuaXtui/m+ihjOiwg+aVtOWSjOS/ruato++8jOehruS/neS6p+WTgei0qOmHj+eahOeos+WumuaAp+WSjOS4gOiHtOaAp+OAgiAzLjIg5Z+65LqO6aKE5rWL5YiG5p6Q55qE5pWF6Zqc5qOA5rWL5LiO6aKE6K2mIOWfuuS6jua3seW6puWtpuS5oOeahOacuuaisOaZuuiDveWItumAoOi0qOmHj+aOp+WItuWcqOaVhemanOajgOa1i+S4jumihOitpuaWuemdoumHh+eUqOmihOa1i+WIhuaekOeahOetlueVpeOAgumAmui/h+WIhuaekOWOhuWPsuaVsOaNruWSjOWunuaXtuaVsOaNru+8jOezu+e7n+WPr+S7pemihOa1i+iuvuWkh+i/kOihjOS4reWPr+iDveWPkeeUn+eahOaVhemanO+8jOW5tuaPkOWJjei/m+ihjOmihOitpu+8jOS7pemBv+WFjeeUn+S6p+S4reeahOi0qOmHj+mXrumimOOAgiDpppblhYjvvIzmt7HluqblrabkuaDmqKHlnovlj6/ku6XlrabkuaDorr7lpIfov5DooYzov4fnqIvkuK3nmoTlkITnp43mqKHlvI/lkozop4TlvovjgILpgJrov4flr7nlpKfph4/ljoblj7LmlbDmja7nmoTorq3nu4PvvIzns7vnu5/lj6/ku6Xor4bliKvlh7rkuI3lkIzmlYXpmpzmqKHlvI/nmoTnibnlvoHvvIzlu7rnq4vmlYXpmpzpooTmtYvmqKHlnovjgILlvZPlrp7ml7bmlbDmja7kuI7pooTmtYvmqKHlnovkuI3nrKbml7bvvIzns7vnu5/lj6/ku6XliKTmlq3lj6/og73lrZjlnKjmlYXpmpzvvIzlubblj5Hlh7rpooTorabkv6Hlj7fjgIIg5YW25qyh77yM6aKE5rWL5YiG5p6Q5Y+v5Lul5Z+65LqO5aSa56eN5pWw5o2u5rqQ77yM5YyF5ous6K6+5aSH5pWw5o2u44CB546v5aKD5pWw5o2u44CB5L6b5bqU6ZO+5pWw5o2u562J44CC6YCa6L+H57u85ZCI5YiG5p6Q6L+Z5Lqb5pWw5o2u77yM57O757uf5Y+v5Lul5pu05YeG56Gu5Zyw6aKE5rWL5pWF6Zqc55qE5Y+R55Sf77yM5bm25Y+K5pe26YeH5Y+W55u45bqU55qE5o6q5pa977yM5L6L5aaC5YGc5py657u05L+u44CB5pu05o2i6Zu26YOo5Lu2562J77yM5Lul6YG/5YWNLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgd3JpdGUgYW4gYWJzdHJhY3QgZm9yIGEgcGFwZXIgb24gY29udGFpbmVyIHRlY2hub2xvZ3kuIFRoZSBvdGhlciBwYXJ0cyBvZiB0aGUgcGFwZXIgYXJlIGFzIGZvbGxvd3M6ICoqUmVzZWFyY2ggb24gQ2xvdWQgUGxhdGZvcm0gTmV0d29yayBBcmNoaXRlY3R1cmUgQmFzZWQgb24gQ29udGFpbmVyIFRlY2hub2xvZ3kqKgoKMCBJbnRyb2R1Y3Rpb24gIApJbiBjbG91ZCBjb21wdXRpbmcgZW52aXJvbm1lbnRzLCBvcHRpbWl6aW5nIG5ldHdvcmsgYXJjaGl0ZWN0dXJlIGlzIGNydWNpYWwgZm9yIGVuaGFuY2luZyB0aGUgcGVyZm9ybWFuY2Ugb2YgY2xvdWQgc2VydmljZXNbMV0uIENvbnRhaW5lciB0ZWNobm9sb2d5LCB3aXRoIGl0cyBsaWdodHdlaWdodCBhbmQgZWZmaWNpZW50IGNoYXJhY3RlcmlzdGljcywgb2ZmZXJzIG5ldyBwZXJzcGVjdGl2ZXMgZm9yIHRoZSBuZXR3b3JrIGFyY2hpdGVjdHVyZSBvZiBjbG91ZCBwbGF0Zm9ybXNbMi00XS4gVGhpcyBzdHVkeSBmb2N1c2VzIG9uIHRoZSBhcHBsaWNhdGlvbiBvZiBjb250YWluZXIgdGVjaG5vbG9neSBpbiBjbG91ZCBwbGF0Zm9ybSBuZXR3b3JrIGFyY2hpdGVjdHVyZSwgYWltaW5nIHRvIHNvbHZlIGlzc3VlcyBzdWNoIGFzIG5ldHdvcmsgaXNvbGF0aW9uLCBzY2FsYWJpbGl0eSwgYW5kIHNlY3VyaXR5IHByb2JsZW1zIHByZXNlbnQgaW4gdHJhZGl0aW9uYWwgdmlydHVhbGl6YXRpb24gZW52aXJvbm1lbnRzLiBUaGUgZGVzaWduIG9mIGNvbnRhaW5lciBuZXR3b3JrIGFyY2hpdGVjdHVyZSBtdXN0IG1lZXQgdGhlIGR5bmFtaWMgYW5kIGVsYXN0aWMgcmVxdWlyZW1lbnRzIG9mIGNsb3VkIHNlcnZpY2VzIHdoaWxlIGVuc3VyaW5nIHRoZSBlZmZpY2llbmN5IGFuZCBzZWN1cml0eSBvZiBuZXR3b3JrIGNvbW11bmljYXRpb24uIFRoaXMgcmVzZWFyY2ggZXhwbG9yZXMgdGhlIGtleSB0ZWNobm9sb2dpZXMgb2YgY29udGFpbmVyIG5ldHdvcmtzLCBpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIG5ldHdvcmsgaXNvbGF0aW9uIG1lY2hhbmlzbXMsIGxvYWQgYmFsYW5jaW5nIHN0cmF0ZWdpZXMsIHNlcnZpY2UgZGlzY292ZXJ5LCBhbmQgc2VjdXJpdHkgaGFyZGVuaW5nIG1lYXN1cmVzLiAgCgoxIENvbnRhaW5lciBOZXR3b3JrIEFyY2hpdGVjdHVyZSBEZXNpZ24gIAoxLjEgRGVzaWduIENvbmNlcHQgIApUaGUgY29yZSBvZiBjb250YWluZXIgbmV0d29yayBhcmNoaXRlY3R1cmUgZGVzaWduIGlzIHRvIGFjaGlldmUgZWZmaWNpZW50LCBmbGV4aWJsZSwgYW5kIHNlY3VyZSBuZXR3b3JrIGNvbW11bmljYXRpb24uIEluIGNsb3VkIHBsYXRmb3JtcywgY29udGFpbmVycywgYXMgYSBsaWdodHdlaWdodCB2aXJ0dWFsaXphdGlvbiB0ZWNobm9sb2d5LCByZXF1aXJlIGEgbmV0d29yayBkZXNpZ24gdGhhdCBzYXRpc2ZpZXMgdGhlIG5lZWRzIG9mIHJhcGlkIGRlcGxveW1lbnQgYW5kIGR5bmFtaWMgc2NhbGFiaWxpdHkgaW4gYSBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZS4gVGhpcyBzZWN0aW9uIHdpbGwgZGVsdmUgaW50byB0aGUgZGVzaWduIGNvbmNlcHQgb2YgY29udGFpbmVyIG5ldHdvcmsgYXJjaGl0ZWN0dXJlLCBpbmNsdWRpbmcgbmV0d29yayBpc29sYXRpb24sIHNlcnZpY2UgZGlzY292ZXJ5LCBsb2FkIGJhbGFuY2luZywgYW5kIHNlY3VyaXR5IHN0cmF0ZWdpZXMuICAKTmV0d29yayBpc29sYXRpb24gaXMgZXNzZW50aWFsIGZvciBlbnN1cmluZyBzZWN1cmUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIGNvbnRhaW5lcnMuIFR1bm5lbCB0ZWNobm9sb2dpZXMgc3VjaCBhcyBWWExBTiBvciBTVFQgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IG5ldHdvcmsgaXNvbGF0aW9uIGJldHdlZW4gZGlmZmVyZW50IHRlbmFudHMuIE1lYW53aGlsZSwgRG9ja2Vy4oCZcyBuZXR3b3JrIHBsdWdpbnMgKGUuZy4sIENhbGljbyBvciBGbGFubmVsKSBjYW4gcHJvdmlkZSBlYWNoIGNvbnRhaW5lciB3aXRoIGFuIGluZGVwZW5kZW50IG5ldHdvcmsgc3RhY2suIFNlcnZpY2UgZGlzY292ZXJ5IGlzIGFuIGludGVncmFsIHBhcnQgb2YgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUuICAKCjEuMiBOZXR3b3JrIENvbXBvbmVudHMgYW5kIEZ1bmN0aW9ucyAgClRoZSBkZXNpZ24gb2YgY29udGFpbmVyIG5ldHdvcmsgYXJjaGl0ZWN0dXJlIGZvY3VzZXMgb24gYnVpbGRpbmcgYW4gZWZmaWNpZW50LCBzY2FsYWJsZSwgYW5kIHNlY3VyZSBuZXR3b3JrIGVudmlyb25tZW50IHRvIHN1cHBvcnQgY29udGFpbmVyaXplZCBkZXBsb3ltZW50IG9uIGNsb3VkIHBsYXRmb3Jtcy4gVGhlIGNvcmUgY29tcG9uZW50cyBpbmNsdWRlIG5ldHdvcmsgaW50ZXJmYWNlIGNvbnRyb2xsZXJzLCBzZXJ2aWNlIGRpc2NvdmVyeSBtZWNoYW5pc21zLCBsb2FkIGJhbGFuY2VycywgYW5kIHNlY3VyaXR5IHBvbGljaWVzLiBUaGUgbmV0d29yayBpbnRlcmZhY2UgY29udHJvbGxlciBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIG1hbmFnaW5nIGNvbnRhaW5lciBuZXR3b3JrcywgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgY29udGFpbmVyIHJ1bnRpbWUgdmlhIHRoZSBBcHBsaWNhdGlvbiBQcm9ncmFtbWluZyBJbnRlcmZhY2UgKEFQSSkgdG8gZW5hYmxlIGR5bmFtaWMgbmV0d29yayBjb25maWd1cmF0aW9uLiBUaGUgc2VydmljZSBkaXNjb3ZlcnkgbWVjaGFuaXNtIGFsbG93cyBjb250YWluZXJzIHRvIGNvbW11bmljYXRlIHZpYSBzZXJ2aWNlIG5hbWVzIHJhdGhlciB0aGFuIElQIGFkZHJlc3NlcyBieSByZWdpc3RlcmluZyBzZXJ2aWNlIGluc3RhbmNlcyBhbmQgaW5zdGFuY2UgaW5mb3JtYXRpb24sIGVuYWJsaW5nIGR5bmFtaWMgc2VydmljZSByZWdpc3RyYXRpb24gYW5kIGRpc2NvdmVyeS4gIApMb2FkIGJhbGFuY2VycyBhcmUgZGlzdHJpYnV0ZWQgYWNyb3NzIHRoZSBuZXR3b3JrIGFuZCBhbGxvY2F0ZSByZXF1ZXN0cyB0byBhcHByb3ByaWF0ZSBjb250YWluZXIgaW5zdGFuY2VzIGJhc2VkIG9uIHJlYWwtdGltZSB0cmFmZmljIGFuZCBoZWFsdGggY2hlY2sgcmVzdWx0cywgZW5zdXJpbmcgaGlnaCBhdmFpbGFiaWxpdHkgYW5kIHJlc3BvbnNpdmVuZXNzIG9mIHNlcnZpY2VzLiBTZWN1cml0eSBwb2xpY2llcyBwcm90ZWN0IGRhdGEgdHJhbnNtaXNzaW9uIGJldHdlZW4gY29udGFpbmVycyBieSBpbXBsZW1lbnRpbmcgbmV0d29yayBpc29sYXRpb24sIGFjY2VzcyBjb250cm9sLCBhbmQgZW5jcnlwdGVkIGNvbW11bmljYXRpb24uIFRhYmxlIDEgbGlzdHMgdGhlIHBlcmZvcm1hbmNlIG1ldHJpY3Mgb2YgZGlmZmVyZW50IGxvYWQgYmFsYW5jaW5nIGFsZ29yaXRobXMsIGRlbW9uc3RyYXRpbmcgdGhlIHBlcmZvcm1hbmNlIG9mIFJvdW5kIFJvYmluLCBSYW5kb20sIGFuZCBMZWFzdCBDb25uZWN0aW9ucyBhbGdvcml0aG1zIGluIHZhcmlvdXMgc2NlbmFyaW9zLiAgCgpUYWJsZSAxOiBQZXJmb3JtYW5jZSBNZXRyaWNzIG9mIERpZmZlcmVudCBMb2FkIEJhbGFuY2luZyBBbGdvcml0aG1zICAKCnwgQWxnb3JpdGhtIFR5cGUgfCBBdmVyYWdlIFJlc3BvbnNlIFRpbWUgKG1zKSB8IFJlc291cmNlIFV0aWxpemF0aW9uICglKSB8ICAKfC0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwgIAp8IFJvdW5kIFJvYmluICAgIHwgNTAgICAgICAgICAgICAgICAgICAgICAgICAgfCA4MCAgICAgICAgICAgICAgICAgICAgICAgfCAgCnwgUmFuZG9tICAgICAgICAgfCA3NSAgICAgICAgICAgICAgICAgICAgICAgICB8IDc1ICAgICAgICAgICAgICAgICAgICAgICB8ICAKfCBMZWFzdCBDb25uZWN0aW9ucyB8IDQ1ICAgICAgICAgICAgICAgICAgICAgfCA4NSAgICAgICAgICAgICAgICAgICAgICAgfCAgCgoxLjMgSXNvbGF0aW9uIGFuZCBTZWN1cml0eSBvZiBDb250YWluZXIgTmV0d29ya3MgIApUaGUgaXNvbGF0aW9uIGFuZCBzZWN1cml0eSBvZiBjb250YWluZXIgbmV0d29ya3MgYXJlIGNydWNpYWwgZm9yIGVuc3VyaW5nIHRoZSBzdGFibGUgb3BlcmF0aW9uIG9mIGNsb3VkIHBsYXRmb3Jtcy4gQ29udGFpbmVyIHRlY2hub2xvZ3kgYWNoaWV2ZXMgbmV0d29yayBpc29sYXRpb24gdGhyb3VnaCBuYW1lc3BhY2VzIGFuZCBuZXR3b3JrIHBvbGljaWVzLCBwcmV2ZW50aW5nIHVubmVjZXNzYXJ5IGNvbW11bmljYXRpb24gYmV0d2VlbiBjb250YWluZXJzLCB0aGVyZWJ5IHJlZHVjaW5nIHNlY3VyaXR5IHJpc2tzLiBOZXR3b3JrIHBvbGljaWVzIGNvbnRyb2wgaW5jb21pbmcgYW5kIG91dGdvaW5nIHRyYWZmaWMgdG8gY29udGFpbmVycyB0aHJvdWdoIGlwdGFibGVzIHJ1bGVzIG9yIHRoaXJkLXBhcnR5IHNvbHV0aW9ucyAoc3VjaCBhcyBDYWxpY28pLCBlbmFibGluZyBmaW5lLWdyYWluZWQgYWNjZXNzIGNvbnRyb2wuICAKQWRkaXRpb25hbGx5LCBlbmNyeXB0aW9uIHRlY2hub2xvZ3kgaW4gY29udGFpbmVyIG5ldHdvcmtzIGVuc3VyZXMgdGhlIHNlY3VyaXR5IG9mIGRhdGEgdHJhbnNtaXNzaW9uLiBUaGUgVHJhbnNwb3J0IExheWVyIFNlY3VyaXR5IChUTFMpIHByb3RvY29sIGlzIHdpZGVseSB1c2VkIHRvIGVzdGFibGlzaCBzZWN1cmUgY29tbXVuaWNhdGlvbiBjaGFubmVscyBiZXR3ZWVuIGNvbnRhaW5lcnMsIGVuc3VyaW5nIHRoZSBpbnRlZ3JpdHkgYW5kIHByaXZhY3kgb2YgZGF0YSBkdXJpbmcgdHJhbnNtaXNzaW9uLiAgClRvIHF1YW50aWZ5IHRoZSBlZmZlY3Qgb2YgbmV0d29yayBpc29sYXRpb24sIHRoaXMgcGFwZXIgdXNlcyBhbiBpc29sYXRpb24gZWZmaWNpZW5jeSBmb3JtdWxhLCBhcyBzaG93biBpbiBlcXVhdGlvbiAoMSkuICAK8J2cgj3wnZGZ8J2Qv8OXMTAwJSDigIMoMSkgIAp3aGVyZSDOtyBpcyB0aGUgaXNvbGF0aW9uIGVmZmljaWVuY3ksIGwgaXMgdGhlIGlsbGVnYWwgdHJhZmZpYyBzdWNjZXNzZnVsbHkgYmxvY2tlZCwgYW5kIEwgaXMgdGhlIHRvdGFsIGlsbGVnYWwgdHJhZmZpYy4gIAoKMiBDbG91ZCBQbGF0Zm9ybSBOZXR3b3JrIEFyY2hpdGVjdHVyZSBJbXBsZW1lbnRhdGlvbiAgCjIuMSBOZXR3b3JrIENvbXBvbmVudCBJbXBsZW1lbnRhdGlvbiBUZWNobm9sb2dpZXMgIApLZXkgdGVjaG5vbG9naWVzIGZvciBpbXBsZW1lbnRpbmcgY2xvdWQgcGxhdGZvcm0gbmV0d29yayBhcmNoaXRlY3R1cmUgaW5jbHUuLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpQbGVhc2UgaGVscCBtZSB3cml0ZSBhbiBpbnRyb2R1Y3Rpb24gZm9yIGFuIEludGVybmV0IG9mIFRoaW5ncyAoSW9UKSBzZWN1cml0eSBwYXBlciBiYXNlZCBvbiB0aGUgY29udGVudCBJIHByb3ZpZGUsIGV4cGxhaW5pbmcgdGhlIGluY3JlYXNpbmdseSBzZXJpb3VzIHNlY3VyaXR5IHRocmVhdHMgcG9zZWQgYnkgSW9UIGRldmljZXMuIFByb3ZpZGUgYSBkZXRhaWxlZCBleHBsYW5hdGlvbiBvZiB0aGUgdGVjaG5pY2FsIGZlYXR1cmVzIG9mIGN1cnJlbnQgbWFpbnN0cmVhbSBwcm90ZWN0aW9uIHNvbHV0aW9ucyAoc3VjaCBhcyBmaXJtd2FyZSBoYXJkZW5pbmcsIGFjY2VzcyBjb250cm9sLCBldGMuKSBhbmQgdGhlIGxpbWl0YXRpb25zIGVuY291bnRlcmVkIGluIHByYWN0aWNhbCBhcHBsaWNhdGlvbnMuIE5hdHVyYWxseSwgbGVhZCBpbnRvIHRoZSBpbm5vdmF0aXZlIHBvaW50cyBhbmQgYWR2YW50YWdlcyBvZiB0aGUgbmV3IHByb3RlY3Rpb24gbWV0aG9kIEkgcHJvcG9zZS4gIApBcyBhIGZyb250bGluZSByZXNlYXJjaGVyIGFuZCBkZXZlbG9wbWVudCBlbmdpbmVlciBpbiBJb1Qgc2VjdXJpdHksIEkgYW0gZGVlcGx5IGF3YXJlIG9mIHRoZSBpbmNyZWFzaW5nIHNlY3VyaXR5IGNoYWxsZW5nZXMgaW4gdGhlIEluZHVzdHJpYWwgSW50ZXJuZXQgb2YgVGhpbmdzIChJSW9UKSBlbnZpcm9ubWVudC4gSW4gYWN0dWFsIHByb2plY3RzLCBJIGhhdmUgYmVlbiBpbnZvbHZlZCBpbiB0aGUgc2VjdXJpdHkgYXNzZXNzbWVudCBhbmQgcHJvdGVjdGlvbiBkZXZlbG9wbWVudCBvZiBzZXZlcmFsIGluZHVzdHJpYWwgY29udHJvbCBzeXN0ZW1zLCBhbmQgaGF2ZSBlbmNvdW50ZXJlZCBzb21lIGNoYWxsZW5naW5nIHNlY3VyaXR5IGluY2lkZW50cy4gRm9yIGV4YW1wbGUsIGluIGEgdHlwaWNhbCBpbmR1c3RyaWFsIG1vbml0b3Jpbmcgc3lzdGVtLCB3ZSBkaXNjb3ZlcmVkIGFuIGF0dGFjayBtZXRob2Qgd2hlcmUgYW4gYXR0YWNrZXIgZXhwbG9pdGVkIGEgZGV2aWNlIGZpcm13YXJlIHZ1bG5lcmFiaWxpdHkgdG8gaW50ZXJmZXJlIHdpdGggdGhlIGluZHVzdHJpYWwgcHJvZHVjdGlvbiBwcm9jZXNzLCBjYXVzaW5nIHByb2R1Y3Rpb24gZG93bnRpbWUgYW5kIGRhdGEgbGVha2FnZS4gU3VjaCBjYXNlcyBoaWdobGlnaHQgdGhlIGltcG9ydGFuY2Ugb2Ygc2VjdXJpdHkgcHJvdGVjdGlvbiBmb3IgSW9UIGRldmljZXMgYW5kIGhhdmUgbWFkZSBtZSByZWFsaXplIHRoZSBsaW1pdGF0aW9ucyBvZiB0cmFkaXRpb25hbCBzZWN1cml0eSBtZWFzdXJlcyBpbiBkZWFsaW5nIHdpdGggdGhlc2Ugc3BlY2lmaWMgYXR0YWNrIHNjZW5hcmlvcy4KClRocm91Z2ggeWVhcnMgb2YgcHJhY3RpY2FsIGV4cGVyaWVuY2UsIEkgaGF2ZSBmb3VuZCB0aGF0IGFsdGhvdWdoIHRoZXJlIGFyZSBzb21lIHByb3RlY3Rpb24gc29sdXRpb25zIG9uIHRoZSBtYXJrZXQsIHN1Y2ggYXMgZmlybXdhcmUgaGFyZGVuaW5nLCBhY2Nlc3MgY29udHJvbCwgYW5kIGVuY3J5cHRlZCB0cmFuc21pc3Npb24sIHRoZXkgZmFjZSBtYW55IGNoYWxsZW5nZXMgaW4gcHJhY3RpY2FsIGFwcGxpY2F0aW9ucy4gRm9yIGluc3RhbmNlLCB3aGlsZSBmaXJtd2FyZSBoYXJkZW5pbmcgZWZmZWN0aXZlbHkgaW1wcm92ZXMgZGV2aWNlIHNlY3VyaXR5LCBpdCBvZnRlbiBpbmNyZWFzZXMgdGhlIGNvc3QgYW5kIGNvbXBsZXhpdHkgb2YgdGhlIGRldmljZSwgYW5kIHRoZSBoYXJkZW5lZCBkZXZpY2VzIGhhdmUgc2xvdyByZXNwb25zZSB0aW1lcyB3aGVuIGZhY2luZyBuZXcgdHlwZXMgb2YgYXR0YWNrczsgYWNjZXNzIGNvbnRyb2wgc29sdXRpb25zLCB3aGlsZSBlZmZlY3RpdmVseSByZXN0cmljdGluZyB1bmF1dGhvcml6ZWQgYWNjZXNzLCBhcmUgY29zdGx5IHRvIGltcGxlbWVudCwgY29tcGxleCB0byBjb25maWd1cmUsIGFuZCBkaWZmaWN1bHQgdG8gYWRhcHQgdG8gdGhlIGR5bmFtaWMgaW5kdXN0cmlhbCBlbnZpcm9ubWVudC4gVGhyb3VnaCB0aGVzZSBwZXJzb25hbCBleHBlcmllbmNlcywgSSBkZWVwbHkgcmVhbGl6ZSB0aGF0IGN1cnJlbnQgcHJvdGVjdGl2ZSBtZWFzdXJlcyBhcmUgZmFyIGZyb20gbWVldGluZyB0aGUgaGlnaCBzZWN1cml0eSByZXF1aXJlbWVudHMgaW4gdGhlIGluZHVzdHJpYWwgSW9UIGZpZWxkLgoKQmFzZWQgb24gbXkgYWNjdW11bGF0ZWQgZXhwZXJpZW5jZSBpbiBJSW9UIHNlY3VyaXR5LCB0aGlzIHBhcGVyIHByb3Bvc2VzIGEgbmV3IHByb3RlY3RpdmUgbWV0aG9kIGFpbWVkIGF0IG92ZXJjb21pbmcgdGhlIGxpbWl0YXRpb25zIG9mIGV4aXN0aW5nIHRlY2hub2xvZ2llcyBhbmQgaW1wcm92aW5nIHRoZSBzZWN1cml0eSBhbmQgYWRhcHRhYmlsaXR5IG9mIElvVCBkZXZpY2VzLiBPdXIgYXBwcm9hY2ggY29tYmluZXMgKiptdWx0aS1sYXllciBkeW5hbWljIG1vbml0b3JpbmcqKiB3aXRoIGFuICoqYWRhcHRpdmUgcmVzcG9uc2UgbWVjaGFuaXNtKiosIGFuYWx5emluZyBkZXZpY2UgYmVoYXZpb3IgYW5kIG5ldHdvcmsgdHJhZmZpYyBpbiByZWFsIHRpbWUgdG8gYXV0b21hdGljYWxseSBpZGVudGlmeSBhbmQgYmxvY2sgcG90ZW50aWFsIHNlY3VyaXR5IHRocmVhdHMuIFVubGlrZSB0cmFkaXRpb25hbCBzdGF0aWMgcHJvdGVjdGlvbiBtZWFzdXJlcywgdGhpcyBhcHByb2FjaCBjYW4gZmxleGlibHkgYWRqdXN0IHByb3RlY3Rpb24gc3RyYXRlZ2llcyBiYXNlZCBvbiBhY3R1YWwgY29uZGl0aW9ucywgc2lnbmlmaWNhbnRseSByZWR1Y2luZyBmYWxzZSBwb3NpdGl2ZSByYXRlcyBhbmQgaW1wcm92aW5nIHByb3RlY3Rpb24gZWZmaWNpZW5jeS4gQWRkaXRpb25hbGx5LCB3ZSBoYXZlIGludHJvZHVjZWQgYSAqKmJsb2NrY2hhaW4tYmFzZWQqKiBkZXZpY2UgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIHRvIGVuc3VyZSB0aGUgcmVsaWFiaWxpdHkgb2YgZGV2aWNlIGlkZW50aXRpZXMgYW5kIHRoZSB0cmFuc3BhcmVuY3kgb2YgY29tbXVuaWNhdGlvbiBwcm9jZXNzZXMsIGFkZHJlc3NpbmcgdGhlIGNvbW1vbiBzZWN1cml0eSByaXNrcyBhc3NvY2lhdGVkIHdpdGggZGV2aWNlIGlkZW50aXR5IGF1dGhlbnRpY2F0aW9uLiAKClRoZXNlIGlubm92YXRpb25zIG1ha2Ugb3VyIHByb3RlY3Rpb24gbWV0aG9kIG5vdCBvbmx5IHBlcmZvcm0gZXhjZWxsZW50bHkgaW4gcmVzcG9uZGluZyB0byBrbm93biB0aHJlYXRzIGJ1dCBhbHNvIGVmZmVjdGl2ZWx5IGRlYWwgd2l0aCBlbWVyZ2luZyB0eXBlcyBvZiBhdHRhY2tzLCBmaWxsaW5nIHRoZSBnYXAgaW4gZmxleGliaWxpdHkgYW5kIGFkYXB0YWJpbGl0eSBpbiBjdXJyZW50IHRlY2hub2xvZ2ljYWwgc29sdXRpb25zLgp1c2VyOgpQbGVhc2UgaGVscCBtZSByZXZpc2UgdGhlIGludHJvZHVjdGlvbiBvZiB0aGlzIHBhcGVyIG9uIHNtYXJ0IGNpdGllcyBhbmQgZXhwYW5kIGl0IGEgYml0IG1vcmUsIHN1Y2ggYXMgYWRkaW5nIHRoZSByZXNlYXJjaCBiYWNrZ3JvdW5kLCByZXNlYXJjaCBzaWduaWZpY2FuY2UsIGV0Yy4gVGhlIG9yaWdpbmFsIGZ1bGwgdGV4dCBvZiB0aGUgcGFwZXIgaXMgYXMgZm9sbG93czogKipSZXNlYXJjaCBvbiB0aGUgQ29uc3RydWN0aW9uIFBsYW4gb2YgTmV3IFNtYXJ0IENpdGllcyoqICAKQWJzdHJhY3Q6IFRoZSBjb25zdHJ1Y3Rpb24gb2Ygc21hcnQgY2l0aWVzIG5vdCBvbmx5IGNvbmNlcm5zIHRoZSBhY2N1cmFjeSBvZiB1cmJhbiBwbGFubmluZyBhbmQgZGVjaXNpb24tbWFraW5nIGJ1dCBhbHNvIGRpcmVjdGx5IGltcGFjdHMgcmVzaWRlbnRzJyBoYXBwaW5lc3MgYW5kIHNhdGlzZmFjdGlvbiwgc2VydmluZyBhcyBhIGtleSBpbmRpY2F0b3IgZm9yIG1lYXN1cmluZyB0aGUgcXVhbGl0eSBvZiB1cmJhbiBkZXZlbG9wbWVudC4gVGhpcyBwYXBlciBhaW1zIHRvIGNvbWJpbmUgdGhlIGlubm92YXRpdmUgcHJhY3RpY2VzIGluIGRhdGEgc2hhcmluZywgZ292ZXJubWVudCBzZXJ2aWNlcywgdXJiYW4gbWFuYWdlbWVudCwgYW5kIG90aGVyIGFyZWFzIGZyb20gYWR2YW5jZWQgY2l0aWVzIHN1Y2ggYXMgU2hhbmdoYWkgYW5kIEhhbmd6aG91LCBwcm9wb3NpbmcgYSBmcmFtZXdvcmsgYW5kIGNvbnN0cnVjdGlvbiBpZGVhcyBmb3Igc21hcnQgY2l0eSBkZXZlbG9wbWVudCwgd2l0aCB0aGUgZ29hbCBvZiBwcm9tb3Rpbmcgc2NpZW50aWZpYyBhbmQgcHJlY2lzZSBzb2NpYWwgZ292ZXJuYW5jZSBhbmQgZW5oYW5jaW5nIHRoZSBpbnRlbGxpZ2VuY2UgYW5kIGNvbnZlbmllbmNlIG9mIGdvdmVybm1lbnQgc2VydmljZXMuICAKS2V5d29yZHM6IHNtYXJ0IGNpdHk7IHVyYmFuIG9wZXJhdGlvbjsgZGF0YSBzaGFyaW5nOyBjb2xsYWJvcmF0aXZlIGFwcGxpY2F0aW9ucyAgCgpUaGUgY29uc3RydWN0aW9uIG9mIHNtYXJ0IGNpdGllcyBlbXBoYXNpemVzIHRoZSBjcml0aWNhbCByb2xlIG9mIGNvbW11bmljYXRpb24gdGVjaG5vbG9neSBpbmZyYXN0cnVjdHVyZSBpbnZlc3RtZW50IGFuZCB0aGUgYXBwbGljYXRpb24gb2YgbmV3IHRlY2hub2xvZ2llcyBpbiB0aGUgdXJiYW4gZGV2ZWxvcG1lbnQgcHJvY2VzcyBbMV0uIEluIHJlY2VudCB5ZWFycywgdGhlIG5hdGlvbmFsIGFuZCBsb2NhbCBnb3Zlcm5tZW50cyBoYXZlIGludHJvZHVjZWQgYSBzZXJpZXMgb2YgcG9saWN5IGRvY3VtZW50cyBhaW1lZCBhdCBwcm9tb3Rpbmcgc3VzdGFpbmFibGUgdXJiYW4gZGV2ZWxvcG1lbnQgdGhyb3VnaCBkaWdpdGFsIHRyYW5zZm9ybWF0aW9uLiBCYXNlZCBvbiB0aGUgc3VjY2Vzc2Z1bCBleHBlcmllbmNlcyBvZiBhZHZhbmNlZCBjaXRpZXMsIHRoaXMgcGFwZXIgZm9jdXNlcyBvbiB0aGUgdGhyZWUgY29yZSBvcGVyYXRpb25zIG9mIOKAnHVuaWZpZWQgbWFuYWdlbWVudCwgdW5pZmllZCBzZXJ2aWNlLCBhbmQgdW5pZmllZCBjb2xsYWJvcmF0aW9u4oCdIGFuZCBwcm9wb3NlcyBjb3JyZXNwb25kaW5nIGluc3RpdHV0aW9uYWwgYW5kIG1lY2hhbmlzbSBzdXBwb3J0IG1lYXN1cmVzLiBUaGUgYWltIGlzIHRvIHByb3ZpZGUgZWZmZWN0aXZlIHBhdGh3YXlzIGZvciBzb2x2aW5nIGNvbW1vbiBwcm9ibGVtcyBpbiBjdXJyZW50IHNtYXJ0IGNpdHkgY29uc3RydWN0aW9uLCBzdWNoIGFzIGRhdGEgc2lsb3MsIGludGVyLWRlcGFydG1lbnRhbCBjb2xsYWJvcmF0aW9uIGRpZmZpY3VsdGllcywgYW5kIGluc3VmZmljaWVudCBkZWNpc2lvbi1tYWtpbmcgc3VwcG9ydC4gSXQgc2Vla3MgdG8gcHJvbW90ZSB0aGUgaW50ZWdyYXRpb24gb2YgZ292ZXJubWVudCBwbGF0Zm9ybXMsIHRoZSByZWxlYXNlIG9mIGRhdGEgcmVzb3VyY2UgdmFsdWUsIGFnaWxlIGNhcGFiaWxpdGllcywgZWZmaWNpZW50IGNvb3JkaW5hdGlvbiBpbiBkaWdpdGFsIGdvdmVybmFuY2UsIGFuZCBpbXByb3ZlZCBxdWFsaXR5IGFuZCBjb250cm9sbGFiaWxpdHkgaW4gc2VjdXJpdHkgYW5kIG9wZXJhdGlvbmFsIG1hbmFnZW1lbnQgWzJdLiAgCgoxLiBQcm9ibGVtcyAgCkNoaW5h4oCZcyBzbWFydCBjaXR5IGNvbnN0cnVjdGlvbiBoYXMgZ29uZSB0aHJvdWdoIHNldmVyYWwgc3RhZ2VzOiB0aGUgaW5kdXN0cnkgYXBwbGljYXRpb24tZHJpdmVuIGRpZ2l0YWwgY2l0eSwgZW1lcmdpbmcgdGVjaG5vbG9neS1kcml2ZW4gc21hcnQgY2l0eSBkZXZlbG9wbWVudCBbM10sIGFuZCB0aGUgZGlnaXRhbCBnb3Zlcm5tZW50IHRyYW5zaXRpb24gZnJvbSBlLWdvdmVybm1lbnQgYW5kIGRpZ2l0YWwgZ292ZXJuYW5jZSB0byBhIG5ldyBzdGFnZSBvZiBjb29yZGluYXRlZCBhbmQgaW5ub3ZhdGl2ZSBtYW5hZ2VtZW50IFs0XS4gTG9jYWwgZGlnaXRhbCBjb25zdHJ1Y3Rpb24gaXMgaW4gYSByYXBpZCBkZXZlbG9wbWVudCBwaGFzZSwgYnV0IGR1ZSB0byBkaWZmZXJlbmNlcyBpbiBlY29ub21pYyBmb3VuZGF0aW9uLCB0ZWNobm9sb2dpY2FsIGxldmVscywgYW5kIHJlc291cmNlIGVuZG93bWVudCwgY29uc3RydWN0aW9uIHByb2dyZXNzIGFuZCByZXN1bHRzIHZhcnkuIERlc3BpdGUgc29tZSBhY2hpZXZlbWVudHMsIGNvbW1vbiBwcm9ibGVtcyBzdGlsbCBwZXJzaXN0LiAgCgpUaGUgcGhlbm9tZW5vbiBvZiBkYXRhIHNpbG9zIGlzIHNldmVyZS4gQWx0aG91Z2ggdmFyaW91cyByZWdpb25zIGhhdmUgYnVpbHQgZGF0YS1zaGFyaW5nIG9wZW4gcGxhdGZvcm1zIGFuZCBwcm92aWRlZCBzb21lIGdvdmVybm1lbnQgZGF0YSBzaGFyaW5nIHdpbmRvd3MsIHRoZSB3aWxsaW5nbmVzcyB0byBzaGFyZSBkYXRhIGlzIHdlYWsgaW4gbWFueSBkZXBhcnRtZW50cyBvciB0aGV5IGhhdmUgYSBzdHJvbmcgc2Vuc2Ugb2YgZGF0YSBvd25lcnNoaXAuIFRoaXMgbGVhZHMgdG8gaW5zdWZmaWNpZW50IGRhdGEgc2hhcmluZyBpbiB0ZXJtcyBvZiB2b2x1bWUsIHJlYWwtdGltZSBhdmFpbGFiaWxpdHksIGFuZCBhY2N1cmFjeSwgYW5kIGZhaWxzIHRvIHR1cm4gdGhlIGJ1c2luZXNzIGRhdGEgYWNjdW11bGF0ZWQgYnkgZGVwYXJ0bWVudHMgaW50byBjaXR5IGRhdGEgYXNzZXRzLiBPbiB0aGUgb3RoZXIgaGFuZCwgZHVlIHRvIHRoZSBsYWNrIG9mIGRlZXAgbGVhcm5pbmcsIGtub3dsZWRnZSBncmFwaHMsIGRlY2lzaW9uIHN1cHBvcnQsIGFuZCBvdGhlciBmb3VuZGF0aW9uYWwgZGF0YSB2YWx1ZS1hZGRlZCBwcm9kdWN0cywgdGhlIGFwcGxpY2F0aW9uIHZhbHVlIGFuZCBwb3RlbnRpYWwgZW5lcmd5IG9mIGRhdGEgaGF2ZSBub3QgYmVlbiBmdWxseSByZWxlYXNlZCwgbGltaXRpbmcgaXRzIHJvbGUgaW4gaW1wcm92aW5nIHVyYmFuIGdvdmVybmFuY2UgZWZmZWN0aXZlbmVzcywgb3B0aW1pemluZyBwdWJsaWMgc2VydmljZXMsIGFuZCBwcm9tb3RpbmcgZWNvbm9taWMgYW5kIHNvY2lhbCBkZXZlbG9wbWVudC4gIAoKQ3Jvc3MtZGVwYXJ0bWVudGFsIGNvbGxhYm9yYXRpb24gaXMgZGlmZmljdWx0LiBUaGVyZSBpcyBhbiBvdmVyYWxsIHRlbmRlbmN5IHRvIGZvY3VzIG9uIGJ1c2luZXNzIHJhdGhlciB0aGFuIGNvbGxhYm9yYXRpb24sIGFuZCBhIGxhY2sgb2YgZXZlbnQtY2VudGVyZWQsIHNlcnZpY2Utb3JpZW50ZWQgdXJiYW4gb3BlcmF0aW9uYWwgY29vcmRpbmF0aW9uIG1lY2hhbmlzbXMuIFRoaXMgcmVzdWx0cyBpbiBkZXBhcnRtZW50cyBzdGlja2luZyB0byB0aGVpciBvd24gd29yayBhbmQgZmFpbGluZyB0byBjcmVhdGUgYW4gZWZmZWN0aXZlIHVuaWZpZWQgZ29hbC1vcmllbnRlZCBhbmQgY29sbGFib3JhdGl2ZSBjb25zZW5zdXMsIG1ha2luZyBpdCBkaWZmaWN1bHQgdG8gZm9ybSBhIHJhcGlkLXJlc3BvbnNlIGFuZCBlZmZpY2llbnQgdXJiYW4gZ292ZXJuYW5jZSBhbmQgcHVibGljIHNlcnZpY2Ugc3lzdGVtLiBUaGlzIGlzIGVzcGVjaWFsbHkgdHJ1ZSBpbiBzb2NpYWwgZ292ZXJuYW5jZSwgd2hlcmUgYnJlYWt0aHJvdWdoIGFjaGlldmVtZW50cyBhcmUgbGFja2luZy4gIAoKU3VwZXJ2aXNpb24gYW5kIGFzc2Vzc21lbnQgbWVjaGFuaXNtcyBhcmUgaW5hZGVxdWF0ZS4gSW4gdGVybXMgb2YgYnVzaW5lc3MgcGVyZm9ybWFuY2UsIHRoZXJlIGlzIGEgbGFjayBvZiBlZmZpY2llbnQgaW5mb3JtYXRpb24tYmFzZWQgbW9uaXRvcmluZyBtZXRob2RzIGFuZCBsb25nLXRlcm0gYXNzZXNzbWVudCBtZWNoYW5pc21zLiBJdCBpcyBkaWZmaWN1bHQgdG8gdHJhY2sgYW5kIGFuYWx5emUgc29jaWFsIGdvdmVybmFuY2UgYW5kIHB1YmxpYyBzZXJ2aWNlIHByb2Nlc3NlcyBhbmQgcmVzdWx0cyBjb21wcmVoZW5zaXZlbHksIGNvbnRpbnVvdXNseSwgYW5kIGRlZXBseSwgaGluZGVyaW5nIHRoZSBkaXNjb3Zlcnkgb2YgcG90ZW50aWFsIGlzc3VlcyBhbmQgdGhlIGFkanVzdG1lbnQgb2YgbWVhc3VyZXMsIHdoaWNoIGlzIG5vdCBjb25kdWNpdmUgdG8gdGhlIHN0YWJsZSBpbXByb3ZlbWVudCBhbmQgY29udGludW91cyBvcHRpbWl6YXRpb24gb2YgYnVzaW5lc3MgcGVyZm9ybWFuY2UgcXVhbGl0eS4gIAoKVGhyb3VnaCB0b3AtbGV2ZWwgZGVzaWduLCBjbGFyaWZ5aW5nIHRoZSBib3VuZGFyaWVzIG9mIHJpZ2h0cyBhbmQgcmVzcG9uc2liaWxpdGllcywgc3RyZW5ndGhlbmluZyB0aGUgcmUtZW5naW5lZXJpbmcgb2YgZ292ZXJuYW5jZSBidXNpbmVzcyBwcm9jZXNzZXMgYmFzZWQgb24gaW5mb3JtYXRpb24gc2hhcmluZywgYW5kIHN0YW5kYXJkaXppbmcgdXJiYW4gZXZlbnQgY2xhc3NpZmljYXRpb24gYW5kIHJlc3BvbnNlIHBsYW5zLCB3ZSBjYW4gYnVpbGQgdGhlIGZvdW5kYXRpb24gZm9yIHVyYmFuIGdvdmVybmFuY2UgYnVzaW5lc3MgY29sbGFib3JhdGlvbiwgZnVydGhlciBlbmhhbmNlIHJlc3BvbnNlIHNwZWVkIGFuZCBkaXNwb3NhbCBjYXBhYmlsaXRpZXMsIGFuZCBwcm9tb3RlIHRoZSBkZXZlbG9wbWVudCBhbmQgaW5ub3ZhdGlvbiBvZiBnb3Zlcm5hbmNlIGFuZCBzZXJ2aWNlIHN5c3RlbXMuICAKCjIuIENvbnN0cnVjdGlvbiBQbGFuICAKMi4xIENvbnN0cnVjdGlvbiBJZGVhcyAgClN0cmVuZ3RoZW4gdG9wLWxldmVsIGRlc2lnbiBhbmQgY29vcmRpbmF0ZWQgY29uc3RydWN0aW9uLiBGcm9tIGEgbWFjcm8gcGVyc3BlY3RpdmUsIC4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6ClBsZWFzZSBoZWxwIG1lIHdyaXRlIGFuIGludHJvZHVjdGlvbiBmb3IgYSBwYXBlciBvbiBjbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlLiBUaGUgb3RoZXIgcGFydHMgb2YgdGhlIHBhcGVyIGFyZSBhcyBmb2xsb3dzIEFwcGxpY2F0aW9uIFJlc2VhcmNoIG9mIENsb3VkLU5hdGl2ZSBBcmNoaXRlY3R1cmUgQ29tcHV0aW5nIFBsYXRmb3JtIGluIE1lZGljYWwgSW1hZ2luZyBFZHVjYXRpb24KCjEgQ2xvdWQtTmF0aXZlIEFyY2hpdGVjdHVyZSBDb21wdXRpbmcgUGxhdGZvcm0gIAoxLjEgQ2xvdWQtTmF0aXZlIENvbmNlcHQgIApUaGUgY29uY2VwdCBvZiBjbG91ZC1uYXRpdmUgcmVwcmVzZW50cyBhIG5ldyBwYXJhZGlnbSBpbiBtb2Rlcm4gc29mdHdhcmUgZGV2ZWxvcG1lbnQsIGRlcGxveW1lbnQsIGFuZCBtYWludGVuYW5jZSwgZm9jdXNpbmcgb24gYnVpbGRpbmcgYXBwbGljYXRpb25zIHRoYXQgY2FuIHJ1biBlZmZpY2llbnRseSBpbiBjbG91ZCBlbnZpcm9ubWVudHMuIFRoZSBjb3JlIG9mIHRoaXMgYXBwcm9hY2ggaXMgZW5zdXJpbmcgdGhhdCBhcHBsaWNhdGlvbnMgZnVsbHkgbGV2ZXJhZ2UgdGhlIGVsYXN0aWNpdHksIHNjYWxhYmlsaXR5LCBhbmQgYXV0b21hdGlvbiBhZHZhbnRhZ2VzIHByb3ZpZGVkIGJ5IGNsb3VkIGNvbXB1dGluZy4gQnkgYWRvcHRpbmcgYWR2YW5jZWQgdGVjaG5vbG9naWVzIHN1Y2ggYXMgY29udGFpbmVyaXphdGlvbiwgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUsIERldk9wcyBwcmFjdGljZXMsIGFuZCBjb250aW51b3VzIGludGVncmF0aW9uL2NvbnRpbnVvdXMgZGVwbG95bWVudCAoQ0kvQ0QpLCBjbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIGNhbiBiZSByYXBpZGx5IGRlcGxveWVkLCBmbGV4aWJseSBzY2FsZWQgYWNjb3JkaW5nIHRvIGRlbWFuZCwgYWNoaWV2ZSBlZmZpY2llbnQgb3BlcmF0aW9ucyBtYW5hZ2VtZW50LCBhbmQgYWNjZWxlcmF0ZSBwcm9kdWN0IGl0ZXJhdGlvbiBhbmQgdXBncmFkZXMuIFRoZSBwcm9tb3Rpb24gb2YgdGhpcyBwYXJhZGlnbSBoYXMgbWFkZSBzb2Z0d2FyZSBkZXZlbG9wbWVudCBhbmQgb3BlcmF0aW9ucyBtb3JlIGZsZXhpYmxlIGFuZCBlZmZpY2llbnQsIGFkYXB0aW5nIHRvIHRoZSByYXBpZGx5IGNoYW5naW5nIGRlbWFuZHMgb2YgdGhlIGNsb3VkIGNvbXB1dGluZyBlcmEuICAKCjEuMiBDbG91ZC1OYXRpdmUgQXJjaGl0ZWN0dXJlICAKMS4yLjEgQ29tcG9uZW50cyBvZiBDbG91ZC1OYXRpdmUgQXJjaGl0ZWN0dXJlICAKQ2xvdWQtbmF0aXZlIGFyY2hpdGVjdHVyZSBjb25zaXN0cyBvZiBzZXZlcmFsIGtleSBjb21wb25lbnRzIHRoYXQgY29sbGFib3JhdGUgdG8gcHJvdmlkZSBhbiBlZmZpY2llbnQsIHJlbGlhYmxlLCBhbmQgc2NhbGFibGUgcnVudGltZSBlbnZpcm9ubWVudCBmb3IgYXBwbGljYXRpb25zLiBUaGVzZSBpbmNsdWRlIG1pY3Jvc2VydmljZXMsIGNvbnRhaW5lcml6YXRpb24sIGNvbnRpbnVvdXMgaW50ZWdyYXRpb24vY29udGludW91cyBkZXBsb3ltZW50IChDSS9DRCksIGFuZCBEZXZPcHMsIGFtb25nIG90aGVycy4gIAoxKSBNaWNyb3NlcnZpY2VzOiBUaGUgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUgYnJlYWtzIGRvd24gbGFyZ2UgYXBwbGljYXRpb25zIGludG8gc21hbGxlciB0YXNrcyBhbmQgaW5kaXZpZHVhbCBzZXJ2aWNlcy4gVmFyaW91cyBidXNpbmVzcyBvcGVyYXRpb25zIHJ1biBpbiB0aGVpciBvd24gcHJvY2Vzc2VzIGFuZCBpbnRlcmFjdCB0aHJvdWdoIGxpZ2h0d2VpZ2h0IGNvbW11bmljYXRpb24gcHJvdG9jb2xzLiAgCjIpIENvbnRhaW5lcml6YXRpb246IFRoaXMgaXMgdGhlIGNvcm5lcnN0b25lIG9mIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUuIEJ5IGRlcGxveWluZyB0aGUgc3lzdGVtIGVudmlyb25tZW50LCBhcHBsaWNhdGlvbnMsIGFuZCByZWxhdGVkIGRlcGVuZGVuY2llcyBpbiBjb250YWluZXJzLCBpdCBlbnN1cmVzIHRoYXQgYXBwbGljYXRpb25zIGFyZSBmdWxseSBwb3J0YWJsZSBhY3Jvc3MgZGlmZmVyZW50IGRlcGxveW1lbnQgZW52aXJvbm1lbnRzLiAgCjMpIENvbnRpbnVvdXMgSW50ZWdyYXRpb24vQ29udGludW91cyBEZXBsb3ltZW50IChDSS9DRCk6IEluIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUsIENJL0NEIGVuYWJsZXMgcmFwaWQgcmVzcG9uc2UgdG8gY2hhbmdlcyBpbiBkZW1hbmQsIGltcHJvdmluZyBkZXZlbG9wbWVudCBlZmZpY2llbmN5IGFuZCBwcm9kdWN0IHF1YWxpdHkgdGhyb3VnaCBhdXRvbWF0ZWQgYnVpbGRpbmcsIHRlc3RpbmcsIGFuZCBkZXBsb3ltZW50IHByb2Nlc3Nlcy4gIAo0KSBEZXZPcHM6IERldk9wcyBpcyBwcmltYXJpbHkgcmVzcG9uc2libGUgZm9yIHRoZSBjb29yZGluYXRpb24gYW5kIGNvbGxhYm9yYXRpb24gYmV0d2VlbiBvcGVyYXRpb25zIGFuZCBkZXZlbG9wbWVudCB3aXRoaW4gdGhlIHBsYXRmb3JtLCBzZXR0aW5nIHVwIHN0YW5kYXJkaXplZCBhbmQgYXV0b21hdGVkIHByb2Nlc3NlcyB0byBhY2hpZXZlIGVmZmljaWVudCBpdGVyYXRpb24sIHJhcGlkIG9wZXJhdGlvbnMsIGFuZCBjb250aW51b3VzIGltcHJvdmVtZW50LiAgCgoxLjIuMiBBZHZhbnRhZ2VzIG9mIENsb3VkLU5hdGl2ZSBBcmNoaXRlY3R1cmUgIApDb21wYXJlZCB0byB0cmFkaXRpb25hbCBhcmNoaXRlY3R1cmUsIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUgaGFzIHRoZSBmb2xsb3dpbmcgY2hhcmFjdGVyaXN0aWNzOiBlbGFzdGljIHNjYWxpbmcsIGhpZ2ggYXZhaWxhYmlsaXR5LCBlZmZpY2llbnQgb3BlcmF0aW9ucywgcmFwaWQgaXRlcmF0aW9uLCBhbmQgY29zdCByZWR1Y3Rpb24sIGFzIG91dGxpbmVkIGJlbG93OiAgCjEpIEVsYXN0aWMgU2NhbGluZzogQ2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBjYW4gcmFwaWRseSBhbmQgZmxleGlibHkgc2NhbGUgdG8gYWNjb21tb2RhdGUgY2hhbmdlcyBpbiBidXNpbmVzcyBkZW1hbmQgdGhyb3VnaCBjb250YWluZXJpemF0aW9uIGFuZCBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZS4gIAoyKSBIaWdoIEF2YWlsYWJpbGl0eTogQ2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBhcmUgaGlnaGx5IGF2YWlsYWJsZSBhbmQgcmVzaWxpZW50LCBjYXBhYmxlIG9mIHJhcGlkIHJlY292ZXJ5IGluIHRoZSBldmVudCBvZiBmYWlsdXJlLiAgCjMpIEVmZmljaWVudCBPcGVyYXRpb25zOiBDbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIGNhbiBhdXRvbWF0ZSBvcGVyYXRpb25zLCBpbmNsdWRpbmcgYXV0b21hdGVkIGJ1aWxkaW5nLCBkZXBsb3ltZW50LCBtb25pdG9yaW5nLCBhbmQgYWxlcnRzLiAgCjQpIFJhcGlkIEl0ZXJhdGlvbjogQ2xvdWQtbmF0aXZlIGFwcGxpY2F0aW9ucyBwcmltYXJpbHkgdXNlIERldk9wcyBhbmQgYWdpbGUgZGV2ZWxvcG1lbnQgbWV0aG9kcywgZW5hYmxpbmcgcmFwaWQgaXRlcmF0aW9uIGFuZCB1cGRhdGVzLiAgCjUpIENvc3QgUmVkdWN0aW9uOiBDbG91ZC1uYXRpdmUgYXBwbGljYXRpb25zIG1ha2UgZnVsbCB1c2Ugb2YgY2xvdWQgcGxhdGZvcm0gcmVzb3VyY2VzLCBlZmZlY3RpdmVseSByZWR1Y2luZyBjb3N0cy4gIAoKMS4zIENsb3VkLU5hdGl2ZSBSZXNlYXJjaCBhbmQgVGVhY2hpbmcgUGxhdGZvcm0gRnJhbWV3b3JrICAKVGhpcyBwYXBlciBwcm9wb3NlcyBhIGRlc2lnbiBzY2hlbWUgZm9yIGEgdGVhY2hpbmcgYW5kIHJlc2VhcmNoIGNvbXB1dGluZyBwbGF0Zm9ybSBiYXNlZCBvbiBjbG91ZC1uYXRpdmUgYXJjaGl0ZWN0dXJlLCBhcyBzaG93biBpbiBGaWd1cmUgMS4gSXQgaW5jbHVkZXMgS3ViZXJuZXRlcyAoSzhTKSBjb21wYXRpYmlsaXR5LCBkaXN0cmlidXRlZCBzdG9yYWdlLCB0YXNrIHF1ZXVlcywgYXV0b21hdGVkIG9wZXJhdGlvbnMsIGFuZCByZXNvdXJjZSBzY2hlZHVsaW5nLiAgCgpGaWd1cmUgMTogQ2xvdWQtTmF0aXZlIEFyY2hpdGVjdHVyZSBUZWFjaGluZyBhbmQgUmVzZWFyY2ggQ29tcHV0aW5nIFBsYXRmb3JtICAKVGhlIHByb3Bvc2VkIGNsb3VkLW5hdGl2ZSBhcmNoaXRlY3R1cmUgdGVhY2hpbmcgYW5kIHJlc2VhcmNoIGNvbXB1dGluZyBwbGF0Zm9ybSBpcyBhIG11bHRpLXVzZXIgcGFyYWxsZWwgY29tcHV0aW5nIHBsYXRmb3JtIGNlbnRlcmVkIG9uIHN0dWRlbnQgcmVzZWFyY2ggYW5kIHRlYWNoaW5nIHNjZW5hcmlvcy4gSXQgcHJvdmlkZXMgZnVsbC1zdGFjayBJVCBhdXRvbWF0aW9uIG9wZXJhdGlvbnMgY2FwYWJpbGl0aWVzLCBzaW1wbGlmeWluZyB0aGUgd29ya2Zsb3cgb2YgdGVhY2hpbmcgYW5kIHJlc2VhcmNoLCBhbmQgcHJvdmlkZXMgYSB1c2VyLWZyaWVuZGx5IGd1aWRlZCBpbnRlcmZhY2UgdGhhdCBlbXBvd2VycyBpbnN0cnVjdG9ycyB0byBxdWlja2x5IGJ1aWxkIGEgcG93ZXJmdWwgYW5kIGZlYXR1cmUtcmljaCBjb250YWluZXIgY2xvdWQgcGxhdGZvcm0gZm9yIHN0dWRlbnRzLiAgCgpGaWd1cmUgMjogQ2xvdWQtTmF0aXZlIFRlYWNoaW5nIGFuZCBSZXNlYXJjaCBQbGF0Zm9ybSBGcmFtZXdvcmsgIApGcm9tIEZpZ3VyZSAyLCB3ZSBjYW4gc2VlIHRoYXQgdGhpcyBwbGF0Zm9ybSBpbnRlZ3JhdGVzIGEgcG93ZXJmdWwgR1BVIGNsdXN0ZXIgdG8gcHJvdmlkZSBlZmZpY2llbnQgZGF0YSBwcm9jZXNzaW5nIGFuZCB2aXN1YWxpemF0aW9uIGNhcGFiaWxpdGllcywgc3VwcG9ydGluZyBpbi1kZXB0aCByZXNlYXJjaCBhbmQgdGVhY2hpbmcgb2YgbWVkaWNhbCBpbWFnaW5nLiBUaGUgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmUgZW5zdXJlcyB0aGF0IHRoZSBwbGF0Zm9ybSBoYXMgc3Ryb25nIG9wZW5uZXNzIGFuZCBzY2FsYWJpbGl0eS4gVGhlIHVzZXIgY2VudGVyIGVuc3VyZXMgdGhlIHNlY3VyZSBhbmQgb3JkZXJseSB1c2Ugb2YgcmVzb3VyY2VzLiBBZGRpdGlvbmFsbHksIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyBHUFUgcGh5c2ljYWwgbWFjaGluZXMgYW5kIFdpbmRvd3MgdmlydHVhbCBtYWNoaW5lcywgbWVldGluZyBkaXZlcnNlIHNvZnR3YXJlIG5lZWRzLiBPdmVyYWxsLCB0aGUgcGxhdGZvcm0gcHJvdmlkZXMgc29saWQgdGVjaG5pY2FsIHN1cHBvcnQgZm9yIHRlYWNoaW5nIGFuZCByZXNlYXJjaCBpbiB0aGUgZmllbGQgb2YgbWVkaWNhbCBpbWFnaW5nLCBwcm9tb3RpbmcgdGhlIGNvbnRpbnVvdXMgZGV2ZWxvcG1lbnQgb2YgdGhlIGZpZWxkLiAgCgoyLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgY2hlY2sgYW5kIGltcHJvdmUgdGhlIGludHJvZHVjdGlvbiBvZiB0aGlzIHBhcGVyIG9uIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5LCBleHBhbmRpbmcgdGhlIHJlc2VhcmNoIGJhY2tncm91bmQgYW5kIHByb3ZpZGluZyBhIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoZSBwYWluIHBvaW50cyBhbmQgc29sdXRpb25zLCAqKklubm92YXRpb24gb2YgVHJ1bmsgTG9naXN0aWNzIEF1dG9ub21vdXMgRHJpdmluZyBUZWNobm9sb2d5IGFuZCBFdm9sdXRpb24gb2YgQnVzaW5lc3MgTW9kZWxzKioKCkFic3RyYWN0OiBBdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBoYXMgZmlyc3QgYmVlbiBpbXBsZW1lbnRlZCBpbiB0aGUgdHJ1bmsgbG9naXN0aWNzIGZpZWxkLiBUaGUgcmlzZSBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBicmluZ3MgbmV3IGRldmVsb3BtZW50IG9wcG9ydHVuaXRpZXMgdG8gdGhlIHRydW5rIGxvZ2lzdGljcyBpbmR1c3RyeS4gVHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGlzIGJlY29taW5nIG1hdHVyZSBhbmQgaGFzIGJlZ3VuIHRvIGV4cGxvcmUgY29tbWVyY2lhbGl6YXRpb24gbW9kZWxzLiBCeSBhbmFseXppbmcgdGhlIHNwZWNpZmljIHNjZW5hcmlvcyBhbmQgY2hhcmFjdGVyaXN0aWNzIG9mIHRydW5rIGxvZ2lzdGljcywgdGhlIGtleSB0ZWNobm9sb2dpZXMgb2YgYXV0b25vbW91cyBkcml2aW5nIGluIHRydW5rIGxvZ2lzdGljcyBhcmUgaWRlbnRpZmllZCwgYW5kIHJlY29tbWVuZGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmdW5jdGlvbiBhbmQgc3lzdGVtIGRlc2lnbiBvZiB0cnVuayB2ZWhpY2xlcy4gQmFzZWQgb24gdGhlIG1hcmtldCBkZW1hbmQgb2YgdHJ1bmsgbG9naXN0aWNzLCB0aGlzIGFydGljbGUgcHJvbW90ZXMgdGhlIGNvbW1lcmNpYWxpemF0aW9uIGV2b2x1dGlvbiBvZiB0cnVuayBsb2dpc3RpY3MgYmFzZWQgb24gdGhlIGlubm92YXRpb24gb2YgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3kuCgpLZXl3b3JkczogdHJ1bmsgbG9naXN0aWNzOyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neTsgYnVzaW5lc3MgbW9kZWxzOyB0ZWNobm9sb2dpY2FsIHJvdXRlcwoKVGhlIHRyYWRpdGlvbmFsIGxvZ2lzdGljcyBvcGVyYXRpb24gbW9kZWwgaGFzIHByb2JsZW1zIHN1Y2ggYXMgaGlnaCBsYWJvciBjb3N0LCBoaWdoIGNvc3RzLCBsb3cgZWZmaWNpZW5jeSwgbG9uZyBkZWxpdmVyeSB0aW1lLCBhbmQgaGlkZGVuIHNhZmV0eSBoYXphcmRzLiBUaHJvdWdoIHRoZSBpbXByb3ZlbWVudCBvZiBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSwgdGhlIGRlZmVjdHMgb2YgdGhlIHRyYWRpdGlvbmFsIGxvZ2lzdGljcyBvcGVyYXRpb24gbW9kZWwgY2FuIGJlIGJldHRlciBhZGRyZXNzZWQuIFRoZXJlZm9yZSwgdGhlIGNvbnRpbnVvdXMgZGV2ZWxvcG1lbnQgb2YgYXV0b25vbW91cyBkcml2aW5nIHRlY2hub2xvZ3kgYnJpbmdzIG5ldyBkZXZlbG9wbWVudCBvcHBvcnR1bml0aWVzIHRvIHRoZSBsb2dpc3RpY3MgaW5kdXN0cnkuIEF0IHByZXNlbnQsIGRvbWVzdGljIGFuZCBmb3JlaWduIHJlc2VhcmNoIGlzIG1vc3RseSBsaW1pdGVkIHRvIHRoZSBhbmFseXNpcyBvZiBzcGVjaWZpYyBzY2VuYXJpb3Mgb24gdHJ1bmsgcm9hZHMsIGxhY2tpbmcgYSBzeXN0ZW1hdGljIGFuYWx5c2lzIG9mIHZhcmlvdXMgYXBwbGljYXRpb24gc2NlbmFyaW9zIHRoYXQgdHJ1bmsgYXV0b25vbW91cyBsb2dpc3RpY3MgdmVoaWNsZXMgbWF5IGZhY2UuIFRoaXMgYXJ0aWNsZSBhaW1zIHRvIGFkZHJlc3Mga2V5IGlzc3VlcyBpbiB2aXN1YWwgcGVyY2VwdGlvbiwgcG9zaXRpb25pbmcsIGFuZCBvdGhlciBjcml0aWNhbCB0ZWNobm9sb2dpZXMgZm9yIHRydW5rIGF1dG9ub21vdXMgbG9naXN0aWNzIHZlaGljbGVzIHRocm91Z2ggaW4tZGVwdGggcmVzZWFyY2ggYW5kIGlubm92YXRpb24gb24gdGhlaXIgdW5pcXVlIHNjZW5hcmlvcyBhbmQgdGVjaG5vbG9naWVzLCBhbmQgcHJvdmlkZSBuZXcgaWRlYXMgZm9yIHRoZSBwcmFjdGljYWwgYXBwbGljYXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGJ1c2luZXNzIG1vZGVscy4KCjEuICoqSW5ub3ZhdGlvbiBvZiBUcnVuayBMb2dpc3RpY3MgQXV0b25vbW91cyBEcml2aW5nIFRlY2hub2xvZ3kgYW5kIEJ1c2luZXNzIE1vZGVsIEFyY2hpdGVjdHVyZSoqCgpUaGUgcmVzZWFyY2ggb24gdGhlIGlubm92YXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5IGFuZCB0aGUgZXZvbHV0aW9uIG9mIGJ1c2luZXNzIG1vZGVscyBjb25zaXN0cyBvZiB0aHJlZSBwYXJ0czogY29uc3RydWN0aW5nIGEgZmxleGlibGUgYXV0b25vbW91cyBkcml2aW5nIG1vZGUsIHRydW5rIGxvZ2lzdGljcyBjbG91ZCBkYXRhIGludGVsbGlnZW5jZSBhbmQgYXV0b25vbW91cyBkcml2aW5nIGludGVncmF0aW9uLCBhbmQgdGhlIHRlY2huaWNhbCByb3V0ZSBvZiB0aGUgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyBidXNpbmVzcyBtb2RlbCwgYXMgc2hvd24gaW4gRmlndXJlIDEuCgoqKkZpZ3VyZSAxKio6IFRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBpbm5vdmF0aW9uIGFuZCBidXNpbmVzcyBtb2RlbCBhcmNoaXRlY3R1cmUKCkJhc2VkIG9uIGV4aXN0aW5nIHRlY2hub2xvZ2llcywgdGhlIGxhdGVzdCB0ZWNobm9sb2dpZXMgYXJlIGludGVncmF0ZWQgdG8gdXBncmFkZSB0aGUgdGVjaG5vbG9neS4gVGhlIGV4cGxvcmF0aW9uIG9mIHRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgdGVjaG5vbG9neSBpbm5vdmF0aW9uIGFuZCBidXNpbmVzcyBtb2RlbHMgd2lsbCBwcm9jZWVkIGZyb20gdGhyZWUgYXNwZWN0czogZmlyc3RseSwgY29uc3RydWN0aW5nIGEgZmxleGlibGUgYXV0b25vbW91cyBkcml2aW5nIG1vZGUsIHdoaWNoIGluY2x1ZGVzIHRoZSBkZXNpZ24gb2YgbXVsdGlwbGUgZHJpdmluZyBtb2RlcywgZGV2ZWxvcG1lbnQgb2YgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nIG1vZHVsZXMsIGltcHJvdmVtZW50IG9mIHZlaGljbGUgcGVyY2VwdGlvbiB0ZWNobm9sb2dpZXMsIGFuZCBvcHRpbWl6YXRpb24gb2YgYXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2UgYWxnb3JpdGhtcywgY29udGludW91c2x5IGltcHJvdmluZyB0aGUgZXhpc3RpbmcgdHJ1bmsgbG9naXN0aWNzIGF1dG9ub21vdXMgZHJpdmluZyB0ZWNobm9sb2d5LCBlbmhhbmNpbmcgaXRzIGFwcGxpY2FiaWxpdHkgYW5kIHVuaXZlcnNhbGl0eTsgc2Vjb25kbHksIGFjaGlldmluZyB0aGUgaW50ZWdyYXRpb24gb2YgdHJ1bmsgbG9naXN0aWNzIGNsb3VkIGRhdGEgaW50ZWxsaWdlbmNlIGFuZCBhdXRvbm9tb3VzIGRyaXZpbmcsIHdoaWNoIGluY2x1ZGVzIGNsb3VkIGRhdGEgb3B0aW1pemF0aW9uIGFuZCB0aGUgaXRlcmF0aW9uIG9mIGNsb3VkIGNvbXB1dGluZyBkYXRhIGludGVsbGlnZW5jZSDigJxzdXBwb3J04oCdIHRlY2hub2xvZ3ksIGltcHJvdmluZyB2ZWhpY2xlIHZhbHVlIHRocm91Z2ggY29tcHV0aW5nIHBvd2VyIHNlcnZpY2VzLCBhbmQgZm9ybWluZyBpbnRlbGxpZ2VudCBkcml2aW5nOyB0aGlyZGx5LCBzdHVkeWluZyB0aGUgdGVjaG5pY2FsIHJvdXRlIG9mIHRydW5rIGxvZ2lzdGljcyBhdXRvbm9tb3VzIGRyaXZpbmcgYnVzaW5lc3MgbW9kZWxzLCBpbmNsdWRpbmcgdGhlIHVwZ3JhZGluZyBvZiBpbnRlbGxpZ2VudCBtb25pdG9yaW5nIGFuZCBtYW5hZ2VtZW50IHN5c3RlbXMsIHRoZSBpbnRlZ3JhdGlvbiBvZiB2ZWhpY2xlIG5ldHdvcmtzIGFuZCBWMlgsIGFuZCB0aGUgaXRlcmF0aW9uIG9mIGNsb3VkIGNvbXB1dGluZyBkYXRhIGludGVsbGlnZW5jZSAic3VwcG9ydCIgdGVjaG5vbG9neS4gQnkgaW50ZWdyYXRpbmcgYW5kIHJlZm9ybWluZyB0aGUgdGVjaG5vbG9neSBvZiB0cnVuayBsb2dpc3RpY3MgYXV0b25vbW91cyBkcml2aW5nIGJ1c2luZXNzIG1vZGVscywgdGhlIGRldmVsb3BtZW50IG9mIHRoZSBpbmR1c3RyeSBjYW4gYmUgYWNjZWxlcmF0ZWQsIHJlc291cmNlIHV0aWxpemF0aW9uIGVmZmljaWVuY3kgaW1wcm92ZWQsIGFuZCBlY29ub21pYyBiZW5lZml0cyBwcm9tb3RlZC4KCjIuICoqRGVzaWduIG9mIFRydW5rIExvZ2lzdGljcyBBdXRvbm9tb3VzIERyaXZpbmcgVGVjaG5vbG9neSBJbm5vdmF0aW9uIE1vZGVsKioKCjIuMSAqKkNvbnN0cnVjdGluZyBhIEZsZXhpYmxlIEF1dG9ub21vdXMgRHJpdmluZyBNb2RlKioKCjIuMS4xICoqRGVzaWduIG9mIE11bHRpcGxlIERyaXZpbmcgTW9kZXMqKgoKVHJ1bmsgbG9naXN0aWNzIHZlaGljbGVzIGFyZSBkZXNpZ25lZCB3aXRoIHZhcmlvdXMgZHJpdmluZyBtb2RlcyBiYXNlZCBvbiBkaWZmZXJlbnQgZGVsaXZlcnkgbG9jYXRpb25zIGFuZCByb2FkIGNvbXBsZXhpdGllcywgYXMgd2VsbCBhcyBkaWZmZXJlbnQgZHJpdmluZyBzY2VuYXJpb3MgYW5kIHJlcXVpcmVtZW50cyB0byByZWR1Y2UgY29zdHMgYW5kIGltcHJvdmUgZWZmaWNpZW5jeS4gVGhlIGF1dG9ub21vdXMgZHJpdmluZyBtb2RlIGNhbiBjaG9vc2UgdGhlIG9wdGltYWwgZHJpdmluZyByb3V0ZSBiYXNlZCBvbiBkaWZmZXJlbnQgc2l0dWF0aW9ucy4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlIG9mIHRyYWZmaWMgY29uZ2VzdGlvbiBvbiB1cmJhbiByb2FkcywgYSBsb3ctc3BlZWQgZGVjZWxlcmF0aW9uIHRyYW5zcG9ydCBtb2RlIGNhbiBiZSB1c2VkIHRvIHJlZHVjZSB2ZWhpY2xlIGVuZXJneSBjb25zdW1wdGlvbiBhbmQgZHJpdmluZyBub2lzZTsgb24gaGlnaHdheXMgb3Igb3BlbiByb2FkcyBpbiBzdWJ1cmJhbiBhcmVhcywgYSBoaWdoLXNwZWVkIHRyYW5zcG9ydCBtb2RlIGlzIHJlcXVpcmVkIHRvIGltcHJvdmUgdHJhbnNwb3J0YXRpb24gZWZmaWNpZW5jeS4KCjIuMS4yICoqRGV2ZWxvcG1lbnQgb2YgSW50ZWxsaWdlbnQgRGVjaXNpb24tTWFraW5nIE1vZHVsZXMqKgoKSW4gb3JkZXIgdG8gZGVsaXZlciBnb29kcyBvbiB0aW1lIGFuZCBpbXByb3ZlIGN1c3RvbWVyIHNhdGlzZmFjdGlvbiwgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nIG1vZHVsZXMgYXJlIHJlcXVpcmVkLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKKipSZXNlYXJjaCBvbiB0aGUgUHJhY3RpY2Ugb2YgSW5kdXN0cmlhbCBJbnRlcm5ldCBTZWN1cml0eSBDYXBhYmlsaXR5IENvbnN0cnVjdGlvbiBpbiBQb3dlciBQcm9kdWN0aW9uIEVudGVycHJpc2VzKiogIAoKIyMjIDEuIERlc2lnbiBvZiBJbmR1c3RyaWFsIEludGVybmV0IFNlY3VyaXR5IEZ1bmN0aW9uYWwgQXJjaGl0ZWN0dXJlIGZvciBQb3dlciBQcm9kdWN0aW9uIEVudGVycHJpc2VzICAKCkJhc2VkIG9uIGN5YmVyc2VjdXJpdHkgcmVndWxhdGlvbnMsIHRoZSBvcGVyYXRpb25hbCBjaGFyYWN0ZXJpc3RpY3Mgb2YgcG93ZXIgZW50ZXJwcmlzZXMsIGFuZCBuYXRpb25hbCBpbmR1c3RyeSByZWd1bGF0b3J5IHByYWN0aWNlcywgcG93ZXIgcHJvZHVjdGlvbiBlbnRlcnByaXNlcyBoYXZlIGVzdGFibGlzaGVkIGEgdGFyZ2V0ZWQgaW5kdXN0cmlhbCBpbnRlcm5ldCBzZWN1cml0eSBwcm90ZWN0aW9uIHN5c3RlbS4gVGhpcyBzeXN0ZW0gYWltcyB0byBwcm9tb3RlIHRoZSBpbnRlbGxpZ2VudCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgcG93ZXIgaW5kdXN0cnkgd2hpbGUgZW5zdXJpbmcgZnVsbCBjb21wbGlhbmNlIGFuZCBlZmZpY2llbnQgc2VjdXJpdHkgdGhyb3VnaCBhIHR3by10aWVyLCB0aHJlZS1sYXllciBhcmNoaXRlY3R1cmUgb2YgdGhlIGluZHVzdHJpYWwgaW50ZXJuZXQgc2VjdXJpdHkgc2VydmljZSBwbGF0Zm9ybSAoVUNTUCkgWzFdLiAgCgpUaGlzIHBsYXRmb3JtIGludGVncmF0ZXMgcmVzb3VyY2VzIGZyb20gdXBzdHJlYW0gYW5kIGRvd25zdHJlYW0gcG93ZXIgcHJvZHVjdGlvbiBlbnRlcnByaXNlcywgcmVndWxhdG9yeSBhZ2VuY2llcywgYW5kIHNlcnZpY2UgcHJvdmlkZXJzLCBmb3JtaW5nIGEgY29sbGFib3JhdGl2ZSBzZWN1cml0eSBvcGVyYXRpb24gYW5kIG1haW50ZW5hbmNlIG1lY2hhbmlzbS4gSXQgb2ZmZXJzIG9uZS1zdG9wIGN5YmVyc2VjdXJpdHkgc2VydmljZXMgdG8gYWRkcmVzcyB2YXJpb3VzIHNlY3VyaXR5IGNoYWxsZW5nZXMgZmFjZWQgYnkgcG93ZXIgZW50ZXJwcmlzZXMgZHVyaW5nIGRpZ2l0YWwgdHJhbnNmb3JtYXRpb24uICAKClVDU1AgaXMgYSBwbGF0Zm9ybSBkZWRpY2F0ZWQgdG8gaW5kdXN0cmlhbCBpbnRlcm5ldCBtb25pdG9yaW5nIGFuZCBwZXJjZXB0aW9uLiBJdCBzZWFtbGVzc2x5IGNvbm5lY3RzIHdpdGggbmF0aW9uYWwgc3VwZXJ2aXNvcnkgbWFuYWdlbWVudCBzeXN0ZW1zIGFuZCByZWxldmFudCBuYXRpb25hbCBwbGF0Zm9ybXMgd2hpbGUgYWN0aXZlbHkgcGFydGljaXBhdGluZyBpbiB0aHJlYXQgaW50ZWxsaWdlbmNlIHNoYXJpbmcgYW5kIGVuZm9yY2luZyBoaWdoIHN0YW5kYXJkcyBvZiByZWd1bGF0b3J5IGNvbXBsaWFuY2UuIEl0cyBmdW5jdGlvbmFsIGFyY2hpdGVjdHVyZSBkZXNpZ24gaXMgc2hvd24gaW4gKipGaWd1cmUgMSoqLiBUaGUgY29yZSBmdW5jdGlvbnMgaW5jbHVkZSBidXQgYXJlIG5vdCBsaW1pdGVkIHRvOiAgCgotIEFzc2V0IGRldGVjdGlvbiAgCi0gVHJhZmZpYyBhbmQgcmlzayBhbmFseXNpcyAgCi0gU2l0dWF0aW9uIGFzc2Vzc21lbnQgIAotIEVhcmx5IHdhcm5pbmcgc3lzdGVtcyAgCi0gRW1lcmdlbmN5IHJlc3BvbnNlICAKClRoZXNlIGZ1bmN0aW9ucyBjb2xsZWN0aXZlbHkgY29udHJpYnV0ZSB0byBhIGRlZXBlciB1bmRlcnN0YW5kaW5nIGFuZCB2aXN1YWxpemF0aW9uIG9mIGluZHVzdHJpYWwgbmV0d29yayBzZWN1cml0eSBjb25kaXRpb25zLCBlbnN1cmluZyByZWFsLXRpbWUgaWRlbnRpZmljYXRpb24gYW5kIHdhcm5pbmcgb2YgcG90ZW50aWFsIHRocmVhdHMsIHJpc2tzLCBhbmQgdnVsbmVyYWJpbGl0aWVzLCB0aHVzIHByb3ZpZGluZyBzdHJvbmcgc3VwcG9ydCBmb3IgcG93ZXIgZW50ZXJwcmlzZXMnIGN5YmVyc2VjdXJpdHkgbWFuYWdlbWVudC4gIAoKKipGaWd1cmUgMTogT3ZlcmFsbCBGdW5jdGlvbmFsIEFyY2hpdGVjdHVyZSBEZXNpZ24gb2YgSW5kdXN0cmlhbCBJbnRlcm5ldCBTZWN1cml0eSBDYXBhYmlsaXR5IGZvciBQb3dlciBQcm9kdWN0aW9uIEVudGVycHJpc2VzKiogIAoKSW4gdGhlIGluZHVzdHJpYWwgbmV0d29yayBzZWN1cml0eSByaXNrIG1vbml0b3JpbmcgYW5kIGFuYWx5c2lzIHN5c3RlbSwgc2VjdXJpdHkgc3RyYXRlZ2llcyBhcmUgZGVzaWduZWQgdG8gc3VwcG9ydCBwb3dlciBlbnRlcnByaXNlcyBpbiBhbGlnbmluZyB3aXRoIE5hdGlvbmFsIFN0YW5kYXJkIDIuMC4gVGhpcyBlbnN1cmVzIHNlY3VyaXR5IGluIG5ldHdvcmsgYm91bmRhcmllcywgY29tbXVuaWNhdGlvbiwgYXBwbGljYXRpb25zLCBhbmQgZGF0YSBsYXllcnMuIFRoZSBzeXN0ZW0gYWRoZXJlcyB0byBpbmR1c3RyeSBzZWN1cml0eSBub3JtcywgYWltaW5nIGZvciByaXNrIGNsYXJpdHksIHZpc3VhbGl6YXRpb24sIGFuZCBjb250cm9sbGFiaWxpdHkgdG8gZW5oYW5jZSB0aGUgY3liZXJzZWN1cml0eSBtYW5hZ2VtZW50IGNhcGFiaWxpdGllcyBvZiBwb3dlciBlbnRlcnByaXNlcyBbMl0uICAKCkZvciBvZmZpY2UgYXJlYSBzZWN1cml0eSBkZXNpZ24sIGluZm9ybWF0aW9uIGNvbGxlY3Rpb24sIGFzc2V0IGNvbnRyb2wsIGFuZCBhdWRpdGluZyB0YXNrcyBhcmUgY292ZXJlZCB0byBwcm92aWRlIHJlYWwtdGltZSBtb25pdG9yaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgdW5pZmllZCBzZWN1cml0eSBwbGF0Zm9ybSBhbmQgc3VwcG9ydCBwbGF0Zm9ybSBzZXJ2aWNlcy4gQXQgdGhlIGNyaXRpY2FsIGluZHVzdHJpYWwgY29udHJvbCBlZGdlIGxheWVyLCBhIGxheWVyZWQgYW5kIGRvbWFpbi1zZXBhcmF0ZWQgc3RyYXRlZ3kgaXMgYWRvcHRlZCwgaW50ZWdyYXRpbmcgbXVsdGlwbGUgc2VjdXJpdHkgdGVjaG5vbG9naWVzIHRvIHJlaW5mb3JjZSBuZXR3b3JrIGJvdW5kYXJ5IHByb3RlY3Rpb24gYmV0d2VlbiBkZXZpY2VzIGFuZCBjb250cm9sIHN5c3RlbXMuICAKCkluIGluZHVzdHJpYWwgY29udHJvbCBlcXVpcG1lbnQsIHBvd2VyIGVudGVycHJpc2VzIGltcGxlbWVudCBzdHJpY3QgaWRlbnRpdHkgdmVyaWZpY2F0aW9uIGFuZCBhY2Nlc3MgY29udHJvbCwgdXRpbGl6aW5nIGhhcmR3YXJlLXVuaXF1ZSBpZGVudGlmaWVycyB0byBlbnN1cmUgbGVnaXRpbWF0ZSBuZXR3b3JrIGFjY2VzcyBhbmQgcnVsZS1iYXNlZCBkYXRhIGludGVyYWN0aW9uIGNvbnRyb2wuICoqRmlndXJlIDIqKiBpbGx1c3RyYXRlcyB0aGUgaW5kdXN0cmlhbCBpbnRlcm5ldCBkYXRhIGZsb3cgYW5kIGNyeXB0b2dyYXBoaWMgZW1wb3dlcm1lbnQgaW4gcG93ZXIgcHJvZHVjdGlvbiBlbnRlcnByaXNlcy4gIAoKU2VjdXJpdHkgbWVhc3VyZXMgaW4gdGhlIGNvbnRyb2wgcHJvY2VzcyBpbmNsdWRlOiAgCgotIFN0cmVuZ3RoZW5pbmcgcHJvdG9jb2wgc2VjdXJpdHkgIAotIFNvZnR3YXJlIGhhcmRlbmluZyAgCi0gQ29tbWFuZCBhdWRpdGluZyAgCi0gRmF1bHQgcHJvdGVjdGlvbiAgCgpBbGwgdXNlcnMgbXVzdCBiZSBhdXRoZW50aWNhdGVkLCBhZGRpdGlvbmFsIGF1dGhlbnRpY2F0aW9uIHN0ZXBzIGFyZSByZXF1aXJlZCBkdXJpbmcgY29tbXVuaWNhdGlvbiB0byBwcmV2ZW50IHVuYXV0aG9yaXplZCBzZXNzaW9ucywgZW5jcnlwdGlvbiBpcyB1c2VkIHRvIHByb3RlY3QgZGF0YSB0cmFuc21pc3Npb24sIGFuZCBzb2Z0d2FyZSB2dWxuZXJhYmlsaXRpZXMgYXJlIHByb21wdGx5IHBhdGNoZWQgb3IgbWl0aWdhdGVkLiBDb21tYW5kIGF1ZGl0aW5nIHByZXZlbnRzIHNlY3VyaXR5IGluY2lkZW50cywgZW5zdXJpbmcgY29tcHJlaGVuc2l2ZSBwcm90ZWN0aW9uIGZvciBpbmR1c3RyaWFsIGludGVybmV0IHNlY3VyaXR5LiAgCgoqKkZpZ3VyZSAyOiBJbmR1c3RyaWFsIEludGVybmV0IERhdGEgRmxvdyBhbmQgQ3J5cHRvZ3JhcGhpYyBFbXBvd2VybWVudCBpbiBQb3dlciBQcm9kdWN0aW9uIEVudGVycHJpc2VzKiogIAoKIyMjIDIuIERlcGxveW1lbnQgUGxhbiBmb3IgSW5kdXN0cmlhbCBJbnRlcm5ldCBTZWN1cml0eSBDYXBhYmlsaXR5IGluIFBvd2VyIFByb2R1Y3Rpb24gRW50ZXJwcmlzZXMgIAoKRm9yIHBvd2VyIHByb2R1Y3Rpb24gZW50ZXJwcmlzZXMsIFVDU1AgaXMgYSBjb21wcmVoZW5zaXZlLCBtdWx0aS1sYXllcmVkIHNlY3VyaXR5IHByb3RlY3Rpb24gc3lzdGVtLiBJdHMgZnVuZGFtZW50YWwgY29tcG9uZW50cyBpbmNsdWRlIG11bHRpcGxlIGxheWVycyBzdWNoIGFzIHRoZSAqKmluZnJhc3RydWN0dXJlIGxheWVyKiogYW5kIHRoZSAqKnN5c3RlbSBjb21wb25lbnQgbGF5ZXIqKiwgd2hpY2ggY29sbGFib3JhdGUgdG8gZW5zdXJlIG5ldHdvcmsgc2VjdXJpdHkgYWNyb3NzIHRoZSBwb3dlciBzeXN0ZW0gWzNdLiAgCgotICoqSW5mcmFzdHJ1Y3R1cmUgTGF5ZXIqKjogRWZmaWNpZW50IHJlc291cmNlIGFuZCBkZXZpY2UgY29tcHV0aW5nIHRvIHByb3ZpZGUgYSBzb2xpZCB0ZWNobm9sb2dpY2FsIGZvdW5kYXRpb24gZm9yIHRoZSBlbnRpcmUgc3lzdGVtLiAgCi0gKipTeXN0ZW0gQ29tcG9uZW50cyBhbmQgRnVuY3Rpb25hbCBTZXJ2aWNlIExheWVyKio6IFVDU1Agc2VydmVzIGFzIHRoZSBjb3JlLCBjb3ZlcmluZyBuaW5lIG1ham9yIGNvbXBvbmVudHMsIGluY2x1ZGluZyBzZWN1cmUgZGF0YSBzdG9yYWdlLCBkYXRhIGludGVncmF0aW9uLCBhbmQgZGF0YSBjbHVzdGVyIG5vZGVzLiBUaGVzZSBjb21wb25lbnRzIGVuYWJsZSBlZmZpY2llbnQgZGF0YSBwcm9jZXNzaW5nIGFuZCBwcmVjaXNlIHNlY3VyaXR5IHN0cmF0ZWdpZXMgdG8gcmFwaWRseSByZXNwb25kIHRvIHNlY3VyaXR5IHRocmVhdHMuICAKLSAqKlNpdHVhdGlvbiBEaXNwbGF5IExheWVyKio6IExhcmdlLXNjYWxlIHNpdHVhdGlvbmFsIG1vbml0b3Jpbmcgc2NyZWVucyBwcm92aWRlIHJlYWwtdGltZSB2aXN1YWxpemF0aW9uIG9mIGZpdmUgbWFqb3Igc2VjdXJpdHkgc2l0dWF0aW9ucywgZW5hYmxpbmcgc2VjdXJpdHkgcGVyc29ubmVsIHRvIGdyYXNwIHRoZSBjdXJyZW50IHNlY3VyaXR5IHN0YXR1cyBhdCBhIGdsYW5jZS4gIAoKQWRkaXRpb25hbGx5LCBVQ1NQIG9mZmVycyB0d28gY3JpdGljYWwgYnVzaW5lc3MgZnVuY3Rpb25zOiAgCgoxLiAqKkFkdmFuY2VkIFBlcnNpc3RlbnQgVGhyZWF0IChBUFQpIERldGVjdGlvbioqICAKMi4gKipDeWJlcnNlY3VyaXR5IFNpdHVhdGlvbiBNb25pdG8uLi4KKGNvbnRlbnQgdHJ1bmNhdGVkKQp1c2VyOgpSZXNlYXJjaCBvbiB0aGUgRGV2ZWxvcG1lbnQgb2YgU21hcnQgQWdyaWN1bHR1cmUgaW4gU3VxaWFuIENpdHkgaW4gdGhlIE5ldyBFcmEg4oCTIEEgQ2FzZSBTdHVkeSBvZiBUaWFud2EgU21hcnQgSW5kdXN0cmlhbCBQYXJrCgpBYnN0cmFjdDogV2l0aCB0aGUgYXJyaXZhbCBvZiB0aGUgZGlnaXRhbCBlcmEsIHNtYXJ0IGFncmljdWx0dXJlIGhhcyBncmFkdWFsbHkgYmVjb21lIGEgaG90IHRvcGljLiBJdCBwbGF5cyBhbiBpbXBvcnRhbnQgcm9sZSBpbiBpbXByb3ZpbmcgbGFib3IgZWZmaWNpZW5jeSwgZW5oYW5jaW5nIHByb2R1Y3Rpdml0eSBxdWFsaXR5LCBvcHRpbWl6aW5nIHJlc291cmNlIGFsbG9jYXRpb24sIGFuZCBwcm9tb3RpbmcgZW52aXJvbm1lbnRhbCBwcm90ZWN0aW9uLiBJdCBoYXMgYmVjb21lIGFuIGltcG9ydGFudCBkZXZlbG9wbWVudCBjb25jZXB0IGZvciBpbXBsZW1lbnRpbmcgdGhlIHJ1cmFsIHJldml0YWxpemF0aW9uIHN0cmF0ZWd5IGFuZCBhIHBvd2VyZnVsIHRvb2wgZm9yIGJ1aWxkaW5nIOKAnG5ldyBhZ3JpY3VsdHVyZSwgbmV3IGNvdW50cnlzaWRlLCBuZXcgZmFybWVyc+KAnSBpbiB0aGUgbmV3IGVyYS4gSW4gdGhpcyByZWdhcmQsIGhvdyB0byB1c2UgIkludGVybmV0ICsiIHRlY2hub2xvZ3kgdG8gaW5qZWN0IHNtYXJ0ICJnZW5lcyIgaW50byBhZ3JpY3VsdHVyYWwgbW9kZXJuaXphdGlvbiBoYXMgYmVjb21lIHRoZSBmb2N1cyBvZiBhZ3JpY3VsdHVyYWwgZGV2ZWxvcG1lbnQgd29yayBpbiB2YXJpb3VzIHJlZ2lvbnMuIFRha2luZyB0aGUgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IG9mIFRpYW53YSBTbWFydCBJbmR1c3RyaWFsIFBhcmsgaW4gU3VxaWFuIENpdHksIEppYW5nc3UgUHJvdmluY2UsIGFzIGFuIGV4YW1wbGUsIHRoaXMgcGFwZXIgZXhwbG9yZXMgdGhlIHBvc2l0aXZlIHNpZ25pZmljYW5jZSBhbmQgdmFsdWFibGUgZXhwZXJpZW5jZSBwcm92aWRlZCBieSB0aGUgZGV2ZWxvcG1lbnQgb2Ygc21hcnQgYWdyaWN1bHR1cmUgaW4gU3VxaWFuIENpdHkgZm9yIHRoZSBlbnRpcmUgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IGluIE5vcnRoZXJuIEppYW5nc3UgUHJvdmluY2UgdGhyb3VnaCBmaWVsZCBzdXJ2ZXlzIGFuZCByZXNlYXJjaC4KCktleXdvcmRzOiBTbWFydCBBZ3JpY3VsdHVyZTsgUnVyYWwgUmV2aXRhbGl6YXRpb247IFRpYW53YSBTbWFydCBJbmR1c3RyaWFsIFBhcmsKClRoZSByZXBvcnQgb2YgdGhlIDIwdGggTmF0aW9uYWwgQ29uZ3Jlc3Mgb2YgdGhlIENvbW11bmlzdCBQYXJ0eSBvZiBDaGluYSBlbXBoYXNpemVzOiBXZSBtdXN0IGFkaGVyZSB0byBwcmlvcml0aXppbmcgYWdyaWN1bHR1cmFsIGFuZCBydXJhbCBkZXZlbG9wbWVudCwgYW5kIG1ha2UgaW1wb3J0YW50IGRlcGxveW1lbnRzIGZvciBjb21wcmVoZW5zaXZlbHkgcHJvbW90aW5nIHJ1cmFsIHJldml0YWxpemF0aW9uLCBhY2NlbGVyYXRpbmcgdGhlIGNvbnN0cnVjdGlvbiBvZiBhIHN0cm9uZyBhZ3JpY3VsdHVyYWwgY291bnRyeSwgYW5kIGNsYXJpZnlpbmcgdGhlIGdyZWF0IGdvYWxzIGZvciBhZ3JpY3VsdHVyYWwgZGV2ZWxvcG1lbnQgaW4gdGhlIG5ldyBlcmEgYW5kIG5ldyBqb3VybmV5LCBwb2ludGluZyBvdXQgdGhlIGRpcmVjdGlvbiBmb3IgdGhlIG1vZGVybml6YXRpb24gb2YgcnVyYWwgZGV2ZWxvcG1lbnQgaW4gQ2hpbmEgYW5kIHRoZSBmdW5kYW1lbnRhbCB3b3JrIHRvIGZvbGxvdy4gSW4gdGhlIG5ldyBlcmEsIG9ubHkgYnkgY29tYmluaW5nICJ0ZWNobm9sb2d5IiB3aXRoICJhZ3JpY3VsdHVyZSwiIGVtcG93ZXJpbmcgYWdyaWN1bHR1cmUgd2l0aCB0ZWNobm9sb2d5LCBhbmQgcHJvbW90aW5nIHRoZSBkZXZlbG9wbWVudCBhbmQgY29uc3RydWN0aW9uIG9mIHNtYXJ0IGFncmljdWx0dXJlIGNhbiB3ZSB1bHRpbWF0ZWx5IGFjaGlldmUgdGhlIGVmZmVjdCBvZiAiMSsxPjIuIgoKMS4gVGhlIENvbmNlcHQgYW5kIENvbm5vdGF0aW9uIG9mIFNtYXJ0IEFncmljdWx0dXJlICAKU2luY2UgYW5jaWVudCB0aW1lcywgQ2hpbmEgaGFzIGJlZW4gYSBsYXJnZSBhZ3JpY3VsdHVyYWwgY291bnRyeSwgd2l0aCBhIGxhcmdlIHByb3BvcnRpb24gb2YgcnVyYWwgcG9wdWxhdGlvbiwgYW5kIGFncmljdWx0dXJlIGhhcyBwbGF5ZWQgYSBzaWduaWZpY2FudCByb2xlIGluIHRoZSBuYXRpb25hbCBlY29ub215LiBXaXRoIHRoZSBlc3RhYmxpc2htZW50IG9mIHRoZSBQZW9wbGUncyBSZXB1YmxpYyBvZiBDaGluYSBhbmQgdGhlIGRldmVsb3BtZW50IG9mIHRoZSByZWZvcm0gYW5kIG9wZW5pbmctdXAgcG9saWN5LCB0aGUgQ2hpbmVzZSBlY29ub215IGhhcyByYXBpZGx5IHNvYXJlZCwgdGhlIHRlcnRpYXJ5IGluZHVzdHJ5IGhhcyByaXNlbiwgYW5kIGhhcyBjb25zdGFudGx5IGltcGFjdGVkIHRoZSBvbGQgZWNvbm9taWMgc3RydWN0dXJlLiBUaGUgcHJvcG9ydGlvbiBvZiBhZ3JpY3VsdHVyYWwgZWNvbm9teSBoYXMgY29udGludWVkIHRvIGRlY2xpbmUsIGFuZCB0aGUgbWFpbiBzb2NpYWwgY29udHJhZGljdGlvbiBoYXMgc2hpZnRlZCB0byB0aGUgY29udHJhZGljdGlvbiBiZXR3ZWVuIHRoZSBwZW9wbGUncyBncm93aW5nIGRlbWFuZCBmb3IgYSBiZXR0ZXIgbGlmZSBhbmQgdW5iYWxhbmNlZCBhbmQgaW5zdWZmaWNpZW50IGRldmVsb3BtZW50LiBJbiByZXNwb25zZSwgb25seSBieSBjb25zdGFudGx5IGltcHJvdmluZyBwcm9kdWN0aXZpdHkgYW5kIGxhYm9yIGVmZmljaWVuY3kgY2FuIHdlIGZ1cnRoZXIgbWVldCB0aGUgbGl2aW5nIG5lZWRzIG9mIHRoZSBwZW9wbGUgYW5kIGFjaGlldmUgdGhlICJUd28gQ2VudGVuYXJ5IEdvYWxzLiIgIApTbWFydCBhZ3JpY3VsdHVyZSByZWZlcnMgdG8gaW50ZWxsaWdlbnQgYWdyaWN1bHR1cmFsIHRlY2hub2xvZ3ksIHdoaWNoIGludm9sdmVzIGEgc2VyaWVzIG9mIGFncmljdWx0dXJhbCBwcm9kdWN0aW9uIGFjdGl2aXRpZXMgY2FycmllZCBvdXQgYnkgYWdyaWN1bHR1cmFsIHByb2R1Y2VycyB1c2luZyBJbnRlcm5ldCBvZiBUaGluZ3MgKElvVCkgdGVjaG5vbG9naWVzLiBUaHJvdWdoIG1vYmlsZSBwaG9uZXMsIGNvbXB1dGVycywgYW5kIG90aGVyIGRldmljZXMsIGFncmljdWx0dXJhbCBwcm9kdWN0aW9uIHByb2Nlc3NlcyBhcmUgY29udHJvbGxlZCBhbmQgbW9uaXRvcmVkLCBhbGxvd2luZyBmb3IgcHJlY2lzaW9uIG1hbmFnZW1lbnQgb2YgYWdyaWN1bHR1cmFsIHByb2R1Y3Rpb24gYW5kIHVsdGltYXRlbHkgb2J0YWluaW5nIGNvcnJlc3BvbmRpbmcgcHJvZHVjdGlvbiBkYXRhLiBBcyBhbiBlbWVyZ2luZyBhZ3JpY3VsdHVyYWwgcHJvZHVjdGlvbiBjb25jZXB0IGludGVncmF0ZWQgd2l0aCBJb1QgdGVjaG5vbG9neSwgdGhlIGRldmVsb3BtZW50IG9mIHNtYXJ0IGFncmljdWx0dXJlIG9mdGVuIHNlcnZlcyBhcyBhbiBpbXBvcnRhbnQgcmVmZXJlbmNlIGZvciB0aGUgbGV2ZWwgb2YgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IGluIGEgcmVnaW9uLiBUaGUgZGVncmVlIG9mIGludGVsbGlnZW5jZSBhbmQgbWVjaGFuaXphdGlvbiBpbiBhIHJlZ2lvbiBpcyBvZiBncmVhdCBpbXBvcnRhbmNlIGluIGFzc2Vzc2luZyB0aGUgYWdyaWN1bHR1cmFsIGRldmVsb3BtZW50IHN0YXR1cyBvZiB0aGF0IGFyZWEuICAKQXMgYW4gaW1wb3J0YW50IGNvbXBvbmVudCBvZiB0aGUgc21hcnQgZWNvbm9teSwgc21hcnQgYWdyaWN1bHR1cmUgZnVsbHkgdXRpbGl6ZXMgbW9kZXJuIGluZm9ybWF0aW9uIHRlY2hub2xvZ3kgdG8gc2VydmUgdHJhZGl0aW9uYWwgYWdyaWN1bHR1cmUsIHByb3ZpZGluZyBwcmVjaXNlIHBsYW50aW5nLCB2aXN1YWwgZHluYW1pYyBtb25pdG9yaW5nLCBhbmQgaW50ZWxsaWdlbnQgZGVjaXNpb24tbWFraW5nIGZvciBhZ3JpY3VsdHVyYWwgcHJvZHVjdGlvbi4gVGhlIGRldmVsb3BtZW50IG9mIHNtYXJ0IGFncmljdWx0dXJlIG5vdCBvbmx5IGFkZHJlc3NlcyBydXJhbCBlbXBsb3ltZW50IGlzc3VlcyBidXQgYWxzbyBlZmZlY3RpdmVseSBpbXByb3ZlcyB0aGUgYWdyaWN1bHR1cmFsIGVjb2xvZ2ljYWwgZW52aXJvbm1lbnQsIGVuaGFuY2VzIGFncmljdWx0dXJhbCBwcm9kdWN0aXZpdHksIGFuZCByZXNvbHZlcyB0aGUgaXNzdWUgb2YgYSBzaG9ydGFnZSBvZiBkcml2aW5nIGZvcmNlIGluIGFncmljdWx0dXJlLiBQcm9tb3RpbmcgYWdyaWN1bHR1cmFsIGFuZCBydXJhbCBtb2Rlcm5pemF0aW9uIHJlcXVpcmVzIHRoZSBhc3Npc3RhbmNlIG9mIHNtYXJ0IGFncmljdWx0dXJlIGFuZCBpcyBhIGtleSBwYXJ0IG9mIGFjY2VsZXJhdGluZyB0aGUgY29uc3RydWN0aW9uIG9mIGEgc3Ryb25nIGFncmljdWx0dXJhbCBjb3VudHJ5LgoKMi4gT3ZlcnZpZXcgb2YgUnVyYWwgRGV2ZWxvcG1lbnQgSXNzdWVzIGluIE5vcnRoZXJuIEppYW5nc3UgYW5kIEFuYWx5c2lzIG9mIENhdXNlcyAgClRoZSBOb3J0aGVybiBKaWFuZ3N1IHJlZ2lvbiBpcyBsb2NhdGVkIGluIG9uZSBvZiBDaGluYSdzIHRocmVlIG1ham9yIHBsYWlucyDigJQgdGhlIG1pZGRsZSBhbmQgbG93ZXIgWWFuZ3R6ZSBSaXZlciBwbGFpbi4gSXQgYmVuZWZpdHMgZnJvbSBpdHMgbG9jYXRpb24gYWxvbmcgdGhlIHJpdmVyLCB3aXRoIGZhdm9yYWJsZSBnZW9ncmFwaGljYWwgY29uZGl0aW9ucywgYW5kIGlzIGtub3duIGFzIHRoZSAiR3JhbmFyeSBvZiB0aGUgV29ybGQuIiBIb3dldmVyLCB3aXRoIHRoZSBhZHZhbmNlbWVudCBvZiB0aW1lLCB0aGUgYWNjZWxlcmF0aW9uIG9mIHVyYmFuaXphdGlvbiBhY3Jvc3MgdGhlIHNvY2lldHksIGFuZCB0aGUgZnVydGhlciBkZXZlbG9wbWVudCBvZiB0aGUgdGVydGlhcnkgaW5kdXN0cnksIHBhcnRpY3VsYXJseSBpbiB0aGUgc291dGhlcm4gSmlhbmdzdSByZWdpb24sIGhhdmUgaW1wYWN0ZWQgdGhlIGFncmljdWx0dXJhbCBkZXZlbG9wbWVudCBpbiBOb3J0aGVybiBKaWFuZ3N1LiAgCjIuMSBBY2NlbGVyYXRlZCBMb3NzIG9mIFByb2R1Y3Rpdml0eSBhbmQgU2V2ZXJlIFJ1cmFsIEhvbGxvd2luZy4gIApTaW5jZSB0aGUgcmVmb3JtIGFuZCBvcGVuaW5nLXVwLCBlc3BlY2lhbGx5IHdpdGggdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzb2NpYWxpc3QgbWFya2V0IGVjb25vbXksIHRoZXJlIGhhdmUgYmVlbiBtb3JlIGRldmVsb3BtZW50IG9wcG9ydHVuaXRpZXMgYW5kIGluLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIHdyaXRlIGFuIGludHJvZHVjdGlvbiBjaGFwdGVyIGZvciBhIG1lZGljYWwgaW1hZ2luZyBhbmFseXNpcyB0aGVzaXMsIHdpdGggYSB3b3JkIGNvdW50IHJlcXVpcmVtZW50IG9mIDIwMDAtMjUwMCB3b3Jkcy4gVGhlIGZvbGxvd2luZyBpcyB0aGUgbWFpbiB0ZXh0IG9mIG15IHRoZXNpczogKipSZXNlYXJjaCBQcm9ncmVzcyBvZiBNZWRpY2FsIEltYWdlIEFuYWx5c2lzIEJhc2VkIG9uIERlZXAgQ29udm9sdXRpb25hbCBOZXR3b3JrcyoqCgoxLiBPdmVydmlldyBvZiBEZWVwIENvbnZvbHV0aW9uYWwgTmV1cmFsIE5ldHdvcmtzICAKVGhlIGh1bWFuIGJyYWluIGlzIHRoZSBpbmZvcm1hdGlvbiBwcm9jZXNzaW5nIGNlbnRlciwgY29udHJvbGxpbmcgaHVtYW4gYmVoYXZpb3IgYW5kIHRob3VnaHQuIFRvIHN0dWR5IHRoZSBzdHJ1Y3R1cmUgYW5kIGZ1bmN0aW9uIG9mIHRoZSBodW1hbiBicmFpbidzIG5lcnZvdXMgc3lzdGVtLCBiaW9sb2dpY2FsIG5ldXJhbCBuZXR3b3JrcyB3ZXJlIHByb3Bvc2VkLiBJbnNwaXJlZCBieSB0aGlzLCBjb21wdXRlciByZXNlYXJjaGVycyBpbnRyb2R1Y2VkIGFydGlmaWNpYWwgbmV1cmFsIG5ldHdvcmtzIHRvIHNpbXVsYXRlIHRoZSBzdHJ1Y3R1cmUgYW5kIGZ1bmN0aW9uaW5nIG9mIHRoZSBodW1hbiBicmFpbuKAmXMgbmVydm91cyBzeXN0ZW0uICAKRnJvbSBhbiBpbmZvcm1hdGlvbiBwcm9jZXNzaW5nIHBlcnNwZWN0aXZlLCBhbiBhcnRpZmljaWFsIG5ldXJhbCBuZXR3b3JrIGlzIGEgY29tcGxleCBtYXRoZW1hdGljYWwgbW9kZWwgdGhhdCBjb25uZWN0cyBhIGxhcmdlIG51bWJlciBvZiBtYXRoZW1hdGljYWwgZnVuY3Rpb25zIGluIHRoZSBmb3JtIG9mIG5ldXJvbnMuIFRoZSB0cmFuc21pc3Npb24gb2YgaW5mb3JtYXRpb24gYmV0d2VlbiBuZXVyb25zIGlzIHNpbWlsYXIgdG8gdGhlIHRyYW5zZmVyIG9mIGhvcm1vbmVzIGJldHdlZW4gYWRqYWNlbnQgbmVydmUgY2VsbHMgaW4gdGhlIGJyYWluLiBUaGUgbnVtYmVyIG9mIG5ldXJvbnMsIHRoZSBjb25uZWN0aW9uIG1ldGhvZCwgaW50ZXJuYWwgcGFyYW1ldGVycywgYW5kIGFjdGl2YXRpb24gZnVuY3Rpb25zIGRpZmZlciB0byBmb3JtIHZhcmlvdXMgbmV1cmFsIG5ldHdvcmsgc3RydWN0dXJlcy4gVGhlIHNpbXBsZXN0IHR5cGUgb2YgYXJ0aWZpY2lhbCBuZXVyYWwgbmV0d29yayBpcyBjYWxsZWQgYSBzaW5nbGUtbGF5ZXIgcGVyY2VwdHJvbiwgY29uc2lzdGluZyBvZiBvbmUgaW5wdXQgbGF5ZXIsIG9uZSBoaWRkZW4gbGF5ZXIsIGFuZCBvbmUgb3V0cHV0IGxheWVyLCBhcyBzaG93biBpbiBGaWd1cmUgMS4gQmVjYXVzZSB0aGlzIHN0cnVjdHVyZSBpcyB0b28gc2ltcGxlIHRvIGhhbmRsZSBjb21wbGV4IGNvbXB1dGF0aW9ucywgaXRzIGFwcGxpY2F0aW9uIGlzIGxpbWl0ZWQuICAKTXVsdGlsYXllciBuZXVyYWwgbmV0d29ya3MsIGFsc28ga25vd24gYXMgbXVsdGktbGF5ZXIgcGVyY2VwdHJvbnMgKE1MUCksIGhhdmUgbXVsdGlwbGUgaGlkZGVuIGxheWVycyBhbmQgYXJlIHZhbHVhYmxlIGFydGlmaWNpYWwgbmV1cmFsIG5ldHdvcmtzIGZvciBwcmFjdGljYWwgYXBwbGljYXRpb25zLiBUaGUgbW9zdCB0eXBpY2FsIG11bHRpbGF5ZXIgbmV1cmFsIG5ldHdvcmsgbW9kZWwgaXMgdGhlIGJhY2twcm9wYWdhdGlvbiAoQlApIG5ldXJhbCBuZXR3b3JrIGludmVudGVkIGJ5IFJ1bWVsaGFydCBldCBhbC4gIAoKRmlndXJlIDE6IFNpbmdsZS1MYXllciBOZXVyb24gU3RydWN0dXJlICAKCldpdGggdGhlIGFkdmFuY2VtZW50IG9mIGNvbXB1dGVyIHBvd2VyIGFuZCBtYXRoZW1hdGljYWwgbG9naWMsIG11bHRpbGF5ZXIgbmV1cmFsIG5ldHdvcmsgc3RydWN0dXJlcyBoYXZlIGJlY29tZSBpbmNyZWFzaW5nbHkgY29tcGxleCBhbmQgZGl2ZXJzZS4gRGVlcCBsZWFybmluZyBhbGdvcml0aG1zIHJlcHJlc2VudGVkIGJ5IENOTnMgZnVydGhlciBleHBhbmQgdGhlIGRlcHRoIGFuZCBicmVhZHRoIG9mIGNvbXB1dGVyIGFsZ29yaXRobXMgc2ltdWxhdGluZyBodW1hbiBjb2duaXRpdmUgZG9tYWlucy4gQXMgc2hvd24gaW4gRmlndXJlIDIsIGEgdHlwaWNhbCBDTk4gc3RydWN0dXJlIGNvbnNpc3RzIG9mIG9uZSBpbnB1dCBsYXllciwgb25lIG91dHB1dCBsYXllciwgc2V2ZXJhbCBjb252b2x1dGlvbmFsIGxheWVycywgcG9vbGluZyBsYXllcnMsIGFuZCBmdWxseSBjb25uZWN0ZWQgbGF5ZXJzLiBUaGlzIG5ldHdvcmsgc3RydWN0dXJlIHBlcmZvcm1zIGJldHRlciB0aGFuIHRyYWRpdGlvbmFsIG11bHRpbGF5ZXIgbmV1cmFsIG5ldHdvcmtzIGluIGNvbXB1dGVyIHZpc2lvbiB0YXNrcyBiZWNhdXNlIGNvbnZvbHV0aW9uYWwgbGF5ZXJzIGFuZCBwb29saW5nIGxheWVycyBjYW4gcmVkdWNlIHRoZSBudW1iZXIgb2Ygd2VpZ2h0IHBhcmFtZXRlcnMgdGhhdCBuZWVkIHRvIGJlIHRyYWluZWQgYnkgdXNpbmcgcGFyYW1ldGVyIHNoYXJpbmcgYW5kIHBhcnRpYWwgZGlzY2FyZGluZyBtZXRob2RzLiBUaGlzIHJlZHVjZXMgbmV0d29yayBjb21wbGV4aXR5LCBlYXNlcyB0aGUgY29tcHV0YXRpb25hbCBsb2FkLCBhbmQgZW5hYmxlcyBDTk5zIHdpdGggdGhlIHNhbWUgZGVwdGggdG8gaGF2ZSBzdHJvbmdlciBkYXRhIHByb2Nlc3NpbmcgYW5kIGZlYXR1cmUgZXh0cmFjdGlvbiBjYXBhYmlsaXRpZXMgdGhhbiBtdWx0aS1sYXllciBwZXJjZXB0cm9ucy4gIApHZW5lcmF0aXZlIEFkdmVyc2FyaWFsIE5ldHdvcmtzIChHQU5zKSBhcmUgdGhlIG1vc3Qgd2lkZWx5IGFwcGxpZWQgY29udm9sdXRpb25hbCBuZXVyYWwgbmV0d29ya3MgaW4gcmVjZW50IHllYXJzLiBVbmxpa2UgY2xhc3NpYyBDTk4gbW9kZWxzIHN1Y2ggYXMgQWxleE5ldCwgVkdHLCBhbmQgUmVzTmV0LCBHQU4gY29uc2lzdHMgb2YgdHdvIGluZGVwZW5kZW50IG5ldHdvcmsgbW9kZWxzOiBhIGdlbmVyYXRvciBhbmQgYSBkaXNjcmltaW5hdG9yLCBhcyBzaG93biBpbiBGaWd1cmUgMy4gSW4gbW9zdCBjYXNlcywgYm90aCB0aGUgZ2VuZXJhdG9yIGFuZCBkaXNjcmltaW5hdG9yIGFyZSBpbXBsZW1lbnRlZCB3aXRoIENOTnMuIFRoZXkgYWN0IGxpa2UgYWR2ZXJzYXJpZXM6IGJvdGggaW5kZXBlbmRlbnQgYW5kIGNvbXBsZW1lbnRhcnksIGNvbXBldGluZyB3aXRoIGVhY2ggb3RoZXIgYW5kIGVuaGFuY2luZyBlYWNoIG90aGVyJ3MgcGVyZm9ybWFuY2UuICAKVGhlIEdBTiwgY29uc2lzdGluZyBvZiB0d28gbW9kZWxzLCBpbmhlcmVudGx5IGhhcyBzZWxmLWRpc2NyaW1pbmF0aW9uLCBzZWxmLW9wdGltaXphdGlvbiwgYW5kIHN0cm9uZyBnZW5lcmFsaXphdGlvbiBhYmlsaXRpZXMsIGFjaGlldmluZyBnb29kIHJlc3VsdHMgaW4gaW1hZ2UgcmVjb25zdHJ1Y3Rpb24gYW5kIGdlbmVyYXRpb24uIEZ1cnRoZXJtb3JlLCBpbXByb3ZlZCBHQU4gbW9kZWxzIHN1Y2ggYXMgQ29uZGl0aW9uYWwgR2VuZXJhdGl2ZSBBZHZlcnNhcmlhbCBOZXR3b3JrcyAoQ0dBTikgYW5kIEN5Y2xlIEdlbmVyYXRpdmUgQWR2ZXJzYXJpYWwgTmV0d29ya3MgKEN5Y2xlIEdBTikgcHJvdmlkZSBuZXcgc29sdXRpb25zIGZvciBjb21wbGV4IGNvbXB1dGVyIHZpc2lvbiB0YXNrcy4KCjIuIEFwcGxpY2F0aW9ucyBvZiBDTk5zIGluIE1lZGljYWwgSW1hZ2UgUHJvY2Vzc2luZyAgCjIuMSBJbWFnZSBTZWdtZW50YXRpb24gIApJbWFnZSBzZWdtZW50YXRpb24gaW52b2x2ZXMgZGl2aWRpbmcgdGhlIHRhcmdldCBpbWFnZSBpbnRvIHJlZ2lvbnMgb2YgaW50ZXJlc3QsIHN1Y2ggYXMgZGlzZWFzZWQgb3JnYW5zLCB0aXNzdWVzLCBhbmQgdHVtb3JzLiBNb3N0IG1lZGljYWwgaW1hZ2VzIGFyZSBncmF5c2NhbGUsIGFuZCB0aGV5IG9mdGVuIHN1ZmZlciBmcm9tIHVuZXZlbiBncmF5c2NhbGUgZGlzdHJpYnV0aW9uLCBzaWduaWZpY2FudCBub2lzZSwgYW5kIHVuY2xlYXIgb3IgY2hhbmdpbmcgYm91bmRhcmllcyBvZiB0aXNzdWVzIGFuZCBvcmdhbnMsIG1ha2luZyB0aGVtIGRpZmZpY3VsdCB0byBpbnRlcnByZXQgYW5kIHVuZGVyc3RhbmQgZm9yIG5vbi1wcm9mZXNzaW9uYWxzLiBUcmFkaXRpb25hbCBpbWFnZSBzZWdtZW50YXRpb24gbWV0aG9kcyBwcmltYXJpbHkgdXNlIGxvY2FsIHBoeXNpY2FsIGZlYXR1cmVzIHN1Y2ggYXMgY29sb3IsIHRleHR1cmUsIGFuZCBtb3JwaG9sb2d5IGZvciByZWdpb24tYmFzZWQgYW5kIGJvdW5kYXJ5LWJhc2VkIHNlZ21lbnRhdGlvbi4gQ29tbW9uIG1ldGhvZHMgaW5jbHVkZSBjbHVzdGVyaW5nIGFsZ29yaXRobXMgaW4gdHJhZGl0aW9uYWwgbWFjaGluZSBsZWFybmluZywgc3VjaCBhcyBmdXp6eSBDLW1lYW5zIChGQ00pIGZvciBtYWduZXRpYyByZXNvbmFuY2UgaW1hZ2UgKE1SSSkgc2VnbWVudGF0aW9uLCBLLW1lYW5zIGNsdXN0ZXJpbmcgYW5kIFdhdGVyc2hlZCBhbGdvcml0aG1zIGZvciBpbWFnZSBzZWdtZW50YXRpb24sIGFuZCBTdXBwb3J0IFZlY3RvciBNYWNoaW5lIChTVk0pLWJhc2VkIGltYWdlIHNlZ21lbnRhdGlvbiwgYW1vbmcgb3RoZXJzLiBUaGVzZSBtZXRob2RzIG1haW5seSB1dGlsaXplIGxvY2FsIHBoeXNpY2FsIGluZm9ybWF0aW9uIGFuZCBkbyBub3QgZnVsbHkgdXRpbGl6ZSB0aGUgc2VtYW50aWMgaW5mb3JtYXRpb24gY29udGFpbmVkIGluIHRoZSBpbWFnZSBpdHNlbGYuCgpGaWd1cmUgMjogVHlwaWNhbCBDb252b2x1dGlvbmFsIE5ldXJhbCBOZXR3b3JrIFN0cnVjdHVyZSAgCkZpZ3VyZSAzOiBCYXNpYyBGcmFtZXdvcmsgb2YgR2VuZXJhdGl2ZSBBZHZlcnNhcmlhbCBOZXR3b3JrcyAgCgpDTk5zLCB3aXRoIHRoZWlyIG11bHRpLW5vZGUgYW5kIG11bHRpLWxheWVyZWQgc3RydWN0dXJlLCBoYXZlIHRoZSBhYmlsaXR5IHRvIGF1dG9tYXRpY2FsbHkgZXh0cmFjdCBkZWVwIGZlYXR1cmVzIGZyb20gaW5wdXQgZGF0YSwgbWFraW5nIHRoZW0gbW9yZSBzdWl0YWJsZSBmb3IgaW1hZ2UgY2xhc3NpZmljYXRpb24gb3IgcmVncmVzc2lvbiB0YXNrcy4gVGhhbmtzIHRvIHRoZSBhZHZlbnQgb2YgRnVsbHkgQ29udm9sdXRpb25hbCBOZXR3b3JrcyAoRkNOcyksIGltYWdlIHNlZ21lbnRhdGlvbiB0YXNrcyBoYXZlIGZvdW5kIG5ldyBzb2x1dGlvbnMuIEZDTnMgcmVwbGFjZSB0aGUgZmluYWwgZnVsbHkgY29ubmVjdGVkIGxheWVycyBvZiB0aGUgY2xhc3NpY2FsIENOTiBtby4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CioqU2ltdWxhdGlvbiBNb2RlbCBEZXNpZ24gYW5kIENvbm5lY3Rpdml0eSBSZWFsaXphdGlvbiBvZiBEaWdpdGFsIFR3aW4gaW4gU21hcnQgRmFjdG9yeSoqCgpBYnN0cmFjdDogQmFzZWQgb24gdGhlIGRpc2NyZXRlIG1hbnVmYWN0dXJpbmcgc21hcnQgZmFjdG9yeSBleHBlcmltZW50YWwgcGxhdGZvcm0sIHRoaXMgcGFwZXIgZGVlcGx5IGFuYWx5emVzIGl0cyBzeXN0ZW0gYXJjaGl0ZWN0dXJlLiBJdCB1c2VzIEZsZXhTaW0gM0QgbW9kZWxpbmcgdGVjaG5vbG9neSB0byBidWlsZCBhIHZpcnR1YWwgaW1hZ2Ugb2YgdGhlIHNtYXJ0IGZhY3RvcnksIGFuZCBhY2hpZXZlcyByZWFsLXRpbWUgaW5mb3JtYXRpb24gZmxvdyBhbmQgYmlkaXJlY3Rpb25hbCBpbnRlcmFjdGlvbiBiZXR3ZWVuIHRoZSBwaHlzaWNhbCBlbnRpdHkgYW5kIHRoZSB2aXJ0dWFsIG1vZGVsIHRocm91Z2ggYSBTb2NrZXQgY29tbXVuaWNhdGlvbiBtZWNoYW5pc20uIFRoZSBkaWdpdGFsIHR3aW4gc3lzdGVtIG9mIHRoZSBzbWFydCBmYWN0b3J5IGlzIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCwgcHJvdmlkaW5nIGlubm92YXRpdmUgaWRlYXMgYW5kIGVtcGlyaWNhbCByZWZlcmVuY2VzIGZvciBkaWdpdGFsIHR3aW4gcHJhY3RpY2VzLgoKRnVuZDogTmluZ2JvIENpdHkgIlNjaWVuY2UgYW5kIFRlY2hub2xvZ3kgSW5ub3ZhdGlvbiBZb25namlhbmcgMjAzNSIgTWFqb3IgQXBwbGljYXRpb24gRGVtb25zdHJhdGlvbiBQbGFuIOKAlCBSZXNlYXJjaCBhbmQgQXBwbGljYXRpb24gb2YgdGhlIENvbW1hbmQgYW5kIERpc3BhdGNoIERlY2lzaW9uLU1ha2luZyBTeXN0ZW0gQmFzZWQgb24gRGlnaXRhbCBUd2luIFBsYXRmb3JtIGZvciBNb2xkIEluZHVzdHJpYWwgUGFyayAoUHJvamVjdCBObzogMjAyNFowMDcpCgpLZXl3b3JkczogU21hcnQgZmFjdG9yeTsgZGlnaXRhbCB0d2luIHNpbXVsYXRpb24gdGVjaG5vbG9neQoKSW50cm9kdWN0aW9uOiBJbiByZWNlbnQgeWVhcnMsIHdpdGggdGhlIGNvbnRpbnVvdXMgZGV2ZWxvcG1lbnQgb2YgcHJvZHVjdGl2aXR5LCBDaGluYeKAmXMgbWFudWZhY3R1cmluZyBpbmR1c3RyeSBoYXMgZ3JhZHVhbGx5IHRyYW5zZm9ybWVkIGZyb20gdHJhZGl0aW9uYWwgbWFudWZhY3R1cmluZyB0byBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nLiBJbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIGhhcyBiZWNvbWUgYW4gaW1wb3J0YW50IHBhdGggdG8gbGVhZCB0aGUgdXBncmFkaW5nIGFuZCBkZXZlbG9wbWVudCBvZiB0aGUgbWFudWZhY3R1cmluZyBpbmR1c3RyeS4gSW50ZWxsaWdlbnQgbWFudWZhY3R1cmluZyBpcyBub3Qgb25seSB0aGUgZW5naW5lIGZvciB0aGUgdHJhbnNmb3JtYXRpb24gYW5kIHVwZ3JhZGluZyBvZiB0aGUgbWFudWZhY3R1cmluZyBpbmR1c3RyeSBidXQgYWxzbyB0aGUga2V5IHRvIHByb21vdGluZyBoaWdoLXF1YWxpdHkgZWNvbm9taWMgZGV2ZWxvcG1lbnQuIEJ5IGludHJvZHVjaW5nIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgdGVjaG5vbG9neSwgQ2hpbmHigJlzIG1hbnVmYWN0dXJpbmcgaW5kdXN0cnkgY2FuIGFjaGlldmUgYSBmdW5kYW1lbnRhbCBjaGFuZ2UgaW4gdGhlIG1vZGUgb2YgcHJvZHVjdGlvbiwgdHJhbnNmb3JtaW5nIGZyb20gbGFib3ItaW50ZW5zaXZlIHRvIHRlY2hub2xvZ3ktaW50ZW5zaXZlLCBpbXByb3ZpbmcgdGhlIGNvcmUgY29tcGV0aXRpdmVuZXNzIGFuZCBpbnRlcm5hdGlvbmFsIHN0YXR1cyBvZiB0aGUgaW5kdXN0cnkuIEF0IHRoZSBzYW1lIHRpbWUsIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcgcHJvbW90ZXMgdGhlIGRlZXAgaW50ZWdyYXRpb24gb2YgbWFudWZhY3R1cmluZyBhbmQgaW5mb3JtYXRpb24gdGVjaG5vbG9neSwgZHJpdmluZyB0aGUgZW1lcmdlbmNlIG9mIG5ldyBidXNpbmVzcyBmb3JtcyBhbmQgbW9kZWxzLCBpbmplY3RpbmcgbmV3IHZpdGFsaXR5IGludG8gZWNvbm9taWMgZGV2ZWxvcG1lbnQuIEluIHNtYXJ0IG1hbnVmYWN0dXJpbmcsIHRoZSBkaWdpdGFsIHR3aW4gc2ltdWxhdGlvbiB0ZWNobm9sb2d5IG9mIHNtYXJ0IGZhY3RvcmllcyBpcyBwbGF5aW5nIGFuIGluY3JlYXNpbmdseSBpbXBvcnRhbnQgcm9sZS4gVGhlIGRpZ2l0YWwgdHdpbiBzaW11bGF0aW9uIHRlY2hub2xvZ3kgb2YgdGhlIHNtYXJ0IGZhY3RvcnkgY2FuIGFjaGlldmUgZGVlcCBpbnRlZ3JhdGlvbiBhbmQgYWNjdXJhdGUgbWFwcGluZyBiZXR3ZWVuIHRoZSBwaHlzaWNhbCB3b3JsZCBhbmQgdGhlIHZpcnR1YWwgd29ybGQuIEl0IG5vdCBvbmx5IHNpbXVsYXRlcyBwcm9kdWN0aW9uIHByb2Nlc3NlcywgZXF1aXBtZW50IG9wZXJhdGlvbiwgYW5kIHByb2R1Y3Rpb24gbGluZSBvcHRpbWl6YXRpb24gaW4gYWR2YW5jZSB0byBlZmZlY3RpdmVseSBhdm9pZCByaXNrcyBhbmQgY29zdCB3YXN0ZSBpbiBhY3R1YWwgb3BlcmF0aW9ucyBidXQgYWxzbyBjb25kdWN0cyBjb3VudGxlc3MgaXRlcmF0aW9ucyBpbiB0aGUgdmlydHVhbCBlbnZpcm9ubWVudCwgYWNjZWxlcmF0aW5nIHByb2R1Y3QgaW5ub3ZhdGlvbiBjeWNsZXMsIHByb3ZpZGluZyBkZWNpc2lvbiBzdXBwb3J0IGZvciBtYW5hZ2Vycywgb3B0aW1pemluZyByZXNvdXJjZSBhbGxvY2F0aW9uLCBhbmQgaW1wcm92aW5nIHByb2R1Y3Rpb24gZWZmaWNpZW5jeSBhbmQgZmxleGliaWxpdHkuIEluIGNvbmNsdXNpb24sIHRoZSBkaWdpdGFsIHR3aW4gc2ltdWxhdGlvbiB0ZWNobm9sb2d5IG9mIHNtYXJ0IGZhY3RvcmllcyBpcyBhIGtleSBmb3JjZSBpbiBkcml2aW5nIHRoZSB0cmFuc2Zvcm1hdGlvbiBvZiBtYW51ZmFjdHVyaW5nIHRvIGludGVsbGlnZW50IGFuZCBlZmZpY2llbnQgc3lzdGVtcy4KCjEuIENvcmUgQ29tcG9uZW50cyBvZiBEaWdpdGFsIFR3aW4gIApJbiB0aGUgY3VycmVudCB3YXZlIG9mIGluZHVzdHJpYWwgdHJhbnNmb3JtYXRpb24gYW5kIHVwZ3JhZGluZywgc21hcnQgZmFjdG9yaWVzIGFuZCBpbnRlbGxpZ2VudCBtYW51ZmFjdHVyaW5nIGFyZSBsZWFkaW5nIHByb2ZvdW5kIGNoYW5nZXMgaW4gdGhlIGluZHVzdHJpYWwgc2VjdG9yLiBBcyBhIG1vZGVsIG9mIHRoZSBmdXNpb24gb2YgbWFudWZhY3R1cmluZyBpbmR1c3RyeSBtYW5hZ2VtZW50IHdpc2RvbSBhbmQgYWR2YW5jZWQgdGVjaG5vbG9neSwgc21hcnQgZmFjdG9yaWVzIHJlbHkgb24gZnJvbnRpZXIgdGVjaG5vbG9naWVzIHN1Y2ggYXMgdGhlIEludGVybmV0IG9mIFRoaW5ncywgYXV0b21hdGlvbiwgbmV0d29yayBjb21tdW5pY2F0aW9uLCBhbmQgYXJ0aWZpY2lhbCBpbnRlbGxpZ2VuY2UgdG8gYnVpbGQgYSBoaWdobHkgaW50ZWdyYXRlZCBlY29zeXN0ZW0gb2YgcGVvcGxlLCBtYWNoaW5lcywgbWF0ZXJpYWxzLCBhbmQgdGhlIGVudmlyb25tZW50LiBUaGlzIHN5c3RlbSBub3Qgb25seSBhY2hpZXZlcyBpbnRlZ3JhdGlvbiBvZiBwcm9kdWN0aW9uIGFuZCBtYW5hZ2VtZW50IGJ1dCBhbHNvIGxheXMgYSBzb2xpZCBmb3VuZGF0aW9uIGZvciB0aGUgY29uc3RydWN0aW9uIG9mIGEgc21hcnQgc3VwcGx5IGNoYWluLiBIb3dldmVyLCB0aGUgZWZmaWNpZW50IG9wZXJhdGlvbiBhbmQgbWFuYWdlbWVudCBvZiBzbWFydCBmYWN0b3JpZXMgcmVseSBvbiB0aGUgZGVlcCBpbnZvbHZlbWVudCBvZiBzaW11bGF0aW9uIHRlY2hub2xvZ3kgdG8gZXZhbHVhdGUgYW5kIG9wdGltaXplIHRoZWlyIGNvbXBsZXggc3lzdGVtcy4gVGhlIGxpbWl0YXRpb24gb2YgdHJhZGl0aW9uYWwgc2ltdWxhdGlvbiB0ZWNobm9sb2d5IGxpZXMgaW4gaXRzICJvZmZsaW5lIiBuYXR1cmUsIHdoaWNoIG1ha2VzIGl0IGRpZmZpY3VsdCB0byByZWZsZWN0IHRoZSBkeW5hbWljIGNoYW5nZXMgb2YgdGhlIHBoeXNpY2FsIHN5c3RlbSBpbiByZWFsLXRpbWUgYW5kIGZhaWxzIHRvIG1lZXQgdGhlIHJlYWwtdGltZSBtb25pdG9yaW5nIGFuZCBwcmVjaXNlIGRlY2lzaW9uLW1ha2luZyBuZWVkcyBvZiBzbWFydCBmYWN0b3JpZXMuCgpBZ2FpbnN0IHRoaXMgYmFja2dyb3VuZCwgZGlnaXRhbCB0d2luIHRlY2hub2xvZ3kgZW1lcmdlZCBhcyBhIGtleSBmb3JjZSBkcml2aW5nIHRoZSBkZXZlbG9wbWVudCBvZiBzbWFydCBmYWN0b3JpZXMgYW5kIGludGVsbGlnZW50IG1hbnVmYWN0dXJpbmcuIERpZ2l0YWwgdHdpbnMgY3JlYXRlIGFuIGFjY3VyYXRlIHZpcnR1YWwgaW1hZ2Ugb2YgdGhlIHBoeXNpY2FsIGVudGl0eSwgZW5hYmxpbmcgc2VhbWxlc3MgaW50ZWdyYXRpb24gYW5kIHJlYWwtdGltZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIHRoZSBwaHlzaWNhbCB3b3JsZCBhbmQgdGhlIGRpZ2l0YWwgd29ybGQuIEEgZGlnaXRhbCB0d2luIGNvbnNpc3RzIG9mIHRocmVlIG1haW4gcGFydHM6IHRoZSBwaHlzaWNhbCBlbnRpdHkgaW4gdGhlIHBoeXNpY2FsIHNwYWNlLCB0aGUgdmlydHVhbCBlbnRpdHkgaW4gdGhlIHZpcnR1YWwgc3BhY2UsIGFuZCB0aGUgZGF0YSBhbmQgaW5mb3JtYXRpb24gZXhjaGFuZ2UgaW50ZXJmYWNlIGJldHdlZW4gdGhlIHBoeXNpY2FsIGFuZCB2aXJ0dWFsIHNwYWNlcy4gRGlnaXRhbCB0d2lucyBjYW4gbm90IG9ubHkgcmVjZWl2ZSByZWFsLXRpbWUgZGF0YSBmcm9tIHBoeXNpY2FsIGVudGl0aWVzIHRvIGRyaXZlIHNpbXVsYXRpb24gYW5kIGR5bmFtaWMgYWRqdXN0bWVudHMgb2YgdmlydHVhbCBtb2RlbHMgYnV0IGFsc28gZmVlZCBiYWNrIG9wdGltaXphdGlvbiBzdHJhdGVnaWVzIGZyb20gdGhlIHZpcnR1YWwgd29ybGQgdG8gdGhlIHBoeXNpY2FsIHdvcmxkLCBndWlkaW5nIHRoZSBwcmVjaXNlIGV4ZWN1dGlvbiBvZiBhY3R1YWwgcHJvZHVjdGlvbiBwcm9jZXNzZXMuIFRoZSBjb3JlIG9mIGRpZ2l0YWwgdHdpbnMgbGllcyBpbiB0aGVpciBiaWRpcmVjdGlvbmFsIGR5bmFtaWMgbWFwcGluZyBhbmQgaW50ZXJhY3Rpb24gbWVjaGFuaXNtcywgd2hpY2ggYnJlYWsgZG93biB0aGUgYm91bmRhcmllcyBiZXR3ZWVuIHRoZSBwaHlzaWNhbCBhbmQgZGlnaXRhbCB3b3JsZHMsIGNyZWF0aW5nIGEgY2xvc2VkLWxvb3AgY29udHJvbCBzeXN0ZW0gZm9yIGNvbXByZWhlbnNpdmUgcGVyY2VwdGlvbiwgcmVhbC10aW1lIGFuYWx5c2lzLCBpbnRlbGxpZ2VudCBkZWNpc2lvbi1tYWtpbmcsIGFuZCBwcmVjaXNlIGV4ZWN1dGlvbi4gVGhyb3VnaCB0aGUgZGVlcCBpbnRlZ3JhdGlvbiBvZiBwaHlzLi4uCihjb250ZW50IHRydW5jYXRlZCkKdXNlcjoKUGxlYXNlIGhlbHAgbWUgd3JpdGUgYSB0ZWNobmljYWwgcG9kY2FzdCAoMTAwMOKAkzIwMDAgd29yZHMpIGludHJvZHVjaW5nIHRoZSBtYWluIGNvbnRyaWJ1dGlvbnMgb2YgdGhlIEFwYWNoZSBQT0kgb3Blbi1zb3VyY2UgdGVjaG5vbG9neSBsaWJyYXJ5Lgp1c2VyOgpJIGFtIHdyaXRpbmcgYSByZXBvcnQgb24gYW4gb3B0aWNhbCBmaWJlciBjb21tdW5pY2F0aW9uIGV4cGVyaW1lbnQuIENvdWxkIHlvdSBwbGVhc2UgaGVscCBtZSB3cml0ZSB0aGUgdGhlb3J5IHNlY3Rpb24/IFVzZSBzaW1wbGUgbGFuZ3VhZ2UgdG8gZXhwbGFpbiB0aGUgdGhlb3J5IG9mIG9wdGljYWwgZmliZXIgY29tbXVuaWNhdGlvbi4gVGhlIGxlbmd0aCBzaG91bGQgYmUgYmV0d2VlbiAxMDAwIGFuZCAxNTAwIHdvcmRzLiBUaGUga2V5IHRvcGljcyB0byBiZSBjb3ZlcmVkIGluY2x1ZGU6IHRoZSBiYXNpYyBwcmluY2lwbGVzIG9mIG9wdGljYWwgZmliZXIgY29tbXVuaWNhdGlvbiwgdGhlIHRyYW5zbWlzc2lvbiBjaGFyYWN0ZXJpc3RpY3Mgb2Ygb3B0aWNhbCBmaWJlcnMsIHNpZ25hbCBtb2R1bGF0aW9uIGFuZCBkZW1vZHVsYXRpb24gbWV0aG9kcywgYW5kIGNvcmUgY29uY2VwdHMgc3VjaCBhcyBmaWJlciBsb3NzIGFuZCBkaXNwZXJzaW9uLgp1c2VyOgrmiJHopoHlhpnkuIDnr4fjgIrmlbDlrZflrarnlJ/mioDmnK/lnKjmmbrog73liLbpgKDkuK3nmoTlupTnlKjnoJTnqbbjgIvvvIzor7fmoLnmja7miYDmj5DkvpvnmoTlj4LogIPorrrmlofnm7jlhbPotYTmlpnnu5PlkIjku6XkuIvor6bnu4bopoHmsYLluK7miJHlhpnnm7jlhbPlt6XkvZzpg6jliIbjgIIKIOWGheWuuee7k+aehOimgeaxgu+8mgotIOamgui/sOaVsOWtl+WtqueUn+aKgOacr+eahOWPkeWxleWOhueoi+WSjOWfuuacrOamguW/tQotIOezu+e7n+ais+eQhuaZuuiDveWItumAoOmihuWfn+aVsOWtl+WtqueUn+eahOS4u+imgeW6lOeUqOWcuuaZrwotIOmHjeeCueWIhuaekOW3peeoi+Wunui3teS4reeahOWFs+mUruaKgOacr+mavueCuQotIOivpue7huiuqOiuuuebruWJjeW3peeoi+iQveWcsOmdouS4tOeahOS4u+imgeaMkeaImO+8iOaKgOacr+OAgeaIkOacrOOAgeagh+WHhuWMluetieaWuemdou+8iQotIOWvueacquadpeWPkeWxlei2i+WKv+i/m+ihjOWxleacmwoK5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6L5LiO5YWz6ZSu5oqA5pyv56CU56m2ICDpvZDlpKnms5Mg77yMIOm7hOa1t+WzsCDvvIwg5pu55LmQIO+8jCDlvKDnrJHnq7kgICDljJfkuqznp5HmioDlpKflraYgIO+8jCAg5Lit5Zu955S156eR5aSn5pWw5o2u56CU56m26Zmi5pyJ6ZmQ5YWs5Y+4ICDvvIwgIOWkquaegeiuoeeul+acuuiCoeS7veaciemZkOWFrOWPuCAgIOaRmOimge+8muS4uuaOqOWKqOWItumAoOS4muaVsOWtl+WMluOAgeaZuuiDveWMlui9rOWei+WNh+e6p++8jOaPkOWHuuaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWei++8jOWMheWQq+amguW/teaooeWei+imgeaxguOAgeamguW/teaooeWei+aetuaehOOAgeamguW/teaooeWei+WHhuehruaAp+WSjOWPr+mdoOaAp+S/nemanOaWueazlTTkuKrnu7TluqbvvIzlnKjor6XmpoLlv7XmqKHlnovln7rnoYDkuIrku4vnu43kuobmmbrog73liLbpgKDmlbDlrZflrarnlJ/mioDmnK/mnrbmnoTvvIzliIbmnpDkuobmlbDlrZflrarnlJ/lu7rmqKHjgIHku7/nnJ/lkozmlbDmja7liIbmnpDnrYnlhbPplK7mioDmnK/vvIzlubblr7nmnKrmnaXmioDmnK/lj5HlsZXov5vooYzkuoblsZXmnJvjgIIgIOWFs+mUruivje+8muaZuuiDveWItumAoDvmpoLlv7XmqKHlnos75pWw5a2X5a2q55Sf5a6e5L2TICDmlLbnqL/ml6XmnJ/vvJoyMDI0LTAzLTI5ICBSZXNlYXJjaCBvbiBJbnRlbGxpZ2VudCBNYW51ZmFjdHVyaW5nIERpZ2l0YWwgVHdpbiBDb25jZXB0dWFsIE1vZGVsIGFuZCBLZXkgVGVjaG5vbG9naWVzICBBYnN0cmFjdO+8mlRvIHByb21vdGUgdGhlIGRpZ2l0YWwgdHJhbnNmb3JtYXRpb24gYW5kIHVwZ3JhZGluZyBvZiBzbWFydCBtYW51ZmFjdHVyaW5nLGEgY29uY2VwdHVhbCBtb2RlbCBvZiB0aGUgZGlnaXRhbCB0d2luIGZvciBzbWFydCBtYW51ZmFjdHVyaW5nIGlzIHByb3Bvc2VkLkl0IGluY2x1ZGVzIGZvdXIgZGltZW5zaW9uczpyZXF1aXJlbWVudHMgb2YgdGhlIGNvbmNlcHR1YWwgbW9kZWwsYXJjaGl0ZWN0dXJlIG9mIHRoZSBjb25jZXB0dWFsIG1vZGVsLGFuZCBtZXRob2RzIHRvIGVuc3VyZSB0aGUgYWNjdXJhY3kgYW5kIHJlbGlhYmlsaXR5IG9mIHRoZSBjb25jZXB0dWFsIG1vZGVsLkJhc2VkIG9uIHRoaXMgY29uY2VwdHVhbCBtb2RlbCx0aGUgdGVjaG5pY2FsIGZyYW1ld29yayBvZiB0aGUgZGlnaXRhbCB0d2luIGZvciBzbWFydCBtYW51ZmFjdHVyaW5nIGlzIGludHJvZHVjZWQuS2V5IHRlY2hub2xvZ2llcyBzdWNoIGFzIGRpZ2l0YWwgdHdpbiBtb2RlbGluZyxzaW11bGF0aW9uLGFuZCBkYXRhIGFuYWx5c2lzIGFyZSBhbmFseXplZCxhbmQgZnV0dXJlIHRlY2hub2xvZ2ljYWwgZGV2ZWxvcG1lbnRzIGFyZSBwcm9zcGVjdGVkLiBLZXkgd29yZHPvvJppbnRlbGxpZ2VuY2UgbWFudWZhY3R1cmluZyA7IGNvbmNlcHR1YWwgbW9kZWwgOyBkaWdpdGFsIHR3aW4gZW50aXR5IFJlY2VpdmVk77yaMjAyNC0wMy0yOSAgMCDlvJXoqIAg5pm66IO95Yi26YCg5piv5paw6LSo55Sf5Lqn5Yqb5b2i5oiQ5ZKM5Y+R5bGV55qE6YeN6KaB6amx5Yqo5Yqb77yM5piv5bel5LiaNC4wLzUuMOeahOaguOW/g++8jOS7peWPiuaOqOWKqOWunueOsOmrmOaViOOAgeeBtea0u+OAgee7v+iJsuOAgeaZuuiDveeahOeUn+S6p+aWueW8j1sxXeOAguaVsOWtl+WtqueUn+aKgOacr+S9nOS4uuaZuuiDveWItumAoOeahOWFs+mUruaKgOacr+S5i+S4gO+8jOmAmui/h+aehOW7uueJqeeQhuiuvuWkh+S4juiZmuaLn+aooeWei+S5i+mXtOeahOWunuaXtuaYoOWwhOWSjOWQjOatpe+8jOS4uuWItumAoOS4mueahOaZuuiDveWMluOAgemrmOaViOWMluaPkOS+m+acieWKm+aUr+aMge+8jOaOqOWKqOWItumAoOS4mueahOi9rOWei+WNh+e6p+OAgiDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mmK/lnKjnjrDku6PkvKDmhJ/mioDmnK/jgIHnvZHnu5zmioDmnK/jgIHoh6rliqjljJbmioDmnK/jgIHmi5/kurrljJbmmbrog73mioDmnK/nrYnmioDmnK/nmoTln7rnoYDkuIrvvIzpgJrov4fmmbrog73ljJbnmoTmhJ/nn6XjgIHkurrmnLrkuqTkupLjgIHlhrPnrZblkozmiafooYzmioDmnK/vvIzlr7nkuqflk4HjgIHliLbpgKDov4fnqIvmiJbmlbTkuKrlt6XljoLov5vooYzomZrmi5/ku7/nnJ/vvIzlrp7njrDorr7orqHov4fnqIvjgIHliLbpgKDov4fnqIvjgIHnrqHnkIbov4fnqIvlkozliLbpgKDoo4XlpIfmmbrog73ljJbvvIzmj5Dpq5jliLbpgKDkvIHkuJrkuqflk4HnoJTlj5HjgIHliLbpgKDlkoznrqHnkIbmlYjnjofvvIzmmK/kv6Hmga/mioDmnK/jgIHmmbrog73mioDmnK/kuI7oo4XlpIfliLbpgKDmioDmnK/nmoTmt7Hluqbono3lkIjkuI7pm4bmiJBbMi00XeOAguS+i+Wmgu+8jOWcqOS6p+WTgeiuvuiuoeaWuemdou+8jOmAmui/h+aVsOWtl+WtqueUn+aehOW7uuS6p+WTgeiZmuaLn+aooeWei++8jOi/m+ihjOS6p+WTgeaAp+iDveS7v+ecn+WSjOS8mOWMluiuvuiuoe+8jOaPkOmrmOS6p+WTgeiuvuiuoei0qOmHj+WSjOaViOeOh++8m+WcqOeUn+S6p+WItumAoOaWuemdou+8jOWunuaXtuebkeaOp+eUn+S6p+i/h+eoi++8jOmihOa1i+iuvuWkh+aVhemanO+8jOS8mOWMlueUn+S6p+a1geeoi++8jOmZjeS9jueUn+S6p+aIkOacrO+8m+WcqOS+m+W6lOmTvueuoeeQhuaWuemdou+8jOWfuuS6juaVsOWtl+WtqueUn+WunueOsOS+m+W6lOmTvuaVsOaNrueahOmbhuaIkOWSjOWFseS6q++8jOS8mOWMlui1hOa6kOmFjee9ru+8jOaPkOmrmOS+m+W6lOmTvuWNj+WQjOaViOeOh+OAgiDmnKzmlofpppblhYjku4vnu43kuobmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnovlkozmioDmnK/moYbmnrbvvJvlhbbmrKHvvIzpmJDov7Dkuobmmbrog73liLbpgKDmlbDlrZflrarnlJ/lhbPplK7mioDmnK/vvIzmnIDlkI7vvIzlr7nmnKrmnaXmioDmnK/lj5HlsZXov5vooYzlsZXmnJvjgIIgMSDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnosgMS4xIOamguW/teaooeWei+imgeaxgiDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mpoLlv7XmqKHlnoso5Lul5LiL566A56ew4oCc5qaC5b+15qih5Z6L4oCdKeaYr+WcqOaVsOWtl+epuumXtOWunueOsOeJqeeQhuWunuS9k+WPiui/h+eoi+eahOWxnuaAp+OAgeaWueazleOAgeihjOS4uuetieeJueaAp+eahOaVsOWtl+WMluW7uuaooe+8jOaYr+WvueWunuS9k+WvueixoeWklumDqOW9ouaAgeOAgeWGhemDqOacuueQhuWSjOi/kOihjOWFs+ezu+etieeahOaVtOS9k+aKveixoeaPj+i/sOOAguamguW/teaooeWei+S4u+imgeW6lOa7oei2s+WmguS4i+imgeaxgu+8miAoMSnmjIHnu63ov63ku6Pmm7TmlrBbNV3jgIIg5Zyo55Sf5Lqn6L+H56iL5Lit77yM5ZCE57G755Sf5Lqn5pWw5o2u5a6e5pe25Y+Y5YyW77yM5qaC5b+15qih5Z6L5bqU6IO95qC55o2u54mp55CG5a6e5L2T55qE6L+Q6KGM54q25oCB5ZKM5Y+N6aaI5L+h5oGv5oyB57ut5pu05paw6L+t5Luj77yM5L+d5oyB5LiO54mp55CG5a6e5L2T55qE5ZCM5q2l44CCICgyKeiZmuWunuS6pOS6kuaYoOWwhOOAgiDmlK/mjIHomZrmi5/nqbrpl7TkuI7niannkIbnqbrpl7TnmoTkuqTkupLvvIzomZrmi5/nqbrpl7Tml6Log73lrp7ml7blj43mmKDliLbpgKDov4fnqIvniannkIbnqbrpl7TnirbmgIHvvIzmm7TlupTog73pgJrov4fmlbDmja7ono3lkIjjgIHliIbmnpDjgIHkvJjljJbjgIHmjqfliLbniannkIbnqbrpl7TnmoTov5DooYzjgIIgKDMp5aSa5rqQ5pWw5o2u6amx5Yqo44CCIOWItumAoOi/h+eoi+a2ieWPiuaVsOaNruexu+Wei+S8l+Wkmu+8jOW6lOiDveiejeWQiOWkmua6kOW8guaehOaVsOaNru+8jOWMheaLrOWunuaXtuS8oOaEn+WZqOaVsOaNruWSjOWOhuWPsuaVsOaNru+8jOS7peaPkOmrmOamguW/teaooeWei+eahOWHhuehruaAp+OAgiAoNCnoh6rpgILlupTlj4LmlbDosIPmlbTjgIIg5qaC5b+15qih5Z6L6IO95qC55o2u5LiN5ZCM5bqU55So5Zy65pmv5pSv5oyB6Ieq6YCC5bqU6LCD5pW05Y+C5pWw6K6+572u77yM5Lul5o+Q6auY5qaC5b+15qih5Z6L5Zyo5LiN5ZCM546v5aKD5LiL55qE6YCC55So5oCn44CCICg1Kei/reS7o+S8mOWMluWGs+etlls2XeOAgiDnu5PlkIjomZrmi5/ku7/nnJ/kuI7mlbDmja7liIbmnpDvvIzmlK/mjIHov63ku6PkvJjljJblhrPnrZbvvIzovoXliqnlrp7njrDnlJ/kuqfns7vnu5/nmoTmmbrog73ljJbjgIIgMS4yIOamguW/teaooeWei+aetuaehCDmnKzmlofmj5Dlh7rnlLHniannkIblrp7kvZPjgIHmnI3liqHlrp7kvZPjgIHmlbDlrZflrarnlJ/lrp7kvZPjgIHmlbDmja7lrp7kvZPlkozlkITpg6jliIbpl7TnmoTov57mjqXlrp7kvZPnu4TmiJDnmoTkupTnu7TmlbDlrZflrarnlJ/mqKHlnovjgILln7rkuo7mlofnjK5bN13vvIzpkojlr7nmmbrog73liLbpgKDpoobln5/nibnngrnvvIzmj5Dlh7rlpoLlm74x5omA56S65qaC5b+15qih5Z6L5p625p6E44CCICgxKeeJqeeQhuWunuS9kyDlm74xIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+amguW/teaooeWei+aetuaehCAg54mp55CG5a6e5L2T5piv5Z+656GA77yM5a+55pm66IO95Yi26YCg55qE5q+P5LiA5Liq5pWw5a2X5a2q55Sf5bqU55So5Zy65pmv77yM5Y+v5Lul6L+b5LiA5q2l5YiS5YiG5Y2V5YWD57qn44CB57O757uf57qn5ZKM5aSN5p2C57O757uf57qn562J5LiN5ZCM57KS5bqm5bGC5qyhWzhd44CC5L6L5aaC77yM5pW05Liq5pm66IO95bel5Y6C55qE5pWw5a2X5a2q55Sf77yM6L2m6Ze055Sf5Lqn57q/5Y+v5L2c5Li65Y2V5YWD57qn77yM55Sf5Lqn57q/5omA5Zyo6L2m6Ze05Y+v5L2c5Li657O757uf57qn77yM6ICM5pW05Liq5bel5Y6C5YiZ5L2c5Li65aSN5p2C57O757uf57qn44CC5aaC5p6c5Lul6L2m6Ze05Li65pWw5a2X5a2q55Sf5a+56LGh77yM5YiZ5Y+v5bCG5p6E5oiQ55Sf5Lqn57q/55qE6K6+5aSH5L2c5Li65Y2V5YWD57qn77yM5a6e546w5Y2V5Liq6K6+5aSH55qE55uR5rWL44CB5pWF6Zqc6aKE5rWL5ZKM6aKE6K2m5Lul5Y+K57u05oqkWzld77yb55Sf5Lqn57q/5L2c5Li657O757uf57qn77yM5a+555Sf5Lqn6L+b6KGM6LCD5bqm44CB6L+b5bqm5o6n5Yi25ZKM5Lqn5ZOB6LSo6YeP5o6n5Yi277yb5pW05Liq6L2m6Ze05YiZ5L2c5Li65aSN5p2C57O757uf57qn77yM5a+55pW05Liq6L2m6Ze055Sf5Lqn6L+Q6KGM6L+b6KGM55uR5rWL5LiO6LCD5bqm5LyY5YyW44CCICgyKeaVsOWtl+WtqueUn+WunuS9kyDmlbDlrZflrarnlJ/lrp7kvZPmoLnmja7niannkIblrp7kvZPnmoTkuI3lkIzlsYLmrKHlkoznibnngrnvvIzku47kuI3lkIzml7bpl7Tlkoznqbrpl7TlsLrluqblr7nniannkIblrp7kvZPov5vooYzmj4/ov7DvvIzljIXmi6zlh6DkvZXmqKHlnovjgIHniannkIbmqKHlnovjgIHop4TliJnmqKHlnovlkozooYzkuLrmqKHlnovnrYlbMTBd77yM5pSv5oyB5Lqn5ZOB5pWw5a2X5a2q55Sf44CB55Sf5Lqn5pWw5a2X5a2q55Sf44CB6K6+5aSH5pWw5a2X5a2q55Sf77yM6LSv56m/5pW05Liq5pm66IO95Yi26YCg5Lqn5ZOB55Sf5ZG95ZGo5pyf566h55CG5Lu35YC86ZO+44CCIOWHoOS9leaooeWei+aPj+i/sOeJqeeQhuWunuS9k+WmguW3peWOguOAgei9pumXtOOAgeeUn+S6p+e6v+OAgeiuvuWkh+aIluiuvuWkh+WFg+WZqOS7tuetieeahOW9oueKtuOAgeWwuuWvuOOAgeS9jee9ruOAgeepuumXtOW4g+WxgOaIluijhemFjeWFs+ezu+etie+8jOS4gOiIrOWFt+acieaXtuepuuS4gOiHtOaAp++8jOW4uOeUqOi9r+S7tuW3peWFt+mAmui/h+S4iee7tOW7uuaooeaWueW8j+WIm+W7uuOAgiDniannkIbmqKHlnovlnKjlh6DkvZXmqKHlnovln7rnoYDkuIrlop7liqDniannkIblrp7kvZPnmoTniannkIblsZ7mgKfjgIHnuqbmnZ/lkoznibnlvoHnrYnvvIzlpoLnu5PmnoTjgIHmtYHkvZPjgIHnlLXlnLrjgIHno4HlnLrlu7rmqKHku7/nnJ/nrYnvvIzlj6/ku47lvq7op4Llkozlro/op4LnrYnkuI3lkIzlsLrluqbpgJrov4fkuIDkupvlt6Xlhbfova/ku7bov5vooYzmlbDlrabov5HkvLzmqKHmi5/lkozliLvnlLvjgIIg6KGM5Li65qih5Z6L5o+P6L+w5LiN5ZCM5bGC5qyh44CB5LiN5ZCM5pe256m65LiL54mp55CG5a6e5L2T5Zyo5YaF5aSW6YOo5LiN5ZCM5L2c55So5Zug57Sg5ZKM5L2c55So5py65Yi25LiL55qE6KGM5Li65ZKM6KGM5Li65ryU5YyW77yM5piv5LiA5Liq5aSN5p2C55qE6L+H56iL77yM5Y+v6YeH55So6ams5bCU5Y+v5aSr6ZO+44CB5pyJ6ZmQ54q25oCB5py6562J6L+b6KGM5o+P6L+w44CCIOinhOWImeaooeWei+aPj+i/sOmihuWfn+OAgeWHhuWImeOAgeefpeivhuWSjOe7j+mqjO+8jOS+i+WmguiuvuWkh+aTjeS9nOinhOeoi+OAgeiuvuWkh+iwg+S8mOWPguaVsOOAgeeUn+S6p+e6v+i/kOihjOeuoeeQhuinhOWImeOAgeeJqeaWmeaKleaUvuagh+WHhuetie+8jOmaj+edgOinhOWImeeahOWinuWKoOWSjOa8lOWMlu+8jOS9v+aVsOWtl+WtqueUn+WunuS9k+mAkOa4kOW9ouaIkOWunuaXtuWIpOaWreOAgeiHquS8mOWMluOAgeiHquagoeato+WSjOmihOa1i+etieiDveWKm++8jOWvueeJqeeQhuWunuS9k+i/m+ihjOaOp+WItuWSjOi/kOihjOaMh+WvvOOAguinhOWImeaooeWei+WPr+S7pemAmui/h+aVtOWQiOeOsOacieefpeivhuW6k++8jOW5tue7k+WQiOacuuWZqOWtpuS5oOaKgOacr+adpeWPkeaOmOaWsOeahOinhOWIme+8jOS7juiAjOaehOW7uuWSjOWujOWWhOOAgumAmui/h+iZmuaLn+eOsOWunihWUinlkozlop7lvLrnjrDlrp4oQVIp562J5oqA5pyv5a+55Yeg5L2V5qih5Z6L44CB54mp55CG5qih5Z6L44CB6KGM5Li65qih5Z6L5ZKM6KeE5YiZ5qih5Z6L562J6L+b6KGM6ZuG5oiQ44CB6J6N5ZCI5ZKM5LiA6Ie05oCn5qCh5qC477yM5bm25LiO54mp55CG5a6e5L2T6Jma5a6e5Y+g5Yqg5Y+K6J6N5ZCI5pi+56S677yM5o+Q6auY5pWw5a2X5a2q55Sf5L2T55qE55yf5a6e5oCn44CB5rKJ5rW45oCn5ZKM5Lqk5LqS5oCn44CCICgzKeacjeWKoeWunuS9kyDmnI3liqHlrp7kvZPlr7nmlbDmja7jgIHmqKHlnovjgIHnrpfms5XnrYnov5vooYzmnI3liqHljJblsIHoo4XvvIzkuLrmlbDlrZflrarnlJ/lrp7njrDmj5DkvpvmnI3liqHmlK/mjIHjgILmoLnmja7mnI3liqHnsbvlnovvvIzlj6/liIbkuLrmlbDmja7mnI3liqHjgIHku7/nnJ/mnI3liqHjgIHkuJrliqHmnI3liqHnrYnjgILmlbDmja7mnI3liqHljIXmi6zmlbDmja7ph4fpm4bjgIHlrZjlgqjjgIHmuIXmtJfjgIHlhbPogZTjgIHono3lkIjjgIHmjJbmjpjjgIHmjqXlhaXjgIHorr/pl67nrYnlkITnsbvmlbDmja7nrqHnkIbjgIHlpITnkIbkuI7orr/pl67mnI3liqHvvJvku7/nnJ/mnI3liqHljIXmi6zlu7rmqKHku7/nnJ/jgIHku7/nnJ/mqKHlnovnu4Too4XjgIHku7/nnJ/mqKHlnovono3lkIjjgIHku7/nnJ/mqKHlnovnrqHnkIbnrYnjgILkuJrliqHmnI3liqHlr7nmlbDlrZflrarnlJ/lupTnlKjov4fnqIvkuK3pnaLlkJHkuI3lkIzliLbpgKDpoobln5/jgIHkuI3lkIzlsYLmrKHnlKjmiLfmu6HotrPlkITnsbvliLbpgKDkuJrliqHpnIDmsYLnmoTmnI3liqHov5vooYzlsIHoo4XvvIzku6XlkITnsbvova/ku7blvaLlvI/lrZjlnKjvvIzljIXmi6zpnaLlkJHnjrDlnLrmk43kvZzkurrlkZjnmoTmnI3liqHjgIHpnaLlkJHnrqHnkIblhrPnrZbkurrlkZjnmoTmnI3liqHnrYnvvIzmjInpnIDkvb/nlKjjgIHngbXmtLvnu4TlkIjvvIzlrp7njrDlkITnsbvliLbpgKDkuJrliqHog73lipvjgIIgKDQp5pWw5o2u5a6e5L2TIOaVsOaNruWunuS9k+mbhuaIkOiejeWQiOS/oeaBr+aVsOaNruOAgeeJqeeQhuaVsOaNru+8jOa7oei2s+S/oeaBr+epuumXtOS4jueJqeeQhuepuumXtOeahOS4gOiHtOaAp+mcgOaxgu+8jOS4uuaZuuiDveWItumAoOaVsOWtl+WtqueUn+aPkOS+m+WFqOimgee0oOOAgeWFqOa1geeoi+WSjOWFqOS4muWKoeeahOaVsOaNruaUr+aMgeOAgiDniannkIbmlbDmja7ljIXmi6zlj43mmKDlkITnsbvniannkIblrp7kvZPop4TmoLzjgIHlip/og73jgIHmgKfog73jgIHlhbPns7vnrYnnmoTpnZnmgIHlsZ7mgKfmlbDmja7kuI7lj43mmKDniannkIblrp7kvZPov5DooYznirblhrXjgIHmgKfog73jgIHnjq/looPlj4LmlbDnrYnnmoTliqjmgIHov4fnqIvmlbDmja7vvIzov5nkupvmlbDmja7pgJrov4fpooTorr7nmoTmoIflh4blgLzlkozlkITnsbvkvKDmhJ/lmajph4fpm4bnmoTmlbDmja7ov5vooYzorr7lrprlkozojrflj5bjgIIg5L+h5oGv5pWw5o2u5YyF5ous5pWw5a2X5a2q55Sf5qih5Z6L5pWw5o2u44CB55+l6K+G5pWw5o2u44CB55Sf5Lqn5Yi26YCg5Lia5Yqh5pWw5o2u562J44CC5qih5Z6L5pWw5o2u5Y+N5pig5pWw5a2X5a2q55Sf5a6e5L2T5Yeg5L2V5qih5Z6L44CB54mp55CG5qih5Z6L44CB6KGM5Li65qih5Z6L5ZKM6KeE5YiZ5qih5Z6L562J5a2q55Sf5qih5Z6L5pWw77yb55+l6K+G5pWw5o2u5YyF5ous5ZCE57G75Yi26YCg5Lia5Yqh5qCH5YeG5LiO6KeE5YiZ44CB55Sf5Lqn55+l6K+G44CB5LiT5a6255+l6K+G562J77yb55Sf5Lqn5Yi26YCg5Lia5Yqh5pWw5o2u5YyF5ous55Sf5Lqn566h55CG44CB5Lqn5ZOB566h55CG44CB54mp5paZ566h55CG44CB6LCD5bqm566h55CG44CB5LyB5Lia566h55CG562J5pWw5o2u44CCICg1Kei/nuaOpeWunuS9kyDov57mjqXlrp7kvZPlrp7njrDniannkIblrp7kvZPjgIHmlbDlrZflrarnlJ/lrp7kvZPjgIHmnI3liqHlrp7kvZPku6Xlj4rmlbDmja7lrp7kvZPkuYvpl7TnmoTmma7pgILljJblt6XkuJrkupLogZTvvIzmlK/mjIHomZrlrp7lrp7ml7bkupLogZTkuI7ono3lkIhbMTFd44CC6YCa6L+H5ZCE56eN5Lyg5oSf5Zmo44CB5bWM5YWl5byP57O757uf562J5a+554mp55CG5a6e5L2T5pWw5o2u6L+b6KGM5a6e5pe26YeH6ZuG5bm25Lyg6L6T5Yiw5a2q55Sf5pWw5o2u5a6e5L2T77yM57uP6L+H5a2q55Sf5pWw5o2u5a6e5L2T5aSE55CG5ZCO55qE6YCa6L+H55u45bqU55qE5Y2P6K6u5Lyg6L6T5Y+N6aaI57uZ54mp55CG5a6e5L2T77yM5a6e546w54mp55CG5a6e5L2T55qE6L+Q6KGM5LyY5YyW44CC54mp55CG5a6e5L2T5a6e5pe25pWw5o2u6YCa6L+H5Y2P6K6u5Lyg6L6T5Yiw5pWw5a2X5a2q55Sf5a6e5L2T77yM6L+b6KGM5pWw5a2X5a2q55Sf5qih5Z6L55qE6Jma5a6e5LiA6Ie05oCn5qCh5q2j77yM5pWw5a2X5a2q55Sf5a6e5L2T5Lu/55yf5YiG5p6Q562J5pWw5o2u6L2s5YyW5Li65o6n5Yi25oyH5Luk5Lyg6L6T5Yiw54mp55CG5a6e5L2T77yM5a+554mp55CG5a6e5L2T6L+b6KGM5a6e5pe25Lqk5LqS5o6n5Yi244CC54mp55CG5a6e5L2T44CB5pWw5a2X5a2q55Sf5a6e5L2T5ZKM5pWw5o2u5a6e5L2T5LiO5pyN5Yqh5a6e5L2T5a6e5pe26L+e5o6l77yM6L+b6KGM5pWw5o2u44CB5qih5Z6L44CB5Lia5Yqh5pyN5Yqh55qE5a6e5pe26K6/6Zeu5LiO5LyY5YyW44CCIDEuMyDmpoLlv7XmqKHlnovlh4bnoa7mgKflkozlj6/pnaDmgKcg5qaC5b+15qih5Z6L55qE5YeG56Gu5oCn5ZKM5Y+v6Z2g5oCn5piv5pWw5a2X5a2q55Sf5oqA5pyv5bqU55So5LqO5pm66IO95Yi26YCg55qE5YWz6ZSu44CC5Y+v6YCa6L+H5aaC5LiL5omL5q615L+d6Zqc5qaC5b+15qih5Z6L55qE5YeG56Gu5oCn5ZKM5Y+v6Z2g5oCn44CCICgxKeaVsOaNruiejeWQiOOAgiDpm4bmiJDkuI3lkIzmnaXmupDmlbDmja7vvIzpgJrov4fml7bnqbrlr7npvZDjgIHmoLzlvI/lr7npvZDnrYnmlbDmja7ono3lkIjnmoTmlrnlvI/vvIzmj5Dpq5jmlbDmja7nmoTlh4bnoa7mgKflkozkuIDoh7TmgKfjgIIgKDIp57K+56Gu5bu65qih44CCIOmHh+eUqOeyvuehruaVsOWtpuaooeWei+WSjOeul+azle+8jOaooeaLn+eJqeeQhuWunuS9k+eahOihjOS4uu+8jOS9v+amguW/teaooeWei+iDveWkn+WHhuehruWPjeaYoOeJqeeQhuWunuS9k+eahOeJueaAp+OAgiAoMynmpoLlv7XmqKHlnovmoKHlh4bjgIIg5a+55pWw5a2X5a2q55Sf5a6e5L2T5ZKM54mp55CG5a6e5L2T6L+b6KGM5pWw5o2u5ZCM5q2l5oCn5ZKM5LiA6Ie05oCn5qOA5p+l77yM56Gu5L+d5pWw5o2u5ZCM5q2l5ZKM5LiA6Ie044CCICg0KemXreeOr+WPjemmiOOAgiDmr5TovoPmlbDlrZflrarnlJ/mqKHlnovnmoTovpPlh7rkuI7niannkIblrp7kvZPnmoTlrp7pmYXmgKfog73lt67lvILvvIzlkJHmqKHlnovkvp3mja7lt67lvILmg4XlhrXov5vooYzmqKHlnovosIPmlbTvvIzlu7rnq4vmqKHlnovkuI7niannkIblrp7kvZPnmoTpl63njq/lj43ppojmnLrliLbjgIIgKDUp5qaC5b+15qih5Z6L5oyB57ut6Ieq5a2m5Lmg5ZKM5LyY5YyW44CCIOmAmui/h+S6uuW3peaZuuiDveetieaKgOacr++8jOi/m+ihjOamguW/teaooeWei+aMgee7reiHquiwg+aVtOWSjOiHquS8mOWMlu+8jOaMgee7reaPkOmrmOaooeWei+mihOa1i+WSjOWIhuaekOiDveWKm+OAgiAoNinmpoLlv7XmqKHlnovmtYvor5Xlkozpqozor4HjgIIg6L+b6KGM5LiN5ZCM5Zy65pmv5LiL5qaC5b+15qih5Z6L5YeG56Gu5oCn5ZKM5Y+v6Z2g5oCn5rWL6K+V5ZKM6aqM6K+B44CCICg3KeWuieWFqOaAp+S/neaKpOOAgiDnoa7kv53mpoLlv7XmqKHlnovmlbDmja7lronlhajvvIzpmLLmraLmlbDmja7ms4TpnLLlkoznr6HmlLnjgIIgMiDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mioDmnK/mnrbmnoQg5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5oqA5pyv5p625p6E5o+P6L+w5LqG5pm66IO95Yi26YCg5pWw5a2X5a2q55Sf5qaC5b+15qih5Z6L5LiN5ZCM5a6e5L2T5LmL6Ze05Lqk5LqS55qE5oqA5pyv5a6e546w57uT5p6E44CCIOWmguWbvjLmiYDnpLrvvIzniannkIblsYLmtonlj4rliLbpgKDpoobln5/kurrlkZjjgIHorr7lpIfjgIHnianmlpnjgIHlt6XoibrjgIHnjq/looPnrYnnlJ/kuqfopoHntKDjgILkuI3lkIzliLbpgKDpoobln5/nmoTniannkIblrp7kvZPmnInmiYDkuI3lkIzjgILkvovlpoLvvIzpkqLpk4HlhrbngrzliqDlt6XkvIHkuJrvvIzniannkIblrp7kvZPmnInlhrbngrzpq5jngonjgIHnn7/nn7PjgIHpk7jku7bjgIHlhrbngrzmjqfliLbns7vnu5/nrYnvvJvoiLnoiLbliLbpgKDkvIHkuJrvvIzniannkIblrp7kvZPmnInoiLnoiLbljp/lnovjgIHoiLnoiLbpg6jku7bjgIHlvoXkv67oiLnoiLbnrYnjgIIg5Zu+MiDmmbrog73liLbpgKDmlbDlrZflrarnlJ/mioDmnK/mnrbmnoQgIOaEn+efpeS8oOi+k+WxguaPkOS+m+eJqeeQhuWxguS4jeWQjOWxguasoeS5i+mXtOeahOS6kumAmuOAgiDmlbDmja7lsYLljIXmi6zniannkIblrp7kvZPnmoTlkITnsbvpnZnmgIHlkozliqjmgIHmlbDlrZfljJbkv6Hmga/jgIIg5qih5Z6L5bGC5ZKM5pyN5Yqh5bGC5Li65bqU55So5bGC5o+Q5L6b5ZCE57G75pyN5Yqh77yM5YyF5ous5qih5Z6L5pyN5Yqh44CB5pWw5o2u5pyN5Yqh44CB5Lu/55yf5pyN5Yqh5ZKM5Lia5Yqh5pyN5Yqh562J44CCIOW6lOeUqOWxguWIqeeUqOS4iui/sOWQhOWxguiDveWKm++8jOeBtea0u+aehOW7uuaZuuiDveWItumAoOS4jeWQjOmihuWfn+OAgeS4jeWQjOeykuW6pueahOaVsOWtl+WtqueUn+WunuS9k++8jOS+i+WmgueUn+S6p+i/h+eoi+aVsOWtl+WtqueUn+OAgeiuvuWkh+aVsOWtl+WtqueUn+OAgeW3peiJuuS8mOWMluaVsOWtl+WtqueUn+etie+8jOimhuebluS6p+WTgeeUn+WRveWRqOacn+euoeeQhuWFqOS7t+WAvOmTvuWSjOWItumAoOWFqOa1geeoi+mTvuOAgiAzIOaZuuiDveWItumAoOaVsOWtl+WtqueUn+WFs+mUruaKgOacryAzLjEg5pWw5a2X5a2q55Sf5bu65qih5oqA5pyvIOW7uuaooeagueaNruiiq+S7v+ecn+WvueixoeaIluezu+e7n+eahOaehOaIkOimgee0oOOAgei/kOWKqOinhOW+i+OAgee6puadn+adoeS7tuWSjOeJqeeQhueJueaAp+etie+8jOW7uueri+W9ouW8j+WMlueahOS4jueJqeeQhuWunuS9k+ebuOWvueW6lOeahOiZmuaLn+aVsOWtl+WtqueUn+WunuS9k+aooeWei++8jOWPjeaYoOeJqeeQhuWunuS9k+eahOWkluinguOAgeWGhemDqOeahOeJueaAp+OAgee7k+aehOWSjOihjOS4uuOAguWFt+S9k+WcqOaZuuiDveWItumAoOmihuWfn++8jOW7uuaooeaKgOacr+aYr+mSiOWvueWItumAoOS4reeahOi9veS9kyjlpoLmlbDmjqfmnLrluoop44CB5Yi26YCg6L+H56iLKOWmguWKoOW3pei/h+eoi+S4reeahOeDreOAgeWKm+etiSnlkozooqvliqDlt6Xlr7nosaEo5aaC6KKr5Yi26YCg55qE6aOe5py6Keetie+8jOW6lOeUqOacuuaisOOAgeeJqeeQhuOAgeWKm+WtpuOAgeiuoeeul+acuuWSjOaVsOWtpuetieefpeivhu+8jOWvueW7uuaooeWvueixoeeahOS4gOenjei/keS8vOihqOi+vuOAgiDmlbDlrZflrarnlJ/lrp7kvZPmqKHlnovlnKjojIPlm7TkuIrvvIzmnInlhajlsYDnu5PmnoTmqKHlnoso5L6L5aaC5bel5Y6C5YWo55Sf5Lqn57q/KeOAgeWxgOmDqOe7k+aehOaooeWeiyjlpoLmn5DkuIDovabpl7TnlJ/kuqfoo4Xnva4p44CB5Lqn5ZOB57uT5p6E5qih5Z6L5ZKM55Sf5Lqn6K6h5YiS6LCD5bqm5qih5Z6L562J77yb5Zyo5pa55rOV5LiK77yM5pyJ5pWw5a2m6Kej5p6Q5qih5Z6LKOWmgueKtuaAgeepuumXtOaooeWeiynjgIHlm77npLrigJTop6PlkIjmqKHlnoso5aaCUGV0cmnnvZHmqKHlnosp562J77yb5Zyo5Yqf6IO95LiK77yM5pyJ57uT5p6E5o+P6L+w5qih5Z6L44CB57O757uf5YiG5p6Q5qih5Z6L44CB57O757uf6K6+6K6h5a6e5pa95qih5Z6L5ZKM57O757uf6L+Q6KGM566h55CG5qih5Z6L562J44CCIOW7uuaooeeahOS4u+imgei/h+eoi+WMheaLrOWItumAoOaVsOaNrumHh+mbhuS4jumbhuaIkOOAgeaooeWei+WIm+W7uuOAgeWunuaXtuaVsOaNruWQjOatpeOAgemXreeOry4uLgooY29udGVudCB0cnVuY2F0ZWQpCnVzZXI6CkkgYW0gYSBncmFkdWF0ZSBzdHVkZW50IGluIHRoZSBmaWVsZCBvZiBjcnlwdG9ncmFwaHkgYW5kIG5lZWQgdG8gd3JpdGUgYSBwYXBlciBvbiB0aGUgYXBwbGljYXRpb24gb2YgcXVhbnR1bSBjb21wdXRpbmcgaW4gY3J5cHRvZ3JhcGh5LiBQbGVhc2UgcHJvdmlkZSB0aGUgY29udGVudCBmb3IgdGhlIHJlbGF0ZWQgd29yayBzZWN0aW9uIG9mIHRoZSBwYXBlciwgd2l0aCBhIGZvY3VzIG9uOgotIFRocmVhdCBhbmFseXNpcyBvZiBTaG9yJ3MgYWxnb3JpdGhtIG9uIGV4aXN0aW5nIGNyeXB0b2dyYXBoaWMgc3lzdGVtcwotIExhdGVzdCByZXNlYXJjaCBwcm9ncmVzcyBvbiBtYWluc3RyZWFtIHBvc3QtcXVhbnR1bSBjcnlwdG9ncmFwaHkgdGVjaG5pcXVlcyAobGF0dGljZS1iYXNlZCBjcnlwdG9ncmFwaHksIG11bHRpdmFyaWF0ZSBjcnlwdG9ncmFwaHksIGhhc2gtYmFzZWQgc2lnbmF0dXJlcywgZXRjLikKLSBEZXRhaWxlZCBkaXNjdXNzaW9uIG9mIHRoZSBsYXRlc3QgcHJvZ3Jlc3MgaW4gdGhlIE5JU1QgcG9zdC1xdWFudHVtIGNyeXB0b2dyYXBoeSBzdGFuZGFyZGl6YXRpb24gcHJvamVjdCwgZXNwZWNpYWxseSB0aGUgdGVjaG5pY2FsIGRldGFpbHMgb2YgdGhlIGZpcnN0IGJhdGNoIG9mIHNlbGVjdGVkIGFsZ29yaXRobXMgaW4gMjAyMgotIFNwZWNpZmljIGV4YW1wbGVzIG9mIHRoZSBjb21tZXJjaWFsaXphdGlvbiBvZiBwb3N0LXF1YW50dW0gY3J5cHRvZ3JhcGh5IGJ5IG1ham9yIHRlY2hub2xvZ3kgY29tcGFuaWVzIChHb29nbGUsIElCTSwgZXRjLikKdXNlcjoKVGhpcyBpcyBhIHJlcG9ydCBvbiB0aGUgdGVuc2lsZSBleHBlcmltZW50IG9mIG1hdGVyaWFsIG1lY2hhbmljcywgKipNYXRlcmlhbCoqCgoxLiBTYW1wbGUgSW5mb3JtYXRpb24KCiAgICBNYXRlcmlhbCBOYW1lOiBMb3cgQ2FyYm9uIFN0ZWVsICAKICAgIFNhbXBsZSBTaGFwZTogUm91bmQgQmFyICAKICAgIFNhbXBsZSBEaWFtZXRlcjogMTAgbW0gIAogICAgU2FtcGxlIExlbmd0aDogMTAwIG1tICAKICAgIFNhbXBsZSBJRDogQS0wMSAgCgoyLiBUZXN0aW5nIEVxdWlwbWVudAoKICAgIFRlc3RpbmcgTWFjaGluZSBOYW1lOiBJTlNUUk9OIDU1NjkgVGVuc2lsZSBUZXN0aW5nIE1hY2hpbmUgIAogICAgICAgIE1heGltdW0gTG9hZDogMTAwIGtOICAKICAgICAgICBUZW5zaWxlIFNwZWVkOiAyIG1tL21pbiAgCiAgICAgICAgRGlzcGxhY2VtZW50IFJlc29sdXRpb246IDAuMDAxIG1tICAKICAgICAgICBTdHJhaW4gTWVhc3VyZW1lbnQgU3lzdGVtOiBIaWdoLVByZWNpc2lvbiBEaXNwbGFjZW1lbnQgU2Vuc29yICAKICAgICAgICBDb250cm9sIFN5c3RlbTogRGlnaXRhbCBDb250cm9sIFN5c3RlbSwgc3VwcG9ydHMgcmVhbC10aW1lIGRpc3BsYXkgb2YgZm9yY2UtZGlzcGxhY2VtZW50IGN1cnZlIGFuZCBkYXRhIHJlY29yZGluZyAgCgozLiBFeHBlcmltZW50IFByb2Nlc3MKCiAgICBTYW1wbGUgUHJlcGFyYXRpb246ICAKICAgICAgICBJbnNwZWN0IHRoZSBzYW1wbGUgc3VyZmFjZSBmb3IgY3JhY2tzIG9yIGRlZmVjdHMsIGVuc3VyaW5nIHRoZSBzdXJmYWNlIGlzIHNtb290aC4gIAogICAgICAgIE1lYXN1cmUgdGhlIGluaXRpYWwgZGlhbWV0ZXIgb2YgdGhlIHNhbXBsZSB0byBiZSAxMC4wIG1tIGFuZCB0aGUgbGVuZ3RoIHRvIGJlIDEwMCBtbSB1c2luZyBjYWxpcGVycy4gIAoKICAgIFRlc3RpbmcgUHJvY2VzczogIAogICAgICAgIEluc3RhbGwgdGhlIHNhbXBsZSBpbiB0aGUgdGVzdGluZyBtYWNoaW5lIGdyaXBzLCBlbnN1cmluZyBzeW1tZXRyaWMgbG9hZGluZy4gIAogICAgICAgIFN0YXJ0IHRoZSB0ZW5zaWxlIHRlc3RpbmcgbWFjaGluZSwgc2V0IHRoZSB0ZW5zaWxlIHNwZWVkIHRvIDIgbW0vbWluLCBhbmQgYmVnaW4gbG9hZGluZy4gIAoKNC4gRXhwZXJpbWVudGFsIFJhdyBEYXRhCgogICAgU3RyZXNzIChNUGEpICAgU3RyYWluIChtbS9tbSkgICBMb2FkIChrTikgICBEZWZvcm1hdGlvbiAobW0pICAKICAgIDAgICAgICAgICAgICAgMCAgICAgICAgICAgICAgICAwICAgICAgICAgICAwICAKICAgIDUwICAgICAgICAgICAgMC4wMDIgICAgICAgICAgICAwLjUgICAgICAgICAwLjIgIAogICAgMTAwICAgICAgICAgICAwLjAwNCAgICAgICAgICAgIDEuMCAgICAgICAgIDAuNCAgCiAgICAxNTAgICAgICAgICAgIDAuMDA2ICAgICAgICAgICAgMS41ICAgICAgICAgMC42ICAKICAgIDIwMCAgICAgICAgICAgMC4wMDggICAgICAgICAgICAyLjAgICAgICAgICAwLjggIAogICAgMjUwICAgICAgICAgICAwLjAxMCAgICAgICAgICAgIDIuNSAgICAgICAgIDEuMCAgCiAgICAzMDAgICAgICAgICAgIDAuMDEyICAgICAgICAgICAgMy4wICAgICAgICAgMS4yICAKICAgIDM1MCAgICAgICAgICAgMC4wMTUgICAgICAgICAgICAzLjUgICAgICAgICAxLjQgIAogICAgNDAwICAgICAgICAgICAwLjAxOCAgICAgICAgICAgIDQuMCAgICAgICAgIDEuNiAgCiAgICA0NTAgICAgICAgICAgIDAuMDIwICAgICAgICAgICAgNC41ICAgICAgICAgMS44ICAKICAgIDUwMCAgICAgICAgICAgMC4wMjIgICAgICAgICAgICA1LjAgICAgICAgICAyLjAgIAogICAgNTEwICAgICAgICAgICAwLjAyMyAgICAgICAgICAgIDUuMSAgICAgICAgIDIuMSAgCgo1LiBUaGVvcmV0aWNhbCBDYWxjdWxhdGlvbgoKICAgIFlpZWxkIFN0cmVuZ3RoICjPg195KSAgCiAgICBUaGUgeWllbGQgc3RyZW5ndGggb2YgdGhlIHN0cmVzcy1zdHJhaW4gY3VydmUgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZSBleHBlcmltZW50YWwgZGF0YSwgYXNzdW1pbmcgdGhlIHlpZWxkIHBvaW50IGFzIHRoZSBwb2ludCBiZWZvcmUgdGhlIHN0cmVzcyByZWFjaGVzIGl0cyBtYXhpbXVtIHZhbHVlLiAgCiAgICAgICAgTWF4aW11bSBTdHJlc3Mgz4NfbWF4ID0gNTEwIE1QYSAgCiAgICAgICAgWWllbGQgU3RyZW5ndGggz4NfeSA9IDI1MCBNUGEgKFRoZW9yZXRpY2FsIFZhbHVlKSAgCgogICAgVGVuc2lsZSBTdHJlbmd0aCAoz4NfYikgIAogICAgVGhlIHRlbnNpbGUgc3RyZW5ndGggaXMgdGhlIHN0cmVzcyBhdCB0aGUgbWF4aW11bSBsb2FkIHBvaW50IGR1cmluZyBzdHJldGNoaW5nLiAgCiAgICAgICAgVGhlb3JldGljYWwgVmFsdWUgz4NfYiA9IDUxMCBNUGEgIAoKICAgIEVsb25nYXRpb24gQWZ0ZXIgRnJhY3R1cmUgKEEpICAKICAgIEFjY29yZGluZyB0byB0aGUgZm9ybXVsYTogIAogICAgQSA9IChsX2YgLSBsXzApIC8gbF8wIMOXIDEwMCUgIAogICAgV2hlcmUsIGxfZiBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBzYW1wbGUgYWZ0ZXIgZnJhY3R1cmUsIGFuZCBsXzAgaXMgdGhlIG9yaWdpbmFsIGxlbmd0aC4gIAogICAgQXNzdW1lIHRoZSBsZW5ndGggYWZ0ZXIgZnJhY3R1cmUgaXMgbF9mID0gMTAyIG1tLCAgCiAgICBBID0gKDEwMiAtIDEwMCkgLyAxMDAgw5cgMTAwJSA9IDIlICAKICAgICAgICBFbG9uZ2F0aW9uIEFmdGVyIEZyYWN0dXJlOiAyJSAgCgogICAgRWxhc3RpYyBNb2R1bHVzIChFKSAgCiAgICBUaGUgZWxhc3RpYyBtb2R1bHVzIGNhbiBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIHNsb3BlIG9mIHRoZSBpbml0aWFsIGxpbmVhciBzZWN0aW9uIG9mIHRoZSBzdHJlc3Mtc3RyYWluIGN1cnZlOiAgCiAgICBFID0gz4MgLyDOtSAgCiAgICBUYWtpbmcgc3RyZXNzIGFzIDEwMCBNUGEgYW5kIHN0cmFpbiBhcyAwLjAwNDogIAogICAgRSA9IDEwMCBNUGEgLyAwLjAwNCA9IDI1LDAwMCBNUGEgPSAyNSBHUGEgIAogICAgICAgIEVsYXN0aWMgTW9kdWx1cyBFID0gMjUgR1BhIChUaGVvcmV0aWNhbCBWYWx1ZSkgIAoKNi4gQW5hbHlzaXMgb2YgRXhwZXJpbWVudGFsIFJlc3VsdHMKCiAgICBZaWVsZCBTdHJlbmd0aCBvZiB0aGUgTWF0ZXJpYWw6IFRoZSBleHBlcmltZW50YWwgcmVzdWx0IHNob3dzIHRoYXQgdGhlIHlpZWxkIHN0cmVuZ3RoIG9mIHRoZSBzYW1wbGUgaXMgMjUwIE1QYSwgd2hpY2ggaXMgY2xvc2UgdG8gdGhlIHRoZW9yZXRpY2FsIHZhbHVlIGFuZCBtZWV0cyBleHBlY3RhdGlvbnMuICAKICAgIFRlbnNpbGUgU3RyZW5ndGg6IFRoZSBtYXhpbXVtIHN0cmVzcyByZWFjaGVzIDUxMCBNUGEsIG11Y2ggaGlnaGVyIHRoYW4gdGhlIHlpZWxkIHN0cmVuZ3RoLCBpbmRpY2F0aW5nIHN0cm9uZyB0ZW5zaWxlIGNhcGFiaWxpdHkgb2YgdGhlIG1hdGVyaWFsLiAgCiAgICBFbG9uZ2F0aW9uIEFmdGVyIEZyYWN0dXJlOiBUaGUgMiUgZWxvbmdhdGlvbiBhZnRlciBmcmFjdHVyZSBzaG93cyB0aGF0IHRoZSBtYXRlcmlhbCBoYXMgYSBjZXJ0YWluIGRlZ3JlZSBvZiBkdWN0aWxpdHksIG1ha2luZyBpdCBzdWl0YWJsZSBmb3IgYXBwbGljYXRpb25zIHRoYXQgcmVxdWlyZSBzdWJzdGFudGlhbCBwbGFzdGljIGRlZm9ybWF0aW9uLiAgCiAgICBFbGFzdGljIE1vZHVsdXM6IFRoZSBlbGFzdGljIG1vZHVsdXMgaXMgMjUgR1BhLCBpbmRpY2F0aW5nIGhpZ2ggcmlnaWRpdHksIGNvbnNpc3RlbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWNzIG9mIGxvdyBjYXJib24gc3RlZWwuICAKCjcuIENvbmNsdXNpb24KCiAgICBUaGlzIHRlbnNpbGUgdGVzdCB2ZXJpZmllZCB0aGUgeWllbGQgc3RyZW5ndGgsIHRlbnNpbGUgc3RyZW5ndGgsIGFuZCBkdWN0aWxpdHkgb2YgbG93IGNhcmJvbiBzdGVlbC4gQ29tcGFyaW5nIHdpdGggdGhlIHRoZW9yZXRpY2FsIHZhbHVlcywgdGhlIGV4cGVyaW1lbnRhbCByZXN1bHRzIGFyZSBpbiBsaW5lIHdpdGggdGhlIGJhc2ljIHByaW5jaXBsZXMgb2YgbWF0ZXJpYWwgbWVjaGFuaWNzLCBwcm92aW5nIHRoYXQgdGhpcyBtYXRlcmlhbCBoYXMgZ29vZCBtZWNoYW5pY2FsIHByb3BlcnRpZXMgYW5kIGlzIHN1aXRhYmxlIGZvciB1c2UgaW4gc3RydWN0dXJhbCBjb21wb25lbnRzIHRoYXQgYmVhciBsYXJnZSBsb2Fkcy4uIFBsZWFzZSB3cml0ZSBhIGRpc2N1c3Npb24gc2VjdGlvbiBvZiBhcHByb3hpbWF0ZWx5IDMwMDAgd29yZHMgYmFzZWQgb24gdGhpcyByZXBvcnQuIEZyb20gdGhlIHRocmVlIGRpbWVuc2lvbnMgb2YgdGhlb3JldGljYWwgZm91bmRhdGlvbiwgZXhwZXJpbWVudGFsIHByb2Nlc3MsIGFuZCBkYXRhIGFuYWx5c2lzLCBlbGFib3JhdGUgb24gdGhlIHJlYXNvbnMgZm9yIHRoZSBkZXZpYXRpb24gYmV0d2VlbiB0aGUgZXhwZXJpbWVudGFsIHJlc3VsdHMgYW5kIHRoZSB0aGVvcmV0aWNhbCB2YWx1ZXMuIEZvciBlYWNoIGRldmlhdGlvbiByZWFzb24sIHByb3Bvc2Ugc3BlY2lmaWMgYW5kIGZlYXNpYmxlIGltcHJvdmVtZW50IG1lYXN1cmVzLCBpbmNsdWRpbmcgaW5zdHJ1bWVudCBzZWxlY3Rpb24sIG9wdGltaXphdGlvbiBvZiBleHBlcmltZW50YWwgc3RlcHMsIGRhdGEgcHJvY2Vzc2luZyBtZXRob2RzLCBldGMuCnVzZXI6CuWFt+S9k+S7quWZqOWei+WPt+eahOaKgOacr+aJi+WGjOaIluivtOaYjuS5pu+8mgrml6Xnq4tTVTgwMTDlnovlj7dTRU0KMSDlvIDmnLoK5byA5b2i6LKM55S16ISR77ya5omT5byA5b6q546v5rC04oCU4oCUZGlzcGxheeaMiemSruWIsOKblO+4j+KAlOKAlCDkvJroh6rliqjlvIDmnLrigJTigJTngrnlh7vnlKjmiLcgc3U4MDEwIOayoeacieWvhueggSDvvIjlpoLmnpzlnKjlvIDmnLrkuYvlkI7kuI3lsI/lv4Pmiorova/ku7blhbPmjonkuobngrnlh7vnlLXohJHlt6bkuIvop5LlvIDlp4vvvIzngrnlh7twYy1zZW3lsLHlj6/ku6XmiZPlvIDova/ku7bvvIkKCuW8gOiDveiwseeUteiEke+8mueCueWHu+iDveiwseeUteiEkeS4u+acuuiDjOWQjueahOm7keiJsuaMiemSruWIsOKblO+4j+KAlOKAlOaJk+W8gOS4u+acuuKAlOKAlOaJk+W8gOaYvuekuuWxj+W8gOWFs+KAlOKAlOaJk+W8gOi9r+S7tu+8iCDnlKjmiLdTVTgwMTAtRURTIOayoeacieWvhuegge+8iUFadGVjCgrmr4/mrKHlvIDmnLrlkI7pnIDopoHmo4Dmn6XvvJoKCumrmOWAjeS4i+afpeeci+aYr+WQpuaKiuejgeaAp+aooeW8j+WFs+S6hu+8mueCueWHu3NldHVw4oCU4oCU5Yu+6YCJ5LiK56OB5oCn5qih5byPCuajgOafpeeUteWOi+aYr+S4jeaYrzNrdu+8mueCueWHu+i9r+S7tuW3puS4iuinkum7keiJsuacieeUteWOi+eahOmDqOWIhgpmbGFzaGluZ+S4gOS4i++8mueCueWHu+W3puS4iuinkum7keiJsuahhuKAlOKAlOeCueWHu2ZsYXNoaW5n4oCU4oCU54K55Ye7ZXhlY3V0ZeKAlOKAlOWcqOS4pOWPsOeUteiEkeS4remXtOeahOacrOWtkOS4iuiusOW9leeUtea1geaVsOWAvOWSjOW9k+aXpeW8gOWni+aXtumXtArorrDlvZVJUOaVsOWAvO+8mueCueWHu+WPs+S4i+inkm1haW50ZeKAlOKAlOWcqOS4iumdoueahOacrOWtkOS4iuiusOW9leS4ieS4qklQ5pWw5YC8CuatpOaXtuWPr+S7pemhuuS+v+aJk+W8gOWwj+inhumikeeahOaMiemSrgrvvIjms6jvvJozLDTkuKTpobnmr4/lpKk154K55Lmf6ZyA6KaB5pON5L2c5LiA5qyh77yJCgoyIOWItuagtwrnoa7lrprnlKjmiLfmtYvnmoTmmK/mlq3pnaLov5jmmK/ooajpnaLvvJrlubPpnaLlj7Ag5p+x6ZW/IO+8m+aWremdouWPsCDmn7Hnn63jgIIKCuagt+WTgeWPsOacieS4pOS4qu+8jOS4gOS4quWkp+eahO+8jOS4gOS4quWwj+eahO+8jOiuqeeUqOaIt+iHquW3semAieaLqemcgOimgeeahOOAggoK5YWz5LqO5a+855S16IO277ya57qi6Imy5a+855S16IO26YCC5ZCI57KJ5pyr6I2v5ZOB55So77yM5Lu35qC86LS177yb6JOd6Imy5a+855S16IO26YCC5ZCI6Zmk57KJ5pyr5aSW5YW25LuW5qC35ZOB77yM5Lu35qC85L6/5a6c77yM6IO955yL5Yiw5a2U44CCCgrmoLflk4Hlj7DkuIrotLTlpb3lr7znlLXog7blkI7vvIzlho3otLTlpb3nlKjmiLfmiYDmnInnmoTlvoXmtYvmoLflk4HjgIIKCjMg6ZWA6YeRCuW8gOacuu+8miBzd2l0Y2ggb27igJTigJQgRkZCIG9u4oCU4oCUcG93ZXIgb27im5TvuI/igJTigJRCTGxva++8jCBvcGVuIO+8iOavj+WkqeS4gOadpeWPr+S7peWFiOe7memVgOmHkeS7quaJk+W8gO+8iQoK5YWz5py677ya54K55Ye7U3RhcnTmir3nnJ/nqbrigJTigJTmir3liLBFMCBQYeKAlOKAlEJMbG9r6L2s5Yqo5YiwY2xvc2XigJTigJTngrnlh7vmmL7npLrlsY9zdG9w4oCU4oCUcG93ZXJvZmbigJTigJQgRkZCIG9mZuKAlOKAlHN3aXRjaCBvZmYKCuWFs+S6juWWt+mHkQoK5Za355qE5YW25a6e5piv6YmRCgrllrfph5Eg6Jm954S26K6+572u55qE5pivNDBz44CBNjBz77yM5L2G5piv5a6e6ZmF5LiK6KaBOC455YiG6ZKf77yM5Zug5Li66KaBYWly77yMZXZhY++8mwoK5Za36YeR5rOo5oSP54K577ya5LiA5Liq5piv5pWw5a2X6KaB5a+55YeG77yb5LqM5piv6ZO+5p2h5LiN6KaB5Y2h5Yiw6YeM6Z2i5Y6777ybCgrllrfph5HlrozmiJDnmoTmoIflv5fmmK/plYDph5Hku6rnmoTpnIfliqjlo7DlgZzmraLjgIIKCjQg56Gs5Lu26L+b5qC3CuWPr+S7peWcqOagt+WTgeWPsOS4iueUqOiusOWPt+eslOagh+iusOS4gOS4i+esrOS4gOS4quagt+WTgeeahOS9jee9ruOAggoK5oun57Sn5Y6f54mH77yM6K6p5Y6f54mH5ZKM6ZSB5a6a5Zmo5oiQ5Li65pW05L2T4oCU4oCU5oqK5qC35ZOB5Y+w5pS+5Yiw5bmz6Z2i5Y+w5oiW6ICF5pat6Z2i5Y+w6ZSB5a6a5Zmo5LiK4oCU4oCU6aG65pe26ZKI5oun57Sn5qC35ZOB5Y+w4oCU4oCU5pyJ5Lik5Liq5bCP5a2U55qE5pyd5ZCR6Ieq5bex4oCU4oCU5bCG5Lit6Ze055qE5Y6f54mH6YCG5pe26ZKI5pa55ZCR56iN5b6u5oun5p2+5LiA54K554K577yI6aG65YWz6YCG5byA77yJ4oCU4oCUIOaXi+i9rOagt+WTgeWPsO+8jOiwg+aVtOmUgeWumuWZqOieuuavjeeahOmrmOW6pu+8iOmhuuaXtumSiOmZjeS9ju+8jOmAhuaXtumSiOWNh+mrmO+8ie+8jOS9v+W+l+agt+WTgeWPsOeahOmHj+mrmOavlOa1i+mrmOS7queojeW+ruS9jjEtMm1t77yI5rOo77ya5aaC5p6c5piv56OB5oCn5qC35ZOB77yM6ZyA6KaB55u45beuMy00bW3vvInigJTigJTlkIzml7bkuZ/pnIDopoHnoa7kv53nlKjmiLfnmoTnrKzkuIDkuKrmoLflk4HlnKjlt6bkuIrop5LmlrnlkJHigJTigJTpobrml7bpkojmi6fntKfkuK3pl7Tljp/niYfigJTigJTnlKjmtJfogLPnkIPlkLnkuIDlkLnmoLflk4HooajpnaLnmoTohI/kuJzopb/vvIzotoXlm5vlkajlkLnvvIzkuI3opoHkupLnm7jmsaHmn5PmoLflk4HvvIzmnJ3lnLDpnaLlkLnvvIzkuI3opoHlr7nnnYDmoYzpnaLlkLnmsaHmn5PmoYzpnaLjgIIKCui1t+Wni+eKtuaAge+8mmNsb3NlIGV2ZWMKCueCueWHu2FpcuWcqOS6pOaNouS7k+mHjOazqOWFpeepuuawlOKAlOKAlOaJi+WKqOaKiuS6pOaNouS7k+aLieWHuuadpeKAlOKAlOaUvuS4iuWItuWkh+WlveeahOagt+WTgeWPsOWQjOaXtmxvY2vkuIDkuIvigJTigJTmiorkuqTmjaLku5PpgIHov5vljrvigJTigJTngrnlh7tldmFj5oq955yf56m64oCU4oCU54K55Ye7b3BlbuaJk+W8gOiIsemXqOKAlOKAlOaOqOi/m+WOu+agt+WTgeadhuWIsOacgOmHjOmdouebtOWIsHhj6JOd54Gv5Lqu6LW34oCU4oCUdW5sb2Nr5qC35ZOB5ouJ5Ye65qC35ZOB5p2G5Yiw5pyA6L+c56uv5ZCs5Yiw56Cw55qE5LiA5aOw5LiN5pS+5omL4oCU4oCU54K55Ye7Y2xvc2XlhbPpl63ku5Ppl6jigJTigJTmnb7lvIDmi4nnnYDmoLflk4HmnYbnmoTmiYsKCjUg6L2v5Lu26LCD5pW0CuWmguaenOW+hea1i+agt+WTgeaYr+ejgeaAp+agt+WTge+8jOi9r+S7tnNldHVw56OB5oCn5qih5byP5Yu+6YCJ5LiK77yM5ZCM5LiA5Liq5Lq655qE5qC35ZOB55So5a6M5LqG6K6w5b6X6KaB5Y+W5raI5Yu+6YCJ77yB77yBCgrlpoLmnpzmmK/mgJXmsKfljJbnmoTmoLflk4Eg5LiA5a6a6KaB5b+r6YCf5pON5L2c77yB77yBCgrngrnlh7vova/ku7blt6bkuIrop5JvbuaJk+W8gOeUteWOi++8iOatpOaXtumcgOimgeeojeW+ruetieS4gOS8muWEv++8ieKAlOKAlOiwg+aVtOWIsOS9juWAjeaooeW8j0xN4oCU4oCU5om+5Yiw56ys5LiA5Liq5qC35ZOB6LW35aeL5L2N572uKOWkp+agt+WTgeWPsDrmnIDlt6bovrnvvIgtMTcsMO+8iSDlt6bkuIrop5LvvIgtMTcsNe+8ie+8m+Wwj+agt+WTgeWPsO+8iCAtMTIsMO+8iSnigJTigJTliIfmjaLliLDpq5jlgI3kuIvigJTigJTosIPliLAKCjEwa+W3puWPs++8iOW3peS9nOi3neemu+S4ujjlt6blj7PvvInigJTigJTovrnmlL7lpKfovrnnspfosIPnhLblkI7lho3nu4bosIPliLDlsL3lj6/og73muIXmpZrigJTigJTlho1CQWxpZ27igJTigJTikaAg77iPeHnosIPnlLXlrZDmnZ/lsYXkuK3igJTigJTikaF4eeiwg+WFiemYkeWxheS4re+8jOWIsOS4jeW3puWPs+aZg++8jOmHjOWklumch+WKqOS4uuatouKAlOKAlOKRouKRoyDvuI/vuI/osIPnmoTmmK/lg4/mlaPvvIzosIPliLDkuI3lt6blj7PmmYPvvIzlj5jmiJDph4zlpJbpnIfliqjkuLrmraLigJTigJTngrnlh7tyZWQx5bCP56qX5Y+j77yMZmluZee7huiwg++8jOWGjSB4eeiwg+aVtOWIsOeUu+mdoua4heaZsO+8jOWGjWZpbmXnu4bosIPigJTigJTkuqTnu5nnlKjmiLfmtYvor5UKCuWFs+S6juaXi+i9rOWbvuWDj++8jOWLvumAiXJvdGF0aW9uIOWNs+WPr+i/m+ihjOiwg+aVtOOAggoKNiDog73osLEK5rOo77ya5omT6IO96LCx5bCP6KeG6aKR5b+F6aG76KaB5YWz5o6J77yBCgrovpPlhaXovpPlh7rorqHmlbDnjofpg73opoEgMjAwMOS7peS4iu+8jOWFtuWunjE1MDDkuZ/ooYzvvIzlpoLmnpzlj6rmnInlh6Dnmb7lsLHmnInpl67popjkuobvvIzlmarpn7PkvJrlvojlpJrvvIEKCuWmguaenOeUqOaIt+mcgOimgeaJk+iDveiwse+8jOiuqeeUqOaIt+iHquW3seeUqOeslOiusOW9leS4i+aDs+imgeaJk+iDveiwseeahOS9jee9ru+8mwoK5bem6L6555S16ISR77ya54K55Ye76L2v5Lu25bem5LiK6KeS6buR6Imy6YOo5YiG77yM55S15Y6L6LCD5pW05YiwMTUuMGtW4oCU4oCU6LCD5pW05bel5L2c6Led56a777ya6IO96LCx6ZyA6KaB55qE5bel5L2c6Led56a75Li6MTVtbe+8jOWmguaenOatpOaXtuW9ouiyjOWbvuaYvuekuuW3peS9nOi3neemu+S4unjvvIzlj7Pkvqd65LiL5pa55pi+56S65bel5L2c6Led56a75Li6ee+8jOWImemcgOimgeaJi+WKqOWcqOi9r+S7tuWPs+S+p3rkuIvmlrnovpPlhaXlt6XkvZzot53nprvvvIgxNS14K3nvvInigJTigJTlnKh444CBeeeahOS9jee9ruaJi+WKqOi+k+WFpeeUqOaIt+iusOW9leeahOW+heaJk+iDveiwseeahOS9jee9ru+8jOehruWumuKAlOKAlOiwg+aVtOWlveWIsOWQiOmAgueahOaUvuWkp+WAjeaVsO+8mwoK5Y+z6L6555S16ISR77ya5omT5byA6IO96LCx6L2v5Lu277yM5aaC5p6c5pyJ5LiK5LiA5Liq5Lq66YGX55WZ55qE5pWw5o2u77yM54K55Ye75Y+W5raI77yM5LiN6KaB54K54oCc5piv4oCd5oiW4oCc5ZCm4oCd77yM5Lya6KaG55uW5o6J5LiK5LiA5Liq5Lq655qE5pWw5o2u4oCU4oCU6aG555uu5Y+m5a2Y5Li677yM5om+5Yiw55So5oi355qE5Liq5Lq65paH5Lu25aS54oCU4oCU5L6d5qyh54K55Ye74pGg6Z2i5YiG5biD5Zu+4pGh5omr5o+P5Zu+5YOPLeW8gOWni+KRoumHh+mbhuWIhuW4g+WbvuaVsOaNri3lvIDlp4vikaPmnoTlu7rliIbluIPlm77mlbDmja7ikaTnoa7orqTlhYPntKDikaXnvJbovpHliJfigJTigJTpnaLnp6/orqHmlbDliLDovr4yNXcr5pe25bCx5Y+v5Lul5Yu+6YCJ5Y+z5L6n5Yy6MeeahOaWueahhuWPr+S7peWBnOS6huKAlOKAlOa3u+WKoOaIluiAheWIoOmZpOWFg+e0oO+8mueCueWHu+KAnOiuoeeul+aIkOWIhuKAnSDvvIzngrnlh7vigJznvJbovpHliJcg4oCd77yM5Y+q5Yu+6YCJd3Ql44CBd3Qlc2lnbWHjgIHljp/lrZDnmb7liIbmr5Tov5nkuInkuKrlsLHooYzigJTigJTpnaLliIbluIPlm77mqKHlvI/kuIvvvIzlj7PplK7miqXlkYrvvIzov73liqDigJTigJRwb2ludElE5qih5byP5LiL77yM5Y+z6ZSu5oql5ZGK77yM54K55Ye76L+95Yqg4oCU4oCU5L+d5a2Y5aW95paH5Lu24oCU4oCU5om+5LiL5LiA5Liq5L2N572u5omT6IO96LCx5oiW6ICF57uT5p2f4oCU4oCU5ZyodXBsb2FkIGRhdGHmlofku7blpLnkuIvvvIzmlrDlu7rnlKjmiLfpooTnuqbnvJblj7flkb3lkI3nmoTmlofku7blpLnvvIzlpoIyNDI0MjLvvIjmraTmlofku7blpLnph4zpnaLlj6rog73mlL7ljZXkuKrmlofku7bmiJbogIXljovnvKnljIXvvInvvIzmiormlofku7bmlL7liLDor6Xmlofku7blpLnkuIvjgILms6jvvJrmiZPlrozog73osLHvvIzog73osLHliIfmjaLliLDlvaLosozvvIzkuIDlrprmiornlLXljovosIPlm57liLAza1YhCjcg5o2i5qC35ZOBCueCueWHu+i9r+S7tueahGhvbWXov5vooYzlpI3kvY3igJTigJTngrnlh7tvZmblhbPpl63nlLXljovigJTigJTngrnlh7tvcGVu5omT5byA5Lqk5o2i5LuT6Zeo4oCU4oCU5o6o6L+b5qC35ZOB5p2G5Yiw5pyA6YeM6Z2i55u05YiweGPnrYnkuq7otbfigJTigJRsb2Nr6ZSB5L2P5qC35ZOB5Y+w4oCU4oCU5ouJ5Ye65qC35ZOB5p2G5Yiw5pyA5aSW6Z2i5LiN6KaB5p2+5omL77yM5ouJ5Yiw5L2N5Lya5ZCs5Yiw5aOw6Z+z4oCU4oCU54K55Ye7Y2xvc2XlhbPpl63kuqTmjaLku5Ppl6jvvIzpl6jlhbPkuIrkuoblho3mnb7miYvigJTigJTngrnlh7thaXLorqnkuqTmjaLku5Pov5vnqbrmsJTvvIzlrozmiJDlkI5haXLnga/kuI3pl6rvvIzlj5jmiJDpu4ToibLvvIzlubbkuJTmnInlo7Dpn7Pmj5DnpLrigJTigJTmi4nlvIDkuqTmjaLku5PigJTigJTlt6bmiYvmibbkvY/moLflk4Hlj7DvvIzlj7PmiYt1bmxvY2vmoLflk4HmnYbvvIzlt6bmiYvlj5bkuIvmoLflk4Hlj7DvvIzmiorkuqTmjaLku5Pmjqjov5vljrvigJTigJTmiorkuIvkuIDkuKrkurrnmoTmoLflk4Hlj7DmlL7liLDplIHlrprlmajkuIrjgIIKCjgg5LiK5Lyg5pWw5o2uCuWFs+aOieW9ouiyjOaIluiAheiDveiwse+8iOWFs1NFTei9r+S7tu+8mmZpbGUtZXhpdC1vayDvvInnmoTova/ku7bigJTigJTlnKjkuLvmnLrkuIrmj5LlhaXnvZHljaHigJTigJTnrYnlvoV3aWZp6L+e5o6l5YiwMi40R0h64oCU4oCU5Y+M5Ye76buE6Imy55qEdXBsb2Fk6L2v5Lu24oCU4oCU54K55Ye75LiK5Lyg77yI5LiN6ZyA6KaB5YWo6YCJ77yJ4oCU4oCU562J5b6F5LiK5Lyg5a6M5q+V4oCU4oCU5YWz5o6JdXBsb2Fk6L2v5Lu244CCCgo5IOWFs+acugrlhbPog73osLHnlLXohJHvvJrlhbPmmL7npLrlsY/igJTigJTlhbPkuLvmnLrlkI7pnaLnmoTpu5HoibLmjInpkq7liLAw55qE5L2N572u77ybCuWFs+W9ouiyjOeUteiEke+8muWFs+aYvuekuuWxj+KAlOKAlOWFs2Rpc3BsYXnigJTigJTlhbPlvqrnjq/msLTjgIIKMTAg5YW25LuW77yI5YWz5LqO5Y+w5byP77yJCuagt+WTgeWPsO+8mueqhOeahOS4gOS+p+acneWQkeiHquW3se+8jOmcgOimgeeUqOeZveiJsuadv+mHj+mrmO+8jOeUteiEkei+k+WFpeaVsOaNruavlOWunumZheagt+WTgeWPsOmrmOW6pumrmDFtbe+8mwoK6L2v5Lu277ya4pGg5Yig6Zmk5o6J5LiK5LiA5Liq5Lq655qE5Zu+54mH77yM54K5cmVtb3Zl77yM5LiN6KaB54K5ZGVsZXRl77yM5Zy65Y+R5bCE5Y+v5Lul54K5ZGVsZXRl77yb4pGh5YWz5LqO5peL6L2s5Zu+5YOP77yM5Y+w5byP5Yu+6YCJb27vvIzlnLrlj5HlsITli77pgIlyb3RhdGlvbu+8mwoK572R5Y2h77ya5Y+w5byP55qE5b2i6LKM5ZKM5Zy65Y+R5bCE55qE5b2i6LKM44CB6IO96LCx5YWx55So5LiA5Liq572R5Y2h77yM5Y+w5byP55qE6IO96LCx5Y2V54us5LiA5Liq572R5Y2h77ybCgrog73osLHvvJrlj7DlvI/pnIDopoHlnKjog73osLHnlLXohJHlj7PkuIvop5LmiYvliqjovpPlhaXmlL7lpKflgI3njofjgIHlt6XkvZzot53nprvjgIHnlLXljovvvIzlnLrlj5HlsITkuI3pnIDopoHjgIIK5biD6bKB5YWLRDggWFJECjEu5byA5py65YeG5aSH77ya6aaW5YWI5o+S5YWl55S15rqQ57q/77yM5o+S5LiK6ZKl5YyZ5bm25ouo5YiwT07kvY3nva7vvIznrYnlvoXlsY/luZXkuq7otbflubblh7rnjrDoj5zljZXnlYzpnaLjgILlkIzml7bvvIzor7fnoa7kv51V55uY77yI55So5LqO55Sf5oiQ5bGA5Z+f572R77yJ5bey5o+S5YWl5LiU5LiN6ZyA6KaB5ouU5LiL77yM54S25ZCO6L+e5o6l5qC35ZOB5oyv6I2h5Zmo44CCCjIu5qC35ZOB5aSE55CG77ya5LuO5qC35ZOB5LiK5Yiu5Y+W6YCC6YeP57KJ5pyr77yI57qmNTBtZ++8ieW5tui/h+etm+OAguS9v+eUqOWIruWLuuWwhueyieacq+mAgeWFpeagt+WTgeaxoO+8jOS5i+WQjuerluebtOaMr+iNoeWZqOiuqeeyieacq+iHqueEtuiQveWFpemAmumBk+WGheOAggozLumch+iNoemAgeagt++8muijheWlveaMr+iNoeWZqOWQju+8jOWcqOS4u+iPnOWNleeVjOmdoumAieaLqeKAnFNIQUtF4oCd5byA5aeL6ZyH6I2h77yM5bCG5qC35ZOB6YCB5YWl5qC35ZOB5rGg5YaF44CC5qC55o2u6ZyA6KaB6YCJ5oup5oyv6I2h5Yqb5bqm77yM5b2T5qC35ZOB5Z+65pys5a6M5YWo6L+b5YWl5qC35ZOB5rGg5ZCO77yM5YGc5q2i6ZyH6I2h44CCCjQu6L2v5Lu25a6J6KOF5LiO5pWw5o2u5YiG5p6Q77yaWFJE5pWw5o2u5YiG5p6Q6L2v5Lu25ZCN5Li64oCcWFBvd2RlcuKAne+8jOWuieijheeoi+W6j+S9jeS6juS7quWZqOiHquW4pueahFXnm5jkuK3jgILlsIblronoo4XnqIvluo/mi7fotJ3oh7Poh6rlt7HnmoTorr7lpIflubbov5vooYzlronoo4XvvIzlronoo4XlrozmiJDlkI7pnIDopoHmv4DmtLvova/ku7bjgILkuYvlkI7lronoo4XmlbDmja7lupPvvIzlubblsIblkITnsbvmlbDmja7lupPmi7fotJ3oh7Pova/ku7blronoo4Xnm67lvZXnmoTmjIflrprmlofku7blpLnjgILmiZPlvIDova/ku7blkI7vvIzpgInmi6nliJrliJrlronoo4XnmoTmlbDmja7lupPvvIzlvIDlp4vliIbmnpDmlbDmja7jgIIKNS7lhbPmnLrkuI7muIXnkIbvvJrkvb/nlKjmjK/ojaHlmajpnIfojaHlip/og73lsIbmoLflk4HnsonmnKvmjK/lh7rvvIzlv4XopoHml7bnlKjljovnvKnmsJTmnqrmiJbonrrkuJ3liIDmuIXnkIbmoLflk4HmsaDjgILlnKjku6rlmajoj5zljZXmoI/kuK3pgInmi6nigJxzaHV0IGRvd27igJ3lhbPpl63mnLrlmajvvIznhLblkI7mi6fliqjpkqXljJnoh7NPRkbkvY3nva7vvIzmnIDlkI7mi5Tlh7rmjK/ojaHlmajnur/lj4rnlLXmupDnur/jgIIK6K+356Gu5L+d5oyJ54Wn5LiK6L+w5q2l6aqk5q2j56Gu5pON5L2c5Luq5Zmo77yM5Lul6I635b6X5YeG56Gu55qE5YiG5p6Q57uT5p6c44CCCgoK57G75Ly85Luq5Zmo55qE5qCH5YeG5pON5L2c6KeE56iLKFNPUCnmqKHmnb/vvJoK5qCH5YeGCgpBLuagueaNrueOr+Wig+eahOa0geWHgOeoi+W6pu+8jOWPr+Wumuacn++8iOS4gOiIrDLvvZ4z5Liq5pyI77yJ5bCG57KX5ruk5biD5ouG5LiL5riF5rSX5LqI5Lul5pu05o2i77ybCgpCLuWumuacn++8iOS4gOiIrOS4uuS4gOWRqO+8ieWvuei2heWHgOW3peS9nOWPsOeOr+Wig+i/m+ihjOeBreiPjO+8jOWQjOaXtu+8jOe7j+W4uOeUqOe6seW4g+ayvuS4iumFkueyvuaIluS4memFruacieacuua6tuWJguWwhue0q+WkluadgOiPjOeBr+WkluihqOmdouaPqeaTpuW5suWHgO+8jOS/neaMgeihqOmdoua4hea0ge+8jOWQpuWImeS8muW9seWTjeadgOiPjOaViOaenO+8mwoKQy7lvZPliqDlpKfpo47mnLrnlLXljovkuI3og73kvb/mk43kvZzpo47pgJ/ovr7liLAwLjMybS9z5pe277yM5b+F6aG75pu05o2i6auY5pWI56m65rCU6L+H5ruk5Zmo77ybCgpELuabtOaNoumrmOaViOepuuawlOi/h+a7pOWZqOaXtuWPr+aJk+W8gOmhtueblu+8jOabtOaNouaXtuW6lOazqOaEj+i/h+a7pOWZqOS4iueahOeureWktOagh+W/l++8jOeureWktOaMh+WQkeWNs+S4uuWxguawlOa1gea1geWQke+8mwoKRS7mm7TmjaLpq5jmlYjnqbrmsJTov4fmu6TmsJTlkI7vvIzlupTnlKjlsJjln4PnspLlrZDorqHmlbDlmajmo4Dmn6Xlm5vlkajovrnmoYblr4blsIHmmK/lkKboia/lpb3vvIzosIPoioLpo47mnLrnlLXljovvvIzkvb/mk43kvZzlubPlnYfpo47pgJ/kv53mjIHlnKgwLjMy772eMC40OG0vc+iMg+WbtOWGhe+8jOWGjeacieeUqFkwOS005Z6L5bCY5Z+D57KS5a2Q6K6h5pWw5Zmo5qOA5p+l5rSB5YeA5bqm44CCCgrmk43kvZzop4TnqIvvvJoKCkEu5L2/55So5bel5L2c5Y+w5pe277yM5bqU5o+Q5YmNMeWwj+aXtuW8gOacuu+8jOWQjOaXtuW8gOWQr+e0q+WklueBreiPjOeBr++8jOWkhOeQhuaTjeS9nOWMuuWGheihqOmdouenr+e0r+eahOW+rueUn+eJqe+8jOS4ieWNgeWIhumSn+WQjuWFs+mXreadgOiPjOeBr++8mwoKQi7mlrDlronoo4XnmoTmiJbplb/mnJ/mnKrkvb/nlKjnmoTlt6XkvZzlj7DvvIzkvb/nlKjliY3lv4Xpobvlr7nlt6XkvZzlj7Dlkozlkajlm7Tnjq/looPlhYjnlKjotoXlh4DnnJ/nqbrlkLjlsJjlmajmiJbnlKjkuI3kuqfnlJ/nuqTnu7TnmoTlt6Xlhbfov5vooYzmuIXmtIHlt6XkvZzlj7DvvIzlho3ph4fnlKjoja/niannga3oj4zms5XlkozntKvlpJbnur/nga3oj4zms5Xov5vooYznga3oj4zlpITnkIbvvJsKCkMu5pON5L2c5Yy65YaF5LiN5YWB6K645a2Y5pS+5LiN5b+F6KaB55qE54mp5ZOB77yM5Lul5L+d5oyB5pON5L2c5Yy655qE5rSB5YeA5rCU5rWB5rWB5Z6L5LiN5Y+X5bmy5omw77ybCgpELuaTjeS9nOWMuuWGheW6lOWwvemHj+mBv+WFjeS9nOaYjuaYvuaJsOS5seawlOa1gea1geWei+eahOWKqOS9nO+8m0Uu5pON5L2c5Yy65YaF55qE5L2/55So5rip5bqm5LiN5b6X5aSn5LqONjDihIPjgIIKCgp95a6e6aqM5a6k5bey5pyJ55qE5pON5L2c6KeE6IyD5paH5qGj77yaCgoK5LiA44CB5a6e6aqM5a6k5a6I5YiZCgox44CB6L+b5YWl5a6e6aqM5a6k5bel5L2c5pe277yM5b+F6aG756m/5bel5L2c5pyN77yM56a75byA5a6e6aqM5a6k5pe25bqU6ISx5LiL44CC5bel5L2c5pyN5bqU57uP5bi45L+d5oyB5pW05rSB77yM56aB5q2i56m/5bel5L2c5pyN6L+b5YWl5YWs5YWx5Zy65omA44CC5Zyo6L+b6KGM5Lu75L2V5pyJ5Y+v6IO956Kw5Lyk44CB5Yi65r+A5oiW54On5Lyk55y8552b55qE5bel5L2c5pe277yM5b+F6aG75oi06Ziy5oqk55y86ZWc44CC57uP5bi45o6l6Kem5rWT6YW444CB5rWT56Kx55qE5bel5L2c5Lq65ZGY77yM5bqU5oi06IO25biD5omL5aWX5Y+K5bel5L2c5bi977yM6K+V5qC35Yqg5bel5pON5L2c5pe25LiN5b6X5oi05omL5aWX44CCCgoy44CB56aB5q2i5Zyo5a6e6aqM5a6k5YaF5ZC454Of5Y+K5ZCD5Lic6KW/44CC5LiN5YeG5L2/55So6K+V6aqM5Zmo55q/5L2c6Iy25p2v5oiW6aSQ5YW377yM5LiN5b6X55So5Zi05be05ZOB5bCd5ZGz6YGT55qE5pa55rOV5p2l6Ym05Yir5pyq55+l54mp44CCCgoz44CB5bel5L2c5a6M5q+V5ZCO56a75byA5a6e6aqM5a6k5pe25bqU55So6IKl55qC5rSX5omL44CCCgo044CB5a6e6aqM5a6k5YGc5q2i5L6b55S144CB5L6b5rC05pe25bqU5bCG5rC05rqQ44CB55S15rqQ5byA5YWz5YWo6YOo5YWz5LiK77yM5Lul6Ziy5oGi5aSN5L6b55S144CB5L6b5rC05pe255Sx5LqO5byA5YWz5pyq5YWz6ICM5Y+R55Sf5LqL5pWF44CC56a75byA5a6e6aqM5a6k5pe25bqU5qOA5p+l6Zeo44CB56qX44CB5rC044CB55S144CB5rCU5piv5ZCm5a6J5YWo5Y+K5YWz6Zet44CCCgo144CB5a6e6aqM5a6k5YaF55qE5q+P55O26K+V5YmC5b+F6aG76LS05pyJ5piO5pi+55qE5LiO6K+V5YmC55u456ym55qE5qCH562+44CB5bm25qCH5piO6K+V5YmC5ZCN56ew44CB5rWT5bqm5Y+K6YWN5Yi25pel5pyf5oiW5qCH5a6a5pel5pyf44CCCgo244CB6auY5rip54mp5L2T77yI5L6L5aaC5Yia55Sx6auY5rip54KJ5Lit5Y+W5Ye655qE5Z2p5Z+a5ZKM55O36Iif6KaB5pS+5Zyo5bmy5YeA55qE6ICQ54Gr55+z5qOJ5p2/77yJ5LiK5oiW55O355uY5Lit6ZmE6L+R5LiN5b6X5pyJ5piT54eD54mp44CC6ZyA56ew6YeP55qE5Z2p5Z+a5b6F56iN5Ya35ZCO5pa55Y+v56e76Iez5bmy54el5Zmo5Lit5Ya35Y2044CCCgo344CB5pON5L2c5pe25Lya5Lqn55Sf5pyJ5a6z5rCU5L2T44CB54Of6Zu+5oiW57KJ5bCY5pe277yM5b+F6aG75Zyo6Imv5aW955qE6YCa6aOO5p+c5YaF6L+b6KGM44CCCgo444CB5a6e6aqM5a6k55qE5Luq5Zmo5Zyo5pyq5o6M5o+h5a6J5YWo5pON5L2c6KeE56iL5YmN5LiN5b6X6ZqP5oSP5Yqo55So44CCCgrkuozjgIHnlLXlmajjgIHmmJPnh4PjgIHmmJPniIYKCu+8iOS4gO+8ieeUteWZqOWuieWFqOaTjeS9nOinhOeoiwoKMeOAgeWunumqjOWupOWGheS4jeW+l+acieijuOmcsueahOeUtee6v+OAgemXuOWIgOW8gOWFs+W6lOWujOWFqOWQiOS4iuaIluaWreW8gO+8jOS7pemYsuatouaOpeinpuS4jeWlveS6p+eUn+eBq+iKsei/m+iAjOW8lei1t+aYk+eHg+eJqeeahOeIhueCuO+8jOaLlOS4i+aPkuWktOaXtuW6lOeUqOaJi+aNj+S9j+aPkuWktOWGjeaLlO+8jOS4jeW+l+aJr+aLieeUtee6v+OAggoKMuOAgeWQhOenjeeUteWZqOiuvuWkh+WPiueUtee6v+W6lOWni+e7iOS/neaMgeW5sueHpe+8jOS4jeW+l+a1uOa5v++8jOS7pemYsuefrei3r+W8lei1t+eBq+eBvuaIlueDp+Wdj+eUteWZqOiuvuWkh+OAggoKM+OAgSDlkITnsbvnlLXlmajorr7lpIflj5HnlJ/lvILluLjmiJbmlYXpmpzml7bvvIzlupTlj4rml7bmlq3nlLXvvIznlLHkuJPkuJrkurrlkZjmo4Dkv67jgIIKCjTjgIEg5L+d6Zmp5Lid54aU5pat5pe277yM5bqU5p+l5riF5Y6f5Zug77yM5LiN5b6X5Lu75oSP5aKe5Yqg5oiW5Yqg57KX5L+d6Zmp5Lid77yM5pu05LiN5b6X5Lul6ZOc5Lid5Luj5pu/44CCCgrvvIjkuozvvInmsKfmsJTjgIHmtrLljJbmsJTnk7bnmoTlronlhajkvb/nlKjop4TnqIsKCjHjgIHmsKfmsJTjgIHmtrLljJbmsJTmmK/lvLrng4jnmoTliqnnh4PmsJTkvZPvvIzmsKfmsJTjgIHmtrLljJbmsJTnk7bkuIDlrpropoHkuKXpmLLkuI7msrnohILmjqXop6bjgILlvIDlkK/msKfmsJTjgIHmtrLljJbmsJTnk7bnmoTmibPmiYvkuI3lvpfmsr7mnInmsrnohILjgIIKCjLjgIHmkKzov5DmsKfmsJTjgIHmtrLljJbmsJTnk7bml7bvvIzlupTlhYjoo4XkuIrlronlhajluL3vvIzkuI3lj6/kvb/msJTkvZPlj5fliLDpnIfliqjmiJbmkp7lh7vvvIzku6XpmLLmraLniIbngrjjgIIKCjPjgIHlvZPmsKfmsJTjgIHmtrLljJbmsJTnk7bkuLrnq5bnm7TmlL7nva7ml7bvvIzlv4Xpobvlm7rlrprmi7TniaLjgIIKCjTjgIHmsKfmsJTjgIHmtrLljJbmsJTnk7bkuI3lvpfkuI7nlLXnur/mjqXop6bvvIzkuZ/kuI3lvpfmlL7lnKjpnaDov5HliqDng63lmajjgIHmmI7ngavmiJbmmpbmsJTpmYTov5HvvIzku6Xlj4rpmLPlhYnnm7TlsITnmoTlnLDmlrnvvIzku6XpmLLmraLmsJTkvZPlj5fng63ohqjog4DlvJXotbfniIbngrjjgIIKCjXjgIHlvIDlkK/ljovlipvooajpmIDpl6jml7bopoHnvJPmhaLvvIzmsJTmtYHkuI3lj6/lpKrlv6vvvIzku6XpmLLlhrLlnY/ku6rlmajmiJblvJXotbfnnYDngavvvIzniIbngrjjgIIKCuS4ieOAgeeBreeBq+S4juaApeaVkQoK77yI5LiA77yJ54Gt54GrCgox44CB5a6e6aqM5a6k5aSx54Gr5ZCO77yM5LiA5a6a6KaB5rKJ552A44CB5LiN6KaB5oOK5oWM77yM6KaB5qC55o2u6LW354Gr5Y6f5Zug5LiO54Gr5Yq/5aSn5bCP77yM5Y+K5pe26YeH5Y+W5Lul5LiL5o6q5pa977yaCgoy44CB56uL5Y2z5YWz5o6J55S15rqQ44CB5rCU5rqQ5Y+K6YCa6aOO5py6Cgoz44CB5bCG5a6k5YaF5piT54eD44CB5piT54iG54mp77yI5L6L5aaC5Y6L57yp5rCU55O277yJ5bCP5b+D5pCs56a754Gr5rqQ77yM5rOo5oSP5pCs5Yqo5pe25YiH5LiN5Y+v56Kw5pKe77yM5Lul5YWN5byV6LW35pu05aSn54Gr54G+44CCCgo044CB6L+F6YCf6YCJ55So6YCC5b2T55qE54Gt54Gr5Zmo77yM5bCG5Yia6LW355qE54Gr5omR54Gt44CC5rOo5oSP5LiN6KaB55So5rC05p2l5omR54Gt5LiN5rq25LqO5rC055qE5rK557G75Lul5Y+K5YW25LuW5pyJ5py65rq25YmC562J5Y+v54eD54mp44CCCgo144CB5Y+K5pe25oql6K2m77ya5a6J5YWo5L+d5Y2r55S16K+d77yaMDg3MS02NTkzNzExMCDngavorabnlLXor50xMTnjgIIKCjbjgIHouqvkuIrooaPmnI3nnYDngavml7bvvIzliIfkuI3lj6/ku7vmhI/ot5HliqjjgILlupTnlKjnn7Pmo4nmr6/oo7nlnKjouqvvvIzku6XpmpTnu53nqbrmsJTogIznga3ngavjgILlpoLml6Dnn7Pmo4nmr6/miJboloTmr6/ml7bvvIzlj6/lsLHlnLDourrkuIvmiZPmu5rku6Xnga3ngavjgIIKCjfjgIHlrp7pqozlrqTlupToo4XlpIflv4XopoHnmoTnga3ngavorr7lpIfjgIIKCi4uLgooY29udGVudCB0cnVuY2F0ZWQpCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAAAAAAAACwAAAAAAAAAQgAAAAAAAABYAAAAAAAAAG4AAAAAAAAAhAAAAAAAAACaAAAAAAAAALAAAAAAAAAAxgAAAAAAAADcAAAAAAAAAPIAAAAAAAAACAEAAAAAAAAeAQAAAAAAADQBAAAAAAAASgEAAAAAAABgAQAAAAAAAHYBAAAAAAAAjAEAAAAAAACiAQAAAAAAALgBAAAAAAAAzgEAAAAAAADkAQAAAAAAAPoBAAAAAAAAEAIAAAAAAAAmAgAAAAAAADwCAAAAAAAAUgIAAAAAAABoAgAAAAAAAH4CAAAAAAAAlAIAAAAAAACqAgAAAAAAAMACAAAAAAAA1gIAAAAAAADsAgAAAAAAAAIDAAAAAAAAGAMAAAAAAAAuAwAAAAAAAEQDAAAAAAAAWgMAAAAAAABwAwAAAAAAAIYDAAAAAAAAnAMAAAAAAACyAwAAAAAAAMgDAAAAAAAA3gMAAAAAAAD0AwAAAAAAAAoEAAAAAAAAIAQAAAAAAAA2BAAAAAAAAEwEAAAAAAAAYgQAAAAAAAB4BAAAAAAAAI4EAAAAAAAApAQAAAAAAAC6BAAAAAAAANAEAAAAAAAA5gQAAAAAAAD8BAAAAAAAABIFAAAAAAAAKAUAAAAAAAA+BQAAAAAAAFQFAAAAAAAAagUAAAAAAACABQAAAAAAAJYFAAAAAAAArAUAAAAAAADCBQAAAAAAANgFAAAAAAAA7gUAAAAAAAAEBgAAAAAAABoGAAAAAAAAMAYAAAAAAABGBgAAAAAAAFwGAAAAAAAAcgYAAAAAAACIBgAAAAAAAJ4GAAAAAAAAtAYAAAAAAADKBgAAAAAAAOAGAAAAAAAA9gYAAAAAAAAMBwAAAAAAACIHAAAAAAAAOAcAAAAAAABOBwAAAAAAAGQHAAAAAAAAegcAAAAAAACQBwAAAAAAAKYHAAAAAAAAvAcAAAAAAADSBwAAAAAAAOgHAAAAAAAA/gcAAAAAAAAUCAAAAAAAACoIAAAAAAAAQAgAAAAAAABWCAAAAAAAAGwIAAAAAAAAgggAAAAAAACYCAAAAAAAAEFjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmdBY2FkZW1pYyAmIEVuZ2luZWVyaW5nQWNhZGVtaWMgJiBFbmdpbmVlcmluZ0FjYWRlbWljICYgRW5naW5lZXJpbmcAAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAYAAAAAAAAACUAAAAAAAAALQAAAAAAAAA6AAAAAAAAAEcAAAAAAAAAVAAAAAAAAABhAAAAAAAAAG4AAAAAAAAAdgAAAAAAAACCAAAAAAAAAI4AAAAAAAAAmgAAAAAAAACmAAAAAAAAALIAAAAAAAAAvgAAAAAAAADLAAAAAAAAANcAAAAAAAAA5AAAAAAAAAD1AAAAAAAAAAABAAAAAAAAEQEAAAAAAAAcAQAAAAAAACcBAAAAAAAALwEAAAAAAAA3AQAAAAAAAD8BAAAAAAAATAEAAAAAAABZAQAAAAAAAGEBAAAAAAAAbgEAAAAAAAB7AQAAAAAAAIgBAAAAAAAAlQEAAAAAAACdAQAAAAAAAKkBAAAAAAAAtQEAAAAAAADBAQAAAAAAAM0BAAAAAAAA2QEAAAAAAADlAQAAAAAAAPEBAAAAAAAA/gEAAAAAAAALAgAAAAAAABwCAAAAAAAAJwIAAAAAAAAyAgAAAAAAAD0CAAAAAAAATgIAAAAAAABbAgAAAAAAAGgCAAAAAAAAdQIAAAAAAAB9AgAAAAAAAIoCAAAAAAAAlwIAAAAAAACfAgAAAAAAAKcCAAAAAAAArwIAAAAAAAC8AgAAAAAAAMQCAAAAAAAA0AIAAAAAAADcAgAAAAAAAOgCAAAAAAAA9AIAAAAAAAAAAwAAAAAAAAwDAAAAAAAAGAMAAAAAAAAlAwAAAAAAADIDAAAAAAAAPQMAAAAAAABOAwAAAAAAAF8DAAAAAAAAagMAAAAAAAB1AwAAAAAAAH0DAAAAAAAAhQMAAAAAAACNAwAAAAAAAJUDAAAAAAAAogMAAAAAAACvAwAAAAAAALwDAAAAAAAAyQMAAAAAAADWAwAAAAAAAOMDAAAAAAAA6wMAAAAAAAD3AwAAAAAAAAMEAAAAAAAADwQAAAAAAAAbBAAAAAAAACcEAAAAAAAAMwQAAAAAAAA/BAAAAAAAAEwEAAAAAAAAWQQAAAAAAABkBAAAAAAAAHUEAAAAAAAAhgQAAAAAAACRBAAAAAAAAJwEAAAAAAAAQWJzdHJhY3RBYnN0cmFjdEFic3RyYWN0UGFwZXIgT3V0bGluZUFic3RyYWN0UGFwZXIgT3V0bGluZVBhcGVyIE91dGxpbmVQYXBlciBPdXRsaW5lUGFwZXIgT3V0bGluZVBhcGVyIE91dGxpbmVBYnN0cmFjdEludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkNvbnRyaWJ1dGlvbnNJbnRyb2R1Y3Rpb25Db250cmlidXRpb25zTGl0ZXJhdHVyZSBSZXZpZXdFeHBlcmltZW50c0xpdGVyYXR1cmUgUmV2aWV3RXhwZXJpbWVudHNFeHBlcmltZW50c0Fic3RyYWN0QWJzdHJhY3RBYnN0cmFjdFBhcGVyIE91dGxpbmVQYXBlciBPdXRsaW5lQWJzdHJhY3RQYXBlciBPdXRsaW5lUGFwZXIgT3V0bGluZVBhcGVyIE91dGxpbmVQYXBlciBPdXRsaW5lQWJzdHJhY3RJbnRyb2R1Y3Rpb25JbnRyb2R1Y3Rpb25JbnRyb2R1Y3Rpb25JbnRyb2R1Y3Rpb25JbnRyb2R1Y3Rpb25JbnRyb2R1Y3Rpb25JbnRyb2R1Y3Rpb25Db250cmlidXRpb25zQ29udHJpYnV0aW9uc0xpdGVyYXR1cmUgUmV2aWV3RXhwZXJpbWVudHNFeHBlcmltZW50c0V4cGVyaW1lbnRzTGl0ZXJhdHVyZSBSZXZpZXdQYXBlciBPdXRsaW5lUGFwZXIgT3V0bGluZVBhcGVyIE91dGxpbmVBYnN0cmFjdFBhcGVyIE91dGxpbmVQYXBlciBPdXRsaW5lQWJzdHJhY3RBYnN0cmFjdEFic3RyYWN0UGFwZXIgT3V0bGluZUFic3RyYWN0SW50cm9kdWN0aW9uSW50cm9kdWN0aW9uSW50cm9kdWN0aW9uSW50cm9kdWN0aW9uSW50cm9kdWN0aW9uSW50cm9kdWN0aW9uSW50cm9kdWN0aW9uQ29udHJpYnV0aW9uc0NvbnRyaWJ1dGlvbnNFeHBlcmltZW50c0xpdGVyYXR1cmUgUmV2aWV3TGl0ZXJhdHVyZSBSZXZpZXdFeHBlcmltZW50c0V4cGVyaW1lbnRzQWJzdHJhY3RBYnN0cmFjdEFic3RyYWN0QWJzdHJhY3RQYXBlciBPdXRsaW5lUGFwZXIgT3V0bGluZVBhcGVyIE91dGxpbmVQYXBlciBPdXRsaW5lUGFwZXIgT3V0bGluZVBhcGVyIE91dGxpbmVBYnN0cmFjdEludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkludHJvZHVjdGlvbkNvbnRyaWJ1dGlvbnNDb250cmlidXRpb25zRXhwZXJpbWVudHNMaXRlcmF0dXJlIFJldmlld0xpdGVyYXR1cmUgUmV2aWV3RXhwZXJpbWVudHNFeHBlcmltZW50cwAAAAAzMzMzMzMhQM3MzMzMzCBAZmZmZmZmIEAAAAAAAAAiQGZmZmZmZh5AAAAAAAAAIkAAAAAAAAAiQAAAAAAAACJAmpmZmZmZIUAAAAAAAAAiQDMzMzMzMyFAmpmZmZmZIUDNzMzMzMwgQDMzMzMzMxtAAAAAAAAAIEBmZmZmZmYgQAAAAAAAACJAAAAAAAAAIkAAAAAAAAAiQJqZmZmZmSFAMzMzMzMzIUCamZmZmZkhQAAAAAAAACJAAAAAAAAAIkAAAAAAAAAiQDMzMzMzMxtAmpmZmZmZHUBmZmZmZmYgQDMzMzMzMxdAZmZmZmZmGkAAAAAAAAAcQJqZmZmZmR1AZmZmZmZmHkBmZmZmZmYaQAAAAAAAABxAMzMzMzMzH0BmZmZmZmYaQJqZmZmZmR1AZmZmZmZmFkDNzMzMzMwcQDMzMzMzMxtAzczMzMzMFEAzMzMzMzMfQAAAAAAAACBAMzMzMzMzH0DNzMzMzMwcQDMzMzMzMx9AMzMzMzMzH0AAAAAAAAAcQM3MzMzMzBxAAAAAAAAAHEBmZmZmZmYgQJqZmZmZmR1AzczMzMzMHEAAAAAAAAAgQGZmZmZmZh5AMzMzMzMzIUAzMzMzMzMfQGZmZmZmZh5AAAAAAAAAIkAAAAAAAAAgQDMzMzMzMx9AzczMzMzMHEBmZmZmZmYeQGZmZmZmZiBAMzMzMzMzF0CamZmZmZkZQDMzMzMzMyFAZmZmZmZmIEAAAAAAAAAgQAAAAAAAACBAmpmZmZmZIUAAAAAAAAAiQAAAAAAAACJAmpmZmZmZIUAAAAAAAAAgQM3MzMzMzCBAmpmZmZmZHUDNzMzMzMwgQGZmZmZmZh5AAAAAAAAAIEBmZmZmZmYgQGZmZmZmZiBAzczMzMzMIEBmZmZmZmYgQAAAAAAAACBAzczMzMzMIEAzMzMzMzMfQGZmZmZmZh5AAAAAAAAAIkDNzMzMzMwcQGZmZmZmZiBAAAAAAAAAIEDNzMzMzMwgQDMzMzMzMyFAAAAAAAAAIEAAAAAAAAAgQAAAAAAAACJAmpmZmZmZIUAzMzMzMzMhQAAAAAAAAAAANgEAAAAAAABsAgAAAAAAAKADAAAAAAAA1AQAAAAAAAAKBgAAAAAAAD8HAAAAAAAAcwgAAAAAAACpCQAAAAAAAN0KAAAAAAAAFAwAAAAAAABIDQAAAAAAAH0OAAAAAAAAsw8AAAAAAADpEAAAAAAAAB8SAAAAAAAAVBMAAAAAAACKFAAAAAAAAMAVAAAAAAAA9hYAAAAAAAAqGAAAAAAAAGQZAAAAAAAAlxoAAAAAAADMGwAAAAAAAAMdAAAAAAAAOx4AAAAAAABuHwAAAAAAAKEgAAAAAAAA1CEAAAAAAAACIwAAAAAAADEkAAAAAAAAZCUAAAAAAACXJgAAAAAAAMonAAAAAAAA+ygAAAAAAAArKgAAAAAAAF4rAAAAAAAAkSwAAAAAAADDLQAAAAAAAPYuAAAAAAAAKTAAAAAAAABcMQAAAAAAAI8yAAAAAAAAwzMAAAAAAAD2NAAAAAAAACg2AAAAAAAAXzcAAAAAAACROAAAAAAAAMU5AAAAAAAA+DoAAAAAAAAqPAAAAAAAAHc9AAAAAAAAyD4AAAAAAAAVQAAAAAAAAGdBAAAAAAAAukIAAAAAAAAJRAAAAAAAAFtFAAAAAAAArkYAAAAAAAAASAAAAAAAAFVJAAAAAAAAp0oAAAAAAAD5SwAAAAAAAEtNAAAAAAAAnU4AAAAAAADvTwAAAAAAAEFRAAAAAAAAk1IAAAAAAADmUwAAAAAAADdVAAAAAAAAiVYAAAAAAADbVwAAAAAAADJZAAAAAAAAhFoAAAAAAADXWwAAAAAAACpdAAAAAAAAel4AAAAAAADKXwAAAAAAABphAAAAAAAAa2IAAAAAAAC6YwAAAAAAAAllAAAAAAAAWWYAAAAAAACqZwAAAAAAAPpoAAAAAAAATWoAAAAAAACdawAAAAAAAO1sAAAAAAAAPm4AAAAAAACObwAAAAAAAN9wAAAAAAAAL3IAAAAAAAB/cwAAAAAAANB0AAAAAAAAIHYAAAAAAABvdwAAAAAAAL94AAAAAAAAFHoAAAAAAABkewAAAAAAALV8AAAAAAAABn4AAAAAAAB7Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogMTgxNiwgIm91dHB1dF90b2tlbnMiOiAxNzI4LCAidG90YWxfdG9rZW5zIjogMzU0NCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAxNDA4fSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTc1MTcsICJvdXRwdXRfdG9rZW5zIjogMTQxNywgInRvdGFsX3Rva2VucyI6IDE4OTM0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDY3MTMsICJvdXRwdXRfdG9rZW5zIjogMTg0MCwgInRvdGFsX3Rva2VucyI6IDg1NTMsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMTM0NH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDU2ODU4LCAib3V0cHV0X3Rva2VucyI6IDE0OTEsICJ0b3RhbF90b2tlbnMiOiA1ODM0OSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC01IjogeyJpbnB1dF90b2tlbnMiOiAyMDU1LCAib3V0cHV0X3Rva2VucyI6IDk2NywgInRvdGFsX3Rva2VucyI6IDMwMjIsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogNjQwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTgxNjAsICJvdXRwdXRfdG9rZW5zIjogMTQ1MSwgInRvdGFsX3Rva2VucyI6IDE5NjExLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDMxLCAib3V0cHV0X3Rva2VucyI6IDQyMzMsICJ0b3RhbF90b2tlbnMiOiA0MjY0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDE5ODR9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxODc4MCwgIm91dHB1dF90b2tlbnMiOiAxNjU5LCAidG90YWxfdG9rZW5zIjogMjA0MzksICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogMjQzOSwgIm91dHB1dF90b2tlbnMiOiAyMjE5LCAidG90YWxfdG9rZW5zIjogNDY1OCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAxNjAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjMxMzQsICJvdXRwdXRfdG9rZW5zIjogMTU0OSwgInRvdGFsX3Rva2VucyI6IDI0NjgzLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDEwMywgIm91dHB1dF90b2tlbnMiOiA0MDE2LCAidG90YWxfdG9rZW5zIjogNDExOSwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAxMjgwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjI0ODUsICJvdXRwdXRfdG9rZW5zIjogMTgxNSwgInRvdGFsX3Rva2VucyI6IDI0MzAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDk3LCAib3V0cHV0X3Rva2VucyI6IDQ1MzYsICJ0b3RhbF90b2tlbnMiOiA0NjMzLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDEzNDR9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNDg2MiwgIm91dHB1dF90b2tlbnMiOiAxNzAyLCAidG90YWxfdG9rZW5zIjogMjY1NjQsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogMTk0MSwgIm91dHB1dF90b2tlbnMiOiA0OTk3LCAidG90YWxfdG9rZW5zIjogNjkzOCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAyMzY4fSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMzE4NDQsICJvdXRwdXRfdG9rZW5zIjogMTU2NywgInRvdGFsX3Rva2VucyI6IDMzNDExLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDMxLCAib3V0cHV0X3Rva2VucyI6IDM5ODIsICJ0b3RhbF90b2tlbnMiOiA0MDEzLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDE4NTZ9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxNzc0MiwgIm91dHB1dF90b2tlbnMiOiAxNjM4LCAidG90YWxfdG9rZW5zIjogMTkzODAsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogNjc1NywgIm91dHB1dF90b2tlbnMiOiA0NzA2LCAidG90YWxfdG9rZW5zIjogMTE0NjMsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMTQ3Mn0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDgwMDM4LCAib3V0cHV0X3Rva2VucyI6IDIzODQsICJ0b3RhbF90b2tlbnMiOiA4MjQyMiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC01IjogeyJpbnB1dF90b2tlbnMiOiAyMjkzLCAib3V0cHV0X3Rva2VucyI6IDg0MiwgInRvdGFsX3Rva2VucyI6IDMxMzUsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogNTEyfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjAyOTksICJvdXRwdXRfdG9rZW5zIjogMTQ0NiwgInRvdGFsX3Rva2VucyI6IDIxNzQ1LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDM3MjIsICJvdXRwdXRfdG9rZW5zIjogMTY1MiwgInRvdGFsX3Rva2VucyI6IDUzNzQsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogODk2fSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMzAzMzksICJvdXRwdXRfdG9rZW5zIjogMTUzMywgInRvdGFsX3Rva2VucyI6IDMxODcyLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDIzMTcsICJvdXRwdXRfdG9rZW5zIjogMjI3NywgInRvdGFsX3Rva2VucyI6IDQ1OTQsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMTIxNn0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDIzNTE4LCAib3V0cHV0X3Rva2VucyI6IDE1OTYsICJ0b3RhbF90b2tlbnMiOiAyNTExNCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC01IjogeyJpbnB1dF90b2tlbnMiOiAyOTMxLCAib3V0cHV0X3Rva2VucyI6IDIxMjMsICJ0b3RhbF90b2tlbnMiOiA1MDU0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDEzNDR9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNTY4MywgIm91dHB1dF90b2tlbnMiOiAxNTg0LCAidG90YWxfdG9rZW5zIjogMjcyNjcsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogMTgwNiwgIm91dHB1dF90b2tlbnMiOiAyMjEzLCAidG90YWxfdG9rZW5zIjogNDAxOSwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAxNDA4fSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTk5ODksICJvdXRwdXRfdG9rZW5zIjogMTQ5MCwgInRvdGFsX3Rva2VucyI6IDIxNDc5LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDUzOCwgIm91dHB1dF90b2tlbnMiOiAzNTQ4LCAidG90YWxfdG9rZW5zIjogNDA4NiwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAxOTg0fSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTc0NTIsICJvdXRwdXRfdG9rZW5zIjogMTYzMiwgInRvdGFsX3Rva2VucyI6IDE5MDg0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDMxNjIsICJvdXRwdXRfdG9rZW5zIjogMzI5MiwgInRvdGFsX3Rva2VucyI6IDY0NTQsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMTYwMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDMyMTQ3LCAib3V0cHV0X3Rva2VucyI6IDE2NTIsICJ0b3RhbF90b2tlbnMiOiAzMzc5OSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC01IjogeyJpbnB1dF90b2tlbnMiOiAzMTcyLCAib3V0cHV0X3Rva2VucyI6IDE3MDksICJ0b3RhbF90b2tlbnMiOiA0ODgxLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDEwODh9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNjE3OSwgIm91dHB1dF90b2tlbnMiOiAxNjQ1LCAidG90YWxfdG9rZW5zIjogMjc4MjQsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogMjU0MSwgIm91dHB1dF90b2tlbnMiOiA1MDY1LCAidG90YWxfdG9rZW5zIjogNzYwNiwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAxMjE2fSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogNDIzMTcsICJvdXRwdXRfdG9rZW5zIjogMTU2NCwgInRvdGFsX3Rva2VucyI6IDQzODgxLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTUiOiB7ImlucHV0X3Rva2VucyI6IDM1LCAib3V0cHV0X3Rva2VucyI6IDYwMDIsICJ0b3RhbF90b2tlbnMiOiA2MDM3LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDI1NjB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNjA0MCwgIm91dHB1dF90b2tlbnMiOiAxNjEwLCAidG90YWxfdG9rZW5zIjogMjc2NTAsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogMTY3NjIsICJvdXRwdXRfdG9rZW5zIjogMzU1MywgInRvdGFsX3Rva2VucyI6IDIwMzE1LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDEzNDR9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxMzMyNDMsICJvdXRwdXRfdG9rZW5zIjogMTQ0NCwgInRvdGFsX3Rva2VucyI6IDEzNDY4NywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC01IjogeyJpbnB1dF90b2tlbnMiOiA5NSwgIm91dHB1dF90b2tlbnMiOiAzNTQyLCAidG90YWxfdG9rZW5zIjogMzYzNywgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiA4MzJ9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyMjIwNCwgIm91dHB1dF90b2tlbnMiOiAxNjk5LCAidG90YWxfdG9rZW5zIjogMjM5MDMsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogMTU3LCAib3V0cHV0X3Rva2VucyI6IDg2MDUsICJ0b3RhbF90b2tlbnMiOiA4NzYyLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDUzMTJ9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNjQ5NCwgIm91dHB1dF90b2tlbnMiOiAxNzQ1LCAidG90YWxfdG9rZW5zIjogMjgyMzksICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNSI6IHsiaW5wdXRfdG9rZW5zIjogNDMzMSwgIm91dHB1dF90b2tlbnMiOiA2NzEyLCAidG90YWxfdG9rZW5zIjogMTEwNDMsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMjI0MH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDY0Mzc4LCAib3V0cHV0X3Rva2VucyI6IDE3MDQsICJ0b3RhbF90b2tlbnMiOiA2NjA4MiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC01IjogeyJpbnB1dF90b2tlbnMiOiAxMTAxLCAib3V0cHV0X3Rva2VucyI6IDEwNTIwLCAidG90YWxfdG9rZW5zIjogMTE2MjEsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogNTMxMn0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDQxODAyLCAib3V0cHV0X3Rva2VucyI6IDE1NzAsICJ0b3RhbF90b2tlbnMiOiA0MzM3MiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC00byI6IHsiaW5wdXRfdG9rZW5zIjogMjA1NiwgIm91dHB1dF90b2tlbnMiOiAyMDYsICJ0b3RhbF90b2tlbnMiOiAyMjYyLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxNzQ5NSwgIm91dHB1dF90b2tlbnMiOiAxMjA5LCAidG90YWxfdG9rZW5zIjogMTg3MDQsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDY3MTQsICJvdXRwdXRfdG9rZW5zIjogMTc2LCAidG90YWxfdG9rZW5zIjogNjg5MCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogNTQ4NTMsICJvdXRwdXRfdG9rZW5zIjogMTI3MSwgInRvdGFsX3Rva2VucyI6IDU2MTI0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAxODE3LCAib3V0cHV0X3Rva2VucyI6IDQzNSwgInRvdGFsX3Rva2VucyI6IDIyNTIsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE4Nzc3LCAib3V0cHV0X3Rva2VucyI6IDE0NDMsICJ0b3RhbF90b2tlbnMiOiAyMDIyMCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC00byI6IHsiaW5wdXRfdG9rZW5zIjogMzIsICJvdXRwdXRfdG9rZW5zIjogNTI3LCAidG90YWxfdG9rZW5zIjogNTU5LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiA4NjkyLCAib3V0cHV0X3Rva2VucyI6IDEzMDcsICJ0b3RhbF90b2tlbnMiOiA5OTk5LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAzMiwgIm91dHB1dF90b2tlbnMiOiA2NDEsICJ0b3RhbF90b2tlbnMiOiA2NzMsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDk0MTUsICJvdXRwdXRfdG9rZW5zIjogMTI1NywgInRvdGFsX3Rva2VucyI6IDEwNjcyLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAyNDQwLCAib3V0cHV0X3Rva2VucyI6IDM3NSwgInRvdGFsX3Rva2VucyI6IDI4MTUsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDIxNzA0LCAib3V0cHV0X3Rva2VucyI6IDE1MDUsICJ0b3RhbF90b2tlbnMiOiAyMzIwOSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC00byI6IHsiaW5wdXRfdG9rZW5zIjogMTk0MiwgIm91dHB1dF90b2tlbnMiOiA3NTEsICJ0b3RhbF90b2tlbnMiOiAyNjkzLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyMDQ4NCwgIm91dHB1dF90b2tlbnMiOiAxMjU3LCAidG90YWxfdG9rZW5zIjogMjE3NDEsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDY3NTgsICJvdXRwdXRfdG9rZW5zIjogNzE3LCAidG90YWxfdG9rZW5zIjogNzQ3NSwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogNjM3ODMsICJvdXRwdXRfdG9rZW5zIjogMTYyNCwgInRvdGFsX3Rva2VucyI6IDY1NDA3LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAxMDQsICJvdXRwdXRfdG9rZW5zIjogNzUwLCAidG90YWxfdG9rZW5zIjogODU0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxMDMzNSwgIm91dHB1dF90b2tlbnMiOiAxMzcwLCAidG90YWxfdG9rZW5zIjogMTE3MDUsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDk4LCAib3V0cHV0X3Rva2VucyI6IDc0OSwgInRvdGFsX3Rva2VucyI6IDg0NywgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTAxNTIsICJvdXRwdXRfdG9rZW5zIjogMTM4NiwgInRvdGFsX3Rva2VucyI6IDExNTM4LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAyMjk0LCAib3V0cHV0X3Rva2VucyI6IDIyOCwgInRvdGFsX3Rva2VucyI6IDI1MjIsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE5NjA5LCAib3V0cHV0X3Rva2VucyI6IDEyOTYsICJ0b3RhbF90b2tlbnMiOiAyMDkwNSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC00byI6IHsiaW5wdXRfdG9rZW5zIjogMjMxOCwgIm91dHB1dF90b2tlbnMiOiA1MjgsICJ0b3RhbF90b2tlbnMiOiAyODQ2LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyMDQ4MywgIm91dHB1dF90b2tlbnMiOiAxMzkzLCAidG90YWxfdG9rZW5zIjogMjE4NzYsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDUzOSwgIm91dHB1dF90b2tlbnMiOiA0NzEsICJ0b3RhbF90b2tlbnMiOiAxMDEwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxMTE3NywgIm91dHB1dF90b2tlbnMiOiAxNDIyLCAidG90YWxfdG9rZW5zIjogMTI1OTksICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDE4MDcsICJvdXRwdXRfdG9rZW5zIjogMzczLCAidG90YWxfdG9rZW5zIjogMjE4MCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTc1MTQsICJvdXRwdXRfdG9rZW5zIjogMTM3OCwgInRvdGFsX3Rva2VucyI6IDE4ODkyLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAzNzIzLCAib3V0cHV0X3Rva2VucyI6IDQ0OCwgInRvdGFsX3Rva2VucyI6IDQxNzEsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDI4NDY0LCAib3V0cHV0X3Rva2VucyI6IDEzNzAsICJ0b3RhbF90b2tlbnMiOiAyOTgzNCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC00byI6IHsiaW5wdXRfdG9rZW5zIjogMzE2MywgIm91dHB1dF90b2tlbnMiOiA2MzIsICJ0b3RhbF90b2tlbnMiOiAzNzk1LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNTg0NywgIm91dHB1dF90b2tlbnMiOiAxMzY3LCAidG90YWxfdG9rZW5zIjogMjcyMTQsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDI5MzIsICJvdXRwdXRfdG9rZW5zIjogNDYyLCAidG90YWxfdG9rZW5zIjogMzM5NCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjQwMzgsICJvdXRwdXRfdG9rZW5zIjogMTQ1NiwgInRvdGFsX3Rva2VucyI6IDI1NDk0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAyNTQyLCAib3V0cHV0X3Rva2VucyI6IDE0NTEsICJ0b3RhbF90b2tlbnMiOiAzOTkzLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyODA5NywgIm91dHB1dF90b2tlbnMiOiAxNDU0LCAidG90YWxfdG9rZW5zIjogMjk1NTEsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDMxNzMsICJvdXRwdXRfdG9rZW5zIjogNDY5LCAidG90YWxfdG9rZW5zIjogMzY0MiwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjUyMDQsICJvdXRwdXRfdG9rZW5zIjogMTUzMSwgInRvdGFsX3Rva2VucyI6IDI2NzM1LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAzNiwgIm91dHB1dF90b2tlbnMiOiAxNTYwLCAidG90YWxfdG9rZW5zIjogMTU5NiwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTQ5MDAsICJvdXRwdXRfdG9rZW5zIjogMTM1MywgInRvdGFsX3Rva2VucyI6IDE2MjUzLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJvcGVuYWkvZ3B0LTRvIjogeyJpbnB1dF90b2tlbnMiOiAxNjc2MywgIm91dHB1dF90b2tlbnMiOiA3ODgsICJ0b3RhbF90b2tlbnMiOiAxNzU1MSwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMCwgInJlYXNvbmluZ190b2tlbnMiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTI0MzEzLCAib3V0cHV0X3Rva2VucyI6IDEyNjIsICJ0b3RhbF90b2tlbnMiOiAxMjU1NzUsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDk2LCAib3V0cHV0X3Rva2VucyI6IDExODIsICJ0b3RhbF90b2tlbnMiOiAxMjc4LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxMjgzNCwgIm91dHB1dF90b2tlbnMiOiAxNDk3LCAidG90YWxfdG9rZW5zIjogMTQzMzEsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDExMDIsICJvdXRwdXRfdG9rZW5zIjogMTMwOCwgInRvdGFsX3Rva2VucyI6IDI0MTAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDAsICJyZWFzb25pbmdfdG9rZW5zIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE5MDM3LCAib3V0cHV0X3Rva2VucyI6IDE0MDksICJ0b3RhbF90b2tlbnMiOiAyMDQ0NiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsib3BlbmFpL2dwdC00byI6IHsiaW5wdXRfdG9rZW5zIjogNDMzMiwgIm91dHB1dF90b2tlbnMiOiA5MTcsICJ0b3RhbF90b2tlbnMiOiA1MjQ5LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiA0MTQxMywgIm91dHB1dF90b2tlbnMiOiAxMjg5LCAidG90YWxfdG9rZW5zIjogNDI3MDIsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17Im9wZW5haS9ncHQtNG8iOiB7ImlucHV0X3Rva2VucyI6IDE1OCwgIm91dHB1dF90b2tlbnMiOiA5MTgsICJ0b3RhbF90b2tlbnMiOiAxMDc2LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwLCAicmVhc29uaW5nX3Rva2VucyI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxMTg2OSwgIm91dHB1dF90b2tlbnMiOiAxNDUyLCAidG90YWxfdG9rZW5zIjogMTMzMjEsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogMzQsICJvdXRwdXRfdG9rZW5zIjogNDU0LCAidG90YWxfdG9rZW5zIjogNDg4LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDc4MDcsICJvdXRwdXRfdG9rZW5zIjogMTM3MSwgInRvdGFsX3Rva2VucyI6IDkxNzgsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogMTAzLCAib3V0cHV0X3Rva2VucyI6IDkzMywgInRvdGFsX3Rva2VucyI6IDEwMzYsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTA2MTcsICJvdXRwdXRfdG9rZW5zIjogMTUwMywgInRvdGFsX3Rva2VucyI6IDEyMTIwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDMzLCAib3V0cHV0X3Rva2VucyI6IDQxNiwgInRvdGFsX3Rva2VucyI6IDQ0OSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiA3NjUwLCAib3V0cHV0X3Rva2VucyI6IDE0MDAsICJ0b3RhbF90b2tlbnMiOiA5MDUwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDI2NzYsICJvdXRwdXRfdG9rZW5zIjogNDk0LCAidG90YWxfdG9rZW5zIjogMzE3MCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyMTc5OSwgIm91dHB1dF90b2tlbnMiOiAxNTQ4LCAidG90YWxfdG9rZW5zIjogMjMzNDcsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogMjEzMCwgIm91dHB1dF90b2tlbnMiOiAxMzIzLCAidG90YWxfdG9rZW5zIjogMzQ1MywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyMjgxNCwgIm91dHB1dF90b2tlbnMiOiAxNDM4LCAidG90YWxfdG9rZW5zIjogMjQyNTIsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogMTA5LCAib3V0cHV0X3Rva2VucyI6IDczMiwgInRvdGFsX3Rva2VucyI6IDg0MSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiA5NTIwLCAib3V0cHV0X3Rva2VucyI6IDE0MzYsICJ0b3RhbF90b2tlbnMiOiAxMDk1NiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LTIwMjUwMjE5IjogeyJpbnB1dF90b2tlbnMiOiAyMDMzLCAib3V0cHV0X3Rva2VucyI6IDcwNywgInRvdGFsX3Rva2VucyI6IDI3NDAsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTg4MjcsICJvdXRwdXRfdG9rZW5zIjogMTQyOCwgInRvdGFsX3Rva2VucyI6IDIwMjU1LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDk0MjcsICJvdXRwdXRfdG9rZW5zIjogNTc4LCAidG90YWxfdG9rZW5zIjogMTAwMDUsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogNTY0OTMsICJvdXRwdXRfdG9rZW5zIjogMTI4NCwgInRvdGFsX3Rva2VucyI6IDU3Nzc3LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDIyMzQsICJvdXRwdXRfdG9rZW5zIjogMjkwLCAidG90YWxfdG9rZW5zIjogMjUyNCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxNzgxNSwgIm91dHB1dF90b2tlbnMiOiAxMzI3LCAidG90YWxfdG9rZW5zIjogMTkxNDIsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogMTAyNTIsICJvdXRwdXRfdG9rZW5zIjogNzAyOSwgInRvdGFsX3Rva2VucyI6IDE3MjgxLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDkzNjYzLCAib3V0cHV0X3Rva2VucyI6IDIxNjcsICJ0b3RhbF90b2tlbnMiOiA5NTgzMCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LTIwMjUwMjE5IjogeyJpbnB1dF90b2tlbnMiOiAyNTQ1LCAib3V0cHV0X3Rva2VucyI6IDI1MywgInRvdGFsX3Rva2VucyI6IDI3OTgsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTk2MTksICJvdXRwdXRfdG9rZW5zIjogMTI0NywgInRvdGFsX3Rva2VucyI6IDIwODY2LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDI0NzUsICJvdXRwdXRfdG9rZW5zIjogODQ0LCAidG90YWxfdG9rZW5zIjogMzMxOSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyMTg5OCwgIm91dHB1dF90b2tlbnMiOiAxNTQ2LCAidG90YWxfdG9rZW5zIjogMjM0NDQsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogNDExNywgIm91dHB1dF90b2tlbnMiOiA0MjMsICJ0b3RhbF90b2tlbnMiOiA0NTQwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDI4MDY5LCAib3V0cHV0X3Rva2VucyI6IDE0MjQsICJ0b3RhbF90b2tlbnMiOiAyOTQ5MywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LTIwMjUwMjE5IjogeyJpbnB1dF90b2tlbnMiOiA1NjMsICJvdXRwdXRfdG9rZW5zIjogMTAyNSwgInRvdGFsX3Rva2VucyI6IDE1ODgsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMTM3MTcsICJvdXRwdXRfdG9rZW5zIjogMTU1MSwgInRvdGFsX3Rva2VucyI6IDE1MjY4LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDMzOTMsICJvdXRwdXRfdG9rZW5zIjogNzYxLCAidG90YWxfdG9rZW5zIjogNDE1NCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNjE4NywgIm91dHB1dF90b2tlbnMiOiAxNDgwLCAidG90YWxfdG9rZW5zIjogMjc2NjcsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogMjAxNywgIm91dHB1dF90b2tlbnMiOiAzODEsICJ0b3RhbF90b2tlbnMiOiAyMzk4LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE3MzI5LCAib3V0cHV0X3Rva2VucyI6IDE0MjgsICJ0b3RhbF90b2tlbnMiOiAxODc1NywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LTIwMjUwMjE5IjogeyJpbnB1dF90b2tlbnMiOiAzMjE3LCAib3V0cHV0X3Rva2VucyI6IDYwNCwgInRvdGFsX3Rva2VucyI6IDM4MjEsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjQ1MzgsICJvdXRwdXRfdG9rZW5zIjogMTM4MSwgInRvdGFsX3Rva2VucyI6IDI1OTE5LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDI4MjMsICJvdXRwdXRfdG9rZW5zIjogMzE0NywgInRvdGFsX3Rva2VucyI6IDU5NzAsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMzU1NDcsICJvdXRwdXRfdG9rZW5zIjogMTU3NCwgInRvdGFsX3Rva2VucyI6IDM3MTIxLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDM4LCAib3V0cHV0X3Rva2VucyI6IDE4NDYsICJ0b3RhbF90b2tlbnMiOiAxODg0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE1MjI1LCAib3V0cHV0X3Rva2VucyI6IDE1OTYsICJ0b3RhbF90b2tlbnMiOiAxNjgyMSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS0zLTctc29ubmV0LTIwMjUwMjE5IjogeyJpbnB1dF90b2tlbnMiOiAzNTA2LCAib3V0cHV0X3Rva2VucyI6IDM4OSwgInRvdGFsX3Rva2VucyI6IDM4OTUsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjQ1NzQsICJvdXRwdXRfdG9rZW5zIjogMTQ2NywgInRvdGFsX3Rva2VucyI6IDI2MDQxLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDEwMSwgIm91dHB1dF90b2tlbnMiOiAxODA0LCAidG90YWxfdG9rZW5zIjogMTkwNSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxNTM5NCwgIm91dHB1dF90b2tlbnMiOiAxNTE0LCAidG90YWxfdG9rZW5zIjogMTY5MDgsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogMjI2MTcsICJvdXRwdXRfdG9rZW5zIjogNTc4MSwgInRvdGFsX3Rva2VucyI6IDI4Mzk4LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE0NzI5OCwgIm91dHB1dF90b2tlbnMiOiAxNTY3LCAidG90YWxfdG9rZW5zIjogMTQ4ODY1LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTkiOiB7ImlucHV0X3Rva2VucyI6IDE2NywgIm91dHB1dF90b2tlbnMiOiAzOTUxLCAidG90YWxfdG9rZW5zIjogNDExOCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNjQzOSwgIm91dHB1dF90b2tlbnMiOiAxNzkwLCAidG90YWxfdG9rZW5zIjogMjgyMjksICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogMTIxMiwgIm91dHB1dF90b2tlbnMiOiAzNDcxLCAidG90YWxfdG9rZW5zIjogNDY4MywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyODg0MiwgIm91dHB1dF90b2tlbnMiOiAxNDk2LCAidG90YWxfdG9rZW5zIjogMzAzMzgsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOSI6IHsiaW5wdXRfdG9rZW5zIjogNTg4OCwgIm91dHB1dF90b2tlbnMiOiAzOTgzLCAidG90YWxfdG9rZW5zIjogOTg3MSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiA1NTAzMywgIm91dHB1dF90b2tlbnMiOiAxNDk2LCAidG90YWxfdG9rZW5zIjogNTY1MjksICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDIyMzQsICJvdXRwdXRfdG9rZW5zIjogMzE4LCAidG90YWxfdG9rZW5zIjogMjU1MiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxNzk1NSwgIm91dHB1dF90b2tlbnMiOiAxMzQ3LCAidG90YWxfdG9rZW5zIjogMTkzMDIsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDIwMzMsICJvdXRwdXRfdG9rZW5zIjogNjQwLCAidG90YWxfdG9rZW5zIjogMjY3MywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxODQ5MiwgIm91dHB1dF90b2tlbnMiOiAxNDI4LCAidG90YWxfdG9rZW5zIjogMTk5MjAsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDI2NzYsICJvdXRwdXRfdG9rZW5zIjogNzY2LCAidG90YWxfdG9rZW5zIjogMzQ0MiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyMzE1OSwgIm91dHB1dF90b2tlbnMiOiAxNTE4LCAidG90YWxfdG9rZW5zIjogMjQ2NzcsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDk0MjcsICJvdXRwdXRfdG9rZW5zIjogODg3LCAidG90YWxfdG9rZW5zIjogMTAzMTQsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogNTgwMzgsICJvdXRwdXRfdG9rZW5zIjogMTUzNiwgInRvdGFsX3Rva2VucyI6IDU5NTc0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1IjogeyJpbnB1dF90b2tlbnMiOiAzNCwgIm91dHB1dF90b2tlbnMiOiAxMzM5LCAidG90YWxfdG9rZW5zIjogMTM3MywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxMjIzMiwgIm91dHB1dF90b2tlbnMiOiAxNTExLCAidG90YWxfdG9rZW5zIjogMTM3NDMsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDMzLCAib3V0cHV0X3Rva2VucyI6IDEzMTgsICJ0b3RhbF90b2tlbnMiOiAxMzUxLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDEyMTYwLCAib3V0cHV0X3Rva2VucyI6IDE0MTgsICJ0b3RhbF90b2tlbnMiOiAxMzU3OCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNSI6IHsiaW5wdXRfdG9rZW5zIjogMTA5LCAib3V0cHV0X3Rva2VucyI6IDEzMjAsICJ0b3RhbF90b2tlbnMiOiAxNDI5LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDEyNDYwLCAib3V0cHV0X3Rva2VucyI6IDE0MjUsICJ0b3RhbF90b2tlbnMiOiAxMzg4NSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNSI6IHsiaW5wdXRfdG9rZW5zIjogMjEzMCwgIm91dHB1dF90b2tlbnMiOiAxNTk5LCAidG90YWxfdG9rZW5zIjogMzcyOSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNDE5NCwgIm91dHB1dF90b2tlbnMiOiAxNjE4LCAidG90YWxfdG9rZW5zIjogMjU4MTIsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDEwMywgIm91dHB1dF90b2tlbnMiOiAxOTE2LCAidG90YWxfdG9rZW5zIjogMjAxOSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxNTUzMiwgIm91dHB1dF90b2tlbnMiOiAxNTM3LCAidG90YWxfdG9rZW5zIjogMTcwNjksICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDEwMjUyLCAib3V0cHV0X3Rva2VucyI6IDIwNjgsICJ0b3RhbF90b2tlbnMiOiAxMjMyMCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiA2ODg1OCwgIm91dHB1dF90b2tlbnMiOiAxNzY3LCAidG90YWxfdG9rZW5zIjogNzA2MjUsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDI1NDUsICJvdXRwdXRfdG9rZW5zIjogMzIwLCAidG90YWxfdG9rZW5zIjogMjg2NSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxOTk1NCwgIm91dHB1dF90b2tlbnMiOiAxMzUyLCAidG90YWxfdG9rZW5zIjogMjEzMDYsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDU2MywgIm91dHB1dF90b2tlbnMiOiAxMTYwLCAidG90YWxfdG9rZW5zIjogMTcyMywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAxNDM5MiwgIm91dHB1dF90b2tlbnMiOiAxNTY1LCAidG90YWxfdG9rZW5zIjogMTU5NTcsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDI0NzUsICJvdXRwdXRfdG9rZW5zIjogMTAxMiwgInRvdGFsX3Rva2VucyI6IDM0ODcsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjI3MzgsICJvdXRwdXRfdG9rZW5zIjogMTUzMCwgInRvdGFsX3Rva2VucyI6IDI0MjY4LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1IjogeyJpbnB1dF90b2tlbnMiOiA0MTE3LCAib3V0cHV0X3Rva2VucyI6IDg5NiwgInRvdGFsX3Rva2VucyI6IDUwMTMsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMzA0MzQsICJvdXRwdXRfdG9rZW5zIjogMTQ1NywgInRvdGFsX3Rva2VucyI6IDMxODkxLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1IjogeyJpbnB1dF90b2tlbnMiOiAzMzkzLCAib3V0cHV0X3Rva2VucyI6IDE4MzIsICJ0b3RhbF90b2tlbnMiOiA1MjI1LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDMxNTQyLCAib3V0cHV0X3Rva2VucyI6IDE3MDIsICJ0b3RhbF90b2tlbnMiOiAzMzI0NCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNSI6IHsiaW5wdXRfdG9rZW5zIjogMjAxNywgIm91dHB1dF90b2tlbnMiOiA4OTQsICJ0b3RhbF90b2tlbnMiOiAyOTExLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE5ODk0LCAib3V0cHV0X3Rva2VucyI6IDE0NDcsICJ0b3RhbF90b2tlbnMiOiAyMTM0MSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNSI6IHsiaW5wdXRfdG9rZW5zIjogMzIxNywgIm91dHB1dF90b2tlbnMiOiA2NTUsICJ0b3RhbF90b2tlbnMiOiAzODcyLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDI0NzkzLCAib3V0cHV0X3Rva2VucyI6IDE1NDQsICJ0b3RhbF90b2tlbnMiOiAyNjMzNywgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNSI6IHsiaW5wdXRfdG9rZW5zIjogMjgyMywgIm91dHB1dF90b2tlbnMiOiAxODQzLCAidG90YWxfdG9rZW5zIjogNDY2NiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyOTAyNywgIm91dHB1dF90b2tlbnMiOiAxNTE3LCAidG90YWxfdG9rZW5zIjogMzA1NDQsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDM1MDYsICJvdXRwdXRfdG9rZW5zIjogNjcyLCAidG90YWxfdG9rZW5zIjogNDE3OCwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiAyNTk4OSwgIm91dHB1dF90b2tlbnMiOiAxNTM4LCAidG90YWxfdG9rZW5zIjogMjc1MjcsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX17ImFudGhyb3BpYy9jbGF1ZGUtb3B1cy00LTEtMjAyNTA4MDUiOiB7ImlucHV0X3Rva2VucyI6IDM4LCAib3V0cHV0X3Rva2VucyI6IDE5MjIsICJ0b3RhbF90b2tlbnMiOiAxOTYwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE1NjA1LCAib3V0cHV0X3Rva2VucyI6IDE1NTQsICJ0b3RhbF90b2tlbnMiOiAxNzE1OSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNSI6IHsiaW5wdXRfdG9rZW5zIjogMTAxLCAib3V0cHV0X3Rva2VucyI6IDE3ODIsICJ0b3RhbF90b2tlbnMiOiAxODgzLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDE1Mjg0LCAib3V0cHV0X3Rva2VucyI6IDE1NjEsICJ0b3RhbF90b2tlbnMiOiAxNjg0NSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNSI6IHsiaW5wdXRfdG9rZW5zIjogMjI2MTcsICJvdXRwdXRfdG9rZW5zIjogMzQyNywgInRvdGFsX3Rva2VucyI6IDI2MDQ0LCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDEzNTUyOCwgIm91dHB1dF90b2tlbnMiOiAxMzc0LCAidG90YWxfdG9rZW5zIjogMTM2OTAyLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1IjogeyJpbnB1dF90b2tlbnMiOiAxNjcsICJvdXRwdXRfdG9rZW5zIjogMjkwMSwgInRvdGFsX3Rva2VucyI6IDMwNjgsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfSwgImFudGhyb3BpYy9jbGF1ZGUtMy01LWhhaWt1LWxhdGVzdCI6IHsiaW5wdXRfdG9rZW5zIjogMjExODksICJvdXRwdXRfdG9rZW5zIjogMTkwMywgInRvdGFsX3Rva2VucyI6IDIzMDkyLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH19eyJhbnRocm9waWMvY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1IjogeyJpbnB1dF90b2tlbnMiOiAxMjEyLCAib3V0cHV0X3Rva2VucyI6IDMxMzgsICJ0b3RhbF90b2tlbnMiOiA0MzUwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3dyaXRlIjogMCwgImlucHV0X3Rva2Vuc19jYWNoZV9yZWFkIjogMH0sICJhbnRocm9waWMvY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiOiB7ImlucHV0X3Rva2VucyI6IDI3MTc3LCAib3V0cHV0X3Rva2VucyI6IDE2ODUsICJ0b3RhbF90b2tlbnMiOiAyODg2MiwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9fXsiYW50aHJvcGljL2NsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNSI6IHsiaW5wdXRfdG9rZW5zIjogNTg4OCwgIm91dHB1dF90b2tlbnMiOiAzMjY3LCAidG90YWxfdG9rZW5zIjogOTE1NSwgImlucHV0X3Rva2Vuc19jYWNoZV93cml0ZSI6IDAsICJpbnB1dF90b2tlbnNfY2FjaGVfcmVhZCI6IDB9LCAiYW50aHJvcGljL2NsYXVkZS0zLTUtaGFpa3UtbGF0ZXN0IjogeyJpbnB1dF90b2tlbnMiOiA1MTQ1MywgIm91dHB1dF90b2tlbnMiOiAxMjI1LCAidG90YWxfdG9rZW5zIjogNTI2NzgsICJpbnB1dF90b2tlbnNfY2FjaGVfd3JpdGUiOiAwLCAiaW5wdXRfdG9rZW5zX2NhY2hlX3JlYWQiOiAwfX0AAEa28/3UwF9AmG4Sg8AGZUAQWDm0yApmQFpkO99PhWZAJQaBlUPzZkCq8dJNYqRnQARWDi2yFWlAAiuHFtlqaUCiRbbz/YxqQKJFtvP9HG5AhetRuB7xYkAfhetRuK5dQEw3iUFgmWBAGy/dJAZxYECBlUOLbGNhQDVeukkMAmZASgwCK4eGZUC6SQwCK0dhQCuHFtnO52pAvHSTGASqaUD2KFyPwmlkQH9qvHST9GJA2c73U+PpZ0DHSzeJQdxkQEjhehSu22lALbKd76c2SkCiRbbz/dRLQESLbOf7qU9AJzEIrBwCUUASg8DKoe1RQEoMAiuH1lJAI9v5fmq0U0AzMzMzM8NUQI2XbhKDoFVAoBov3SQeWkCkcD0K12NdQARWDi2y9V9AppvEILB+YUDByqFFtjNgQEw3iUFg/WFA46WbxCAEY0CDwMqhRcZhQBBYObTIfmNAVg4tsp1PYkDP91PjpfNlQCPb+X5qzF9AiUFg5dCiX0CsHFpkO9deQIts5/updWBApHA9Cte3ZEAhsHJoka1aQN9PjZdukl5AyXa+nxo7YECTGARWDlFhQOOlm8Qg4GFAwcqhRbYrYkC6SQwCKytjQJzEILByZGNAZmZmZmYaZED6fmq8dHtvQIlBYOXQ0mlAUI2XbhKvbUC4HoXrUYBsQAaBlUOLoG9AH4XrUbiKbkBqvHSTGDRuQLTIdr6fam5Abef7qfGWcUAhsHJokRFxQEjhehSud2hAppvEILDCY0BvEoPAyi1tQP7UeOkmAWdA/tR46SZtZkDXo3A9CjNmQPyp8dJNgk1A4XoUrkfBVkArhxbZzvdXQNejcD0Kn1hA16NwPQofXECgGi/dJNZcQDVeukkM0l1Ac2iR7Xz7YEBt5/up8aJiQLTIdr6flmRAiUFg5dCybECDwMqhRWZsQPLSTWIQxGxAj8L1KFzbbkDRItv5fqZwQL6fGi/d0HBAc2iR7XwDcEB/arx0k1ByQAaBlUOL5G5AXrpJDAL5cEBYObTIdqJnQKJFtvP9ZG1A+FPjpZs8a0CuR+F6FJJpQKRwPQrXb2lARrbz/dTAX0CYbhKDwAZlQBBYObTICmZAWmQ730+FZkAlBoGVQ/NmQKrx0k1ipGdABFYOLbIVaUACK4cW2WppQKJFtvP9jGpAokW28/0cbkCF61G4HvFiQB+F61G4rl1ATDeJQWCZYEAbL90kBnFgQIGVQ4tsY2FANV66SQwCZkBKDAIrh4ZlQLpJDAIrR2FAK4cW2c7nakC8dJMYBKppQPYoXI/CaWRAf2q8dJP0YkDZzvdT4+lnQMdLN4lB3GRASOF6FK7baUAtsp3vpzZKQKJFtvP91EtARIts5/upT0AnMQisHAJRQBKDwMqh7VFASgwCK4fWUkAj2/l+arRTQDMzMzMzw1RAjZduEoOgVUCgGi/dJB5aQKRwPQrXY11ABFYOLbL1X0Cmm8QgsH5hQMHKoUW2M2BATDeJQWD9YUDjpZvEIARjQIPAyqFFxmFAEFg5tMh+Y0BWDi2ynU9iQM/3U+Ol82VAI9v5fmrMX0CJQWDl0KJfQKwcWmQ7115Ai2zn+6l1YECkcD0K17dkQCGwcmiRrVpA30+Nl26SXkDJdr6fGjtgQJMYBFYOUWFA46WbxCDgYUDByqFFtitiQLpJDAIrK2NAnMQgsHJkY0BmZmZmZhpkQPp+arx0e29AiUFg5dDSaUBQjZduEq9tQLgehetRgGxABoGVQ4ugb0AfhetRuIpuQGq8dJMYNG5AtMh2vp9qbkBt5/up8ZZxQCGwcmiREXFASOF6FK53aECmm8QgsMJjQG8Sg8DKLW1A/tR46SYBZ0D+1HjpJm1mQNejcD0KM2ZA/Knx0k2CTUDhehSuR8FWQCuHFtnO91dA16NwPQqfWEDXo3A9Ch9cQKAaL90k1lxANV66SQzSXUBzaJHtfPtgQG3n+6nxomJAtMh2vp+WZECJQWDl0LJsQIPAyqFFZmxA8tJNYhDEbECPwvUoXNtuQNEi2/l+pnBAvp8aL93QcEBzaJHtfANwQH9qvHSTUHJABoGVQ4vkbkBeukkMAvlwQFg5tMh2omdAokW28/1kbUD4U+OlmzxrQK5H4XoUkmlApHA9CtdvaUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAAADAAAABIAAAAYAAAAHgAAACQAAAAqAAAAMAAAADYAAAA8AAAAQgAAAEgAAABOAAAAVAAAAFoAAABgAAAAZgAAAGwAAAByAAAAeAAAAH4AAACEAAAAigAAAJAAAACWAAAAnAAAAKIAAACoAAAArgAAALQAAAC6AAAAwAAAAMYAAADMAAAA0gAAANgAAADeAAAA5AAAAOoAAADwAAAA9gAAAPwAAAACAQAACAEAAA4BAAAUAQAAGgEAACABAAAmAQAALAEAADUBAAA+AQAARwEAAFABAABZAQAAYgEAAGsBAAB0AQAAfQEAAIYBAACPAQAAmAEAAKEBAACqAQAAswEAALwBAADFAQAAzgEAANcBAADgAQAA6QEAAPIBAAD7AQAABAIAAA0CAAAWAgAAHwIAACgCAAAxAgAAOgIAAEMCAABMAgAAVQIAAF4CAABnAgAAcAIAAHkCAACCAgAAiwIAAJQCAACdAgAApgIAAK8CAAC4AgAAwQIAAMoCAADTAgAA3AIAAOUCAADuAgAAAAAAAE9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSU9wZW5BSUFudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpY0FudGhyb3BpYwAAAAAAAAUAAAAKAAAADwAAABQAAAAZAAAAHgAAACMAAAAoAAAALQAAADIAAAA3AAAAPAAAAEEAAABGAAAASwAAAFAAAABVAAAAWgAAAF8AAABkAAAAaQAAAG4AAABzAAAAeAAAAH0AAACDAAAAiQAAAI8AAACVAAAAmwAAAKEAAACnAAAArQAAALMAAAC5AAAAvwAAAMUAAADLAAAA0QAAANcAAADdAAAA4wAAAOkAAADvAAAA9QAAAPsAAAABAQAABwEAAA0BAAATAQAAJAEAADUBAABGAQAAVwEAAGgBAAB5AQAAigEAAJsBAACsAQAAvQEAAM4BAADfAQAA8AEAAAECAAASAgAAIwIAADQCAABFAgAAVgIAAGcCAAB4AgAAiQIAAJoCAACrAgAAvAIAAMsCAADaAgAA6QIAAPgCAAAHAwAAFgMAACUDAAA0AwAAQwMAAFIDAABhAwAAcAMAAH8DAACOAwAAnQMAAKwDAAC7AwAAygMAANkDAADoAwAA9wMAAAYEAAAVBAAAJAQAADMEAAAAAAAAR1BULTVHUFQtNUdQVC01R1BULTVHUFQtNUdQVC01R1BULTVHUFQtNUdQVC01R1BULTVHUFQtNUdQVC01R1BULTVHUFQtNUdQVC01R1BULTVHUFQtNUdQVC01R1BULTVHUFQtNUdQVC01R1BULTVHUFQtNUdQVC01R1BULTVHUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9HUFQtNG9DbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBTb25uZXQgMy43Q2xhdWRlIFNvbm5ldCAzLjdDbGF1ZGUgU29ubmV0IDMuN0NsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMUNsYXVkZSBPcHVzIDQuMQAAAAAAAAAAAAAA/P//////DwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAQAAAAGAAAACAAAAAoAAAAMAAAADgAAABAAAAASAAAAFAAAABYAAAAYAAAAGgAAABwAAAAeAAAAIAAAACIAAAAkAAAAJgAAACgAAAAqAAAALAAAAC4AAAAwAAAAMgAAADQAAAA2AAAAOAAAADoAAAA8AAAAPgAAAAAAQAACAEAABABAAAYAQAAIAEAACgBAAAwAQAAOAEAAEABAABIAQAAUAEAAFgBAABgAQAAaAEAAHABAAB4AQAAgAEAAIgBAACQAQAAAAAAADIwMjUwMjE5MjAyNTAyMTkyMDI1MDIxOTIwMjUwMjE5MjAyNTAyMTkyMDI1MDIxOTIwMjUwMjE5MjAyNTAyMTkyMDI1MDIxOTIwMjUwMjE5MjAyNTAyMTkyMDI1MDIxOTIwMjUwMjE5MjAyNTAyMTkyMDI1MDIxOTIwMjUwMjE5MjAyNTAyMTkyMDI1MDIxOTIwMjUwMjE5MjAyNTAyMTkyMDI1MDIxOTIwMjUwMjE5MjAyNTAyMTkyMDI1MDIxOTIwMjUwMjE5MjAyNTA4MDUyMDI1MDgwNTIwMjUwODA1MjAyNTA4MDUyMDI1MDgwNTIwMjUwODA1MjAyNTA4MDUyMDI1MDgwNTIwMjUwODA1MjAyNTA4MDUyMDI1MDgwNTIwMjUwODA1MjAyNTA4MDUyMDI1MDgwNTIwMjUwODA1MjAyNTA4MDUyMDI1MDgwNTIwMjUwODA1MjAyNTA4MDUyMDI1MDgwNTIwMjUwODA1MjAyNTA4MDUyMDI1MDgwNTIwMjUwODA1MjAyNTA4MDVTTwAAU08AAFNPAABTTwAAU08AAFNPAABTTwAAU08AAFNPAABTTwAAU08AAFNPAABTTwAAU08AAFNPAABTTwAAU08AAFNPAABTTwAAU08AAFNPAABTTwAAU08AAFNPAABTTwAAkE0AAJBNAACQTQAAkE0AAJBNAACQTQAAkE0AAJBNAACQTQAAkE0AAJBNAACQTQAAkE0AAJBNAACQTQAAkE0AAJBNAACQTQAAkE0AAJBNAACQTQAAkE0AAJBNAACQTQAAkE0AAKpOAACqTgAAqk4AAKpOAACqTgAAqk4AAKpOAACqTgAAqk4AAKpOAACqTgAAqk4AAKpOAACqTgAAqk4AAKpOAACqTgAAqk4AAKpOAACqTgAAqk4AAKpOAACqTgAAqk4AAKpOAADkTQAA5E0AAORNAADkTQAA5E0AAORNAADkTQAA5E0AAORNAADkTQAA5E0AAORNAADkTQAA5E0AAORNAADkTQAA5E0AAORNAADkTQAA5E0AAORNAADkTQAA5E0AAORNAADkTQAAHE4AABxOAAAcTgAAHE4AABxOAAAcTgAAHE4AABxOAAAcTgAAHE4AABxOAAAcTgAAHE4AABxOAAAcTgAAHE4AABxOAAAcTgAAHE4AABxOAAAcTgAAHE4AABxOAAAcTgAAHE4AAOtMAADrTAAA60wAAOtMAADrTAAA60wAAOtMAADrTAAA60wAAOtMAADrTAAA60wAAOtMAADrTAAA60wAAOtMAADrTAAA60wAAOtMAADrTAAA60wAAOtMAADrTAAA60wAAOtMAAA8TgAAPE4AADxOAAA8TgAAPE4AADxOAAA8TgAAPE4AADxOAAA8TgAAPE4AADxOAAA8TgAAPE4AADxOAAA8TgAAPE4AADxOAAA8TgAAPE4AADxOAAA8TgAAPE4AADxOAAA8TgAAtE4AALROAAC0TgAAtE4AALROAAC0TgAAtE4AALROAAC0TgAAtE4AALROAAC0TgAAtE4AALROAAC0TgAAtE4AALROAAC0TgAAtE4AALROAAC0TgAAtE4AALROAAC0TgAAtE4AAAAAAACKAAAAFAEAAJ8BAAApAgAAswIAAD0DAADHAwAAUQQAANsEAABlBQAA8AUAAHsGAAAGBwAAkQcAABwIAACnCAAAMgkAAL0JAABICgAA0woAAF4LAADpCwAAdAwAAP8MAACKDQAAFQ4AAJ8OAAApDwAAsw8AAD0QAADHEAAAUREAANsRAABlEgAA7xIAAHoTAAAFFAAAkBQAABsVAACmFQAAMRYAALwWAABHFwAA0hcAAF0YAADoGAAAcxkAAP4ZAACJGgAAFBsAAJ4bAAAoHAAAshwAADwdAADGHQAAUB4AANoeAABkHwAA7x8AAHkgAAAEIQAAjyEAABoiAAClIgAAMCMAALsjAABGJAAA0SQAAFwlAADnJQAAciYAAP0mAACIJwAAEygAAJ4oAAApKQAAsykAAD0qAADHKgAAUSsAANsrAABlLAAA7ywAAHktAAADLgAAji4AABkvAACkLwAALzAAALowAABFMQAA0DEAAFsyAADmMgAAcTMAAPwzAACHNAAAEjUAAJ01AAAoNgAAAAAAAGh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL3NhbXBsZXMvc2FtcGxlLzgvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL3NhbXBsZXMvc2FtcGxlLzkvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL3NhbXBsZXMvc2FtcGxlLzEwLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS81LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS83LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS82LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS8yLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS8zLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS80LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS8xLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS8xMS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTUvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL3NhbXBsZXMvc2FtcGxlLzEzLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS8xOC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTcvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL3NhbXBsZXMvc2FtcGxlLzEyLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS8xNC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMjAvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL3NhbXBsZXMvc2FtcGxlLzE2LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS8xOS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMjEvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL3NhbXBsZXMvc2FtcGxlLzIzLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1BMd2s4RHhnZEtQdFo5cVZIMmFwV3IuZXZhbC9zYW1wbGVzL3NhbXBsZS8yMi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9QTHdrOER4Z2RLUHRaOXFWSDJhcFdyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMjUvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfUEx3azhEeGdkS1B0WjlxVkgyYXBXci5ldmFsL3NhbXBsZXMvc2FtcGxlLzI0LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9zYW1wbGVzL3NhbXBsZS8xMC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvOS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvOC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvNC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvNS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvNy8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvMy8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvMS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvNi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvMi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTEvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL3NhbXBsZXMvc2FtcGxlLzEzLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9zYW1wbGVzL3NhbXBsZS8xMi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTcvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL3NhbXBsZXMvc2FtcGxlLzE1LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9zYW1wbGVzL3NhbXBsZS8xNC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTgvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL3NhbXBsZXMvc2FtcGxlLzE2LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9zYW1wbGVzL3NhbXBsZS8yMC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTkvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL3NhbXBsZXMvc2FtcGxlLzIxLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9zYW1wbGVzL3NhbXBsZS8yMy8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9rb2Uzam9LcG1RUmdwa1lZbXozZnByLmV2YWwvc2FtcGxlcy9zYW1wbGUvMjQvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfa29lM2pvS3BtUVJncGtZWW16M2Zwci5ldmFsL3NhbXBsZXMvc2FtcGxlLzI1LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX2tvZTNqb0twbVFSZ3BrWVltejNmcHIuZXZhbC9zYW1wbGVzL3NhbXBsZS8yMi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvNC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvNS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvNy8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMy8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvNi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvOC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvOS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTAvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL3NhbXBsZXMvc2FtcGxlLzEvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL3NhbXBsZXMvc2FtcGxlLzExLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9zYW1wbGVzL3NhbXBsZS8xMy8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTUvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL3NhbXBsZXMvc2FtcGxlLzEyLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9zYW1wbGVzL3NhbXBsZS8xNC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTcvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL3NhbXBsZXMvc2FtcGxlLzE4LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9zYW1wbGVzL3NhbXBsZS8xNi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMTkvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL3NhbXBsZXMvc2FtcGxlLzIwLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9zYW1wbGVzL3NhbXBsZS8yMy8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMjEvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfOHZhZkFYRDg1V2Q0RFhUZ3pldkd0Mi5ldmFsL3NhbXBsZXMvc2FtcGxlLzIyLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoXzh2YWZBWEQ4NVdkNERYVGd6ZXZHdDIuZXZhbC9zYW1wbGVzL3NhbXBsZS8yNC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF84dmFmQVhEODVXZDREWFRnemV2R3QyLmV2YWwvc2FtcGxlcy9zYW1wbGUvMjUvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL3NhbXBsZXMvc2FtcGxlLzEwLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS84LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS83LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS85LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS80LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS81LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS82LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS8zLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS8yLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS8xLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS8xMS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvc2FtcGxlcy9zYW1wbGUvMTIvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL3NhbXBsZXMvc2FtcGxlLzEzLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS8xNS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvc2FtcGxlcy9zYW1wbGUvMTQvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL3NhbXBsZXMvc2FtcGxlLzE3LzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS8xOC8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvc2FtcGxlcy9zYW1wbGUvMTYvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL3NhbXBsZXMvc2FtcGxlLzIwLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS8xOS8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvc2FtcGxlcy9zYW1wbGUvMjMvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL3NhbXBsZXMvc2FtcGxlLzIxLzFodHRwczovL3NhbXBsZXMubWVyaWRpYW5sYWJzLmFpLyMvbG9ncy93cml0aW5nX2JlbmNoLzIwMjUtMDgtMTRUMTYtMDItMjctMDQtMDBfd3JpdGluZ2JlbmNoX1lDTVV4aldZTFI5QmVCZXJMTHFYekQuZXZhbC9zYW1wbGVzL3NhbXBsZS8yMi8xaHR0cHM6Ly9zYW1wbGVzLm1lcmlkaWFubGFicy5haS8jL2xvZ3Mvd3JpdGluZ19iZW5jaC8yMDI1LTA4LTE0VDE2LTAyLTI3LTA0LTAwX3dyaXRpbmdiZW5jaF9ZQ01VeGpXWUxSOUJlQmVyTExxWHpELmV2YWwvc2FtcGxlcy9zYW1wbGUvMjQvMWh0dHBzOi8vc2FtcGxlcy5tZXJpZGlhbmxhYnMuYWkvIy9sb2dzL3dyaXRpbmdfYmVuY2gvMjAyNS0wOC0xNFQxNi0wMi0yNy0wNC0wMF93cml0aW5nYmVuY2hfWUNNVXhqV1lMUjlCZUJlckxMcVh6RC5ldmFsL3NhbXBsZXMvc2FtcGxlLzI1LzH/////AAAAAA=="},"tooltip":null}},"7adb0847128846469cbd44bca5f0e6c5":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz.plot._legend.Legend","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  if (options.frameAnchor === \"bottom\" || options.frameAnchor === \"top\") {\n    legendContainerEl.style.padding = \"0 0.3em\";\n  } else {\n    legendContainerEl.style.padding = \"0.3em\";\n  }\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    const backgroundDefaultColor = \"var(--bs-body-bg, var(--jp-cell-editor-background, #ffffff))\";\n    targetEl.style.background = background === true ? backgroundDefaultColor : background || backgroundDefaultColor;\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_e6c0771c419c4918866b69e089e5cd0c","spec":"","tabbable":null,"tables":{},"tooltip":null}},"9dca8ca926c94032924dd6d15415597b":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"bd01a5a407664d389148d161333f37f6":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"c58f0ac6b78347c8bcbb5780de7ba889":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"e6c0771c419c4918866b69e089e5cd0c":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"e8851a7cb7804519afd6cd89031f6f88":{"model_module":"anywidget","model_module_version":"~0.9.*","model_name":"AnyModel","state":{"_anywidget_id":"inspect_viz._core.component.Component","_css":"","_dom_classes":[],"_esm":"// js/widgets/mosaic.ts\nimport {\n  parseSpec\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\nimport { throttle as throttle3 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\n\n// js/context/index.ts\nimport { wasmConnector } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { InstantiateContext } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-spec@0.16.2/+esm\";\n\n// js/inputs/choice.ts\nimport {\n  isParam,\n  isSelection,\n  clausePoint,\n  clausePoints,\n  toDataColumns\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  Query\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\n\n// js/util/object.ts\nvar isObject = (v) => {\n  return v !== null && typeof v === \"object\" && !Array.isArray(v);\n};\n\n// js/inputs/input.ts\nimport {\n  coordinator,\n  MosaicClient\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nfunction input(InputClass, ...params) {\n  const input2 = new InputClass(...params);\n  coordinator().connect(input2);\n  return input2.element;\n}\nvar Input = class extends MosaicClient {\n  element;\n  constructor(filterBy) {\n    super(filterBy);\n    this.element = document.createElement(\"div\");\n    Object.defineProperty(this.element, \"value\", { value: this });\n  }\n  activate() {\n  }\n};\n\n// js/util/id.ts\nfunction generateId() {\n  return \"id-\" + Math.random().toString(36).substring(2) + Date.now().toString(36);\n}\n\n// js/inputs/util.ts\nfunction createFieldset(legend) {\n  const fieldset = window.document.createElement(\"fieldset\");\n  if (legend) {\n    const legendEl = window.document.createElement(\"legend\");\n    legendEl.innerText = legend;\n    fieldset.append(legend);\n  }\n  return fieldset;\n}\nfunction setFieldsetOptions(fieldset, options, type) {\n  fieldset.querySelectorAll(\"input, label\").forEach((el) => {\n    el.remove();\n  });\n  const name = generateId();\n  for (const { value, label } of options || []) {\n    const { inputLabel } = createLabeledInput(type, label, name, value);\n    fieldset.appendChild(inputLabel);\n  }\n}\nfunction createLabeledInput(type, label, name, value) {\n  const inputLabel = window.document.createElement(\"label\");\n  const input2 = window.document.createElement(\"input\");\n  input2.type = type;\n  if (name) {\n    input2.name = name;\n  }\n  if (value) {\n    input2.value = value;\n  }\n  inputLabel.appendChild(input2);\n  inputLabel.appendChild(window.document.createTextNode(` ${label || value}`));\n  return { inputLabel, input: input2 };\n}\nfunction setupActivationListeners(input2, element) {\n  element.addEventListener(\"pointerenter\", (evt) => {\n    if (!evt.buttons) input2.activate();\n  });\n  element.addEventListener(\"focus\", () => input2.activate());\n}\n\n// js/inputs/choice.ts\nvar ChoiceInput = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n  }\n  data_ = [];\n  activate() {\n    if (isSelection(this.options_.as) && this.options_.column) {\n      const field = this.options_.field || this.options_.column;\n      this.options_.as.activate(clausePoint(field, void 0, { source: this }));\n    }\n  }\n  publish(value) {\n    const { as, field, column: column2 } = this.options_;\n    if (isSelection(as) && column2) {\n      let clause = clausePoint(field || column2, void 0, { source: this });\n      if (Array.isArray(value) && value.length > 0) {\n        clause = clausePoints(\n          [field || column2],\n          value.map((v) => [v]),\n          { source: this }\n        );\n      } else if (value?.length) {\n        clause = clausePoint(field || column2, value, { source: this });\n      }\n      as.update(clause);\n    } else if (isParam(as)) {\n      as.update(value);\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from) {\n      return null;\n    }\n    if (!column2) {\n      throw new Error(\"You must specify a column along with a data source\");\n    }\n    return Query.from(from).select({ value: column2 }).distinct().where(...filter).orderby(column2);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData([{ value: \"\", label: \"All\" }, ...this.queryResultOptions(data)]);\n    }\n    return this;\n  }\n  queryResultOptions(data) {\n    const columns = toDataColumns(data);\n    const values = columns.columns.value;\n    return values.map((v) => ({ value: v }));\n  }\n  setOptions(options) {\n    this.setData(options.map((opt) => isObject(opt) ? opt : { value: opt }));\n    this.update();\n  }\n  setupParamListener() {\n    if (!isSelection(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        this.selectedValue = value;\n      });\n    }\n  }\n  setupActivationListeners(element) {\n    if (isSelection(this.options_.as)) {\n      setupActivationListeners(this, element);\n    }\n  }\n  updateSelectedValue() {\n    const value = isSelection(this.options_.as) ? this.options_.as.valueFor(this) : this.options_.as.value;\n    this.selectedValue = value === void 0 ? \"\" : value;\n  }\n  setData(options) {\n    if (!isSelection(this.options_.as)) {\n      const paramValue = this.options_.as.value;\n      if (paramValue && !Array.isArray(paramValue) && !options.some((option) => option.value === paramValue)) {\n        options = [...options, { value: paramValue }];\n      }\n    }\n    this.data_ = options;\n  }\n};\n\n// js/inputs/radio_group.ts\nvar RadioGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.selectedValue = \"\";\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"radio\") {\n          this.publish(this.selectedValue ?? null);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelector(\n      'input[type=\"radio\"]:checked'\n    );\n    return checked?.value ? checked.value === \"on\" ? \"\" : checked.value : \"\";\n  }\n  set selectedValue(value) {\n    value = value === \"\" ? \"on\" : value;\n    const radios = this.fieldset_.querySelectorAll('input[type=\"radio\"]');\n    for (const radio of radios) {\n      if (radio.value === value) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event(\"change\", { bubbles: true }));\n        break;\n      }\n    }\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"radio\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/types.ts\nvar kSidebarFullwidth = \"sidebar-fullwidth\";\nvar kInputSearch = \"input-search\";\n\n// js/inputs/select.ts\nimport TomSelect from \"https://cdn.jsdelivr.net/npm/tom-select@2.4.3/+esm\";\nimport { isSelection as isSelection2 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Select = class extends ChoiceInput {\n  select_;\n  multiple_;\n  allowEmpty_;\n  initialValue_;\n  tomSelect_ = void 0;\n  constructor(options) {\n    super(options);\n    this.multiple_ = options.multiple ?? false;\n    this.allowEmpty_ = options.value === \"all\";\n    this.initialValue_ = options.value === \"all\" || options.value === \"auto\" ? void 0 : options.value;\n    this.element.classList.add(kSidebarFullwidth);\n    let labelEl = null;\n    if (options.label !== void 0) {\n      labelEl = window.document.createElement(\"label\");\n      labelEl.innerText = options.label;\n      this.element.appendChild(labelEl);\n    }\n    this.select_ = document.createElement(\"select\");\n    if (options.width) {\n      this.select_.style.width = `${options.width}px`;\n    }\n    this.select_.id = generateId();\n    if (labelEl) {\n      labelEl.appendChild(this.select_);\n    } else {\n      this.element.appendChild(this.select_);\n    }\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    if (this.initialValue_ !== void 0 && isSelection2(this.options_.as)) {\n      this.publish(options.value);\n    }\n    this.select_.addEventListener(\"input\", () => {\n      this.publish(this.selectedValue ?? null);\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.select_);\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      if (this.multiple_ || !this.allowEmpty_) {\n        this.setData(this.queryResultOptions(data));\n        return this;\n      } else {\n        return super.queryResult(data);\n      }\n    } else {\n      return this;\n    }\n  }\n  get selectedValue() {\n    return this.tomSelect_?.getValue() ?? \"\";\n  }\n  set selectedValue(value) {\n    this.tomSelect_?.setValue(value);\n  }\n  update() {\n    if (!this.tomSelect_) {\n      if (this.multiple_) {\n        this.select_.multiple = true;\n      }\n      const config = {\n        create: false,\n        dropdownParent: \"body\"\n      };\n      if (!this.select_.multiple) {\n        config.allowEmptyOption = this.allowEmpty_;\n        config.controlInput = null;\n      } else {\n        config.plugins = {\n          remove_button: {\n            title: \"Remove this item\"\n          }\n        };\n      }\n      this.tomSelect_ = new TomSelect(this.select_, config);\n      if (this.multiple_) {\n        this.tomSelect_.on(\"item_add\", () => {\n          this.tomSelect_.control_input.value = \"\";\n          this.tomSelect_?.refreshOptions(false);\n        });\n      }\n      const defaultValue = this.initialValue_ ?? (this.allowEmpty_ ? \"\" : this.data_?.[0].value);\n      const value = isSelection2(this.options_.as) ? defaultValue : this.options_.as.value || defaultValue;\n      this.selectedValue = value;\n      this.publish(value);\n    }\n    this.tomSelect_.clearOptions();\n    this.tomSelect_.addOptions(\n      this.data_.map((o) => ({ value: o.value, text: o.label || o.value }))\n    );\n    this.tomSelect_.refreshOptions(false);\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox_group.ts\nvar CheckboxGroup = class extends ChoiceInput {\n  fieldset_;\n  constructor(options) {\n    super(options);\n    this.fieldset_ = createFieldset(options.label);\n    this.element.append(this.fieldset_);\n    if (options.options) {\n      this.setOptions(options.options);\n    }\n    this.fieldset_.addEventListener(\"change\", (e) => {\n      if (e.target instanceof HTMLInputElement) {\n        if (e.target.type === \"checkbox\") {\n          this.publish(this.selectedValue ?? []);\n        }\n      }\n    });\n    this.setupParamListener();\n    this.setupActivationListeners(this.fieldset_);\n  }\n  get selectedValue() {\n    const checked = this.fieldset_.querySelectorAll(\n      'input[type=\"checkbox\"]:checked'\n    );\n    return Array.from(checked).map((checkbox) => checkbox.value);\n  }\n  set selectedValue(values) {\n    const checkboxes = this.fieldset_.querySelectorAll('input[type=\"checkbox\"]');\n    for (const checkbox of checkboxes) {\n      const input2 = checkbox;\n      const shouldBeChecked = values.includes(input2.value);\n      if (input2.checked !== shouldBeChecked) {\n        input2.checked = shouldBeChecked;\n        input2.dispatchEvent(new Event(\"change\", { bubbles: true }));\n      }\n    }\n  }\n  queryResult(data) {\n    if (this.options_.options === void 0) {\n      this.setData(this.queryResultOptions(data));\n    }\n    return this;\n  }\n  update() {\n    setFieldsetOptions(this.fieldset_, this.data_, \"checkbox\");\n    this.updateSelectedValue();\n    return this;\n  }\n};\n\n// js/inputs/checkbox.ts\nimport {\n  clausePoint as clausePoint2,\n  isParam as isParam2,\n  isSelection as isSelection3\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nvar Checkbox = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    const { inputLabel, input: input2 } = createLabeledInput(\"checkbox\", options_.label);\n    input2.id = generateId();\n    this.element.appendChild(inputLabel);\n    input2.checked = !isSelection3(this.options_.as) ? this.options_.as?.value ?? options_.checked : options_.checked;\n    const publish = () => this.publish(\n      input2.checked ? options_.values[0] || void 0 : options_.values[1] || void 0\n    );\n    input2.addEventListener(\"change\", publish);\n    publish();\n    if (!isSelection3(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        input2.checked = value === this.options_.values[0];\n      });\n    } else {\n      setupActivationListeners(this, input2);\n    }\n  }\n  activate() {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.activate(this.clause());\n    }\n  }\n  clause(value) {\n    if (!this.options_.field) {\n      throw new Error(\"checkbox 'field' option must be specified with selection\");\n    }\n    return clausePoint2(this.options_.field, value, { source: this });\n  }\n  publish(value) {\n    if (isSelection3(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam2(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n};\n\n// js/inputs/slider.ts\nimport {\n  clauseInterval,\n  clausePoint as clausePoint3,\n  isParam as isParam3,\n  isSelection as isSelection4\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  max,\n  min,\n  Query as Query2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  create as createSlider\n} from \"https://cdn.jsdelivr.net/npm/nouislider@15.8.1/+esm\";\nvar kSliderInput = \"slider-input\";\nvar Slider = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSliderInput, kSidebarFullwidth);\n    const id = generateId();\n    const label = options_.label;\n    let container = this.element;\n    if (label) {\n      container = window.document.createElement(\"label\");\n      container.innerText = label;\n      this.element.appendChild(container);\n    }\n    let { value, width, min: min3, max: max3 } = options_;\n    this.slider_ = document.createElement(\"div\");\n    this.slider_.classList.add(\"noUi-round\");\n    this.slider_.setAttribute(\"id\", id);\n    if (width != void 0) {\n      this.slider_.style.width = `${+width}px`;\n    }\n    if (container) {\n      container.appendChild(this.slider_);\n    } else {\n      this.element.appendChild(this.slider_);\n    }\n    this.sliderApi_ = createSlider(this.slider_, {\n      range: { min: 0, max: 0 },\n      connect: options_.select === \"interval\",\n      start: options_.select === \"interval\" ? [0, 0] : 0\n    });\n    this.curval_ = document.createElement(\"label\");\n    this.curval_.setAttribute(\"class\", \"slider-value\");\n    this.element.appendChild(this.curval_);\n    if (this.options_.as?.value === void 0) {\n      this.publish(value);\n    } else if (value === void 0) {\n      value = this.options_.as?.value;\n    }\n    this.updateCurrentValue();\n    if (!isSelection4(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value2) => {\n        if (!areEqual(value2, this.sliderValue)) {\n          this.sliderApi_.set(value2);\n          this.updateCurrentValue();\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.slider_);\n    }\n    if (!options_.from) {\n      min3 = min3 ?? (Array.isArray(value) ? value[0] : value ?? 0);\n      max3 = max3 ?? (Array.isArray(value) ? value[1] : value ?? 0);\n      const start = value ?? (options_.select === \"interval\" ? [0, 0] : 0);\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    }\n  }\n  slider_;\n  sliderApi_;\n  curval_;\n  firstQuery_ = false;\n  updateCurrentValue() {\n    const value = this.sliderValue;\n    if (Array.isArray(value)) {\n      this.curval_.innerText = `${value[0].toLocaleString()}-${value[1].toLocaleString()}`;\n    } else {\n      this.curval_.innerHTML = value.toLocaleString();\n    }\n  }\n  get sliderValue() {\n    const value = this.sliderApi_.get();\n    if (Array.isArray(value)) {\n      return value.map(cleanNumber).slice(0, 2);\n    } else {\n      return cleanNumber(value);\n    }\n  }\n  set sliderValue(value) {\n    this.sliderApi_.set(value, true);\n  }\n  activate() {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.activate(this.clause());\n    }\n  }\n  query(filter = []) {\n    const { from, column: column2 } = this.options_;\n    if (!from || !column2) {\n      return null;\n    }\n    return Query2.select({ min: min(column2), max: max(column2) }).from(from).where(...filter);\n  }\n  queryResult(data) {\n    const { min: dataMin, max: dataMax } = Array.from(data)[0];\n    const min3 = this.options_.min ?? dataMin;\n    const max3 = this.options_.max ?? dataMax;\n    let start = this.sliderValue;\n    if (!this.firstQuery_) {\n      this.firstQuery_ = true;\n      if (this.options_.value === void 0) {\n        start = this.options_.select === \"interval\" ? [min3, max3] : max3;\n      } else {\n        start = this.options_.value;\n      }\n      this.updateSlider(min3, max3, start);\n      this.sliderApi_.on(\"update\", () => {\n        this.updateCurrentValue();\n        this.publish(this.sliderValue);\n      });\n    } else {\n      this.updateSlider(min3, max3, start);\n    }\n    return this;\n  }\n  updateSlider(min3, max3, start) {\n    const step = this.options_.step ?? (min3 >= 5 || max3 >= 5 ? 1 : void 0);\n    this.sliderApi_.updateOptions(\n      {\n        range: {\n          min: min3,\n          max: max3\n        },\n        step,\n        start\n      },\n      true\n    );\n    return this;\n  }\n  clause(value) {\n    let { field, column: column2, min: min3, select = \"point\" } = this.options_;\n    field = field || column2;\n    if (!field) {\n      throw new Error(\n        \"You must specify a 'column' or 'field' for a slider targeting a selection.\"\n      );\n    }\n    if (select === \"interval\" && value !== void 0) {\n      const domain = Array.isArray(value) ? value : [min3 ?? 0, value];\n      return clauseInterval(field, domain, {\n        source: this,\n        bin: \"ceil\",\n        scale: { type: \"identity\", domain },\n        pixelSize: this.options_.step || void 0\n      });\n    } else {\n      return clausePoint3(field, Array.isArray(value) ? value[0] : value, {\n        source: this\n      });\n    }\n  }\n  publish(value) {\n    const target = this.options_.as;\n    if (isSelection4(target)) {\n      target.update(this.clause(value));\n    } else if (isParam3(target)) {\n      target.update(value);\n    }\n  }\n};\nfunction areEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.map(cleanNumber) === b.map(cleanNumber);\n  } else if (!Array.isArray(a) && !Array.isArray(b)) {\n    return cleanNumber(a) === cleanNumber(b);\n  } else {\n    return false;\n  }\n}\nfunction cleanNumber(num) {\n  if (typeof num === \"string\") {\n    num = parseFloat(num);\n  }\n  if (!isFinite(num)) return num;\n  if (num === 0) return 0;\n  const magnitude = Math.abs(num);\n  const epsilon = magnitude * Number.EPSILON * 100;\n  const rounded = Math.round(num);\n  if (Math.abs(num - rounded) < epsilon) {\n    return rounded;\n  }\n  return parseFloat(num.toPrecision(15));\n}\n\n// js/inputs/table.ts\nimport {\n  clausePoints as clausePoints2,\n  isSelection as isSelection5,\n  queryFieldInfo,\n  throttle,\n  toDataColumns as toDataColumns2\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport {\n  and,\n  asc,\n  contains,\n  desc,\n  eq,\n  gt,\n  gte,\n  isNull,\n  literal,\n  lt,\n  lte,\n  neq,\n  not,\n  or,\n  prefix,\n  suffix,\n  Query as Query3,\n  sql,\n  column,\n  avg,\n  count,\n  sum,\n  argmax,\n  mad,\n  max as max2,\n  min as min2,\n  product,\n  geomean,\n  median,\n  mode,\n  variance,\n  stddev,\n  skewness,\n  kurtosis,\n  entropy,\n  varPop,\n  stddevPop,\n  first,\n  last,\n  stringAgg,\n  arrayAgg,\n  argmin,\n  quantile,\n  corr,\n  covarPop,\n  regrIntercept,\n  regrSlope,\n  regrCount,\n  regrR2,\n  regrSXX,\n  regrSYY,\n  regrSXY,\n  regrAvgX,\n  regrAvgY\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nimport {\n  createGrid,\n  ModuleRegistry,\n  AllCommunityModule,\n  themeBalham\n} from \"https://cdn.jsdelivr.net/npm/ag-grid-community@33.3.2/+esm\";\nimport * as d3Format from \"https://cdn.jsdelivr.net/npm/d3-format@3.1.0/+esm\";\nimport * as d3TimeFormat from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\nvar kAutoRowCount = 12;\nvar kAutoRowMaxHeight = 380;\nvar Table = class extends Input {\n  constructor(options_) {\n    super(options_.filter_by);\n    this.options_ = options_;\n    ModuleRegistry.registerModules([AllCommunityModule]);\n    this.id_ = generateId();\n    this.currentRow_ = -1;\n    this.element.classList.add(\"inspect-viz-table\");\n    if (typeof this.options_.width === \"number\") {\n      this.element.style.width = `${this.options_.width}px`;\n    }\n    if (this.options_.max_width) {\n      this.element.style.maxWidth = `${this.options_.max_width}px`;\n    }\n    if (this.options_.auto_filling) {\n      this.element.style.height = `100%`;\n    } else if (this.options_.height && this.options_.height !== \"auto\") {\n      this.element.style.height = `${this.options_.height}px`;\n    }\n    if (this.options_.style) {\n      if (this.options_.style?.background_color) {\n        this.element.style.setProperty(\n          \"--ag-background-color\",\n          this.options_.style.background_color\n        );\n      }\n      if (this.options_.style?.foreground_color) {\n        this.element.style.setProperty(\n          \"--ag-foreground-color\",\n          this.options_.style.foreground_color\n        );\n      }\n      if (this.options_.style?.accent_color) {\n        this.element.style.setProperty(\n          \"--ag-accent-color\",\n          this.options_.style.accent_color\n        );\n      }\n    }\n    this.gridContainer_ = document.createElement(\"div\");\n    this.gridContainer_.id = this.id_;\n    this.gridContainer_.style.width = \"100%\";\n    this.gridContainer_.style.height = \"100%\";\n    this.element.appendChild(this.gridContainer_);\n    this.gridOptions_ = this.createGridOptions(this.options_);\n  }\n  id_;\n  columns_ = [];\n  columnsByName_ = {};\n  columnTypes_ = {};\n  gridContainer_;\n  grid_ = null;\n  gridOptions_;\n  currentRow_;\n  sortModel_ = [];\n  filterModel_ = {};\n  data_ = {\n    numRows: 0,\n    columns: {}\n  };\n  // contribute a selection clause back to the target selection\n  clause(rows = []) {\n    const fields = this.getDatabaseColumns().map((column2) => column2.column_id);\n    const values = rows.map((row) => {\n      return fields.map((f) => this.data_.columns[f][row]);\n    });\n    return clausePoints2(fields, values, { source: this });\n  }\n  // mosaic calls this and initialization to let us fetch the schema\n  // and do related setup\n  async prepare() {\n    const table = this.options_.from;\n    const schema = await queryFieldInfo(this.coordinator, [{ column: \"*\", table }]);\n    const userColumns = this.options_.columns ? this.options_.columns : schema.map((f) => f.column);\n    this.columns_ = resolveColumns(userColumns);\n    this.columnsByName_ = this.columns_.reduce(\n      (acc, col) => {\n        acc[col.column_name] = col;\n        return acc;\n      },\n      {}\n    );\n    this.columns_.filter((c) => c.type !== \"literal\").forEach((column2) => {\n      const item = schema.find((s) => s.column === column2.column_id);\n      if (item) {\n        this.columnTypes_[column2.column_name] = item.type;\n      }\n    });\n    this.getLiteralColumns().forEach((c) => {\n      const colVal = c.column;\n      if (Array.isArray(colVal)) {\n        const firstVal = colVal[0];\n        const typeStr = typeof firstVal === \"boolean\" ? \"boolean\" : typeof firstVal === \"number\" ? \"number\" : void 0;\n        if (typeStr) {\n          this.columnTypes_[c.column_name] = typeStr;\n        }\n      } else if (typeof colVal === \"boolean\") {\n        this.columnTypes_[c.column_name] = \"boolean\";\n      } else if (typeof colVal === \"number\") {\n        this.columnTypes_[c.column_name] = \"number\";\n      }\n    });\n    const columnDefs = this.columns_.map((column2) => {\n      const t = this.columnTypes_[column2.column_name];\n      return this.createColumnDef(column2.column_name, t);\n    });\n    this.gridOptions_.columnDefs = columnDefs;\n    this.grid_ = createGrid(this.gridContainer_, this.gridOptions_);\n  }\n  // mosaic calls this every time it needs to show data to find\n  // out what query we want to run\n  query(filter = []) {\n    const selectItems = {};\n    const groupBy = [];\n    let has_aggregate = false;\n    for (const column2 of this.getDatabaseColumns()) {\n      if (column2.type === \"aggregate\") {\n        const item = aggregateExpression(column2);\n        selectItems[item[0]] = item[1];\n        has_aggregate = true;\n      } else if (column2.type === \"column\") {\n        selectItems[column2.column_id] = column2.column_id;\n        groupBy.push(column2.column_id);\n      }\n    }\n    let query = Query3.from(this.options_.from).select(\n      Object.keys(selectItems).length ? selectItems : \"*\"\n    );\n    if (has_aggregate && groupBy.length > 0) {\n      query.groupby(groupBy);\n    }\n    query = query.where(...filter);\n    Object.keys(this.filterModel_).forEach((columnName) => {\n      const col = this.columnsByName_[columnName] || {};\n      if (col.type !== \"literal\") {\n        const useHaving = col.type === \"aggregate\";\n        const filter2 = this.filterModel_[columnName];\n        const expression = filterExpression(columnName, filter2, query);\n        if (expression) {\n          if (useHaving) {\n            query.having(expression);\n          } else {\n            query = query.where(expression);\n          }\n        }\n      }\n    });\n    if (this.sortModel_.length > 0) {\n      this.sortModel_.forEach((sort) => {\n        const col = this.columnsByName_[sort.colId] || {};\n        if (col.type !== \"literal\") {\n          query = query.orderby(sort.sort === \"asc\" ? asc(sort.colId) : desc(sort.colId));\n        }\n      });\n    }\n    return query;\n  }\n  // mosaic returns the results of the query() in this function.\n  queryResult(data) {\n    this.data_ = toDataColumns2(data);\n    return this;\n  }\n  // requests a client UI update (e.g. to reflect results from a query)\n  update() {\n    this.updateGrid(null);\n    return this;\n  }\n  updateGrid = throttle(async () => {\n    if (!this.grid_) {\n      return;\n    }\n    const rowData = [];\n    for (let i = 0; i < this.data_.numRows; i++) {\n      const row = {};\n      this.columns_.forEach(({ column_name, column: column2 }) => {\n        if (Array.isArray(column2)) {\n          const index = i % column2.length;\n          row[column_name] = column2[index];\n        } else if (typeof column2 === \"boolean\" || typeof column2 === \"number\") {\n          row[column_name] = column2;\n        } else {\n          row[column_name] = this.data_.columns[column_name][i];\n        }\n      });\n      rowData.push(row);\n    }\n    this.grid_.setGridOption(\"rowData\", rowData);\n    if (this.data_.numRows < kAutoRowCount && this.options_.height === void 0) {\n      this.grid_.setGridOption(\"domLayout\", \"autoHeight\");\n    } else if (!this.options_.auto_filling && (this.options_.height === \"auto\" || this.options_.height === void 0)) {\n      this.element.style.height = `${kAutoRowMaxHeight}px`;\n    }\n  });\n  createGridOptions(options) {\n    const headerHeightPixels = typeof options.header_height === \"string\" ? void 0 : options.header_height;\n    const hoverSelect = options.select === \"hover\";\n    const explicitSelection = resolveRowSelection(options);\n    const gridTheme = themeBalham.withParams({\n      textColor: this.options_.style?.text_color,\n      headerTextColor: this.options_.style?.header_text_color || this.options_.style?.text_color,\n      cellTextColor: this.options_.style?.cell_text_color,\n      fontFamily: this.options_.style?.font_family,\n      headerFontFamily: this.options_.style?.header_font_family || this.options_.style?.font_family,\n      cellFontFamily: this.options_.style?.cell_font_family || this.options_.style?.font_family,\n      spacing: this.options_.style?.spacing || 4,\n      borderColor: this.options_.style?.border_color,\n      borderRadius: this.options_.style?.border_radius,\n      selectedRowBackgroundColor: this.options_.style?.selected_row_background_color\n    });\n    const domLayout = this.options_.height === \"auto\" ? \"autoHeight\" : void 0;\n    return {\n      // always pass filter to allow server-side filtering\n      pagination: !!options.pagination,\n      paginationAutoPageSize: options.pagination?.page_size === \"auto\" || options.pagination?.page_size === void 0,\n      paginationPageSizeSelector: options.pagination?.page_size_selector,\n      paginationPageSize: typeof options.pagination?.page_size === \"number\" ? options.pagination.page_size : void 0,\n      animateRows: false,\n      headerHeight: headerHeightPixels,\n      rowHeight: options.row_height,\n      domLayout,\n      columnDefs: [],\n      rowData: [],\n      rowSelection: explicitSelection,\n      suppressCellFocus: true,\n      enableCellTextSelection: true,\n      theme: gridTheme,\n      onFilterChanged: () => {\n        this.filterModel_ = this.grid_?.getFilterModel() || {};\n        this.requestQuery();\n      },\n      onSortChanged: () => {\n        if (this.grid_) {\n          const sortModel = this.grid_.getColumnState().filter((col) => col.sort).map((col) => ({ colId: col.colId, sort: col.sort }));\n          this.sortModel_ = sortModel;\n          this.requestQuery();\n        }\n      },\n      onSelectionChanged: (event) => {\n        if (explicitSelection !== void 0 && isSelection5(this.options_.as)) {\n          if (event.selectedNodes) {\n            const rowIndices = event.selectedNodes.map((n) => n.rowIndex).filter((n) => n !== null);\n            this.options_.as.update(this.clause(rowIndices));\n          }\n        }\n      },\n      onCellMouseOver: (event) => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          const rowIndex = event.rowIndex;\n          if (rowIndex !== void 0 && rowIndex !== null && rowIndex !== this.currentRow_) {\n            this.currentRow_ = rowIndex;\n            this.options_.as.update(this.clause([rowIndex]));\n          }\n        }\n      },\n      onCellMouseOut: () => {\n        if (hoverSelect && isSelection5(this.options_.as)) {\n          this.currentRow_ = -1;\n          this.options_.as.update(this.clause());\n        }\n      },\n      onGridReady: () => {\n        this.patchGrid();\n      }\n    };\n  }\n  getLiteralColumns() {\n    return this.columns_.filter((c) => c.type === \"literal\");\n  }\n  getDatabaseColumns() {\n    return this.columns_.filter((c) => c.type === \"column\" || c.type === \"aggregate\");\n  }\n  createColumnDef(column_name, type) {\n    const column2 = this.columnsByName_[column_name] || {};\n    const align = column2.align || (type === \"number\" ? \"right\" : \"left\");\n    const headerAlignment = column2.header_align;\n    const formatter = formatterForType(type, column2.format);\n    const sortable = this.options_.sorting !== false && column2.sortable !== false;\n    const filterable = this.options_.filtering !== false && column2.filterable !== false;\n    const resizable = column2.resizable !== false;\n    const minWidth = column2.min_width;\n    const maxWidth = column2.max_width;\n    const autoHeight = column2.auto_height;\n    const autoHeaderHeight = this.options_.header_height === \"auto\" && column2.header_auto_height !== false;\n    const wrapText = column2.wrap_text;\n    const wrapHeaderText = column2.header_wrap_text;\n    const flex = column2.flex;\n    const disableClientSort = (_valueA, _valueB) => {\n      return 0;\n    };\n    const filter = filterable ? filterForColumnType(type) : void 0;\n    const colDef = {\n      field: column_name,\n      headerName: column2.label || column_name,\n      headerClass: headerClasses(headerAlignment),\n      cellStyle: { textAlign: align },\n      comparator: column2.type !== \"literal\" ? disableClientSort : void 0,\n      filter: filter?.filter,\n      filterParams: filter?.filterParams,\n      flex,\n      sortable,\n      resizable,\n      minWidth,\n      maxWidth,\n      autoHeight,\n      autoHeaderHeight,\n      wrapText,\n      wrapHeaderText,\n      floatingFilter: this.options_.filtering === \"row\",\n      // Disable column moving\n      suppressMovable: true,\n      valueFormatter: (params) => {\n        const value = params.value;\n        if (formatter && value !== null && value !== void 0) {\n          return formatter(value);\n        }\n        return value;\n      }\n    };\n    const width = column2.width;\n    if (width) {\n      colDef.width = width;\n    } else if (flex === void 0 || flex === null) {\n      colDef.flex = 1;\n    }\n    return colDef;\n  }\n  patchGrid() {\n    if (!this.grid_) {\n      return;\n    }\n    const columns = this.grid_.getColumns();\n    if (columns) {\n      columns.forEach(async (column2) => {\n        const colId = column2.getColId();\n        const filterInstance = await this.grid_.getColumnFilterInstance(colId);\n        const col = this.columnsByName_[colId] || {};\n        if (filterInstance && typeof filterInstance.doesFilterPass === \"function\" && col.type !== \"literal\") {\n          filterInstance.doesFilterPass = () => true;\n        }\n      });\n    }\n  }\n  // all mosaic inputs implement this, not exactly sure what it does\n  activate() {\n    if (isSelection5(this.options_.as)) {\n      this.options_.as.activate(this.clause([]));\n    }\n  }\n};\nvar resolveColumns = (columns) => {\n  let columnCount = 1;\n  const incrementedColumnName = () => {\n    return `col_${columnCount++}`;\n  };\n  return columns.map((col) => {\n    if (typeof col === \"string\") {\n      return {\n        column_name: col,\n        column_id: col,\n        column: col,\n        type: \"column\"\n      };\n    } else if (typeof col === \"object\" && col !== null) {\n      if (typeof col.column === \"string\") {\n        return {\n          ...col,\n          column_name: col.column,\n          column_id: col.column,\n          type: \"column\"\n        };\n      } else if (typeof col.column === \"number\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"boolean\") {\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (Array.isArray(col.column)) {\n        if (col.column.length === 0) {\n          throw new Error(\"Empty array column is not supported\");\n        }\n        return {\n          ...col,\n          column_name: incrementedColumnName(),\n          column: col.column,\n          type: \"literal\"\n        };\n      } else if (typeof col.column === \"object\") {\n        const agg = Object.keys(col.column)[0];\n        const targetColumn = col.column[agg];\n        return {\n          ...col,\n          column_name: `${agg}_${targetColumn}`,\n          column_id: targetColumn,\n          agg_expr: agg,\n          agg_expr_args: [targetColumn],\n          type: \"aggregate\"\n        };\n      } else {\n        throw new Error(\"Unsupported column type: \" + typeof col.column);\n      }\n    } else {\n      throw new Error(`Invalid column definition: ${col}`);\n    }\n  });\n};\nvar headerClasses = (align) => {\n  if (!align) {\n    return void 0;\n  }\n  return [`header-${align}`];\n};\nvar resolveRowSelection = (options) => {\n  if (options.select === \"hover\") {\n    return void 0;\n  }\n  const selectType = options.select || \"single_row\";\n  if (selectType.startsWith(\"single_\")) {\n    return {\n      mode: \"singleRow\",\n      checkboxes: options.select === \"single_checkbox\",\n      enableClickSelection: options.select === \"single_row\"\n    };\n  } else if (selectType.startsWith(\"multiple_\")) {\n    return {\n      mode: \"multiRow\",\n      selectAll: \"filtered\",\n      checkboxes: options.select === \"multiple_checkbox\"\n    };\n  } else {\n    throw new Error(\"Invalid select option: \" + options.select);\n  }\n};\nvar filterForColumnType = (type) => {\n  switch (type) {\n    case \"number\":\n    case \"integer\":\n    case \"float\":\n    case \"decimal\":\n      return { filter: \"agNumberColumnFilter\" };\n    case \"date\":\n    case \"datetime\":\n    case \"timestamp\":\n      return { filter: \"agDateColumnFilter\" };\n    case \"boolean\":\n      return {\n        filter: \"agTextColumnFilter\",\n        filterParams: {\n          filterOptions: [\"equals\"],\n          textMatcher: ({ filterText, value }) => {\n            const stringValue = String(value);\n            return stringValue === filterText;\n          }\n        }\n      };\n    default:\n      return { filter: \"agTextColumnFilter\" };\n  }\n};\nvar formatterForType = (type, formatStr) => {\n  switch (type) {\n    case \"integer\":\n      return d3Format.format(formatStr || \",\");\n    case \"number\":\n    case \"float\":\n      return d3Format.format(formatStr || \",.2~f\");\n    case \"decimal\":\n      return d3Format.format(formatStr || \",.4~f\");\n    case \"date\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d\");\n    case \"datetime\":\n    case \"timestamp\":\n      return d3TimeFormat.timeFormat(formatStr || \"%Y-%m-%d %H:%M:%S\");\n    case \"boolean\":\n    case \"string\":\n    default:\n      return void 0;\n  }\n};\nvar filterExpression = (colId, filter, query) => {\n  if (isCombinedSimpleModel(filter)) {\n    const operator = filter.operator === \"AND\" ? and : or;\n    const expressions = filter.conditions?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expressions && expressions.length > 0) {\n      return operator(...expressions);\n    }\n  } else if (isTextFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter, void 0, true);\n  } else if (isNumberFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.filter);\n  } else if (isMultiFilter(filter)) {\n    const expr = filter.filterModels?.map((f) => {\n      return filterExpression(colId, f, query);\n    }).filter((e) => e !== void 0);\n    if (expr && expr.length > 0) {\n      return and(...expr);\n    }\n  } else if (isDateFilter(filter)) {\n    return simpleExpression(colId, filter.type, filter.dateFrom, filter.dateTo || void 0);\n  } else if (isSetFilter(filter)) {\n    console.warn(\"Set filter not implemented\");\n  }\n};\nvar simpleExpression = (colId, type, filter, filterTo = void 0, textColumn = false) => {\n  switch (type) {\n    case \"equals\":\n      return eq(colId, literal(filter));\n    case \"notEqual\":\n      return neq(colId, literal(filter));\n    case \"contains\":\n      if (textColumn) {\n        return sql`${column(colId)} ILIKE ${literal(\"%\" + filter + \"%\")}`;\n      } else {\n        return contains(colId, String(filter));\n      }\n    case \"notContains\":\n      return not(contains(colId, String(filter)));\n    case \"blank\":\n      return isNull(colId);\n    case \"notBlank\":\n      return not(isNull(colId));\n    case \"startsWith\":\n      return prefix(colId, String(filter));\n    case \"endsWith\":\n      return suffix(colId, String(filter));\n    case \"greaterThan\":\n      return gt(colId, literal(filter));\n    case \"lessThan\":\n      return lt(colId, literal(filter));\n    case \"greaterThanOrEqual\":\n      return gte(colId, literal(filter));\n    case \"lessThanOrEqual\":\n      return lte(colId, literal(filter));\n    case \"inRange\":\n      if (filterTo !== void 0 && filterTo !== null) {\n        return gte(colId, literal(filter)), lte(colId, literal(filterTo));\n      }\n      break;\n    default:\n      console.warn(`Unsupported filter type: ${type}`);\n  }\n  return void 0;\n};\nvar aggregateExpression = (c) => {\n  const aggExpr = c.agg_expr;\n  const firstArg = () => {\n    if (c.agg_expr_args.length > 0) {\n      return c.agg_expr_args[0];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least one argument`);\n  };\n  const secondArg = () => {\n    if (c.agg_expr_args.length > 1) {\n      return c.agg_expr_args[1];\n    }\n    throw new Error(`Aggregate expression ${aggExpr} requires at least two arguments`);\n  };\n  const r = (val) => {\n    return [c.column_name, val];\n  };\n  switch (aggExpr) {\n    case \"count\":\n      return r(count(firstArg()));\n    case \"sum\":\n      return r(sum(firstArg()));\n    case \"avg\":\n      return r(avg(firstArg()));\n    case \"argmax\":\n      return r(argmax(firstArg(), secondArg()));\n    case \"mad\":\n      return r(mad(firstArg()));\n    case \"max\":\n      return r(max2(firstArg()));\n    case \"min\":\n      return r(min2(firstArg()));\n    case \"product\":\n      return r(product(firstArg()));\n    case \"geomean\":\n      return r(geomean(firstArg()));\n    case \"median\":\n      return r(median(firstArg()));\n    case \"mode\":\n      return r(mode(firstArg()));\n    case \"variance\":\n      return r(variance(firstArg()));\n    case \"stddev\":\n      return r(stddev(firstArg()));\n    case \"skewness\":\n      return r(skewness(firstArg()));\n    case \"kurtosis\":\n      return r(kurtosis(firstArg()));\n    case \"entropy\":\n      return r(entropy(firstArg()));\n    case \"varPop\":\n      return r(varPop(firstArg()));\n    case \"stddevPop\":\n      return r(stddevPop(firstArg()));\n    case \"first\":\n      return r(first(firstArg()));\n    case \"last\":\n      return r(last(firstArg()));\n    case \"stringAgg\":\n      return r(stringAgg(firstArg()));\n    case \"arrayAgg\":\n      return r(arrayAgg(firstArg()));\n    case \"argmin\":\n      return r(argmin(firstArg(), secondArg()));\n    case \"quantile\":\n      return r(quantile(firstArg(), secondArg()));\n    case \"corr\":\n      return r(corr(firstArg(), secondArg()));\n    case \"covarPop\":\n      return r(covarPop(firstArg(), secondArg()));\n    case \"regrIntercept\":\n      return r(regrIntercept(firstArg(), secondArg()));\n    case \"regrSlope\":\n      return r(regrSlope(firstArg(), secondArg()));\n    case \"regrCount\":\n      return r(regrCount(firstArg(), secondArg()));\n    case \"regrR2\":\n      return r(regrR2(firstArg(), secondArg()));\n    case \"regrSXX\":\n      return r(regrSXX(firstArg(), secondArg()));\n    case \"regrSYY\":\n      return r(regrSYY(firstArg(), secondArg()));\n    case \"regrSXY\":\n      return r(regrSXY(firstArg(), secondArg()));\n    case \"regrAvgX\":\n      return r(regrAvgX(firstArg(), secondArg()));\n    case \"regrAvgY\":\n      return r(regrAvgY(firstArg(), secondArg()));\n    default:\n      throw new Error(`Unsupported aggregate expression: ${aggExpr}.`);\n  }\n};\nvar isCombinedSimpleModel = (filter) => {\n  return typeof filter === \"object\" && filter !== null && \"operator\" in filter && \"conditions\" in filter && (filter.operator === \"AND\" || filter.operator === \"OR\") && typeof filter.conditions === \"object\";\n};\nvar isTextFilter = (filter) => {\n  return filter?.filterType === \"text\";\n};\nvar isNumberFilter = (filter) => {\n  return filter?.filterType === \"number\";\n};\nvar isDateFilter = (filter) => {\n  return filter?.filterType === \"date\" || filter?.filterType === \"dateString\";\n};\nvar isMultiFilter = (filter) => {\n  return filter?.filterType === \"multi\" && \"filterModels\" in filter;\n};\nvar isSetFilter = (filter) => {\n  return filter?.filterType === \"set\";\n};\n\n// js/inputs/search.ts\nimport {\n  clauseMatch,\n  isParam as isParam4,\n  isSelection as isSelection6\n} from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-core@0.16.2/+esm\";\nimport { Query as Query4 } from \"https://cdn.jsdelivr.net/npm/@uwdata/mosaic-sql@0.16.2/+esm\";\nvar Search = class extends Input {\n  constructor(options_) {\n    super(options_.filterBy);\n    this.options_ = options_;\n    this.element.classList.add(kSidebarFullwidth);\n    if (options_.label) {\n      const inputLabel = window.document.createElement(\"label\");\n      inputLabel.setAttribute(\"for\", this.id_);\n      inputLabel.innerText = options_.label;\n      this.element.appendChild(inputLabel);\n    }\n    this.input_ = window.document.createElement(\"input\");\n    this.input_.autocomplete = \"off\";\n    this.input_.classList.add(kInputSearch);\n    this.input_.id = this.id_;\n    this.input_.type = \"text\";\n    if (this.options_.placeholder) {\n      this.input_.setAttribute(\"placeholder\", this.options_.placeholder);\n    }\n    if (this.options_.width) {\n      this.input_.style.width = `${options_.width}px`;\n    }\n    this.element.appendChild(this.input_);\n    this.input_.addEventListener(\"input\", () => {\n      this.publish(this.input_.value);\n    });\n    if (!isSelection6(this.options_.as)) {\n      this.options_.as.addEventListener(\"value\", (value) => {\n        if (value !== this.input_.value) {\n          this.input_.value = value;\n        }\n      });\n    } else {\n      setupActivationListeners(this, this.input_);\n    }\n  }\n  input_;\n  id_ = generateId();\n  data_ = [];\n  datalist_;\n  reset() {\n    this.input_.value = \"\";\n  }\n  clause(value) {\n    const field = this.options_.field || this.options_.column;\n    return clauseMatch(field, value, { source: this, method: this.options_.type });\n  }\n  activate() {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.activate(this.clause(\"\"));\n    }\n  }\n  publish(value) {\n    if (isSelection6(this.options_.as)) {\n      this.options_.as.update(this.clause(value));\n    } else if (isParam4(this.options_.as)) {\n      this.options_.as.update(value);\n    }\n  }\n  query(filter = []) {\n    return Query4.from(this.options_.from).select({ list: this.options_.column }).distinct().where(...filter);\n  }\n  queryResult(data) {\n    this.data_ = data;\n    return this;\n  }\n  update() {\n    const list = document.createElement(\"datalist\");\n    const id = `${this.id_}_list`;\n    list.setAttribute(\"id\", id);\n    for (const d of this.data_) {\n      const opt = document.createElement(\"option\");\n      opt.setAttribute(\"value\", d.list);\n      list.append(opt);\n    }\n    if (this.datalist_) {\n      this.datalist_.remove();\n    }\n    this.element.appendChild(this.datalist_ = list);\n    this.input_.setAttribute(\"list\", id);\n    return this;\n  }\n};\n\n// js/inputs/index.ts\nvar INPUTS = {\n  select: (options) => input(Select, options),\n  slider: (options) => input(Slider, options),\n  search: (options) => input(Search, options),\n  checkbox: (options) => input(Checkbox, options),\n  radio_group: (options) => input(RadioGroup, options),\n  checkbox_group: (options) => input(CheckboxGroup, options),\n  table: (options) => input(Table, options)\n};\n\n// js/context/duckdb.ts\nimport {\n  getJsDelivrBundles,\n  selectBundle,\n  AsyncDuckDB,\n  ConsoleLogger,\n  LogLevel\n} from \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/+esm\";\n\n// js/util/async.ts\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction throttle2(func, wait, options = {}) {\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n  const later = function() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, args === null ? [] : args);\n    if (!timeout) {\n      context = null;\n      args = null;\n    }\n  };\n  return function(...callArgs) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    context = this;\n    args = callArgs;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) {\n        context = null;\n        args = null;\n      }\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// js/context/duckdb.ts\nasync function initDuckdb() {\n  const JSDELIVR_BUNDLES = getJsDelivrBundles();\n  const bundle = await selectBundle(JSDELIVR_BUNDLES);\n  const worker_url = URL.createObjectURL(\n    new Blob([`importScripts(\"${bundle.mainWorker}\");`], {\n      type: \"text/javascript\"\n    })\n  );\n  const worker = new Worker(worker_url);\n  const logger = new ConsoleLogger(LogLevel.WARNING);\n  const db = new AsyncDuckDB(logger, worker);\n  await db.instantiate(bundle.mainModule, bundle.pthreadWorker);\n  URL.revokeObjectURL(worker_url);\n  return { db, worker };\n}\nasync function waitForTable(conn, table, { interval = 250 } = {}) {\n  while (true) {\n    try {\n      const res = await conn.query(\n        `SELECT 1\n           FROM information_schema.tables\n         WHERE table_schema = 'main'\n           AND table_name   = '${table}'\n         LIMIT 1`\n      );\n      if (res.numRows) return;\n    } catch (err) {\n      console.log(\n        `Table ${table} not yet available, trying again in ${interval}ms (error: ${err})`\n      );\n    }\n    await sleep(interval);\n  }\n}\n\n// js/util/errors.ts\nfunction initializeErrorHandling(ctx, worker) {\n  window.addEventListener(\"error\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.error));\n  });\n  window.addEventListener(\"unhandledrejection\", (event) => {\n    ctx.recordUnhandledError(errorInfo(event.reason));\n  });\n  worker.addEventListener(\"message\", (event) => {\n    if (event.data.type === \"ERROR\") {\n      ctx.recordUnhandledError(errorInfo(event.data.data.message));\n    }\n  });\n}\nfunction errorInfo(error) {\n  if (isError(error)) {\n    return {\n      name: error.name || \"Error\",\n      message: error.message || \"An unknown error occurred\",\n      stack: error.stack || \"\",\n      code: error.code || null,\n      ...error\n      // Include any custom properties\n    };\n  } else if (typeof error === \"string\") {\n    return {\n      name: \"Error\",\n      message: error,\n      stack: new Error().stack || \"\",\n      code: null\n    };\n  } else {\n    return {\n      name: \"Unknown Error\",\n      message: JSON.stringify(error, null, 2),\n      stack: new Error().stack || \"\",\n      code: null,\n      originalValue: error\n    };\n  }\n}\nfunction errorAsHTML(error) {\n  const colors = {\n    bg: \"#ffffff\",\n    border: \"#dc3545\",\n    title: \"#dc3545\",\n    text: \"#212529\",\n    subtext: \"#6c757d\",\n    codeBg: \"#f8f9fa\",\n    link: \"#007bff\"\n  };\n  const stackLines = parseStackTrace(error.stack);\n  let html = `\n    <div style=\"\n      background: ${colors.bg};\n      border: 2px solid ${colors.border};\n      border-radius: 8px;\n      padding: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;\n      color: ${colors.text};\n      margin: 10px 0;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.1);\n      width: 100%;\n    \">\n      <div style=\"display: flex; align-items: center; margin-bottom: 15px;\">\n        <svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" style=\"margin-right: 10px;\">\n          <circle cx=\"12\" cy=\"12\" r=\"10\" stroke=\"${colors.title}\" stroke-width=\"2\" fill=\"none\"/>\n          <path d=\"M12 8v5m0 4h.01\" stroke=\"${colors.title}\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/>\n        </svg>\n        <h3 style=\"margin: 0; color: ${colors.title}; font-size: 20px; font-weight: 600;\">\n          ${escapeHtml(error.name)}\n        </h3>\n      </div>\n      \n      <div style=\"\n        background: ${colors.codeBg};\n        padding: 15px;\n        border-radius: 6px;\n        margin-bottom: 15px;\n        border-left: 4px solid ${colors.border};\n      \">\n        <p style=\"margin: 0; font-size: 13px; line-height: 1.5; font-family: monospace; white-space: pre-wrap;\">${escapeHtml(error.message)}</p>\n      </div>`;\n  if (error.code !== null) {\n    html += `\n      <div style=\"margin-bottom: 10px;\">\n        <span style=\"color: ${colors.subtext}; font-size: 143x;\">Error Code:</span>\n        <span style=\"color: ${colors.text}; font-weight: 500; margin-left: 8px;\">\n          ${escapeHtml(String(error.code))}\n        </span>\n      </div>`;\n  }\n  if (stackLines.length > 0) {\n    html += `\n      <details style=\"margin-top: 15px;\">\n        <summary style=\"\n          cursor: pointer;\n          color: ${colors.subtext};\n          font-size: 13px;\n          font-weight: 500;\n          outline: none;\n          user-select: none;\n        \">\n          Stack Trace (${stackLines.length} frames)\n        </summary>\n        <div style=\"margin-top: 10px; font-size: 13px; font-family: monospace;\">`;\n    stackLines.forEach((line, i) => {\n      html += `\n        <div style=\"\n          background: ${i % 2 === 0 ? colors.codeBg : \"transparent\"};\n          border-radius: 4px;\n          margin: 2px 0;\n          display: flex;\n          align-items: center;\n        \">\n          <span style=\"color: ${colors.subtext}; min-width: 24px;\">${i + 1}.</span>\n          <span style=\"color: ${colors.link}; margin-left: 8px;\">\n            ${escapeHtml(line)}\n          </span>\n        </div>`;\n    });\n    html += `\n        </div>\n      </details>`;\n  }\n  html += `</div>`;\n  return html;\n}\nfunction displayRenderError(error, renderEl) {\n  renderEl.setAttribute(\"style\", \"\");\n  renderEl.innerHTML = errorAsHTML(error);\n}\nfunction parseStackTrace(stack) {\n  if (!stack) return [];\n  const lines = stack.split(\"\\n\");\n  const functions = [];\n  const patterns = [\n    // Chrome/Edge: \"    at functionName (file:line:column)\"\n    /^\\s*at\\s+(.+?)\\s+\\(/,\n    // Chrome/Edge: \"    at file:line:column\" (anonymous)\n    /^\\s*at\\s+[^(]+$/,\n    // Firefox/Safari: \"functionName@file:line:column\"\n    /^(.+?)@/\n  ];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed || trimmed === \"Error\") continue;\n    let functionName = \"anonymous\";\n    for (const pattern of patterns) {\n      const match = trimmed.match(pattern);\n      if (match) {\n        if (match[1]) {\n          functionName = match[1].trim();\n        }\n        break;\n      }\n    }\n    if (functionName === \"anonymous\" && !patterns.some((p) => p.test(trimmed))) {\n      functionName = trimmed;\n    }\n    functions.push(functionName);\n  }\n  return functions;\n}\nfunction escapeHtml(text) {\n  const div = document.createElement(\"div\");\n  div.textContent = text;\n  return div.innerHTML;\n}\nfunction isError(value) {\n  return value instanceof Error;\n}\n\n// js/context/index.ts\nvar VizContext = class extends InstantiateContext {\n  constructor(conn_, plotDefaults) {\n    super({ plotDefaults });\n    this.conn_ = conn_;\n    this.api = { ...this.api, ...INPUTS };\n    this.coordinator.databaseConnector(wasmConnector({ connection: this.conn_ }));\n  }\n  tables_ = /* @__PURE__ */ new Set();\n  unhandledErrors_ = [];\n  async insertTable(table, data) {\n    if (this.tables_.has(table)) {\n      await this.waitForTable(table);\n      return;\n    }\n    this.tables_.add(table);\n    await this.conn_?.insertArrowFromIPCStream(data, {\n      name: table,\n      create: true\n    });\n  }\n  async waitForTable(table) {\n    await waitForTable(this.conn_, table);\n  }\n  recordUnhandledError(error) {\n    this.unhandledErrors_.push(error);\n  }\n  async collectUnhandledError(wait = 1e3) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < wait) {\n      if (this.unhandledErrors_.length > 0) {\n        return this.unhandledErrors_.shift();\n      }\n      await sleep(100);\n    }\n    return void 0;\n  }\n  clearUnhandledErrors() {\n    this.unhandledErrors_ = [];\n  }\n};\nvar VIZ_CONTEXT_KEY = Symbol.for(\"@@inspect-viz-context\");\nasync function vizContext(plotDefaults) {\n  const globalScope = typeof window !== \"undefined\" ? window : globalThis;\n  if (!globalScope[VIZ_CONTEXT_KEY]) {\n    globalScope[VIZ_CONTEXT_KEY] = (async () => {\n      const { db, worker } = await initDuckdb();\n      const conn = await db.connect();\n      const ctx = new VizContext(conn, plotDefaults);\n      initializeErrorHandling(ctx, worker);\n      return ctx;\n    })();\n  }\n  return globalScope[VIZ_CONTEXT_KEY];\n}\n\n// js/util/platform.ts\nfunction isNotebook() {\n  const win = window;\n  const hasNotebookGlobal = typeof win.Jupyter !== \"undefined\" || typeof win._JUPYTERLAB !== \"undefined\" || typeof win.google !== \"undefined\" && win.google.colab || typeof win.IPython !== \"undefined\" || typeof win.mo !== \"undefined\" || typeof win.acquireVsCodeApi !== \"undefined\";\n  return hasNotebookGlobal || isVSCodeNotebook();\n}\nfunction isVSCodeNotebook() {\n  return window.location.protocol === \"vscode-webview:\" && window.location.search.includes(\"purpose=notebookRenderer\");\n}\n\n// js/plot/tooltips.ts\nimport svgPathParser from \"https://cdn.jsdelivr.net/npm/svg-path-parser@1.1.0/+esm\";\nimport tippy from \"https://cdn.jsdelivr.net/npm/tippy.js@6.3.7/+esm\";\n\n// js/util/url.ts\nvar isUrl = (value) => {\n  try {\n    new URL(value);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\nvar isLinkableUrl = (value) => {\n  return isUrl(value) && value.startsWith(\"http\");\n};\n\n// js/plot/plot.ts\nvar readMarks = (plotEl) => {\n  const value = plotEl.value;\n  const marks = value ? value.marks || [] : [];\n  return marks;\n};\nvar readOptions = (el) => {\n  const value = el.value;\n  return value ? value.options || {} : {};\n};\nvar readPlotEl = (el) => {\n  const value = el.value;\n  const plot = value?.plot;\n  if (plot) {\n    return plot.element;\n  }\n  return void 0;\n};\nvar hasValue = (el, key) => {\n  const value = el.value;\n  return value ? !!value[key] || false : false;\n};\n\n// js/plot/tooltips.ts\nvar HIDDEN_USER_CHANNEL = \"_user_channels\";\nvar replaceTooltipImpl = (specEl) => {\n  configureSpecSvgTooltips(specEl);\n  const observer = new MutationObserver(() => {\n    configureSpecSvgTooltips(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredSvgs = /* @__PURE__ */ new WeakSet();\nvar configureSpecSvgTooltips = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredSvgs.has(svgEl)) {\n      setupTooltipObserver(svgEl, specEl);\n      configuredSvgs.add(svgEl);\n      return;\n    }\n  });\n};\nvar tooltipInstance = void 0;\nvar tooltipSpecEl = void 0;\nfunction initializeTooltip(specEl) {\n  if (!tooltipInstance || tooltipSpecEl !== specEl) {\n    if (tooltipInstance) {\n      tooltipInstance.destroy();\n    }\n    tooltipInstance = tippy(specEl, {\n      trigger: \"manual\",\n      theme: \"inspect\",\n      interactive: true\n    });\n    tooltipSpecEl = specEl;\n  }\n}\nfunction hideTooltip() {\n  try {\n    tooltipInstance.hide();\n  } catch {\n  } finally {\n    window.removeEventListener(\"scroll\", hideTooltip);\n  }\n}\nfunction maybeHideTooltip() {\n  if (!tooltipInstance.popper.matches(\":hover\")) {\n    hideTooltip();\n  }\n}\nfunction showTooltip() {\n  try {\n    tooltipInstance.show();\n    window.addEventListener(\"scroll\", hideTooltip, { once: true });\n  } catch {\n  }\n}\nvar setupTooltipObserver = (svgEl, specEl) => {\n  initializeTooltip(specEl);\n  const observer = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === \"childList\") {\n        const tipElements = svgEl.querySelectorAll('g[aria-label=\"tip\"]');\n        for (const tipElement of tipElements) {\n          const tipContainerEl2 = tipElement;\n          tipContainerEl2.style.display = \"none\";\n        }\n        let tipEl = void 0;\n        let tipContainerEl = void 0;\n        for (const tipElement of tipElements) {\n          const searchElement = tipElement;\n          const pathEl = searchElement.querySelector(\"path\");\n          const pathElParent = pathEl?.parentElement;\n          if (pathElParent) {\n            tipEl = pathElParent;\n            tipContainerEl = searchElement;\n            break;\n          }\n        }\n        if (!tipEl || !tipContainerEl) {\n          maybeHideTooltip();\n        } else {\n          const userChannels = readUserChannels(svgEl);\n          const userKeys = userChannels ? Object.keys(userChannels) : void 0;\n          const parsed = parseSVGTooltip(tipContainerEl, tipEl);\n          const tooltips = distillTooltips(parsed, userKeys);\n          const svgPoint = svgEl.createSVGPoint();\n          svgPoint.x = parsed.transform?.x || 0;\n          svgPoint.y = parsed.transform?.y || 0;\n          const screenPoint = svgPoint.matrixTransform(svgEl.getScreenCTM());\n          const centerX = screenPoint.x;\n          const centerY = screenPoint.y;\n          tooltipInstance.setProps({\n            placement: parsed.placement !== \"middle\" ? parsed.placement || \"top\" : \"top\",\n            getReferenceClientRect: () => {\n              return {\n                width: 0,\n                height: 0,\n                top: centerY,\n                bottom: centerY,\n                left: centerX,\n                right: centerX,\n                x: centerX,\n                y: centerY,\n                toJSON: () => {\n                }\n              };\n            },\n            arrow: parsed.placement !== \"middle\",\n            offset: parsed.placement === \"middle\" ? [0, 0] : void 0,\n            popperOptions: (\n              // Special handling for middle placement, which isn't a supported\n              // tippy placement\n              parsed.placement === \"middle\" ? {\n                modifiers: [\n                  {\n                    name: \"preventOverflow\",\n                    enabled: false\n                  },\n                  {\n                    name: \"flip\",\n                    enabled: false\n                  },\n                  {\n                    name: \"customMiddle\",\n                    enabled: true,\n                    phase: \"main\",\n                    fn: ({ state }) => {\n                      state.modifiersData.popperOffsets.x = centerX - state.rects.popper.width / 2;\n                      state.modifiersData.popperOffsets.y = centerY - state.rects.popper.height / 2;\n                    }\n                  }\n                ]\n              } : void 0\n            )\n          });\n          const contentEl = document.createElement(\"div\");\n          contentEl.classList.add(\"inspect-tip-container\");\n          let count2 = 0;\n          for (const row of tooltips) {\n            const rowEl = document.createElement(\"div\");\n            rowEl.className = \"inspect-tip-row\";\n            contentEl.appendChild(rowEl);\n            const keyEl = document.createElement(\"div\");\n            keyEl.className = \"inspect-tip-key\";\n            keyEl.append(document.createTextNode(row.key));\n            const valueEl = document.createElement(\"div\");\n            valueEl.className = \"inspect-tip-value\";\n            if (row.href) {\n              const linkEl = document.createElement(\"a\");\n              linkEl.href = row.href;\n              linkEl.target = \"_blank\";\n              linkEl.rel = \"noopener noreferrer\";\n              linkEl.className = \"inspect-tip-link\";\n              linkEl.textContent = row.value;\n              valueEl.appendChild(linkEl);\n            } else {\n              valueEl.append(document.createTextNode(row.value));\n            }\n            if (row.color) {\n              const colorEl = document.createElement(\"span\");\n              colorEl.className = \"inspect-tip-color\";\n              colorEl.style.backgroundColor = row.color;\n              valueEl.append(colorEl);\n            }\n            rowEl.appendChild(keyEl);\n            rowEl.appendChild(valueEl);\n            count2++;\n          }\n          tooltipInstance.setContent(contentEl);\n          showTooltip();\n        }\n      }\n    });\n  });\n  observer.observe(svgEl, {\n    childList: true,\n    subtree: true\n  });\n};\nvar parseTransform = (el) => {\n  const transformVal = el.getAttribute(\"transform\");\n  if (transformVal) {\n    const match = transformVal.match(/translate\\(([^)]+)\\)/);\n    if (match) {\n      const [x, y] = match[1].split(\",\").map(Number);\n      return { x, y };\n    }\n  }\n  return void 0;\n};\nvar parseSVGTooltip = (tipContainerEl, tipEl) => {\n  const result = { values: [] };\n  const tspanEls = tipEl.querySelectorAll(\"tspan\");\n  tspanEls.forEach((tspan) => {\n    let key = void 0;\n    let value = void 0;\n    let color = void 0;\n    tspan.childNodes.forEach((node) => {\n      if (node.nodeName === \"tspan\") {\n        const colorAttr = node.getAttribute(\"fill\");\n        if (colorAttr) {\n          color = colorAttr;\n        } else {\n          key = node.textContent?.trim();\n        }\n      } else if (node.nodeName === \"#text\") {\n        value = node.textContent?.trim();\n      }\n    });\n    if (key !== void 0 && value !== void 0) {\n      if (isLinkableUrl(value)) {\n        result.values.push({ key, value: \"Link\", href: value, color });\n      } else {\n        result.values.push({ key, value, color });\n      }\n    }\n  });\n  const pathEl = tipEl.querySelector(\"path\");\n  if (pathEl) {\n    const pathData = pathEl.getAttribute(\"d\");\n    if (pathData) {\n      result.placement = parseArrowDirection(pathData);\n    }\n    const transforms = getTransformsBetween(pathEl, tipContainerEl);\n    if (transforms.length > 0) {\n      result.transform = transforms.reduce(\n        (acc, transform) => {\n          acc.x += transform.x;\n          acc.y += transform.y;\n          return acc;\n        },\n        { x: 0, y: 0 }\n      );\n    }\n  }\n  return result;\n};\nfunction distillTooltips(parsed, userKeys) {\n  if (!userKeys) {\n    return parsed.values;\n  }\n  const userValues = parsed.values.filter((row) => {\n    return userKeys.includes(row.key);\n  }).map((row) => row.value);\n  const filteredRows = parsed.values.filter((row) => {\n    if (row.key === HIDDEN_USER_CHANNEL) {\n      return false;\n    }\n    if (row.key.startsWith(\"_\")) {\n      return false;\n    }\n    if (userKeys.includes(row.key)) {\n      return true;\n    }\n    if (userValues.includes(row.value)) {\n      return false;\n    }\n    return false;\n  });\n  return filteredRows;\n}\nfunction readUserChannels(svgEl) {\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    for (const mark of marks) {\n      const markChannels = mark.channels || [];\n      const markChannelNames = markChannels.map((c) => c.channel);\n      if (markChannelNames.includes(\"tip\")) {\n        const userChannels = markChannels.find(\n          (c) => c.channel === HIDDEN_USER_CHANNEL\n        );\n        const userChannelsValue = userChannels?.value;\n        if (userChannelsValue) {\n          const parsedChannels = JSON.parse(userChannelsValue);\n          return parsedChannels;\n        }\n      }\n    }\n  }\n  return void 0;\n}\nfunction getTransformsBetween(pathElement, containerElement) {\n  const transforms = [];\n  let current = pathElement.parentElement;\n  while (current) {\n    const transform = parseTransform(current);\n    if (transform) {\n      transforms.unshift(transform);\n    }\n    if (current !== containerElement) {\n      current = current.parentElement;\n    } else {\n      break;\n    }\n  }\n  return transforms;\n}\nvar parseArrowPosition = (a, b) => {\n  if (a < b) {\n    return \"end\";\n  } else if (a > b) {\n    return \"start\";\n  } else {\n    return \"center\";\n  }\n};\nvar parseArrowDirection = (pathData) => {\n  const parsed = svgPathParser.parseSVG(pathData);\n  if (parsed.length < 3) {\n    return \"top\";\n  }\n  const moveTo = parsed[0];\n  if (moveTo.code !== \"M\") {\n    console.warn(\"Expected moveto command (M) in path data, found:\", moveTo);\n    return \"top\";\n  }\n  if (moveTo.x !== 0 && moveTo.y !== 0) {\n    return \"middle\";\n  }\n  const lineTo = parsed[1];\n  if (lineTo.code !== \"l\") {\n    console.warn(\"Expected lineto command (l) in path data, found:\", lineTo);\n    return \"top\";\n  }\n  const firstEdgeLineTo = parsed[2];\n  if (firstEdgeLineTo.code !== \"h\" && firstEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command after move, found:\",\n      firstEdgeLineTo\n    );\n    return \"top\";\n  }\n  const lastEdgeLineTo = parsed[parsed.length - 2];\n  if (lastEdgeLineTo.code !== \"h\" && lastEdgeLineTo.code !== \"v\") {\n    console.warn(\n      \"Expected horizontal (h) or vertical (v) line command before close, found:\",\n      lastEdgeLineTo\n    );\n    return \"top\";\n  }\n  const x = lineTo.x;\n  const y = lineTo.y;\n  let arrowDirection = \"top\";\n  if (x > 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else if (x < 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"bottom\";\n    } else {\n      arrowDirection = \"left\";\n    }\n  } else if (x > 0 && y < 0) {\n    if (firstEdgeLineTo.code === \"h\") {\n      arrowDirection = \"top\";\n    } else {\n      arrowDirection = \"right\";\n    }\n  } else if (x < 0 && y > 0) {\n    arrowDirection = \"bottom\";\n  } else {\n    console.warn(\n      \"Could not determine arrow direction from path data, returning default placement: top\"\n    );\n  }\n  let arrowPosition = \"center\";\n  if (firstEdgeLineTo.code === \"h\") {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.x, lastEdgeLineTo.x);\n  } else {\n    arrowPosition = parseArrowPosition(firstEdgeLineTo.y, lastEdgeLineTo.y);\n  }\n  if (arrowPosition === \"center\") {\n    return arrowDirection;\n  } else {\n    return `${arrowDirection}-${arrowPosition}`;\n  }\n};\n\n// js/plot/text-collision.ts\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3-force@3.0.0/+esm\";\nvar installTextCollisionHandler = (specEl) => {\n  configurePlotObservers(specEl);\n  const observer = new MutationObserver(() => {\n    configurePlotObservers(specEl);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n};\nvar configuredPlots = /* @__PURE__ */ new WeakSet();\nvar configurePlotObservers = (specEl) => {\n  const childSvgEls = specEl.querySelectorAll(\"div.plot svg\");\n  childSvgEls.forEach((svgEl) => {\n    if (svgEl && !configuredPlots.has(svgEl)) {\n      const options = readTextOptions(svgEl);\n      if (options.shiftOverlappingText) {\n        configurePlotObserver(svgEl);\n        configuredPlots.add(svgEl);\n      }\n    }\n  });\n};\nvar configurePlotObserver = (plotElement) => {\n  const observer = new MutationObserver(() => {\n    processCollidingText(plotElement);\n  });\n  processCollidingText(plotElement);\n  observer.observe(plotElement, { childList: true, subtree: true });\n};\nfunction processCollidingText(plotElement) {\n  const textElements = plotElement.querySelectorAll('g[aria-label=\"text\"] text');\n  if (textElements.length === 0) {\n    return;\n  }\n  const nodes = Array.from(textElements).map((el) => {\n    const textEl = el;\n    const screenRect = textEl.getBoundingClientRect();\n    const svgRect = plotElement.getBoundingClientRect();\n    const actualX = screenRect.left - svgRect.left + screenRect.width / 2;\n    const actualY = screenRect.top - svgRect.top + screenRect.height / 2;\n    const originalSvgX = parseFloat(textEl.getAttribute(\"x\") || \"0\");\n    const originalSvgY = parseFloat(textEl.getAttribute(\"y\") || \"0\");\n    return {\n      element: textEl,\n      rect: screenRect,\n      x: actualX,\n      y: actualY,\n      initialX: actualX,\n      initialY: actualY,\n      originalSvgX,\n      originalSvgY\n    };\n  });\n  d3.forceSimulation(nodes).force(\"collision\", rectangularVerticalCollisionForce().padding(0)).force(\"x\", d3.forceX((d) => d.initialX).strength(0.1)).force(\"y\", d3.forceY((d) => d.initialY).strength(0.1)).alphaDecay(0.75).velocityDecay(0.9).on(\"tick\", () => {\n    nodes.forEach((d) => {\n      const deltaX = d.x - d.initialX;\n      if (deltaX !== 0) {\n        d.element.setAttribute(\"x\", String(d.originalSvgX + deltaX));\n      }\n      const deltaY = d.y - d.initialY;\n      if (deltaY !== 0) {\n        d.element.setAttribute(\"y\", String(d.originalSvgY + deltaY));\n      }\n    });\n  });\n}\nfunction rectangularVerticalCollisionForce() {\n  let nodes;\n  let padding = 2;\n  function force() {\n    for (let i = 0; i < nodes.length; i++) {\n      const nodeA = nodes[i];\n      const rectA = nodeA.rect;\n      for (let j = i + 1; j < nodes.length; j++) {\n        const nodeB = nodes[j];\n        const rectB = nodeB.rect;\n        const aLeft = nodeA.x - rectA.width / 2;\n        const aRight = nodeA.x + rectA.width / 2;\n        const aTop = nodeA.y - rectA.height / 2;\n        const aBottom = nodeA.y + rectA.height / 2;\n        const bLeft = nodeB.x - rectB.width / 2;\n        const bRight = nodeB.x + rectB.width / 2;\n        const bTop = nodeB.y - rectB.height / 2;\n        const bBottom = nodeB.y + rectB.height / 2;\n        const xOverlap = aRight + padding > bLeft && bRight + padding > aLeft;\n        const yOverlap = aBottom + padding > bTop && bBottom + padding > aTop;\n        if (xOverlap && yOverlap) {\n          const dy = nodeB.y - nodeA.y;\n          const minDistanceY = (rectA.height + rectB.height) / 2 + padding;\n          if (Math.abs(dy) < minDistanceY) {\n            const overlapY = minDistanceY - Math.abs(dy);\n            const moveY = overlapY / 2 * (dy > 0 ? 1 : -1);\n            nodeA.y -= moveY;\n            nodeB.y += moveY;\n          }\n        }\n      }\n    }\n  }\n  force.initialize = function(newNodes) {\n    nodes = newNodes;\n  };\n  force.padding = function(value) {\n    if (value === void 0) return padding;\n    padding = value;\n    return force;\n  };\n  return force;\n}\nvar readTextOptions = (svgEl) => {\n  const textOptions = {};\n  const plotEl = svgEl.parentElement;\n  if (plotEl) {\n    const marks = readMarks(plotEl);\n    const textMarks = marks.filter((mark) => mark.type === \"text\");\n    for (const mark of textMarks) {\n      const shiftTextEnabled = mark.channels?.some((c) => {\n        if (c.channel === \"_shift_overlapping_text\") {\n          const val = c.value;\n          if (Array.isArray(val)) {\n            return val.includes(true);\n          }\n        }\n        return false;\n      });\n      if (shiftTextEnabled) {\n        textOptions.shiftOverlappingText = true;\n        break;\n      }\n    }\n  }\n  return textOptions;\n};\n\n// js/plot/ticks.ts\nimport * as d3TimeFormat2 from \"https://cdn.jsdelivr.net/npm/d3-time-format@4.1.0/+esm\";\n\n// js/util/spec.ts\nfunction visitPlot(obj, fn) {\n  if (Array.isArray(obj)) {\n    obj.flatMap((item) => visitPlot(item, fn));\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (\"plot\" in obj) {\n      fn(obj);\n    } else {\n      Object.values(obj).flatMap((value) => visitPlot(value, fn));\n    }\n  }\n}\n\n// js/plot/ticks.ts\nvar applyTickFormatting = (spec) => {\n  visitPlot(spec, (plot) => {\n    if (\"xTickFormat\" in plot) {\n      const format2 = plot.xTickFormat;\n      if (typeof format2 === \"string\") {\n        processTickFormat(plot, \"xTickFormat\");\n        processTickFormat(plot, \"yTickFormat\");\n      }\n    }\n  });\n};\nvar processTickFormat = (obj, formatKey) => {\n  if (formatKey in obj) {\n    const format2 = obj[formatKey];\n    if (typeof format2 === \"string\") {\n      if (isD3TimeFormat(format2)) {\n        obj[formatKey] = (val) => {\n          if (typeof val === \"number\") {\n            const d = new Date(val);\n            return d3TimeFormat2.timeFormat(format2)(d);\n          } else {\n            return d3TimeFormat2.timeFormat(format2)(val);\n          }\n        };\n      }\n    }\n  }\n};\nvar isD3TimeFormat = (format2) => {\n  return /%[aAbBcdefHIjLmMpqQsSuUVwWxXyYzZ%]/.test(format2);\n};\n\n// js/plot/legend.ts\nvar kInsetX = \"_inset_x\";\nvar kInsetY = \"_inset_y\";\nvar kInset = \"_inset\";\nvar kFrameAnchor = \"_frame_anchor\";\nvar kBackground = \"_background\";\nvar kBorder = \"_border\";\nvar installLegendHandler = (specEl, responsive) => {\n  const existingObserver = observedSpecs.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    observedSpecs.delete(specEl);\n  }\n  const hasLegend = specEl.querySelector(\"div.legend\") !== null;\n  if (!hasLegend) {\n    return;\n  }\n  configureLegendHandler(specEl, responsive);\n  const observer = new MutationObserver(() => {\n    configureLegendHandler(specEl, responsive);\n  });\n  observer.observe(specEl, { childList: true, subtree: true });\n  observedSpecs.set(specEl, observer);\n};\nvar observedSpecs = /* @__PURE__ */ new WeakMap();\nfunction legendPaddingRegion(spec) {\n  const result = { top: false, bottom: false, left: false, right: false };\n  function visitLegends(obj) {\n    if (!obj || typeof obj !== \"object\") return;\n    if (\"legend\" in obj) {\n      const legendObj = obj;\n      const hasInset = kInset in legendObj || kInsetX in legendObj || kInsetY in legendObj;\n      if (!hasInset && kFrameAnchor in legendObj) {\n        const frameAnchor = legendObj[kFrameAnchor];\n        switch (frameAnchor) {\n          case \"top\":\n          case \"top-left\":\n          case \"top-right\":\n            result.top = true;\n            break;\n          case \"bottom\":\n          case \"bottom-left\":\n          case \"bottom-right\":\n            result.bottom = true;\n            break;\n          case \"left\":\n            result.left = true;\n            break;\n          case \"right\":\n            result.right = true;\n            break;\n        }\n      }\n    }\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        visitLegends(obj[key]);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj.forEach((item) => visitLegends(item));\n    }\n  }\n  visitLegends(spec);\n  return result;\n}\nvar configuredLegends = /* @__PURE__ */ new WeakSet();\nvar specHandlers = /* @__PURE__ */ new WeakMap();\nvar configureLegendHandler = (specEl, responsive) => {\n  const newLegends = Array.from(specEl.querySelectorAll(\"div.legend\")).filter(\n    (legend) => !configuredLegends.has(legend)\n  );\n  if (newLegends.every((legend) => legend.childElementCount === 0)) {\n    return;\n  }\n  const frameLegends = groupLegendsByPosition(newLegends);\n  const existingObserver = specHandlers.get(specEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    specHandlers.delete(specEl);\n  }\n  const processLegends = throttle2(() => {\n    const legends = specEl.querySelectorAll(\"div.legend\");\n    legends.forEach((legend) => {\n      const legendEl = legend;\n      applyLegendStyles(legendEl);\n    });\n  }, 25);\n  if (newLegends.length > 0) {\n    emplaceLegendContainers(frameLegends, specEl);\n    newLegends.forEach((legend) => configuredLegends.add(legend));\n  }\n  processLegends();\n  if (responsive) {\n    const observer = new ResizeObserver(() => {\n      processLegends();\n    });\n    observer.observe(specEl);\n    specHandlers.set(specEl, observer);\n  }\n};\nvar applyLegendStyles = (legendEl) => {\n  const options = readLegendOptions(legendEl);\n  if (!options.frameAnchor) {\n    return;\n  }\n  const legendContainerEl = legendEl.parentElement;\n  const legendContainerParentEl = legendContainerEl.parentElement;\n  legendContainerParentEl.style.position = \"relative\";\n  if (options.frameAnchor === \"bottom\" || options.frameAnchor === \"top\") {\n    legendContainerEl.style.padding = \"0 0.3em\";\n  } else {\n    legendContainerEl.style.padding = \"0.3em\";\n  }\n  legendContainerEl.style.position = \"absolute\";\n  legendContainerEl.style.width = \"max-content\";\n  applyBackground(legendContainerEl, options.background);\n  applyBorder(legendContainerEl, options.border);\n  applyParentPadding(options, legendContainerEl, legendContainerParentEl);\n  responsiveScaleLegend(options, legendEl, legendContainerEl);\n  applyCursorStyle(legendEl);\n};\nvar applyBackground = (targetEl, background) => {\n  if (background !== false) {\n    const backgroundDefaultColor = \"var(--bs-body-bg, var(--jp-cell-editor-background, #ffffff))\";\n    targetEl.style.background = background === true ? backgroundDefaultColor : background || backgroundDefaultColor;\n  }\n};\nvar applyBorder = (targetEl, border) => {\n  if (border !== false) {\n    const borderColor = border === true ? \"#DDDDDD\" : border || \"#DDDDDD\";\n    targetEl.style.border = `1px solid ${borderColor}`;\n  }\n};\nvar applyCursorStyle = (legendEl) => {\n  const existingObserver = cursorObserver.get(legendEl);\n  if (existingObserver) {\n    existingObserver.disconnect();\n    cursorObserver.delete(legendEl);\n  }\n  const applyPointer = () => {\n    if (hasValue(legendEl, \"selection\")) {\n      const subContainerEl = legendEl.firstElementChild;\n      subContainerEl.style.cursor = \"pointer\";\n    }\n  };\n  const observer = new MutationObserver(() => {\n    applyPointer();\n  });\n  observer.observe(legendEl, { childList: true, subtree: true });\n  applyPointer();\n  cursorObserver.set(legendEl, observer);\n};\nvar cursorObserver = /* @__PURE__ */ new WeakMap();\nvar applyParentPadding = (options, legendEl, parentEl) => {\n  if (!options.inset) {\n    const observer = new MutationObserver(() => {\n      if (options.frameAnchor) {\n        const newSize = legendEl.getBoundingClientRect();\n        const parentConfig = kParentAnchorConfig[options.frameAnchor];\n        const useHeight = parentConfig.paddingType === \"paddingTop\" || parentConfig.paddingType === \"paddingBottom\";\n        parentEl.style[parentConfig.paddingType] = useHeight ? newSize.height + \"px\" : newSize.width + \"px\";\n      }\n    });\n    observer.observe(legendEl, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\", \"class\"]\n    });\n  }\n};\nvar responsiveScaleLegend = (options, legendEl, legendContainerEl) => {\n  const anchor = options.frameAnchor || \"right\";\n  const config = kLegendAnchorConfig[anchor];\n  Object.assign(legendContainerEl.style, config.position);\n  if (config.centerTransform) {\n    legendContainerEl.style.transform = \"translateX(-50%)\";\n  }\n  const plotEl = readPlotEl(legendEl);\n  if (!plotEl || !plotEl.children || plotEl.childElementCount === 0) {\n    return;\n  }\n  const parentEl = plotEl.parentElement;\n  if (!parentEl) {\n    console.warn(\"No parent element found for the plot.\");\n    return;\n  }\n  const svgEl = plotEl.children[0];\n  if (svgEl.tagName !== \"svg\") {\n    console.warn(\"The first child of the plot element is not an SVG element.\");\n    return;\n  }\n  const baseWidth = svgEl.getAttribute(\"width\");\n  if (!baseWidth) {\n    console.warn(\"Plot element does not have a width attribute.\");\n    return;\n  }\n  const parentRect = parentEl.getBoundingClientRect();\n  const actualWidth = parentRect.width;\n  const scaleFactor = actualWidth / parseFloat(baseWidth);\n  const styles = {};\n  if (config.transformOrigin) {\n    styles.transformOrigin = config.transformOrigin;\n  }\n  if (config.centerTransform) {\n    styles.transform = `translateX(-50%) scale(${scaleFactor})`;\n  } else {\n    styles.transform = `scale(${scaleFactor})`;\n  }\n  if (options.inset) {\n    const plotRect = findPlotRegionRect(plotEl);\n    const yShift = config.transformOrigin?.startsWith(\"bottom\") ? parentRect.bottom - plotRect.bottom : plotRect.top - parentRect.top;\n    const xShift = config.transformOrigin?.endsWith(\"right\") ? parentRect.right - plotRect.right : plotRect.left - parentRect.left;\n    const yInset = options.inset[1] * scaleFactor + yShift;\n    const xInset = options.inset[0] * scaleFactor + xShift;\n    if (config.centerTransform) {\n      styles.margin = `${yInset}px 0px`;\n    } else {\n      styles.margin = `${yInset}px ${xInset}px`;\n    }\n  }\n  Object.assign(legendContainerEl.style, styles);\n};\nvar resolveOptions = (options) => {\n  if (options.inset == null && options.insetX == null && options.insetY == null) {\n    return {\n      inset: void 0,\n      frameAnchor: options.frameAnchor,\n      background: options.background,\n      border: options.border\n    };\n  }\n  let inset = void 0;\n  if (options.inset !== null && options.insetX === null && options.insetY === null) {\n    inset = [Math.abs(options.inset), Math.abs(options.inset)];\n  } else if (options.insetX !== null || options.insetY !== null) {\n    inset = [Math.abs(options.insetX || 0), Math.abs(options.insetY || 0)];\n  }\n  return {\n    inset,\n    frameAnchor: options.frameAnchor,\n    background: options.background,\n    border: options.border\n  };\n};\nvar readLegendOptions = (legendEl) => {\n  const optionsRaw = readOptions(legendEl);\n  const options = {\n    inset: optionsRaw[kInset],\n    insetX: optionsRaw[kInsetX],\n    insetY: optionsRaw[kInsetY],\n    frameAnchor: optionsRaw[kFrameAnchor],\n    background: optionsRaw[kBackground],\n    border: optionsRaw[kBorder]\n  };\n  return resolveOptions(options);\n};\nvar findPlotRegionRect = (plotEl) => {\n  const plotRect = plotEl.getBoundingClientRect();\n  const yLabel = plotEl.querySelector('g[aria-label=\"y-axis label\"]');\n  const top = yLabel ? yLabel.getBoundingClientRect().bottom : plotRect.top;\n  const yTicks = plotEl.querySelector('g[aria-label=\"y-axis tick\"]');\n  const left = yTicks ? yTicks.getBoundingClientRect().right : plotRect.left;\n  const right = plotRect.right;\n  let bottom = plotRect.bottom;\n  const xTicks = plotEl.querySelector('g[aria-label=\"x-axis tick\"]');\n  if (xTicks) {\n    const xRect = xTicks.getBoundingClientRect();\n    bottom = xRect.top;\n  } else {\n    const xLabel = plotEl.querySelector('g[aria-label=\"x-axis label\"]');\n    if (xLabel) {\n      bottom = xLabel.getBoundingClientRect().top;\n    }\n  }\n  return new DOMRect(left, top, right - left, bottom - top);\n};\nvar kParentAnchorConfig = {\n  \"top-left\": { paddingType: \"paddingLeft\" },\n  top: { paddingType: \"paddingTop\" },\n  \"top-right\": { paddingType: \"paddingRight\" },\n  right: { paddingType: \"paddingRight\" },\n  \"bottom-right\": { paddingType: \"paddingRight\" },\n  bottom: { paddingType: \"paddingBottom\" },\n  \"bottom-left\": { paddingType: \"paddingLeft\" },\n  left: { paddingType: \"paddingLeft\" },\n  middle: { paddingType: \"\" }\n};\nvar kLegendAnchorConfig = {\n  \"top-left\": { position: { top: \"0\", left: \"0\" }, transformOrigin: \"top left\" },\n  top: {\n    position: { top: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"top center\"\n  },\n  \"top-right\": { position: { top: \"0\", right: \"0\" }, transformOrigin: \"top right\" },\n  right: {\n    position: { right: \"0\", transformOrigin: \"center right\" }\n  },\n  \"bottom-right\": { position: { bottom: \"0\", right: \"0\" }, transformOrigin: \"bottom right\" },\n  bottom: {\n    position: { bottom: \"0\", left: \"50%\" },\n    centerTransform: true,\n    transformOrigin: \"bottom center\"\n  },\n  \"bottom-left\": { position: { bottom: \"0\", left: \"0\" }, transformOrigin: \"bottom left\" },\n  left: {\n    position: { left: \"0\" },\n    transformOrigin: \"center left\"\n  },\n  middle: { position: {} }\n};\nfunction emplaceLegendContainers(frameLegends, specEl) {\n  for (const [positionKey, legendEls] of Object.entries(frameLegends)) {\n    for (const legendEl of legendEls) {\n      let containerEl = specEl.querySelector(\n        `div.legend-container.${positionKey}`\n      );\n      if (containerEl === null) {\n        containerEl = document.createElement(\"div\");\n        containerEl.className = `legend-container ${positionKey}`;\n        legendEl.parentElement.insertBefore(containerEl, legendEl);\n      }\n      containerEl.appendChild(legendEl);\n    }\n  }\n}\nfunction groupLegendsByPosition(legends) {\n  const frameLegends = {};\n  for (const legend of Array.from(legends)) {\n    const legendEl = legend;\n    const options = readLegendOptions(legendEl);\n    const legendKey = `${options.frameAnchor}-${options.inset?.[0] || 0}-${options.inset?.[1] || 0}`;\n    frameLegends[legendKey] = frameLegends[legendKey] || [];\n    frameLegends[legendKey].push(legendEl);\n  }\n  return frameLegends;\n}\n\n// js/widgets/mosaic.ts\nasync function render({ model, el }) {\n  const spec = JSON.parse(model.get(\"spec\"));\n  const plotDefaultsSpec = { plotDefaults: spec.plotDefaults, vspace: 0 };\n  const plotDefaultsAst = parseSpec(plotDefaultsSpec);\n  const ctx = await vizContext(plotDefaultsAst.plotDefaults);\n  applyTickFormatting(spec);\n  const tables = model.get(\"tables\") || {};\n  await syncTables(ctx, tables);\n  el.classList.add(\"mosaic-widget\");\n  const renderOptions = renderSetup(el);\n  const inputs = new Set(Object.keys(INPUTS));\n  if (renderOptions.autoFillScrolling && isPlotSpec(spec)) {\n    el.style.width = \"100%\";\n    el.style.height = \"400px\";\n  }\n  if (renderOptions.autoFill && isTableSpec(spec)) {\n    const card = el.closest(\".card-body\");\n    if (card) {\n      card.style.padding = \"0\";\n    }\n  }\n  const renderSpec = async () => {\n    try {\n      ctx.clearUnhandledErrors();\n      const targetSpec = renderOptions.autoFill ? responsiveSpec(spec, el) : spec;\n      const ast = parseSpec(targetSpec, { inputs });\n      const specEl = await astToDOM(ast, ctx);\n      el.innerHTML = \"\";\n      el.appendChild(specEl);\n      replaceTooltipImpl(specEl);\n      installTextCollisionHandler(specEl);\n      installLegendHandler(specEl, !renderOptions.autoFill);\n      await displayUnhandledErrors(ctx, el);\n    } catch (e) {\n      console.error(e);\n      const error = errorInfo(e);\n      el.innerHTML = errorAsHTML(error);\n    }\n  };\n  await renderSpec();\n  if (renderOptions.autoFill && !isInputSpec(spec)) {\n    let lastContainerWidth = el.clientWidth;\n    let lastContainerHeight = el.clientHeight;\n    const resizeObserver = new ResizeObserver(\n      throttle3(async () => {\n        if (lastContainerWidth !== el.clientWidth || lastContainerHeight !== el.clientHeight) {\n          lastContainerWidth = el.clientWidth;\n          lastContainerHeight = el.clientHeight;\n          renderSpec();\n        }\n      })\n    );\n    resizeObserver.observe(el);\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }\n}\nasync function syncTables(ctx, tables) {\n  for (const [tableName, base64Data] of Object.entries(tables)) {\n    if (base64Data) {\n      const binaryString = atob(base64Data);\n      const bytes = new Uint8Array(binaryString.length);\n      for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n      }\n      await ctx.insertTable(tableName, bytes);\n    } else {\n      await ctx.waitForTable(tableName);\n    }\n  }\n}\nfunction renderSetup(containerEl) {\n  const widgetEl = containerEl.closest(\".widget-subarea\");\n  if (widgetEl) {\n    widgetEl.style.marginBottom = \"0\";\n  }\n  const autoFill = window.document.body.classList.contains(\"quarto-dashboard\");\n  const autoFillScrolling = autoFill && !window.document.body.classList.contains(\"dashboard-fill\");\n  return { autoFill, autoFillScrolling };\n}\nfunction responsiveSpec(spec, containerEl) {\n  const kLegendWidth = 80;\n  const kLegendHeight = 35;\n  const paddingRegion = legendPaddingRegion(spec);\n  const horizontalPadding = paddingRegion.left || paddingRegion.right ? kLegendWidth : 0;\n  const verticalPadding = paddingRegion.top || paddingRegion.bottom ? kLegendHeight : 0;\n  spec = structuredClone(spec);\n  if (\"input\" in spec && spec.input === \"table\") {\n    const table = spec;\n    table.auto_filling = true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 1) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] ? hconcat[0] : null;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"hconcat\" in spec && spec.hconcat.length == 2) {\n    const hconcat = spec.hconcat;\n    const plot = \"plot\" in hconcat[0] && \"legend\" in hconcat[1] ? hconcat[0] : \"plot\" in hconcat[1] && \"legend\" in hconcat[0] ? hconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth - (spec.hconcat.length > 1 ? horizontalPadding : 0);\n      plot.height = containerEl.clientHeight;\n    }\n  } else if (\"vconcat\" in spec && spec.vconcat.length == 2) {\n    const vconcat = spec.vconcat;\n    const plot = \"plot\" in vconcat[0] && \"legend\" in vconcat[1] ? vconcat[0] : \"plot\" in vconcat[1] && \"legend\" in vconcat[0] ? vconcat[1] : void 0;\n    if (plot) {\n      plot.width = containerEl.clientWidth;\n      plot.height = containerEl.clientHeight - (spec.vconcat.length > 1 ? verticalPadding : 0);\n    }\n  }\n  return spec;\n}\nfunction isPlotSpec(spec) {\n  if (\"plot\" in spec) {\n    return true;\n  } else if (\"input\" in spec && spec.input === \"table\") {\n    return true;\n  } else if (\"hconcat\" in spec && spec.hconcat.length === 2 && (\"plot\" in spec.hconcat[0] || \"plot\" in spec.hconcat[1])) {\n    return true;\n  } else if (\"vconcat\" in spec && spec.vconcat.length === 2 && (\"plot\" in spec.vconcat[0] || \"plot\" in spec.vconcat[1])) {\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isInputSpec(spec) {\n  return \"input\" in spec && spec.input !== \"table\";\n}\nfunction isTableSpec(spec) {\n  return \"input\" in spec && spec.input === \"table\";\n}\nasync function astToDOM(ast, ctx) {\n  for (const [name, node] of Object.entries(ast.params)) {\n    if (!ctx.activeParams.has(name) || isNotebook()) {\n      const param = node.instantiate(ctx);\n      ctx.activeParams.set(name, param);\n    }\n  }\n  return ast.root.instantiate(ctx);\n}\nasync function displayUnhandledErrors(ctx, widgetEl) {\n  const emptyPlotDivs = widgetEl.querySelectorAll(\"div.plot:empty\");\n  for (const emptyDiv of emptyPlotDivs) {\n    const error = await ctx.collectUnhandledError();\n    if (error) {\n      displayRenderError(error, emptyDiv);\n    }\n  }\n}\nvar mosaic_default = { render };\nexport {\n  mosaic_default as default\n};\n","_model_module":"anywidget","_model_module_version":"~0.9.*","_model_name":"AnyModel","_view_count":null,"_view_module":"anywidget","_view_module_version":"~0.9.*","_view_name":"AnyView","layout":"IPY_MODEL_c58f0ac6b78347c8bcbb5780de7ba889","spec":"","tabbable":null,"tables":{},"tooltip":null}}},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/meridianlabs-ai\.github\.io\/inspect_viz");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            trigger: 'click',
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            positionFixed: true,
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./view-sample-tool-calls.html" class="pagination-link" aria-label="Sample Tool Calls">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Sample Tool Calls</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./components-plots.html" class="pagination-link" aria-label="Plots">
        <span class="nav-page-text">Plots</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/">
<p>Meridian Labs</p>
</a>
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz">
<p>Code</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz/blob/main/LICENSE">
<p>License</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz/issues">
<p>Issues</p>
</a>
  </li>  
</ul>
    <div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/meridianlabs-ai/inspect_viz/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/meridianlabs-ai/inspect_viz">
<p>Code</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>