[
  {
    "objectID": "components-marks.html",
    "href": "components-marks.html",
    "title": "Marks",
    "section": "",
    "text": "Marks are graphical primitives, often with accompanying data transforms, that serve as chart layers. Marks accept a Data source (which are queried as required) and a set of supported options, including encoding channels (such as x, y, fill, and stroke) that can encode data fields.\nA data field may be a column reference or query expression, including dynamic param values. Common expressions include aggregates (count(), sum(), avg(), median(), etc.), window functions, date functions, and a bin() transform.\nMarks support dual modes of operation: if an explicit array of data values is provided instead of a backing Data reference, the values will be visualized without issuing any queries to the data. This functionality is particularly useful for adding manual annotations, such as custom rules or text labels.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Marks"
    ]
  },
  {
    "objectID": "components-marks.html#overview",
    "href": "components-marks.html#overview",
    "title": "Marks",
    "section": "",
    "text": "Marks are graphical primitives, often with accompanying data transforms, that serve as chart layers. Marks accept a Data source (which are queried as required) and a set of supported options, including encoding channels (such as x, y, fill, and stroke) that can encode data fields.\nA data field may be a column reference or query expression, including dynamic param values. Common expressions include aggregates (count(), sum(), avg(), median(), etc.), window functions, date functions, and a bin() transform.\nMarks support dual modes of operation: if an explicit array of data values is provided instead of a backing Data reference, the values will be visualized without issuing any queries to the data. This functionality is particularly useful for adding manual annotations, such as custom rules or text labels.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Marks"
    ]
  },
  {
    "objectID": "components-marks.html#basic",
    "href": "components-marks.html#basic",
    "title": "Marks",
    "section": "Basic",
    "text": "Basic\nBasic marks, such as dot(), bar_x(), bar_y(), rect(), cell(), text(), tick(), rule_x(), and rule_y(), mirror their namesakes in Observable Plot.\nFor example, here is a plot with two marks. (a dot plot and a regression line):\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import dot, regression_y\n\nathletes = Data.from_file(\"athletes.parquet\")\n\nplot(\n    dot(athletes,  x=\"weight\", y=\"height\", fill=\"sex\", opacity=0.1),\n    regression_y(athletes, x=\"weight\", y=\"height\", stroke=\"sex\")\n)\n\n\n\n\nVariants such as bar_x() and bar_y() indicate spatial orientation and data type assumptions. bar_y() indicates vertical bars—continuous y over an ordinal x domain—whereas rect_y() indicates a continuous x domain.\nData is backed by a DuckDB SQL database running in the web browser. Basic marks follow a straightforward query construction process:\n\nIterate over all encoding channels to build a SELECT query.\nIf no aggregates are encountered, query all fields directly.\nIf aggregates are present, include non-aggregate fields as GROUP BY criteria.\nIf provided, map filtering criteria to a SQL WHERE clause.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Marks"
    ]
  },
  {
    "objectID": "components-marks.html#channels",
    "href": "components-marks.html#channels",
    "title": "Marks",
    "section": "Channels",
    "text": "Channels\nMarks are constructed by mapping channels to scales. Besides columns, other types of channel inputs include transforms (e.g. count(), bin(), stddev(), or even arbitrary sql() statements) as well as literal values (often used for text() annotations on plots or a line() drawn at an arbitrary location).\nHere are the scales which you will most commonly bind channels to:\n\n\n\nScale\nDescription\n\n\n\n\nx\nHorizontal position\n\n\ny\nVertical position\n\n\nfx\nHorizontal facet position\n\n\nfy\nVertical facet position\n\n\nz\nOptional ordinal channel for grouping data into series.\n\n\nr\nRadius of a mark (e.g. circle radius)\n\n\nstroke\nColor for mark\n\n\nfill\nFill color for mark\n\n\nsymbol\nSymbol used for mark\n\n\n\n\nIn addition, many marks have scales to deal with ranges of x or y values (e.g. area marks, arrows, etc.):\n\n\n\n\nScale\nDescription\n\n\n\n\nx1\nStarting horizontal position\n\n\nx2\nEnding horizontal position\n\n\ny1\nStarting vertical position\n\n\ny2\nEnding vertical position",
    "crumbs": [
      "Getting Started",
      "Components",
      "Marks"
    ]
  },
  {
    "objectID": "components-marks.html#connected",
    "href": "components-marks.html#connected",
    "title": "Marks",
    "section": "Connected",
    "text": "Connected\nThe area() and line() marks connect consecutive sample points. Connected marks are treated similarly to basic marks, with one notable addition: the queries for spatially oriented marks (area_y(), line_x()) can apply M4 optimization. The query construction method uses plot width and data min/max information to determine the pixel resolution of the mark range. When the data points outnumber available pixels, M4 performs perceptually faithful pixel-aware binning of the series, limiting the number of drawn points. This optimisation offers dramatic data reductions for both single and multiple series.\nSeparately, a regression_y() mark is available for linear regression fits. Regression calculations and associated statistics are performed in-database in a single aggregate query. The mark then draws the regression line and optional confidence interval area.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Marks"
    ]
  },
  {
    "objectID": "components-marks.html#density",
    "href": "components-marks.html#density",
    "title": "Marks",
    "section": "Density",
    "text": "Density\nThe density_y() mark performs 1D kernel density estimation (KDE). The density_y() mark defaults to areas, but supports a type option to instead use lines, points, or other basic marks. The generated query performs linear binning, an alternative to standard binning that proportionally distributes the weight of a point between adjacent bins to provide greater accuracy for density estimation. The query uses subqueries for the “left” and “right” bins, then aggregates the results. The query result is a 1D grid of binned values which are then smoothed. As smoothing is performed in the browser, interactive bandwidth updates are processed immediately.\nThe density(), contour(), heatmap(), and raster() marks compute densities over a 2D domain using either linear (default) or standard binning. Smoothing again is performed in browser; setting the bandwidth option to zero disables smoothing. The contour() mark then performs contour generation, whereas the raster() mark generates a coloured bitmap. The heatmap() mark is a convenient shortcut for a raster() that performs smoothing by default. Dynamic changes of bandwidth, contour thresholds, and color scales are handled immediately in browser.\nThe hexbin() mark pushes hexagonal binning and aggregation to the database. Color and size channels may be mapped to count() or other aggregates. Hexagon plotting symbols can be replaced by other basic marks (such as text()) via the type option.\nThe dense_line() mark creates a density map of line segments, rather than points. Line density estimation is pushed to the database. To ensure that steep lines are not over-represented, we approximate arc-length normalisation for each segment by normalising by the number of filled raster cells on a per-column basis. We then aggregate the resulting weights for all series to produce the line densities.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Marks"
    ]
  },
  {
    "objectID": "reference/inspect_viz.transform.html",
    "href": "reference/inspect_viz.transform.html",
    "title": "inspect_viz.transform",
    "section": "",
    "text": "SQL transform for a column.\n\nSource\n\ndef sql(sql: str, label: str | None = None) -&gt; Transform\n\nsql str\n\nA SQL expression string to derive a new column value. Embedded Param references, such as f\"{param} + 1\", are supported. For expressions with aggregate functions, use agg() instead.\n\nlabel str | None\n\nA label for this expression, for example to label a plot axis.\n\n\n\n\n\nAggregation transform for a column.\n\nSource\n\ndef agg(agg: str, label: str | None = None) -&gt; Transform\n\nagg str\n\nA SQL expression string to calculate an aggregate value. Embedded Param references, such as f\"SUM({param} + 1)\", are supported. For expressions without aggregate functions, use sql() instead.”\n\nlabel str | None\n\nA label for this expression, for example to label a plot axis.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.transform"
    ]
  },
  {
    "objectID": "reference/inspect_viz.transform.html#sql",
    "href": "reference/inspect_viz.transform.html#sql",
    "title": "inspect_viz.transform",
    "section": "",
    "text": "SQL transform for a column.\n\nSource\n\ndef sql(sql: str, label: str | None = None) -&gt; Transform\n\nsql str\n\nA SQL expression string to derive a new column value. Embedded Param references, such as f\"{param} + 1\", are supported. For expressions with aggregate functions, use agg() instead.\n\nlabel str | None\n\nA label for this expression, for example to label a plot axis.\n\n\n\n\n\nAggregation transform for a column.\n\nSource\n\ndef agg(agg: str, label: str | None = None) -&gt; Transform\n\nagg str\n\nA SQL expression string to calculate an aggregate value. Embedded Param references, such as f\"SUM({param} + 1)\", are supported. For expressions without aggregate functions, use sql() instead.”\n\nlabel str | None\n\nA label for this expression, for example to label a plot axis.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.transform"
    ]
  },
  {
    "objectID": "reference/inspect_viz.transform.html#column",
    "href": "reference/inspect_viz.transform.html#column",
    "title": "inspect_viz.transform",
    "section": "Column",
    "text": "Column\n\ncolumn\nIntpret a string or param-value as a column reference.\n\nSource\n\ndef column(column: str | Param) -&gt; Transform\n\ncolumn str | Param\n\nColumn name or paramameter.\n\n\n\n\nbin\nBin a continuous variable into discrete intervals.\n\nSource\n\ndef bin(\n    bin: str | float | bool | Param | Sequence[str | float | bool | Param],\n    interval: Literal[\n        \"date\",\n        \"number\",\n        \"millisecond\",\n        \"second\",\n        \"minute\",\n        \"hour\",\n        \"day\",\n        \"month\",\n        \"year\",\n    ]\n    | None = None,\n    step: float | None = None,\n    steps: float | None = None,\n    minstep: float | None = None,\n    nice: bool | None = None,\n    offset: float | None = None,\n) -&gt; Transform\n\nbin str | float | bool | Param | Sequence[str | float | bool | Param]\n\nspecifies a data column or expression to bin. Both numerical and temporal (date/time) values are supported.\n\ninterval Literal['date', 'number', 'millisecond', 'second', 'minute', 'hour', 'day', 'month', 'year'] | None\n\nThe interval bin unit to use, typically used to indicate a date/time unit for binning temporal values, such as hour, day, or month. If date, the extent of data values is used to automatically select an interval for temporal data. The value number enforces normal numerical binning, even over temporal data. If unspecified, defaults to number for numerical data and date for temporal data.\n\nstep float | None\n\nThe step size to use between bins. When binning numerical values (or interval type number), this setting specifies the numerical step size. For data/time intervals, this indicates the number of steps of that unit, such as hours, days, or years.\n\nsteps float | None\n\nThe target number of binning steps to use. To accommodate human-friendly (“nice”) bin boundaries, the actual number of bins may diverge from this exact value. This option is ignored when step is specified.\n\nminstep float | None\n\nThe minimum allowed bin step size (default 0) when performing numerical binning. For example, a setting of 1 prevents step sizes less than 1. This option is ignored when step is specified.\n\nnice bool | None\n\nA flag (default true) requesting “nice” human-friendly end points and step sizes when performing numerical binning. When step is specified, this option affects the binning end points (e.g., origin) only.\n\noffset float | None\n\nOffset for computed bins (default 0). For example, a value of 1 will result in using the next consecutive bin boundary.\n\n\n\n\ndate_day\nTransform a Date value to a day of the month for cyclic comparison.\nYear and month values are collapsed to enable comparison over days only.\n\nSource\n\ndef date_day(expr: str | Param) -&gt; Transform\n\nexpr str | Param\n\nExpression or parameter.\n\n\n\n\ndate_month\nTransform a Date value to a month boundary for cyclic comparison.\nYear values are collapsed to enable comparison over months only.\n\nSource\n\ndef date_month(expr: str | Param) -&gt; Transform\n\nexpr str | Param\n\nExpression or parameter.\n\n\n\n\ndate_month_day\nMap date/times to a month and day value, all within the same year for comparison.\nThe resulting value is still date-typed.\n\nSource\n\ndef date_month_day(expr: str | Param) -&gt; Transform\n\nexpr str | Param\n\nExpression or parameter.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.transform"
    ]
  },
  {
    "objectID": "reference/inspect_viz.transform.html#aggregate",
    "href": "reference/inspect_viz.transform.html#aggregate",
    "title": "inspect_viz.transform",
    "section": "Aggregate",
    "text": "Aggregate\n\navg\nCompute the average (mean) value of the given column.\n\nSource\n\ndef avg(\n    col: TransformArg | None = None,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg | None\n\nColumn to compute the mean for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\ncount\nA count aggregate transform.\n\nSource\n\ndef count(\n    col: TransformArg | None = None,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg | None\n\nCompute the count of records in an aggregation group. If specified, only non-null expression values are counted. If omitted, all rows within a group are counted.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nsum\nCompute the sum of the given column.\n\nSource\n\ndef sum(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the sum for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nmin\nCompute the minimum value of the given column.\n\nSource\n\ndef min(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the minimum for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nmax\nCompute the maximum value of the given column.\n\nSource\n\ndef max(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the maximum for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nmedian\nCompute the median value of the given column.\n\nSource\n\ndef median(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the median for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nmode\nCompute the mode value of the given column.\n\nSource\n\ndef mode(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the mode for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nfirst\nReturn the first column value found in an aggregation group.\n\nSource\n\ndef first(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to get the first value from.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nlast\nReturn the last column value found in an aggregation group.\n\nSource\n\ndef last(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to get the last value from.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nproduct\nCompute the product of the given column.\n\nSource\n\ndef product(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the product for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nquantile\nCompute the quantile value of the given column at the provided probability threshold.\n\nSource\n\ndef quantile(\n    col: TransformArg,\n    threshold: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the quantile for.\n\nthreshold TransformArg\n\nProbability threshold (e.g., 0.5 for median).\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nstddev\nCompute the standard deviation of the given column.\n\nSource\n\ndef stddev(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the standard deviation for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nstddev_pop\nCompute the population standard deviation of the given column.\n\nSource\n\ndef stddev_pop(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the population standard deviation for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nvariance\nCompute the sample variance of the given column.\n\nSource\n\ndef variance(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the variance for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nvar_pop\nCompute the population variance of the given column.\n\nSource\n\ndef var_pop(\n    col: TransformArg,\n    distinct: bool | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to compute the population variance for.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nargmin\nFind a value of the first column that minimizes the second column.\n\nSource\n\ndef argmin(\n    col1: TransformArg,\n    col2: TransformArg,\n    distinct: bool | None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol1 TransformArg\n\nColumn to yield the value from.\n\ncol2 TransformArg\n\nColumn to check for minimum corresponding value of col1.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nargmax\nFind a value of the first column that maximizes the second column.\n\nSource\n\ndef argmax(\n    col1: TransformArg,\n    col2: TransformArg,\n    distinct: bool | None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol1 TransformArg\n\nColumn to yield the value from.\n\ncol2 TransformArg\n\nColumn to check for maximum corresponding value of col1.\n\ndistinct bool | None\n\nAggregate distinct.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nci_bounds\nCompute a confidence interval boundary.\nReturns a tuple of two Transform objects corresponding to the lower and upper bounds of the confidence interval.\n\nSource\n\ndef ci_bounds(\n    level: float,\n    *,\n    score: str | Param,\n    stderr: str | Param,\n) -&gt; tuple[Transform, Transform]\n\nlevel float\n\nConfidence level (e.g. 0.95)\n\nscore str | Param\n\nColumn name for score.\n\nstderr str | Param\n\nColumn name for stderr.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.transform"
    ]
  },
  {
    "objectID": "reference/inspect_viz.transform.html#window",
    "href": "reference/inspect_viz.transform.html#window",
    "title": "inspect_viz.transform",
    "section": "Window",
    "text": "Window\n\nrow_number\nCompute the 1-based row number over an ordered window partition.\n\nSource\n\ndef row_number(**options: Unpack[WindowOptions]) -&gt; Transform\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nrank\nCompute the row rank over an ordered window partition.\nSorting ties result in gaps in the rank numbers ([1, 1, 3, …]).\n\nSource\n\ndef rank(**options: Unpack[WindowOptions]) -&gt; Transform\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\ndense_rank\nCompute the dense row rank (no gaps) over an ordered window partition.\nSorting ties do not result in gaps in the rank numbers ( [1, 1, 2, …]).\n\nSource\n\ndef dense_rank(**options: Unpack[WindowOptions]) -&gt; Transform\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\npercent_rank\nCompute the percetange rank over an ordered window partition.\n\nSource\n\ndef percent_rank(**options: Unpack[WindowOptions]) -&gt; Transform\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\ncume_dist\nCompute the cumulative distribution value over an ordered window partition.\nEquals the number of partition rows preceding or peer with the current row, divided by the total number of partition rows.\n\nSource\n\ndef cume_dist(**options: Unpack[WindowOptions]) -&gt; Transform\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nn_tile\nCompute an n-tile integer ranging from 1 to num_buckets dividing the partition as equally as possible.\n\nSource\n\ndef n_tile(num_buckets: int, **options: Unpack[WindowOptions]) -&gt; Transform\n\nnum_buckets int\n\nNumber of buckets.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nlag\nCompute lagging values in a column.\nReturns the value at the row that is at offset rows (default 1) before the current row within the window frame.\n\nSource\n\ndef lag(\n    col: TransformArg,\n    offset: int = 1,\n    default: TransformArg | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to take value from.\n\noffset int\n\nRows to offset.\n\ndefault TransformArg | None\n\nDefault value if thre is no such row.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nlead\nCompute leading values in a column.\nReturns the value at the row that is at offset rows (default 1) after the current row within the window frame.\n\nSource\n\ndef lead(\n    col: TransformArg,\n    offset: int = 1,\n    default: TransformArg | None = None,\n    **options: Unpack[WindowOptions],\n) -&gt; Transform\n\ncol TransformArg\n\nColumn to take value from.\n\noffset int\n\nRows to offset.\n\ndefault TransformArg | None\n\nDefault value if thre is no such row.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nfirst_value\nGet the first value of the given column in the current window frame.\n\nSource\n\ndef first_value(col: TransformArg, **options: Unpack[WindowOptions]) -&gt; Transform\n\ncol TransformArg\n\nAggregate column to take first value from.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nlast_value\nGet the last value of the given column in the current window frame.\n\nSource\n\ndef last_value(col: TransformArg, **options: Unpack[WindowOptions]) -&gt; Transform\n\ncol TransformArg\n\nAggregate column to take last value from.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.\n\n\n\n\nnth_value\nGet the nth value of the given column in the current window frame, counting from one.\n\nSource\n\ndef nth_value(\n    col: TransformArg, offset: int, **options: Unpack[WindowOptions]\n) -&gt; Transform\n\ncol TransformArg\n\nAggregate column to take nth value from.\n\noffset int\n\nOffset for the nth row.\n\n**options Unpack[WindowOptions]\n\nWindow transform options.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.transform"
    ]
  },
  {
    "objectID": "reference/inspect_viz.transform.html#types",
    "href": "reference/inspect_viz.transform.html#types",
    "title": "inspect_viz.transform",
    "section": "Types",
    "text": "Types\n\nTransform\nColumn transformation operation.\n\nSource\n\nTransform: TypeAlias = dict[str, JsonValue]\n\n\nWindowOptions\nWindow transform options.\n\nSource\n\nclass WindowOptions(TypedDict, total=False)\n\nAttributes\n\norderby str | Param | Sequence[str | Param]\n\nOne or more expressions by which to sort a windowed version of this aggregate function.\n\npartitionby str | Param | Sequence[str | Param]\n\nOne or more expressions by which to partition a windowed version of this aggregate function.\n\nrows Sequence[float | None] | Param\n\nwindow rows frame specification as an array or array-valued expression.\n\nrange Sequence[float | None] | Param\n\nWindow range frame specification as an array or array-valued expression.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.transform"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Reference",
    "section": "",
    "text": "inspect_viz\nCore API (data, components, params, selections)\n\n\ninspect_viz.plot\nPlot and legend creation.\n\n\ninspect_viz.view\nPlot and legend creation.\n\n\ninspect_viz.mark\nPlot marks (charts, annotations, etc.)\n\n\ninspect_viz.interactor\nPlot interactors for selection and navigation.\n\n\ninspect_viz.transform\nData transformers (aggregate, window, etc.)\n\n\ninspect_viz.table\nTabular data display.\n\n\ninspect_viz.input\nInputs for binding to parameters and selections.\n\n\ninspect_viz.layout\nComponent layout functions.",
    "crumbs": [
      "Reference"
    ]
  },
  {
    "objectID": "reference/inspect_viz.view.html",
    "href": "reference/inspect_viz.view.html",
    "title": "inspect_viz.view.beta",
    "section": "",
    "text": "Note\n\n\n\nView functions are currently in beta and are exported from the inspect_ai.view.beta module. The beta module will be preserved after final release so that code written against it now will continue to work after the beta.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.view"
    ]
  },
  {
    "objectID": "reference/inspect_viz.view.html#scores",
    "href": "reference/inspect_viz.view.html#scores",
    "title": "inspect_viz.view.beta",
    "section": "Scores",
    "text": "Scores\n\nscores_by_task\nBar plot for comparing eval scores.\nSummarize eval scores using a bar plot. By default, scores (y) are plotted by “task_name” (fx) and “model” (x). By default, confidence intervals are also plotted (disable this with y_ci=False).\n\nSource\n\ndef scores_by_task(\n    data: Data,\n    x: str = \"model_display_name\",\n    fx: str = \"task_name\",\n    y: str = \"score_headline_value\",\n    y_stderr: str = \"score_headline_stderr\",\n    y_ci: bool | float = 0.95,\n    y_label: str | None | NotGiven = NOT_GIVEN,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nEvals data table. This is typically created using a data frame read with the inspect evals_df() function.\n\nx str\n\nName of field for x axis (defaults to “model_display_name”)\n\nfx str\n\nName of field for x facet (defaults to “task_name”)\n\ny str\n\nName of field for y axis (defaults to “score_headline_value”).\n\ny_stderr str\n\nName of field for stderr (defaults to “score_headline_metric”).\n\ny_ci bool | float\n\nConfidence interval (e.g. 0.80, 0.90, 0.95, etc.). Defaults to 0.95.\n\ny_label str | None | NotGiven\n\nY axis label (pass None for no label).\n\nwidth float | Param | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | Param | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio)\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes. By default, the y_inset_top and margin_bottom are set to 10 pixels and x_ticks is set to [].\n\n\n\n\nscores_timeline\nEval scores by model, organization, and release date.\n\nSource\n\ndef scores_timeline(\n    data: Data,\n    organizations: list[str] | None = None,\n    ci: float | bool = 0.95,\n    x_label: str = \"Release Date\",\n    y_label: str = \"Score\",\n    eval_label: str = \"Eval\",\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nData read using evals_df() and amended with model metadata using the model_info() prepare operation (see Data Preparation for details).\n\norganizations list[str] | None\n\nList of organizations to include (in order of desired presentation).\n\nci float | bool\n\nConfidence interval (defaults to 0.95, pass False for no confidence intervals)\n\nx_label str\n\nx-axis label\n\ny_label str\n\ny-axis label\n\neval_label str\n\nEval select label.\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes. By default, the x_domain is set to “fixed”, the y_domain is set to [0,1.0], color_label is set to “Organizations”, and color_domain is set to organizations.\n\n\n\n\nscores_with_baseline\nBar plot for comparing the scores of different models on a single evaluation.\nSummarize eval scores using a bar plot. By default, scores (y) are plotted by “task_name” (fx) and “model” (x). By default, confidence intervals are also plotted (disable this with y_ci=False).\n\nSource\n\ndef scores_with_baseline(\n    data: Data,\n    *,\n    x: str = \"score_headline_value\",\n    y: str = \"model_display_name\",\n    width: float | None = None,\n    height: float | None = None,\n    baseline: int | float | Baseline | list[Baseline] | None = None,\n    sort: Literal[\"asc\", \"desc\"] | None = None,\n    x_label: str | None | NotGiven = None,\n    y_label: str | None | NotGiven = None,\n    fill: str | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nEvals data table. This is typically created using a data frame read with the inspect evals_df() function.\n\nx str\n\nName of field for x axis (defaults to “score_headline_value”).\n\ny str\n\nName of field for x axis (defaults to “model_display_name”)\n\nwidth float | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio)\n\nbaseline int | float | Baseline | list[Baseline] | None\n\nBaseline value or values to draw on the plot. This can be a single value, a Baseline dictionary, or a list of Baseline dictionaries. If None, no baseline is drawn.\n\nsort Literal['asc', 'desc'] | None\n\nSort order for the bars (sorts using the ‘x’ value). Can be “asc” or “desc”. Defaults to “asc”.\n\nx_label str | None | NotGiven\n\nx-axis label (defaults to None).\n\ny_label str | None | NotGiven\n\nx-axis label (defaults to None).\n\nfill str | None\n\nThe fill color for the bars. Defaults to “#416AD0”. Pass any valid css color value (hex, rgb, named colors, etc.).\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes. By default, the y_inset_top and margin_bottom are set to 10 pixels and x_ticks is set to [].\n\n\n\n\nscores_heatmap\nCreates a heatmap plot of success rate of eval data.\n\nSource\n\ndef scores_heatmap(\n    data: Data,\n    x: str = \"task_name\",\n    y: str = \"model_display_name\",\n    fill: str = \"score_headline_value\",\n    cell: CellOptions | None = None,\n    tip: bool = True,\n    height: float | None = None,\n    width: float | None = None,\n    x_label: str | None | NotGiven = None,\n    y_label: str | None | NotGiven = None,\n    legend: Legend | Literal[False] | None = None,\n    sort: Literal[\"ascending\", \"descending\"] | SortOrder | None = \"ascending\",\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nEvals data table.\n\nx str\n\nName of column to use for columns.\n\ny str\n\nName of column to use for rows.\n\nfill str\n\nName of the column to use as values to determine cell color.\n\ncell CellOptions | None\n\nOptions for the cell marks.\n\ntip bool\n\nWhether to show a tooltip with the value when hovering over a cell (defaults to True).\n\nheight float | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio).\n\nwidth float | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nx_label str | None | NotGiven\n\nx-axis label (defaults to None).\n\ny_label str | None | NotGiven\n\ny-axis label (defaults to None).\n\nlegend Legend | Literal[False] | None\n\nOptions for the legend. Pass None to disable the legend.\n\nsort Literal['ascending', 'descending'] | SortOrder | None\n\nSort order for the x and y axes. If ascending, the highest values will be sorted to the top right. If descending, the highest values will appear in the bottom left. If None, no sorting is applied. If a SortOrder is provided, it will be used to sort the x and y axes.\n\n**attributes Unpack[PlotAttributes]\n\nAdditional `PlotAttributes",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.view"
    ]
  },
  {
    "objectID": "reference/inspect_viz.view.html#tools",
    "href": "reference/inspect_viz.view.html#tools",
    "title": "inspect_viz.view.beta",
    "section": "Tools",
    "text": "Tools\n\ntool_calls\nHeat map visualising tool calls over evaluation turns.\n\nSource\n\ndef tool_calls(\n    data: Data,\n    x: str = \"order\",\n    y: str = \"id\",\n    tool: str = \"tool_call_function\",\n    limit: str = \"limit\",\n    tools: list[str] | None = None,\n    x_label: str | None = \"Message\",\n    y_label: str | None = \"Sample\",\n    width: float | None = None,\n    height: float | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nMessages data table. This is typically created using a data frame read with the inspect messages_df() function.\n\nx str\n\nName of field for x axis (defaults to “order”)\n\ny str\n\nName of field for y axis (defaults to “id”).\n\ntool str\n\nName of field with tool name (defaults to “tool_call_function”)\n\nlimit str\n\nName of field with sample limit (defaults to “limit”).\n\ntools list[str] | None\n\nTools to include in plot (and order to include them). Defaults to all tools found in data.\n\nx_label str | None\n\nx-axis label (defaults to “Message”).\n\ny_label str | None\n\ny-axis label (defaults to “Sample”).\n\nwidth float | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio)\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes. By default, the margin_top is set to 0, margin_left to 20, margin_right to 100, color_label is “Tool”, y_ticks is empty, and x_ticks and color_domain are calculated from data.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.view"
    ]
  },
  {
    "objectID": "reference/inspect_viz.view.html#types",
    "href": "reference/inspect_viz.view.html#types",
    "title": "inspect_viz.view.beta",
    "section": "Types",
    "text": "Types\n\nBaseline\nA baseline is a reference line that can be used to highlight important thresholds (for example, expert human performance).\n\nSource\n\nclass Baseline(TypedDict)\n\nAttributes\n\nlabel str\n\nThe display text that appears alongside the baseline line.\n\nvalue int | float\n\nThe numeric value where the baseline will be positioned on the chart’s scale.\n\ncolor NotRequired[str | None]\n\nThe color of the baseline line and label. Can be any valid CSS color value (hex, rgb, named colors, etc.). If None, defaults to black.\n\nwidth NotRequired[int | float | None]\n\nThe thickness of the baseline line in pixels. Defaults to 1.\n\ndasharray NotRequired[str | None]\n\nSVG dash pattern for the line (e.g., “5,5” for dashed line, “2,3,5,3” for dash-dot pattern). Defaults to “2,4” (a dashed line).\n\nposition NotRequired[Literal['top', 'bottom'] | None]\n\nControls where the label text appears relative to the baseline line. “top” places the label above the line, “bottom” places it below. Defaults to the “top” position.\n\n\n\n\n\nCellOptions\nCell options for the heatmap.\n\nSource\n\nclass CellOptions(TypedDict, total=False)\n\nAttributes\n\ninset float | None\n\nInset for the cell marks. Defaults to 1 pixel.\n\ntext str | None\n\nText color for the cell marks. Defaults to “white”. Set to None to disable text.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.view"
    ]
  },
  {
    "objectID": "reference/inspect_viz.input.html",
    "href": "reference/inspect_viz.input.html",
    "title": "inspect_viz.input",
    "section": "",
    "text": "select\nSelect input.\nSelect inputs can be populated either from a database table (via the data and column parameters) or from a static set of options (via the options parameter).\nSelect inputs can produce either a single value or multiple values when multiple=True is specified.\nSelect inputs have a target which is either a Param or Selection. In the latter case, the field parameter determines the data column name to use within generated selection clause predicates (defaulting to column). If no target is specified then the data source’s selection is used as the target.\nThe intitial selected value will be “All” when target is a Selection (indicating select all records) and the param value when target is a Param.\n\nSource\n\ndef select(\n    data: Data | None = None,\n    *,\n    filter_by: Selection | None = None,\n    column: str | None = None,\n    options: Sequence[str | bool | float]\n    | Mapping[str, str | bool | float]\n    | None = None,\n    value: Literal[\"all\", \"auto\"] | str | list[str] = \"all\",\n    multiple: bool = False,\n    target: Param | Selection | None = None,\n    field: str | None = None,\n    label: str | None = None,\n    width: float | None = None,\n) -&gt; Component\n\ndata Data | None\n\nThe data source (used in conjunction with the column parameter). If data is not specified, you must provide explcit options.\n\nfilter_by Selection | None\n\nA selection to filter the data source indicated by the data parameter.\n\ncolumn str | None\n\nThe name of a column from which to pull options. The unique column values are used as options. Used in conjunction with the data parameter.\n\noptions Sequence[str | bool | float] | Mapping[str, str | bool | float] | None\n\nA list or dict of options (provide a dict if you want values to map to alternate labels). Alternative to populating options from a database column via data and column.\n\nvalue Literal['all', 'auto'] | str | list[str]\n\nInitial value for selection. Pass “all” (the default) for no filtering, “auto” to select the first element in the list, or value(s) for an explicit initial selection. Applies only when target is a Selection (as Param carries its own default value).\n\nmultiple bool\n\nEnable selection of multiple values (defaults to False)\n\ntarget Param | Selection | None\n\nA Param or Selection that this select input should update. For a Param, the selected value is set to be the new param value. For a Selection, a predicate of the form column = value will be added to the selection.\n\nfield str | None\n\nThe data column name to use within generated selection clause predicates. Defaults to the column parameter.\n\nlabel str | None\n\nA text label for the input. If unspecified, the column name (if provided) will be used by default.\n\nwidth float | None\n\nWidth in pixels (defaults to 150).\n\n\n\n\nslider\nSelect input widget.\n\nSource\n\ndef slider(\n    data: Data | None = None,\n    *,\n    filter_by: Selection | None = None,\n    label: str | None = None,\n    column: str | None = None,\n    field: str | None = None,\n    target: Param | Selection | None = None,\n    select: Literal[\"point\", \"interval\"] | None = None,\n    value: float | tuple[float, float] | None = None,\n    min: float | None = None,\n    max: float | None = None,\n    step: float | None = None,\n    width: float = 150,\n) -&gt; Component\n\ndata Data | None\n\nThe data source for this widget. Used in conjunction with the column property. The minimum and maximum values of the column determine the slider range.\n\nfilter_by Selection | None\n\nA selection to filter the data source indicated by the data property.\n\nlabel str | None\n\nA text label for this input (optional).\n\ncolumn str | None\n\nThe name of a database column whose values determine the slider range. Used in conjunction with the data property. The minimum and maximum values of the column determine the slider range.\n\nfield str | None\n\nThe database column name to use within generated selection clause predicates. Defaults to the column property.\n\ntarget Param | Selection | None\n\nA Param or Selection that this select input should update. For a Param, the selected value is set to be the new param value. For a Selection, a predicate that does an equality check (for select==\"point\") or range check (for select==\"interval\").\n\nselect Literal['point', 'interval'] | None\n\nThe type of selection clause predicate to generate when selection is specified. If 'point' (the default for a single value), the selection predicate is an equality check for the slider value. If 'interval' (the default for a pair of values), the predicate checks the slider value interval.\n\nvalue float | tuple[float, float] | None\n\nThe initial slider value. Either a single numeric value or a tuple of two values representing a range.\n\nmin float | None\n\nThe minumum slider value.\n\nmax float | None\n\nThe maximum slider value.\n\nstep float | None\n\nThe slider step, the amount to increment between consecutive values.\n\nwidth float\n\nThe width of the slider in screen pixels (defaults to 200)\n\n\n\n\nsearch\nText search input widget\n\nSource\n\ndef search(\n    data: Data,\n    *,\n    filter_by: Selection | None = None,\n    column: str | None = None,\n    field: str | None = None,\n    target: Param | Selection | None = None,\n    type: Literal[\"contains\", \"prefix\", \"suffix\", \"regexp\"] | None = None,\n    label: str | None = None,\n    placeholder: str | None = None,\n    width: float | None = None,\n) -&gt; Component\n\ndata Data\n\nThe data source for input selections (used in conjunction with the column property).\n\nfilter_by Selection | None\n\nA selection to filter the data source indicated by the data property.\n\ncolumn str | None\n\nTThe name of a database column from which to pull valid search results. The unique column values are used as search autocomplete values. Used in conjunction with the data property.\n\nfield str | None\n\nThe data column name to use within generated selection clause predicates. Defaults to the column property.\n\ntarget Param | Selection | None\n\nA Param or Selection that this search box should update. For a Param, the textbox value is set as the new param value. For a Selection, a predicate based on the type option will be added to the selection.\n\ntype Literal['contains', 'prefix', 'suffix', 'regexp'] | None\n\nThe type of text search query to perform. One of: - \"contains\" (default): the query string may appear anywhere in the text - \"prefix\": the query string must appear at the start of the text - \"suffix\": the query string must appear at the end of the text - \"regexp\": the query string is a regular expression the text must match\n\nlabel str | None\n\nA text label for this input (optional).\n\nplaceholder str | None\n\nPlaceholder text for empty search box.\n\nwidth float | None\n\nWidth in pixels (defaults to 150).\n\n\n\n\ncheckbox\nCheckbox.\nCheckboxes have a target which is either a Param or Selection. In the latter case, the field parameter determines the data column name to use within generated selection clause predicates (defaulting to column). If no target is specified then the data source’s selection is used as the target.\nThe values tuple enables you to determine what value is communicated to the target for checked and unchecked states (by default, this is True and False).\n\nSource\n\ndef checkbox(\n    data: Data | None = None,\n    *,\n    label: str | None = None,\n    target: Param | Selection | None = None,\n    field: str | None = None,\n    checked: bool = False,\n    values: tuple[str | float | bool | None, str | float | bool | None] = (True, False),\n) -&gt; Component\n\ndata Data | None\n\nThe data source (required when specifying the field parameter to target a data source selection).\n\nlabel str | None\n\nA text label for the input (required)\n\ntarget Param | Selection | None\n\nA Param or Selection that this checkbox should interact with (use values to customize the values that are used in the target).\n\nfield str | None\n\nThe data column name to use within generated selection clause predicates (required if target is not a Param).\n\nchecked bool\n\nShould the checkbox be in the checked state by default.\n\nvalues tuple[str | float | bool | None, str | float | bool | None]\n\nWhat value is communicated to the target for checked and unchecked states.\n\n\n\n\nradio_group\nRadio group.\nRadio groups can be populated either from a database table (via the data and column parameters) or from a static set of options (via the options parameter).\nRadio groups have a target which is either a Param or Selection. In the latter case, the field parameter determines the data column name to use within generated selection clause predicates (defaulting to column). If no target is specified then the data source’s selection is used as the target.\nThe intitial selected value will be “All” when target is a Selection (indicating select all records) and the param value when target is a Param.\n\nSource\n\ndef radio_group(\n    data: Data | None = None,\n    *,\n    column: str | None = None,\n    options: Sequence[str | bool | float]\n    | Mapping[str, str | bool | float]\n    | None = None,\n    target: Param | Selection | None = None,\n    field: str | None = None,\n    label: str | None = None,\n    filter_by: Selection | None = None,\n) -&gt; Component\n\ndata Data | None\n\nThe data source (used in conjunction with the column parameter). If data is not specified, you must provide explcit options.\n\ncolumn str | None\n\nThe name of a column from which to pull options. The unique column values are used as options. Used in conjunction with the data parameter.\n\noptions Sequence[str | bool | float] | Mapping[str, str | bool | float] | None\n\nA list or dict of options (provide a dict if you want values to map to alternate labels). Alternative to populating options from a database column via data and column.\n\ntarget Param | Selection | None\n\nA Param or Selection that this radio group should update. For a Param, the selected value is set to be the new param value. For a Selection, a predicate of the form column = value will be added to the selection.\n\nfield str | None\n\nThe data column name to use within generated selection clause predicates. Defaults to the column parameter.\n\nlabel str | None\n\nA text label for the input. If unspecified, the column name (if provided) will be used by default.\n\nfilter_by Selection | None\n\nA selection to filter the data source indicated by the data parameter.\n\n\n\n\ncheckbox_group\nCheckbox group.\nRadio groups can be populated either from a database table (via the data and column parameters) or from a static set of options (via the options parameter).\nCheckbox groups have a target which is either a Param or Selection. In the latter case, the field parameter determines the data column name to use within generated selection clause predicates (defaulting to column). If no target is specified then the data source’s selection is used as the target.\nThe intitial selected values will be empty when target is a Selection (indicating select all records) and the param value(s) when target is a Param (param values should be an array with one or more checkbox values).\n\nSource\n\ndef checkbox_group(\n    data: Data | None = None,\n    *,\n    column: str | None = None,\n    options: Sequence[str | bool | float] | dict[str, str | bool | float] | None = None,\n    target: Param | Selection | None = None,\n    field: str | None = None,\n    label: str | None = None,\n    filter_by: Selection | None = None,\n) -&gt; Component\n\ndata Data | None\n\nThe data source (used in conjunction with the column parameter). If data is not specified, you must provide explcit options.\n\ncolumn str | None\n\nThe name of a column from which to pull options. The unique column values are used as options. Used in conjunction with the data parameter.\n\noptions Sequence[str | bool | float] | dict[str, str | bool | float] | None\n\nA list or dict of options (provide a dict if you want values to map to alternate labels). Alternative to populating options from a database column via data and column.\n\ntarget Param | Selection | None\n\nA Param or Selection that this radio group should update. For a Param, the selected value is set to be the new param value. For a Selection, a predicate of the form column IN (values) will be added to the selection.\n\nfield str | None\n\nThe data column name to use within generated selection clause predicates. Defaults to the column parameter.\n\nlabel str | None\n\nA text label for the input. If unspecified, the column name (if provided) will be used by default.\n\nfilter_by Selection | None\n\nA selection to filter the data source indicated by the data parameter.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.input"
    ]
  },
  {
    "objectID": "reference/inspect_viz.table.html",
    "href": "reference/inspect_viz.table.html",
    "title": "inspect_viz.table",
    "section": "",
    "text": "table\nTabular display of data.\n\nSource\n\ndef table(\n    data: Data,\n    *,\n    columns: Sequence[str | Column] | None = None,\n    filter_by: Selection | None = None,\n    target: Selection | None = None,\n    select: Literal[\n        \"hover\",\n        \"single_row\",\n        \"multiple_row\",\n        \"single_checkbox\",\n        \"multiple_checkbox\",\n        \"none\",\n    ]\n    | None = None,\n    width: float | None = None,\n    max_width: float | None = None,\n    height: float | Literal[\"auto\"] | None = None,\n    header_height: float | None = None,\n    row_height: float | None = None,\n    sorting: bool | None = None,\n    filtering: bool | Literal[\"header\", \"row\"] | None = None,\n    pagination: bool | Pagination | None = None,\n    style: TableStyle | None = None,\n) -&gt; Component\n\ndata Data\n\nThe data source for the table.\n\ncolumns Sequence[str | Column] | None\n\nA list of column names to include in the table grid. If unspecified, all table columns are included.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\ntarget Selection | None\n\nThe output selection. A selection clause of the form column IN (rows) will be added to the selection for each currently selected table row.\n\nselect Literal['hover', 'single_row', 'multiple_row', 'single_checkbox', 'multiple_checkbox', 'none'] | None\n\nThe type of selection to use for the table. Valid values are “hover”, “single_checkbox”, “multiple_checkbox”, “single_row”, “multiple_row”, and “none”. Defaults to “single_row”.\n\nwidth float | None\n\nThe total width of the table widget, in pixels.\n\nmax_width float | None\n\nThe maximum width of the table widget, in pixels.\n\nheight float | Literal['auto'] | None\n\nEither the height of the table widget in pixels, or “auto”. If “auto”, the height of the table will fit the content within the table up to the 500px. Defaults to “auto”.\n\nheader_height float | None\n\nThe height of the table header, in pixels.\n\nrow_height float | None\n\nThe height of each table row, in pixels.\n\nsorting bool | None\n\nSet whether sorting columns is enabled.\n\nfiltering bool | Literal['header', 'row'] | None\n\nEnable filtering. If set to ‘header’ a filter button is shown in the table header. If set to ‘row’, a filter is shown in a row beneath the header.\n\npagination bool | Pagination | None\n\nEnable pagination. If set to True, default pagination settings are used. If set to a Pagination object, custom pagination settings are used.\n\nstyle TableStyle | None\n\nThe style configuration for the table display.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.table"
    ]
  },
  {
    "objectID": "publishing-notebooks.html",
    "href": "publishing-notebooks.html",
    "title": "Notebooks",
    "section": "",
    "text": "A convenient way to share sets of plots and related commentary is to publish a notebook. There are a couple of straightforward ways to create HTML documents from notebooks (Quarto and nbconvert), and then these documents can in turn be printed to PDF if required.\nYou can also share a live version of a notebook that supports filtering and plot interactions by pubishing it on a platform like Google Colab.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Notebooks"
    ]
  },
  {
    "objectID": "publishing-notebooks.html#overview",
    "href": "publishing-notebooks.html#overview",
    "title": "Notebooks",
    "section": "",
    "text": "A convenient way to share sets of plots and related commentary is to publish a notebook. There are a couple of straightforward ways to create HTML documents from notebooks (Quarto and nbconvert), and then these documents can in turn be printed to PDF if required.\nYou can also share a live version of a notebook that supports filtering and plot interactions by pubishing it on a platform like Google Colab.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Notebooks"
    ]
  },
  {
    "objectID": "publishing-notebooks.html#quarto",
    "href": "publishing-notebooks.html#quarto",
    "title": "Notebooks",
    "section": "Quarto",
    "text": "Quarto\nThe Quarto publishing system can also convert notebooks to HTML. To install the quarto-cli Python package:\npip install quarto-cli\nThen, convert any notebook which includes Inspect Viz plots as follows:\nquarto render notebook.ipynb --to html --execute\nThis will create an HTML file named “notebook.html” and a directory named “notebook_files” alongside the “notebook.ipynb”.\nYou can also specify that you’d like code cells removed using the -M echo:false option:\nquarto render notebook.ipynb --to html --execute -M echo:false\nIf you need a PDF version of the notebook, open the file in a browser and print to PDF.\n\nPublishing\nYou can use the Quarto Publish command to publish a notebook to GitHub Pages, Hugging Face Spaces, Netlify, or Quarto’s own publishing service.\nTo publish a notebook, pass it to the quarto publish command:\nquarto publish notebook.ipynb",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Notebooks"
    ]
  },
  {
    "objectID": "publishing-notebooks.html#nbconvert",
    "href": "publishing-notebooks.html#nbconvert",
    "title": "Notebooks",
    "section": "nbconvert",
    "text": "nbconvert\nThe nbconvert Python package enables export of any Jupyter notebook to HTML. Install nbconvert with:\npip install nbconvert\nThen, convert any notebook which includes Inspect Viz plots as follows:\njupyter nbconvert --to html --execute notebook.ipynb\nThis will create an HTML file named “notebook.html” alongside the “notebook.ipynb”.\nYou can also specify that you’d like code cells removed using the --no-input option:\njupyter nbconvert --to html --execute --no-input notebook.ipynb\nIf you need a PDF version of the notebook, open the file in a browser and print to PDF.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Notebooks"
    ]
  },
  {
    "objectID": "view-scores-by-factor.html",
    "href": "view-scores-by-factor.html",
    "title": "Scores by Factor",
    "section": "",
    "text": "The scores_by_factor() function renders a bar plot for comparing eval scores by model and a boolean factor (e.g. non-reasoning vs. reasoning, no hint vs. hint, etc.).\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_by_factor\n\nevals = Data.from_file(\"evals-hint.parquet\")\nscores_by_factor(evals, \"task_arg_hint\", (\"No hint\", \"Hint\"))",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Factor"
    ]
  },
  {
    "objectID": "view-scores-by-factor.html#overview",
    "href": "view-scores-by-factor.html#overview",
    "title": "Scores by Factor",
    "section": "",
    "text": "The scores_by_factor() function renders a bar plot for comparing eval scores by model and a boolean factor (e.g. non-reasoning vs. reasoning, no hint vs. hint, etc.).\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_by_factor\n\nevals = Data.from_file(\"evals-hint.parquet\")\nscores_by_factor(evals, \"task_arg_hint\", (\"No hint\", \"Hint\"))",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Factor"
    ]
  },
  {
    "objectID": "view-scores-by-factor.html#data-preparation",
    "href": "view-scores-by-factor.html#data-preparation",
    "title": "Scores by Factor",
    "section": "Data Preparation",
    "text": "Data Preparation\nAbove we read the data for the plot from a parquet file. This file was in turn created by:\n\nReading logs into a data frame with evals_df().\nUsing the prepare() function to add model_info() and log_viewer() columns to the data frame.\n\nfrom inspect_ai.analysis.beta import evals_df, log_viewer, model_into, prepare\n\ndf = evals_df(\"logs\")\ndf = prepare(df, \n    model_info(),\n    log_viewer(\"eval\", {\"logs\": \"https://samples.meridianlabs.ai/\"}),\n)\ndf.to_parquet(\"evals-hint.parquet\")\nYou should also ensure that your evals data frame has a boolean field corresponding to the factor you are splitting on (in the example above this is “task_arg_hint”).",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Factor"
    ]
  },
  {
    "objectID": "view-scores-by-factor.html#function-reference",
    "href": "view-scores-by-factor.html#function-reference",
    "title": "Scores by Factor",
    "section": "Function Reference",
    "text": "Function Reference\nSummarize eval scores with a factor of variation (e.g ‘No hint’ vs. ‘Hint’).\n\nSource\n\ndef scores_by_factor(\n    data: Data,\n    fx: str,\n    fx_labels: tuple[str, str],\n    x: str = \"score_headline_value\",\n    x_stderr: str = \"score_headline_stderr\",\n    x_label: str = \"Score\",\n    y: str = \"model\",\n    y_label: str = \"Model\",\n    ci: bool | float = 0.95,\n    color: str | tuple[str, str] = \"#3266ae\",\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nEvals data table. This is typically created using a data frame read with the inspect evals_df() function.\n\nfx str\n\nField with factor of variation (should be of type boolean).\n\nfx_labels tuple[str, str]\n\nTuple of labels for factor of variation. False value should be first, e.g. (\"No hint\", \"Hint\").\n\nx str\n\nName of field for x (scoring) axis (defaults to “score_headline_value”).\n\nx_stderr str\n\nName of field for scoring stderr (defaults to “score_headline_stderr”).\n\nx_label str\n\nLabel for x-axis (defaults to “Score”).\n\ny str\n\nName of field for y axis (defaults to “model”).\n\ny_label str\n\nLable for y axis (defaults to “Model”).\n\nci bool | float\n\nConfidence interval (e.g. 0.80, 0.90, 0.95, etc.). Defaults to 0.95.)\n\ncolor str | tuple[str, str]\n\nHex color value (or tuple of two values). If one value is provided the second is computed by lightening the main color.\n\nwidth float | Param | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | Param | None\n\nThe outer height of the plot in pixels, including margins. Default to 65 pixels for each item on the “y” axis.\n\n**attributes Unpack[PlotAttributes]\n\nAdditional `PlotAttributes",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Factor"
    ]
  },
  {
    "objectID": "view-scores-by-factor.html#implementation",
    "href": "view-scores-by-factor.html#implementation",
    "title": "Scores by Factor",
    "section": "Implementation",
    "text": "Implementation\nThe Scores by Factor example demonstrates how this view was implemented using lower level plotting components.",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Factor"
    ]
  },
  {
    "objectID": "view-scores-heatmap.html",
    "href": "view-scores-heatmap.html",
    "title": "Scores Heatmap",
    "section": "",
    "text": "The scores_heatmap()function renders a heatmap for comparing eval scores.\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_heatmap\n\nevals = Data.from_file(\"evals.parquet\")\nscores_heatmap(evals, height=200, legend=False)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Heatmap"
    ]
  },
  {
    "objectID": "view-scores-heatmap.html#overview",
    "href": "view-scores-heatmap.html#overview",
    "title": "Scores Heatmap",
    "section": "",
    "text": "The scores_heatmap()function renders a heatmap for comparing eval scores.\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_heatmap\n\nevals = Data.from_file(\"evals.parquet\")\nscores_heatmap(evals, height=200, legend=False)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Heatmap"
    ]
  },
  {
    "objectID": "view-scores-heatmap.html#data-preparation",
    "href": "view-scores-heatmap.html#data-preparation",
    "title": "Scores Heatmap",
    "section": "Data Preparation",
    "text": "Data Preparation\nAbove we read the data for the plot from a parquet file. This file was in turn created by:\n\nReading logs into a data frame with evals_df().\nUsing the prepare() function to add model_info() and log_viewer() columns to the data frame.\n\nfrom inspect_ai.analysis.beta import evals_df, log_viewer, model_into, prepare\n\ndf = evals_df(\"logs\")\ndf = prepare(df, \n    model_info(),\n    log_viewer(\"eval\", {\"logs\": \"https://samples.meridianlabs.ai/\"}),\n)\ndf.to_parquet(\"evals.parquet\")\nNote that both the log viewer links and model names are optional (the plot will render without links and use raw model strings if the data isn’t prepared with log_viewer() and model_info()).",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Heatmap"
    ]
  },
  {
    "objectID": "view-scores-heatmap.html#function-reference",
    "href": "view-scores-heatmap.html#function-reference",
    "title": "Scores Heatmap",
    "section": "Function Reference",
    "text": "Function Reference\nCreates a heatmap plot of success rate of eval data.\n\nSource\n\ndef scores_heatmap(\n    data: Data,\n    x: str = \"task_name\",\n    y: str = \"model_display_name\",\n    fill: str = \"score_headline_value\",\n    cell: CellOptions | None = None,\n    tip: bool = True,\n    height: float | None = None,\n    width: float | None = None,\n    x_label: str | None | NotGiven = None,\n    y_label: str | None | NotGiven = None,\n    legend: Legend | Literal[False] | None = None,\n    sort: Literal[\"ascending\", \"descending\"] | SortOrder | None = \"ascending\",\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nEvals data table.\n\nx str\n\nName of column to use for columns.\n\ny str\n\nName of column to use for rows.\n\nfill str\n\nName of the column to use as values to determine cell color.\n\ncell CellOptions | None\n\nOptions for the cell marks.\n\ntip bool\n\nWhether to show a tooltip with the value when hovering over a cell (defaults to True).\n\nheight float | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio).\n\nwidth float | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nx_label str | None | NotGiven\n\nx-axis label (defaults to None).\n\ny_label str | None | NotGiven\n\ny-axis label (defaults to None).\n\nlegend Legend | Literal[False] | None\n\nOptions for the legend. Pass None to disable the legend.\n\nsort Literal['ascending', 'descending'] | SortOrder | None\n\nSort order for the x and y axes. If ascending, the highest values will be sorted to the top right. If descending, the highest values will appear in the bottom left. If None, no sorting is applied. If a SortOrder is provided, it will be used to sort the x and y axes.\n\n**attributes Unpack[PlotAttributes]\n\nAdditional `PlotAttributes",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Heatmap"
    ]
  },
  {
    "objectID": "view-scores-heatmap.html#implementation",
    "href": "view-scores-heatmap.html#implementation",
    "title": "Scores Heatmap",
    "section": "Implementation",
    "text": "Implementation\nThe Scores Heatmap example demonstrates how this view was implemented using lower level plotting components.",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Heatmap"
    ]
  },
  {
    "objectID": "examples/general/seattle-weather/index.html",
    "href": "examples/general/seattle-weather/index.html",
    "title": "Seattle Weather",
    "section": "",
    "text": "Select a horizontal range on the dot pot to filter the contents of the bar plot. Click the legend or the bar plot to filter by weather conditions.\n\n\n\nCode\n\nfrom inspect_viz import Data, Selection\nfrom inspect_viz.interactor import Brush, highlight, interval_x, toggle_y\nfrom inspect_viz.plot import legend, plot, plot_defaults\nfrom inspect_viz.mark import bar_x, dot\nfrom inspect_viz.layout import vconcat\nfrom inspect_viz.transform import count, date_month_day\n\n# data\nseattle = Data.from_file(\"seattle-weather.parquet\")\n\n# plot defaults for domain and range\nweather = [\"sun\", \"fog\", \"drizzle\", \"rain\", \"snow\"]\nplot_defaults(\n    color_domain=weather,\n    color_range=[\"#e7ba52\", \"#a7a7a7\", \"#aec7e8\", \"#1f77b4\", \"#9467bd\"]\n)\n\n# selections (scatter x-range and bar/legend click)\nrange = Selection(\"intersect\")\nclick = Selection(\"single\")\n\nvconcat(\n    plot(\n        dot(\n            data=seattle,\n            filter_by=click,\n            x=date_month_day(\"date\"),\n            y=\"temp_max\",\n            fill=\"weather\",\n            fill_opacity=0.7,\n            r=\"precipitation\",\n        ),\n        interval_x(target=range, brush=Brush(fill=\"none\", stroke=\"#888\")),\n        highlight(by=range, fill=\"#ccc\", fill_opacity=0.2),\n        legend=legend(\"color\", target=click),\n        xy_domain=\"fixed\",\n        x_tick_format=\"%b\",\n        r_domain=\"fixed\",\n        r_range=[2, 10]\n    ),\n    plot(\n        bar_x(seattle, x=count(), y=\"weather\", fill=\"#ccc\", fill_opacity=0.2),\n        bar_x(seattle, filter_by=range, x=count(), y=\"weather\", fill=\"weather\"),\n        toggle_y(target=click),\n        highlight(by=click),\n        x_domain=\"fixed\",\n        y_domain=weather,\n        y_label=None,\n        height=200\n    )\n)",
    "crumbs": [
      "Examples",
      "General",
      "Seattle Weather"
    ]
  },
  {
    "objectID": "examples/general/bias-parameter/index.html",
    "href": "examples/general/bias-parameter/index.html",
    "title": "Bias Parameter",
    "section": "",
    "text": "Use the slider to create bias offsets for the y-axis.\n\n\n\nCode\n\nfrom inspect_viz import Data, Param\nfrom inspect_viz.input import slider\nfrom inspect_viz.mark import area_y\nfrom inspect_viz.layout import vconcat\nfrom inspect_viz.plot import plot\nfrom inspect_viz.transform import sql\n\nrandom_walk = Data.from_file(\"random-walk.parquet\")\nbias = Param(100)\n\nvconcat(\n    slider(label=\"Bias\", target=bias, min=0, max=1000, step=1),\n    plot(area_y(random_walk, x=\"t\", y=sql(f\"v + {bias}\"), fill=\"steelblue\"))\n)",
    "crumbs": [
      "Examples",
      "General",
      "Bias Parameter"
    ]
  },
  {
    "objectID": "examples/general/penguins/index.html",
    "href": "examples/general/penguins/index.html",
    "title": "Penguins Explorer",
    "section": "",
    "text": "Use the species drop down to see only points for a particular species. Use the x and y drop downs to explore differnet variables.\n\n\n\nCode\n\nfrom inspect_viz import Data, Param\nfrom inspect_viz.input import select\nfrom inspect_viz.layout import hconcat, vconcat\nfrom inspect_viz.mark import dot\nfrom inspect_viz.plot import plot\nfrom inspect_viz.table import table\n\npenguins = Data.from_file(\"penguins.parquet\")\n\naxes = [\"body_mass\", \"flipper_length\", \"bill_depth\", \"bill_length\"]\nx_axis = Param(\"body_mass\")\ny_axis = Param(\"flipper_length\")\n\nvconcat(\n    hconcat(\n        select(penguins, label=\"Species\", column=\"species\"),\n        select(label=\"X\", options=axes, target=x_axis),\n        select(label=\"Y\", options=axes, target=y_axis)\n    ),\n    plot(\n        dot(penguins, x=x_axis, y=y_axis, stroke=\"species\", symbol=\"species\"),\n        grid=True,\n        x_label=\"Body mass (g) →\",\n        y_label=\"↑ Flipper length (mm)\",\n        legend=\"symbol\",\n    ),\n    table(penguins)\n)",
    "crumbs": [
      "Examples",
      "General",
      "Penguins Explorer"
    ]
  },
  {
    "objectID": "examples/inspect/scores-with-baseline/index.html",
    "href": "examples/inspect/scores-with-baseline/index.html",
    "title": "Scores With Baseline",
    "section": "",
    "text": "This example illustrates the code behind the scores_with_baseline() pre-built view function. If you want to include this plot in your notebooks or websites you should start with that function rather than the lower-level code below.\nThe plot summarizes the scores of a single evaluation task, showing performance for 13 different models. Models are ordered based upon their headline score (defaulting to descending).\n\n\n\nCode\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import bar_x, rule_x, text\n\nevals = Data.from_file(\"agi-lsat-ar.parquet\")\n\nbaseline_color = \"#000000\"\nbaseline_value = 0.91\n    \nplot(\n1    bar_x(\n        evals,\n        x=\"score_headline_value\",\n        y=\"model\",\n        sort={\"y\": \"x\", \"reverse\": True},\n        fill=\"#416AD0\",\n        channels={\"Log Viewer\": \"log_viewer\"},\n        tip=True\n    ),\n2    rule_x(\n        x=[baseline_value],\n        stroke_dasharray=\"2,4\",\n        stroke_width=1,\n        stroke=[baseline_color]\n    ),\n3    text(\n        x=[baseline_value],\n        frame_anchor=\"top\",\n        line_anchor=\"bottom\",\n        dy=-3,\n        text=[\"Baseline\"],\n        text_anchor=\"middle\",\n        fill=[baseline_color]\n    ),\n4    marginLeft=250,\n    marginTop=30,\n    x_domain=[0, 1.0],\n    y_label=None,\n    x_label=\"Accuracy\"\n)\n\n\n\n1\n\nThis draws the core bar chart, sorting the y-axis by the value of x.\n\n2\n\nThis draws the baseline at the baseline_value position. Note that we are passing an explicit value for baseline rather that reading the value from the data frame.\n\n3\n\nThis draws the text label for the baseline, positioning it at the top of the frame and anchoring the bottom of the text to the that top position.\n\n4\n\nProvide margin to allow space for the y-axis labels and for the baseline text above the plot.",
    "crumbs": [
      "Examples",
      "Inspect",
      "Scores w/ Baseline"
    ]
  },
  {
    "objectID": "examples/inspect/tool-calls/index.html",
    "href": "examples/inspect/tool-calls/index.html",
    "title": "Tool Calls",
    "section": "",
    "text": "This example illustrates the code behind the tool_calls() pre-built view function. If you want to include this plot in your notebooks or websites you should start with that function rather than the lower-level code below.\nThe plot visualizes tool usage over a series of turns in a Cybench evaluation. We use a cell() mark to visualize tool use over messages in each sample of an evaluation. We note any limit that ended the sample using a text() mark on the right side of the frame.\n\n\n\nCode\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot, legend\nfrom inspect_viz.mark import cell, text\n\n# read data (see 'Data Preparation' below)\n1data = Data.from_file(\"cybench_tools.parquet\")\n\ntools = [\"bash\", \"python\", \"submit\"]\n\nplot(\n2    cell(\n        data,\n        x=\"order\",\n        y=\"id\",\n        fill=\"tool_call_function\"\n    ),\n    \n3    text(\n        data, \n        text=\"limit\", \n        y=\"id\",\n        frame_anchor=\"right\", \n        font_size=8, \n        font_weight=200,\n        dx=50\n    ),\n    legend=legend(\"color\", location=\"right\"),\n4    margin_top=0,\n    margin_left=20,\n    margin_right=100,\n5    x_ticks=list(range(0, 400, 80)),\n    y_ticks=[],\n6    x_label=\"Message\",\n    y_label=\"Sample\",\n    color_label=\"Tool\",\n7    color_domain=tools\n)\n\n\n\n1\n\nRead tool call data (see Data Preparation for details).\n\n2\n\ncell() mark showing tool calls.\n\n3\n\ntext() mark showing whether the sample terminated due to a limit.\n\n4\n\nTweak the margins so the axis labels and text annotations appear correctly.\n\n5\n\nReduce the number of tick marks on the x-axis and eliminate y-ticks.\n\n6\n\nSet some custom labels and ensure that tools follow our designed order.\n\n7\n\nSpecify which tools we should show and in what order.",
    "crumbs": [
      "Examples",
      "Inspect",
      "Tool Calls"
    ]
  },
  {
    "objectID": "examples/inspect/scores-by-task/index.html",
    "href": "examples/inspect/scores-by-task/index.html",
    "title": "Scores by Task",
    "section": "",
    "text": "This example illustrates the code behind the scores_by_task() pre-built view function. If you want to include this plot in your notebooks or websites you should start with that function rather than the lower-level code below.\n\n\n\nCode\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot, legend\nfrom inspect_viz.mark import bar_y, TipOptions, text, TextStyles\nfrom inspect_viz.transform import sql\n\nevals = Data.from_file(\"evals.parquet\")\n\nplot(\n    text(\n        text=[\"Plot Title\"],\n        frame_anchor=\"top\",\n        facet=\"super\",\n        styles=TextStyles(\n            font_size=16\n        ),\n        dy=-40\n    ),\n    bar_y( \n        evals, \n        x=\"model\", \n1        fx=\"task_name\",\n        y=\"score_headline_value\",\n2        channels= { \"Log Viewer\": \"log_viewer\" },\n        fill=\"model\",\n        tip=True\n    ),\n    legend=legend(\"color\", location=\"bottom\"),\n3    x_label=None, fx_label=None, x_ticks=[],\n4    y_label=\"score\", y_domain=[0, 1.0],\n    color_label=\"Model\",\n    margin_top=40\n)\n\n\n\n1\n\nFacet the x-axis (i.e. create multiple groups of bars) by task name.\n\n2\n\nAdd a channel with links to the Inspect log files (links appear in the tooltip).\n\n3\n\nWe don’t need an explicit “model” or “task_name” label as they are obvious from context. We also don’t need ticks b/c the fill color and legend provide this.\n\n4\n\nEnsure that y-axis shows the full range of scores (by default it caps at the maximum).\n\n\n\n\n\n\n\n\nConfidence Interval\nHere we add a confidence interval for each reported score by adding a rule_x() mark. Note that we compute the confidence interval range dynamically using a sql() transform:\n\n\n\nCode\n\nfrom inspect_viz.mark import rule_x\nfrom inspect_viz.transform import sql, ci_bounds\n\n1# confidence interval bounds\nci_lower, ci_upper = ci_bounds(\n    0.95, \n    score=\"score_headline_value\", \n    stderr=\"score_headline_stderr\"\n)\n\nplot(\n    bar_y( \n        evals, x=\"model\", fx=\"task_name\", \n        y=\"score_headline_value\",\n        channels= { \"Log Viewer\": \"log_viewer\" },\n        fill=\"model\",\n        tip=True\n    ),\n2    rule_x(\n        evals,\n        x=\"model\",\n        fx=\"task_name\",\n        y1=ci_lower,\n        y2=ci_upper,\n        stroke=\"black\",\n        marker=\"tick-x\",\n    ),\n    legend=legend(\"color\", location=\"bottom\"),\n    x_label=None, fx_label=None, x_ticks=[],\n    y_label=\"score\", y_domain=[0, 1.0],\n    color_label=\"Model\"\n)\n\n\n\n1\n\nUse the ci_bounds() bounds function to create transforms that we will pass for y1 and y2.\n\n2\n\nDraw the confidence interval using a rule_x() mark.",
    "crumbs": [
      "Examples",
      "Inspect",
      "Scores by Task"
    ]
  },
  {
    "objectID": "publishing-websites.html",
    "href": "publishing-websites.html",
    "title": "Websites",
    "section": "",
    "text": "If you want to publish one or more plots as part of a website there are a couple of high level orientations to the problem:\n\nUse a Jupyter-based website publishing system that supports interactive Jupyter Widgets (e.g. Quarto).\nUse the to_html() function to create embeddable HTML fragments for your plots and embed them in any website.\n\nWe’ll cover both of these approaches below.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Websites"
    ]
  },
  {
    "objectID": "publishing-websites.html#overview",
    "href": "publishing-websites.html#overview",
    "title": "Websites",
    "section": "",
    "text": "If you want to publish one or more plots as part of a website there are a couple of high level orientations to the problem:\n\nUse a Jupyter-based website publishing system that supports interactive Jupyter Widgets (e.g. Quarto).\nUse the to_html() function to create embeddable HTML fragments for your plots and embed them in any website.\n\nWe’ll cover both of these approaches below.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Websites"
    ]
  },
  {
    "objectID": "publishing-websites.html#quarto-websites",
    "href": "publishing-websites.html#quarto-websites",
    "title": "Websites",
    "section": "Quarto Websites",
    "text": "Quarto Websites\nThe Quarto publishing system can create websites that include dynamic output from Python code, including interactve Jupyter Widgets like the ones created by Inspect Viz. To install the quarto-cli Python package:\npip install quarto-cli\nQuarto is a markdown-based publishing system that enables you to embed executable Python blocks whose output is included in the published website. For instance, Here is the source code for the Bias Parameter example:\n---\ntitle: \"Bias Parameter\"\n1echo: false\n---\n\nUse the slider to create bias offsets for the y-axis.\n\n2```{python}\nfrom inspect_viz import Data, Param\nfrom inspect_viz.input import slider\nfrom inspect_viz.mark import area_y\nfrom inspect_viz.plot import plot\nfrom inspect_viz.transform import sql\n\nrandom_walk = Data.from_file(\"random-walk.parquet\")\nbias = Param(0)\n```\n\n```{python} \nslider(label=\"Bias\", target=bias, min=0, max=1000, step=1, value=100)\n```\n\n```{python} \nplot(area_y(random_walk, x=\"t\", y=sql(f\"v + {bias}\"), fill=\"steelblue\"))\n```\n\n1\n\nWe specify echo: false to prevent display of code blocks.\n\n2\n\nMarkdown code blocks decorated with {python} are executed.\n\n\nHere is what the page looks like when rendered on the website (it’s a screenshot so you won’t be able to use the slider!):\n\n\nLearning More\nThe website was created with Quarto and includes many live Inspect Viz plots and tables. The source code for the Examples section is a good place to start to understand the basics.\nThe documentation on Quarto Websites includes a tutorial and many additional details on creating, customizing, and publishing websites.\nQuarto Dashboards are a special type of Quarto website optimized for displaying many plots and tables together, so are also worth considering.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Websites"
    ]
  },
  {
    "objectID": "publishing-websites.html#html-fragments",
    "href": "publishing-websites.html#html-fragments",
    "title": "Websites",
    "section": "HTML Fragments",
    "text": "HTML Fragments\nIf you are working with an existing website or with another website publishing system, it is also straightforward to embed HTML snippets which include Inspect Viz plots and tables.\n\nSingle Plot\nTo create a standalone snippet which you can include in any website, use the write_html() function:\nfrom inspect_viz import Data\nfrom inspect_viz.mark import dot\nfrom inspect_viz.plot import plot, write_html\n\npenguins = Data.from_file(\"penguins.parquet\")\n\npl = plot(\n    dot(penguins, x=\"body_mass\", y=\"flipper_length\",  \n        stroke=\"species\", symbol=\"species\"),\n    legend=\"symbol\",\n    grid=True\n)\n\nwrite_html(\"penguins.html\", pl)\n\n\nMultiple Plots\nIf you want to include multiple plots on a page, you might find it more convenient to call the to_html() function as part of your website generation process. The returned HTML includes the Jupyter Widget runtime dependencies, so if you have multiple plots you’ll instead want to include these dependencies once in the &lt;head&gt; of your document and the create HTML snippets without the dependencies.\nHere is the dependencies code that you should place in the &lt;head&gt; tag:\n&lt;script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n&lt;script src=\"https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;\nThen, specify dependencies=False when you call to_html() to get only the plot and not the dependencies scripts which are already in your &lt;head&gt; tag:\nfrom inspect_viz.plot import to_html\n\npl = plot(\n    dot(penguins, x=\"body_mass\", y=\"flipper_length\",  \n        stroke=\"species\", symbol=\"species\"),\n    legend=\"symbol\",\n    grid=True\n)\n\npl_html = to_html(pl, dependencies=False)\n\n# ...include pl_html in your website",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Websites"
    ]
  },
  {
    "objectID": "components-tables.html",
    "href": "components-tables.html",
    "title": "Tables",
    "section": "",
    "text": "Use tables to display an interactive grid of data used in your visualization. Tables support commonly used operations like sorting, filtering, pagination and a variety of other customization options.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#basics",
    "href": "components-tables.html#basics",
    "title": "Tables",
    "section": "Basics",
    "text": "Basics\nIn its most simple form, the table() function will display the contents of the Data provided. For example, the following:\nfrom inspect_viz import Data\nfrom inspect_viz.table import table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins)\nresults in a table displaying all the columns and rows in the penguins dataset:\n\n\n\n\n\nIn addition to providing the base Data for the table, you may also select which columns are displayed:\n\nfrom inspect_viz import Data\nfrom inspect_viz.table import table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins, columns=[\n    \"species\", \n    \"island\", \n    \"sex\", \n    \"body_mass\"])\n\n\n\n\nTables have a number of global options for configuring the behavior, but also have many options specific to one or more columns. To specify column level options, using the column function in the list of columns rather than simply passing the column name:\n\nfrom inspect_viz import Data\nfrom inspect_viz.table import column, table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins, columns=[\n    column(\"species\", align=\"center\"), \n    \"island\", \n    \"sex\", \n    \"body_mass\"])\n\n\n\n\n\nSize\nBy default, tables will have a height which matches the size of their content and a width which files their container (with a default maximum size of 500px). You can explicitly provide a height and width value in pixels for the table if you’d like the table to be a specific size:\n\nfrom inspect_viz import Data\nfrom inspect_viz.table import table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins, height=200, width=550)\n\n\n\n\nYou can use max_width to constrain the maximum width of the table in pixels. It will still attempt to fill its container, but it’s width will not exceed the max_width.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#columns",
    "href": "components-tables.html#columns",
    "title": "Tables",
    "section": "Columns",
    "text": "Columns\nWhen providing column data for a table, you can provide a list of columns names from your Data to be displayed. You can also use the column function to provide additional options for each column. For example, to customize the string that is displayed in the header for the column, using the label option like:\n\nfrom inspect_viz import Data\nfrom inspect_viz.table import column, table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins, columns=[\n    \"species\", \n    \"island\", \n    \"sex\", \n    column(\"body_mass\", label=\"mass\")])\n\n\n\n\n\nWidth\nIf no explicit column size is provided, the width of each column is an equal share of the available space. You can specify the width of columns either using an explicit pixel size:\n\nfrom inspect_viz import Data\nfrom inspect_viz.table import column, table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins, width=370, columns=[\n    column(\"species\", width=80), \n    column(\"island\", width=100), \n    column(\"sex\", width=70), \n    column(\"body_mass\", width=100)])\n\n\n\n\nor using flex for some or all of the columns. Flex sizing works by dividing the remaining space in the grid among all flex columns in proportion to their flex value.\n\nfrom inspect_viz import Data\nfrom inspect_viz.table import column, table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins, width=550, columns=[\n    column(\"species\", flex=1), \n    column(\"island\", flex=1.2), \n    column(\"sex\", width=70), \n    column(\"body_mass\", flex=1)])\n\n\n\n\nYou can also use max_width to set a maximum width for a column or min_width to set a minimum width for a column. This will be used to provide caps on width when columns are being sized automatically using flex sizing.\n\n\nAlignment\nYou can control the alignment of the values within each columns header and body using the align and header_align options. For example:\n\nfrom inspect_viz import Data\nfrom inspect_viz.table import column, table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins, columns=[\n    column(\"species\", align=\"center\", header_align=\"center\"), \n    column(\"island\"), \n    column(\"sex\"), \n    column(\"body_mass\")])\n\n\n\n\n\n\nFormatting\nYou can control the formatting of each cell’s value using the format option. The format option accepts a d3-format string for numeric values and a d3-time-format string for date values to define how the value will be formatted.\ntable(penguins, columns=[\n    column(\"species\"), \n    column(\"island\"), \n    column(\"sex\"), \n    column(\"body_mass\", format=\",.2f\")])\nDefault formats for values are as follows:\n\n\n\n\n\n\n\ntype\nformat\n\n\n\n\ninteger\n','\n\n\nnumber\nfloat\n',.2~f'\n\n\ndecimal\n',.4~f'\n\n\ndate\n'%Y-%m-%d'\n\n\ndatetime\ntimestamp\n'%Y-%m-%d %H:%M:%S'\n\n\n\n\n\nText Wrapping\nYou can control the text wrapping behavior of the values within each columns header and body using the wrap_text and header_wrap_text options. This is most frequently paired with auto_height to create rows with automatic heights which wrap text. For example:\ntable(penguins, columns=[\n    column(\"species\", auto_height=True, wrap_text=True), \n    column(\"island\", flex=1.2), \n    column(\"sex\", width=70), \n    column(\"body_mass\", flex=1)])",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#rows",
    "href": "components-tables.html#rows",
    "title": "Tables",
    "section": "Rows",
    "text": "Rows\n\nHeight\nBy default, each row of the the table, including the header row, is 29px tall. You can set an explicit row size for the body of the table using the row_height argument. Set the header’s row height using the header_height argument:\n\nfrom inspect_viz import Data\nfrom inspect_viz.table import table\n\npenguins = Data.from_file(\"penguins.parquet\")\ntable(penguins, header_height=60, row_height=50)\n\n\n\n\n\n\nAuto Height\nIn addition to explicitly providing the heights for rows, you can also allow the content to determine the height of the row. To do this, configure one or more column with auto_height. The height of the row will then be determined using the largest height required to display the content of any columns with the auto_height option.\ntable(penguins, width=550, columns=[\n    column(\"species\", flex=1), \n    column(\"island\", flex=1.2, auto_height=True), \n    column(\"sex\", width=70), \n    column(\"body_mass\", flex=1)])\nYou can also use the header_auto_height option to specify columns that will automatically size the header row height.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#sorting",
    "href": "components-tables.html#sorting",
    "title": "Tables",
    "section": "Sorting",
    "text": "Sorting\nEach column in the table is sortable by clicking on the header for the column you’d like to sort. Each click toggles between the sorting ascending, sorting descending, and not sorting. Holding shift while clicking will add the clicked column as a secondary sort, preserving any other sorts that have already been specified.\nYou can disable sorting for the entire table using the sorting argument:\ntable(penguins, sorting=False)\nYou can control whether individual columns can be sorted using the sortable option for column:\ntable(penguins, columns=[\n    column(\"species\", sortable=False), \n    column(\"island\"), \n    column(\"sex\"), \n    column(\"body_mass\")])",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#filtering",
    "href": "components-tables.html#filtering",
    "title": "Tables",
    "section": "Filtering",
    "text": "Filtering\nEach column of the table is filterable by clicking the filter icon in the header of the column. Depending upon the type of data in the column, different filtering options will be presented to the user. To disable filtering for a table, use filtering:\ntable(penguins, filtering=False)\nYou can control whether individual columns can be filtered using the filterable option for column:\ntable(penguins, columns=[\n    column(\"species\", filterable=False), \n    column(\"island\"), \n    column(\"sex\"), \n    column(\"body_mass\")])\n\nFilter Location\nYou can control where in the table filters appear by passing other header or row as the value for filter. header places in the filter as buttons in the header row next to the header text. row creates` a separate row with inline filter UI for filtering columns. For example:\ntable(penguins, filtering='row')",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#resizing",
    "href": "components-tables.html#resizing",
    "title": "Tables",
    "section": "Resizing",
    "text": "Resizing\nEach column of the table may be resized by the user by clicking and dragging the separator between columns in the header row. To make the table columns not resizable, use the resizing option:\ntable(penguins, resizing=False)\nYou can control whether individual columns can be resized using the resizable option for column:\ntable(penguins, columns=[\n    column(\"species\", resizable=False), \n    column(\"island\"), \n    column(\"sex\"), \n    column(\"body_mass\")])",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#pagination",
    "href": "components-tables.html#pagination",
    "title": "Tables",
    "section": "Pagination",
    "text": "Pagination\nWhen configured, tables can display pages of items with pagination controls at the bottom of the table rather than display all the items in a scrollable body. To enable pagination, simply provide the pagination argument to the table:\n\nfrom inspect_viz.table import column, table\ntable(penguins, \n      columns=[\n        column(\"species\"), \n        column(\"island\"), \n        column(\"sex\"), \n        column(\"body_mass\")],\n      pagination=True)\n\n\n\n\nBy default, the table will automatically set the page size to use the available space in the table without scrolling. You can also explicitly choose page size and page size options:\n\nfrom inspect_viz.table import column, table, Pagination\ntable(penguins, \n      columns=[\n        column(\"species\"), \n        column(\"island\"), \n        column(\"sex\"), \n        column(\"body_mass\")],\n      pagination=Pagination(page_size=20, page_size_selector=[20,40,60]))",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#grouping",
    "href": "components-tables.html#grouping",
    "title": "Tables",
    "section": "Grouping",
    "text": "Grouping\nWhen displaying tabular data, it can be useful to group the data by specific fields. For example, to display a table with the average attributes of male and female penguins based upon their species, you can using grouping function for some columns:\n\nfrom inspect_viz.transform import avg, count\ntable(penguins, \n      height=120,\n      columns=[\n        column(\"species\"), \n        column(avg(\"body_mass\")),\n        column(avg(\"flipper_length\"))])\n\n\n\n\nWhen providing transforms to apply to columns (e.g. avg, sum), columns without aggregating transforms will be treated as columns to group by. So in the above example, the table is grouped by species displaying the rest of the values using their aggregate values.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#literal-data",
    "href": "components-tables.html#literal-data",
    "title": "Tables",
    "section": "Literal Data",
    "text": "Literal Data\nYou can also pass literal values (an int | float | bool) as a column by passing one or more values as the column itself. For example:\n\ntable(penguins, \n      columns=[\n        column([1,2,3,4,5,6,7,8,9], label=\"sample_bucket\"),\n        column(\"species\"), \n        column(\"body_mass\"),\n        column(\"flipper_length\")])\n\n\n\n\nIf a single value is passed, that value will be repeated for every row in the dataset. If a list of values is passed, each row will increment through the list and include the value from the row index. If the list is shorter than the dataset, values will be repeated by repeatedly iterating through the list.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#selection",
    "href": "components-tables.html#selection",
    "title": "Tables",
    "section": "Selection",
    "text": "Selection\nBy default, the table will display the selection provided by the data source. If you’d like, you can provide an alternative selection by using filter_by.\n\nTargeting Selections\nIt can be useful to use selected rows within a table to target a selection to be used elsewhere (for example, in highlighting points within a dot plot). To do this, use the target option to select the output selection. This will cause a selection clause of the form column IN (rows) to be added to the selection for each currently selected table row.\nFor example:\ntable(penguins, \n      target=selection)\nYou can use the select option to control how selection works within the table. By default, select is set to single_row which will allow selection of one row at a time by clicking the row. Other options are listed below:\n\n\n\n\n\n\n\nOption\nAction\n\n\n\n\nhover\nThe selection will be updated when the user’s mouse hovers over a row.\n\n\nsingle_row\nThe selection will be updated when a single row is selected. The selected row will be highlighted.\n\n\nmultiple_row\nThe selection will be updated when one or more rows are selected. The selected rows will be highlighted.\n\n\nsingle_row_checkbox\nThe selection will be updated when a single row is selected using a checkbox.\n\n\nmultiple_row_checkbox\nThe selection will be updated when one or more rows is selected using a checkbox.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "components-tables.html#appearance",
    "href": "components-tables.html#appearance",
    "title": "Tables",
    "section": "Appearance",
    "text": "Appearance\nTables have a minimal default appearance using the AG Grid Balham theme. If the table is being displayed in a Quarto page or dashboard, it will automatically inherit the theme of the page on which it is hosted.\nYou can customize most aspects of the table appearance using the style argument like:\n\nfrom inspect_viz.table import column, table, Pagination, TableStyle\ntable(penguins, \n      columns=[\n        column(\"species\"), \n        column(\"island\"), \n        column(\"sex\"), \n        column(\"body_mass\")],\n      style=TableStyle(\n        background_color=\"#FCFAFF\",  \n        foreground_color=\"purple\", \n        accent_color=\"#E8FFB3\"))\n\n\n\n\n\nColor\nUsing the three following basic color options will provide new colors for the table (with the overall colors of the table derived from these three themes). Each of these colors accepts a css color value (for example a hex color string or a named value like red).\n\n\n\n\n\n\n\nOption\nTarget\n\n\n\n\nbackground_color\nThe background color use for cells.\n\n\nforeground_color\nThe foreground color used for values within cells.\n\n\naccent_color\nAccent color used for things like selection and highlights.\n\n\n\nIn addition to the previous basic options, you can do further customization of the colors by passing a css color value to the following:\n\n\n\n\n\n\n\nOption\nTarget\n\n\n\n\ntext_color\nThe text color for UI elements presented within the table.\n\n\nheader_text_color\nThe color for text in the header row.\n\n\ncell_text_color\nThe color for text in cell within the body of the table.\n\n\nselected_row_background_color\nThe background color of selected rows.\n\n\n\n\n\nFonts\nYou can control the fonts used by the table by passing a css font-family value in the following options:\n\n\n\n\n\n\n\nOption\nTarget\n\n\n\n\nfont_family\nThe default font for all text within the table.\n\n\nheader_font_family\nThe font used for text within the header row.\n\n\ncell_font_family\nThe font used for text within the body of the table.\n\n\n\n\n\nBorder\nYou can control the border of the table using the following border options:\n\n\n\nOptions\nTarget\n\n\n\n\nborder_color\nThe color of the border (value css color value).\n\n\nborder_width\nThe width in pixels of the border.\n\n\nborder_radius\nThe border radius in pixels.\n\n\n\n\n\nSpacing\nThe spacing options controls how tightly data and UI elements are packed together in the table. All the padding within in the table is defined relative to this value, so changing this value will affect the spacing of everything in the table.\nBy default, tables have 4 pixels of spacing. To change this value, pass the number of pixels like so:\ntable(penguins, \n      columns=[\n        column(\"species\"), \n        column(\"island\"), \n        column(\"sex\"), \n        column(\"body_mass\")],\n      style=TableStyle(spacing=20))",
    "crumbs": [
      "Getting Started",
      "Components",
      "Tables"
    ]
  },
  {
    "objectID": "publishing-dashboards.html",
    "href": "publishing-dashboards.html",
    "title": "Dashboards",
    "section": "",
    "text": "Quarto Dashboards are a special type of Quarto website optimized for publishing easily navigable sets of plots and tables. Features of Quarto Dashboards include:\n\nMany flexible ways to layout components (row or column based, tabsets, multiple pages, etc.) including responsive layout for mobile devices.\nA variety of ways to present inputs for interactivity including toolbars, sidebars, and card-level inputs.\nDozens of available themes including the ability to create your own themes.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Dashboards"
    ]
  },
  {
    "objectID": "publishing-dashboards.html#overview",
    "href": "publishing-dashboards.html#overview",
    "title": "Dashboards",
    "section": "",
    "text": "Quarto Dashboards are a special type of Quarto website optimized for publishing easily navigable sets of plots and tables. Features of Quarto Dashboards include:\n\nMany flexible ways to layout components (row or column based, tabsets, multiple pages, etc.) including responsive layout for mobile devices.\nA variety of ways to present inputs for interactivity including toolbars, sidebars, and card-level inputs.\nDozens of available themes including the ability to create your own themes.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Dashboards"
    ]
  },
  {
    "objectID": "publishing-dashboards.html#example",
    "href": "publishing-dashboards.html#example",
    "title": "Dashboards",
    "section": "Example",
    "text": "Example\nHere is the Penguin Explorer example from this repository re-written as a dashboard (this is a live dashboard embedded as an iframe):\n\nBelow is the source code for this dashboard. You’ll notice that this looks quite similar to the code for any other Quarto document, but level-two headings (##) have been added to denote a toolbar and dashboard rows (additional headings could be used to create columns and tabsets).\n---\ntitle: \"Penguins Explorer\"\n1format: dashboard\n---\n\n```{python}\nfrom inspect_viz import Data, Param\nfrom inspect_viz.input import select\nfrom inspect_viz.mark import dot\nfrom inspect_viz.plot import plot\nfrom inspect_viz.table import table\n\npenguins = Data.from_file(\"penguins.parquet\")\naxes = [\"body_mass\", \"flipper_length\", \"bill_depth\", \"bill_length\"]\nx_axis = Param(\"body_mass\")\ny_axis = Param(\"flipper_length\")\n```\n\n2## Row {.toolbar}\n\n```{python}\nselect(penguins, label=\"Species\", column=\"species\")\nselect(label=\"X\", options=axes, target=x_axis)\nselect(label=\"Y\", options=axes, target=y_axis)\n```\n\n3## Row\n\n```{python}\nplot(\n    dot(penguins, x=x_axis, y=y_axis, stroke=\"species\", symbol=\"species\"),\n    grid=True,\n    x_label=\"Body mass (g) →\",\n    y_label=\"↑ Flipper length (mm)\",\n    legend=\"symbol\",\n)\n```\n\n## Row\n\n```{python}\ntable(penguins)\n```\n\n1\n\nformat: dashboard indicates this is a dashbaord not an ordinary HTML page.\n\n2\n\nToolbar for grouping inputs.\n\n3\n\nRow sections to denote additional rows in the dashboard layout.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Dashboards"
    ]
  },
  {
    "objectID": "publishing-dashboards.html#learning-more",
    "href": "publishing-dashboards.html#learning-more",
    "title": "Dashboards",
    "section": "Learning More",
    "text": "Learning More\n\nSee the Quarto Dashboards documentation for additional details on creating dashboards.\nSee the Dashboard Examples to get an idea for the sorts of layouts and themes that are available and to see the source code for a variety of dashboard types.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Dashboards"
    ]
  },
  {
    "objectID": "view-tool-calls.html",
    "href": "view-tool-calls.html",
    "title": "Tool Calls",
    "section": "",
    "text": "The tool_calls() function creates a heat map visualising tool calls over evaluation turns.\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import tool_calls\n\ntools = Data.from_file(\"cybench_tools.parquet\")\ntool_calls(tools)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Tool Calls"
    ]
  },
  {
    "objectID": "view-tool-calls.html#overview",
    "href": "view-tool-calls.html#overview",
    "title": "Tool Calls",
    "section": "",
    "text": "The tool_calls() function creates a heat map visualising tool calls over evaluation turns.\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import tool_calls\n\ntools = Data.from_file(\"cybench_tools.parquet\")\ntool_calls(tools)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Tool Calls"
    ]
  },
  {
    "objectID": "view-tool-calls.html#data-preparation",
    "href": "view-tool-calls.html#data-preparation",
    "title": "Tool Calls",
    "section": "Data Preparation",
    "text": "Data Preparation\nTo create the plot we read a raw messages data frame from an eval log using the messages_df() function, then filter down to just the fields we require for visualization:\n\nfrom inspect_ai.analysis.beta import messages_df, MessageColumns, SampleSummary\n\n# read messages from log\nlog = \"&lt;path-to-log&gt;.eval\"\ndf = messages_df(log, columns=SampleSummary + MessageColumns)\n\n# trim columns\ndf = df[[\n    \"eval_id\",\n    \"id\",\n    \"order\",\n    \"tool_call_function\",\n    \"limit\"\n]]\n\n# write to parquet\ndf.to_parquet(\"cybench_tools.parquet\")\n\nNote that the trimming of columns is particularly important because Inspect Viz embeds datasets directly in the web pages that host them (so we want to minimize their size for page load performance and bandwidth usage).",
    "crumbs": [
      "Getting Started",
      "Views",
      "Tool Calls"
    ]
  },
  {
    "objectID": "view-tool-calls.html#function-reference",
    "href": "view-tool-calls.html#function-reference",
    "title": "Tool Calls",
    "section": "Function Reference",
    "text": "Function Reference\nHeat map visualising tool calls over evaluation turns.\n\nSource\n\ndef tool_calls(\n    data: Data,\n    x: str = \"order\",\n    y: str = \"id\",\n    tool: str = \"tool_call_function\",\n    limit: str = \"limit\",\n    tools: list[str] | None = None,\n    x_label: str | None = \"Message\",\n    y_label: str | None = \"Sample\",\n    width: float | None = None,\n    height: float | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nMessages data table. This is typically created using a data frame read with the inspect messages_df() function.\n\nx str\n\nName of field for x axis (defaults to “order”)\n\ny str\n\nName of field for y axis (defaults to “id”).\n\ntool str\n\nName of field with tool name (defaults to “tool_call_function”)\n\nlimit str\n\nName of field with sample limit (defaults to “limit”).\n\ntools list[str] | None\n\nTools to include in plot (and order to include them). Defaults to all tools found in data.\n\nx_label str | None\n\nx-axis label (defaults to “Message”).\n\ny_label str | None\n\ny-axis label (defaults to “Sample”).\n\nwidth float | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio)\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes. By default, the margin_top is set to 0, margin_left to 20, margin_right to 100, color_label is “Tool”, y_ticks is empty, and x_ticks and color_domain are calculated from data.",
    "crumbs": [
      "Getting Started",
      "Views",
      "Tool Calls"
    ]
  },
  {
    "objectID": "view-tool-calls.html#implementation",
    "href": "view-tool-calls.html#implementation",
    "title": "Tool Calls",
    "section": "Implementation",
    "text": "Implementation\nThe Tool Calls example demonstrates how this view was implemented using lower level plotting components.",
    "crumbs": [
      "Getting Started",
      "Views",
      "Tool Calls"
    ]
  },
  {
    "objectID": "views.html",
    "href": "views.html",
    "title": "Views",
    "section": "",
    "text": "Note\n\n\n\nView functions are currently in beta and are exported from the inspect_ai.view.beta module. The beta module will be preserved after final release so that code written against it now will continue to work after the beta.\n\n\nInspect Viz Views are pre-built plots that work with data created by the Inspect log data frame reading functions.\n\n\n\n\n\n\n\nView\nDescription\n\n\n\n\nscores_by_task()\nBar plot for comparing eval scores (with confidence intervals) across models and tasks.\n\n\nscores_by_factor()\nBar bar plot for comparing eval scores by model and a boolean factor (e.g. no hint vs. hint).\n\n\nscores_timeline()\nScatter plot with eval scores by model, organization, and release date. Filterable by evaluation and organization.\n\n\nscores_heatmap()\nHeatmap with values for comparing scores across model and task.\n\n\nscores_with_baseline()\nBar plot for comparing model scores on a single eval, with one or more baselines overlaid.\n\n\ntool_calls()\nHeat map visualising tool calls over evaluation turns.",
    "crumbs": [
      "Getting Started",
      "Views"
    ]
  },
  {
    "objectID": "publishing.html",
    "href": "publishing.html",
    "title": "Publishing",
    "section": "",
    "text": "There are several ways to publish Inspect Viz content, ranging from PNG images suitable for embedding in documents all the way up to notebooks, websites, and dashboards.\n\n\n\nPlots\nPublish single plots as PNG images or HTML snippets.\n\n\nNotebooks\nPublish collections of plots and tables as a notebook.\n\n\nWebsites\nEmbed plots and tables in a larger website.\n\n\nDashboards\nCreate a dashboard to provide easy navigation of collections of plots.",
    "crumbs": [
      "Getting Started",
      "Publishing"
    ]
  },
  {
    "objectID": "publishing-plots.html",
    "href": "publishing-plots.html",
    "title": "Plots",
    "section": "",
    "text": "There are several ways to publish plots created with Inspect Viz:\n\nUse the write_png() function to create an image for use in a document or presentation.\nUse the write_html() function to create a standalone HTML file.\nCreate and share a Jupyter notebook with the plot.\nEmbed the plot in a website or dashboard.\n\nThis article will cover the first two options for sharing standalone plots—the Notebooks, Websites, and Dashboards articles will cover the other possibilities.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Plots"
    ]
  },
  {
    "objectID": "publishing-plots.html#overview",
    "href": "publishing-plots.html#overview",
    "title": "Plots",
    "section": "",
    "text": "There are several ways to publish plots created with Inspect Viz:\n\nUse the write_png() function to create an image for use in a document or presentation.\nUse the write_html() function to create a standalone HTML file.\nCreate and share a Jupyter notebook with the plot.\nEmbed the plot in a website or dashboard.\n\nThis article will cover the first two options for sharing standalone plots—the Notebooks, Websites, and Dashboards articles will cover the other possibilities.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Plots"
    ]
  },
  {
    "objectID": "publishing-plots.html#plot-as-image",
    "href": "publishing-plots.html#plot-as-image",
    "title": "Plots",
    "section": "Plot as Image",
    "text": "Plot as Image\nUse the write_png() function to save a PNG version of any plot.\n\n\n\n\n\n\nNote\n\n\n\nThe write_png() function requires that you install the playwright Python package, which enables taking screenshots of web graphics using an embedded version of the Chromium web browser. You can do this as follows:\npip install playwright\nplaywright install\n\n\nTo create a plot and export it as a PNG:\nfrom inspect_viz import Data\nfrom inspect_viz.mark import dot\nfrom inspect_viz.plot import plot, write_png\n\npenguins = Data.from_file(\"penguins.parquet\")\n\npl = plot(\n    dot(penguins, x=\"body_mass\", y=\"flipper_length\",  \n        stroke=\"species\", symbol=\"species\"),\n    legend=\"symbol\",\n    grid=True\n)\n\nwrite_png(\"penguins.png\", pl)\nHere is the plot that was written (note that since this plot is a static PNG file rather than a JavaScript widget it does not have tooltips):\n\n\nPlot Size\nYou can control the size of the image written by specifying the width and height directly in the call to plot(). For example:\npl = plot(\n    dot(penguins, x=\"body_mass\", y=\"flipper_length\",  \n        stroke=\"species\", symbol=\"species\"),\n    legend=\"symbol\",\n    grid=True,\n    width=900,\n    height=400\n)\n\n\nExport Options\nThere are a couple of other options that can be used when exporting plots to PNG:\n\n\n\n\n\n\n\nOption\nDescription\n\n\n\n\nscale\nDevice scale to capture plot at. Use 2 (the default) for retina quality images suitable for high resolution displays or print output)\n\n\npadding\nPadding (in pixels) to add around exported plot. Defaults to 8 pixels.",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Plots"
    ]
  },
  {
    "objectID": "publishing-plots.html#plot-as-html",
    "href": "publishing-plots.html#plot-as-html",
    "title": "Plots",
    "section": "Plot as HTML",
    "text": "Plot as HTML\nYou can also create an HTML version of a plot using the write_html() function. For example:\nfrom inspect_viz import Data\nfrom inspect_viz.mark import dot\nfrom inspect_viz.plot import plot, write_html\n\npenguins = Data.from_file(\"penguins.parquet\")\n\npl = plot(\n    dot(penguins, x=\"body_mass\", y=\"flipper_length\",  \n        stroke=\"species\", symbol=\"species\"),\n    legend=\"symbol\",\n    grid=True\n)\n\nwrite_html(\"penguins.html\", pl)\nUnlike with write_png(), the exported HTML plot retains all interactive features (tooltips, filters, etc.). In some cases you might therefore also include inputs with your plot. For example:\npl = vconcat(\n   select(penguins, label=\"Species\", column=\"species\"),\n   plot(\n      dot(penguins, x=\"body_mass\", y=\"flipper_length\",  \n          stroke=\"species\", symbol=\"species\"),\n      legend=\"symbol\",\n      color_domain=\"fixed\"\n   )\n)\n\nwrite_html(\"penguins.html\", pl)",
    "crumbs": [
      "Getting Started",
      "Publishing",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html",
    "href": "components-plots.html",
    "title": "Plots",
    "section": "",
    "text": "A plot() produces a single visualisation as a Web element. Similar to other grammars, a plot consists of marks—graphical primitives such as bars, areas, and lines—which serve as chart layers. Plots use the semantics of Observable Plot, such that each plot has a dedicated set of encoding channels with named scale mappings such as x, y, color, opacity, etc.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#basics",
    "href": "components-plots.html#basics",
    "title": "Plots",
    "section": "Basics",
    "text": "Basics\nPlots support faceting of the x and y dimensions, producing associated fx and fy scales. Plots are rendered to SVG output using Observable Plot.\nHere is a simple dot plot that demonstrates some key concepts:\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import dot\n\npenguins = Data.from_file(\"penguins.parquet\")\n\nplot(\n1    dot(penguins, x=\"body_mass\", y=\"flipper_length\",\n        stroke=\"species\", symbol=\"species\"),\n2    legend=\"symbol\",\n3    grid=True,\n    width=700,\n    height=400\n)\n\n\n1\n\ndot() mark for a simple dot plot, using a distinct stroke and symbol to denote the “species” column.\n\n2\n\nLegend in the default location, keyed by symbol.\n\n3\n\nAdditional attributes that affect plot size and appearance.\n\n\n\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nInspect Viz is built on top of the Mosaic data visualization system which is in turn built on Observable Plot.\nThe Inspect Viz Python API typically maps quite closely to the Observable Plot JavaScript API. Once you start creating your own plots and are using Google or an LLM to help with development, asking how to do things in Observable Plot will typically yield actionable advice.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#facets",
    "href": "components-plots.html#facets",
    "title": "Plots",
    "section": "Facets",
    "text": "Facets\nPlots support faceting of the x and y dimensions, producing associated fx and fy scales. For example, here we comopare model performance on several tasks. The task_name is the fx scale, resulting in a separate grouping of bars for each task:\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot, legend\nfrom inspect_viz.mark import bar_y\n\nevals = Data.from_file(\"evals.parquet\")\n\nplot(\n    bar_y( \n1        evals, x=\"model\", fx=\"task_name\",\n        y=\"score_headline_value\",\n        fill=\"model\",\n        tip=True,\n        channels={\n            \"Task\": \"task_name\",\n            \"Model\": \"model\",\n            \"Score\": \"score_headline_value\",\n            \"Log Viewer\": \"log_viewer\"\n        }\n    ),\n2    legend=legend(\"color\", location=\"bottom\"),\n3    x_label=None, x_ticks=[], fx_label=None,\n4    y_label=\"score\", y_domain=[0, 1.0]\n)\n\n\n1\n\nAdd an x-facet (“task_name”) using the fx option.\n\n2\n\nDefine legend using legend() function (to enable setting location and other options).\n\n3\n\nRemove default x labeling as it is handled by the legend.\n\n4\n\nTweak y-axis with shorter label and ensure that it goes all the way up to 1.0.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#marks",
    "href": "components-plots.html#marks",
    "title": "Plots",
    "section": "Marks",
    "text": "Marks\nThe plots above use only a single mark (dot() and bar_y() respectively). More sophisticated plots are often constructed with multiple marks. For example, here is a plot that adds a regression line mark do a standard dot plot:\n\nfrom inspect_viz import Data\nfrom inspect_viz.mark import dot, regression_y\nfrom inspect_viz.plot import plot\n\nathletes = Data.from_file(\"athletes.parquet\")\n\nplot(\n1    dot(athletes, x=\"weight\", y=\"height\", fill=\"sex\", opacity=0.1),\n2    regression_y(athletes, x=\"weight\", y=\"height\", stroke=\"sex\"),\n    legend=\"color\"\n)\n\n\n1\n\nUse fill to distinguish male and female athletes; use opacity to deal with a large density of data points.\n\n2\n\nUse stroke to ensure that male and female athletes each get their own regression line.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#tooltips",
    "href": "components-plots.html#tooltips",
    "title": "Plots",
    "section": "Tooltips",
    "text": "Tooltips\nTooltips enable you to provide additional details when the user hovers their mouse over various regions of the plot. Tooltips are enabled automatically for dot marks (dot(), dot_x(), dot_y(), circle(), and hexagon()) and cell marks (cell(), cell_x(), etc.) and can be enabled with tip=True for other marks. For example:\nplot(\n    bar_y( \n        evals, x=\"model\", fx=\"task_name\",\n        y=\"score_headline_value\",\n        fill=\"model\",\n        tip=True\n    ),\n    legend=legend(\"color\", location=\"bottom\"),\n    x_label=None, x_ticks=[], fx_label=None,\n    y_label=\"score\", y_domain=[0, 1.0]\n)\n\nAdd tip=True to enable tooltips for marks where they are not automatically enabled.\n\nNote that tooltips can interfere with plot interactions—for example, if your bar plot was clickable to drive selections in other plots you would not want to specify tip=True.\n\nChannels\nBy default, tooltips show all dataset channels that provide scales (e.g. x, y, fx, stroke, fill, symbol, etc.). For the plot above that would look like this:\n\nThere are few things we can improve on here:\n\nThe labels are scale names rather than domain specific names (e.g. “fx” rather than “model”)\nThe order of labels isn’t ideal.\nThere are some duplicate values (e.g “fill” and “fx”)\nWe might want to include additional columns not used in the rest of the plot (e.g. a link to the log file).\n\nYou can exercise more control over the tooltip by specifying channels along with the mark. For example:\nplot(\n    bar_y( \n        evals, x=\"model\", fx=\"task_name\",\n        y=\"score_headline_value\",\n        fill=\"model\",\n        tip=True,\n1        channels={\n            \"Task\": \"task_name\", \n            \"Model\": \"model\",\n            \"Score\": \"score_headline_value\",\n            \"Log Viewer\": \"log_viewer\"\n        }\n    ),\n    ...\n)\n\n1\n\nThe channels option maps labels to columns in the underlying data—all defined channels will appear in the tooltip. URL values are automatically turned into links as shown here.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#colors",
    "href": "components-plots.html#colors",
    "title": "Plots",
    "section": "Colors",
    "text": "Colors\nUse the color_scheme option to the plot() function to pick a theme (see the ColorScheme reference for available schemes). Use the color_range option to specify an explicit set of colors. For example, here we use the “tableau10” color_scheme:\n\nplot(\n    bar_y( \n        evals, x=\"model\", fx=\"task_name\",\n        y=\"score_headline_value\",\n        fill=\"model\",\n    ),\n    legend=legend(\"color\", location=\"bottom\"),\n    x_label=None, x_ticks=[], fx_label=None,\n    y_label=\"score\", y_domain=[0, 1.0],\n    color_scheme=\"tableau10\"\n)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#titles",
    "href": "components-plots.html#titles",
    "title": "Plots",
    "section": "Titles",
    "text": "Titles\nPlot titles can be added using a text() mark. For example, here we add a title at the top of the frame:\n\nfrom inspect_viz.mark import TextStyles, text\n\nplot(\n    text(text=[\"Olympic Athletes\"], frame_anchor=\"top\", \n         styles=TextStyles(font_size=16), dy=-20),\n    dot(athletes, x=\"weight\", y=\"height\", fill=\"sex\", opacity=0.1),\n    regression_y(athletes, x=\"weight\", y=\"height\", stroke=\"sex\"),\n    legend=\"color\"\n)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#data",
    "href": "components-plots.html#data",
    "title": "Plots",
    "section": "Data",
    "text": "Data\nIn the examples above we made Data available by reading from a parquet file. We can also read data from any Python Data Frame (e.g. Pandas, Polars, PyArrow, etc.). For example:\nimport pandas as pd\nfrom inspect_viz import Data\n\n# read directly from file\npenguins = Data.from_file(\"penguins.parquet\")\n\n# read from Pandas DF (i.e. to preprocess first)\ndf = pd.read_parquet(\"penguins.parquet\")\npenguins = Data.from_dataframe(df)\nYou might wonder why is there a special Data class in Inspect Viz rather than using data frames directly? This is because Inpsect Viz is an interactive system where data can be dynamically filtered and transformed as part of plotting—the Data therefore needs to be sent to the web browser rather than remaining only in the Python session. This has a couple of important implications:\n\nData transformations should be done using standard Python Data Frame operations prior to reading into Data for Inspect Viz.\nSince Data is embedded in the web page, you will want to filter it down to only the columns required for plotting (as you don’t want the additional columns making the web page larger than is necessary).\n\n\nData Selections\nOne other important thing to understand is that Data has a built in selection which is used in filtering operations on the client. This means that if you want your inputs and plots to stay synchoronized, you should pass the same Data instance to all of them (i.e. import into Data once and then share that reference). For example:\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import dot\nfrom inspect_viz.input import select\nfrom inspect_viz.layout import vconcat\n\n# we import penguins once and then pass it to select() and dot()\npenguins = Data.from_file(\"penguins.parquet\")\n\nvconcat( \n   select(penguins, label=\"Species\", column=\"species\"),\n   plot(\n      dot(penguins, x=\"body_mass\", y=\"flipper_length\",\n          stroke=\"species\", symbol=\"species\"),\n      legend=\"symbol\",\n      color_domain=\"fixed\"  \n   )\n)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#attributes",
    "href": "components-plots.html#attributes",
    "title": "Plots",
    "section": "Attributes",
    "text": "Attributes\nAttributes are plot-level settings such as width, height, margins, and scale options (e.g., x_domain, color_range, y_tick_format). Attributes may be Param-valued, in which case a plot updates upon param changes.\nSome of the more useful plot attribues include:\n\nwidth, height, and aspect_ratio for controlling plot size.\nmargin and facet_margin (and more specific margins like margin_top) for controlling layout margins.\nstyle for providing CSS styles.\naria_label and aria_description, x_aria_label, x_aria_description, etc. for accessibilty attributes.\nx_domain, x_range,y_domain, andy_range` for controlling the domain and range of axes.\nTick settings for x, y, fx, and fy axes (e.g. x_ticks, x_tick_rotate, etc.)\nr (radius) scale settings (e.g. r_domain, r_range, r_label, etc.)\n\nSee PlotAttributes for documentation on all available plot attributes.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "components-plots.html#legends",
    "href": "components-plots.html#legends",
    "title": "Plots",
    "section": "Legends",
    "text": "Legends\nLegends can be added to plot specifications or included as standalone elements.\nSee the legend() function documentation for details on legend options including location, columns, label text, size, and margins.\nThe name directive gives a plot a unique name. A standalone legend can reference a named plot legend(..., for_plot=\"penguins\") to avoid respecifying scale domains and ranges.\nLegends also act as interactors, taking a bound Selection as a target parameter. For example, discrete legends use the logic of the toggle interactor to enable point selections. Two-way binding is supported for Selections using single resolution, enabling legends and other interactors to share state.\nSee the docs on Toggle interactors for an example of an interactive legend.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Plots"
    ]
  },
  {
    "objectID": "view-scores-by-task.html",
    "href": "view-scores-by-task.html",
    "title": "Scores by Task",
    "section": "",
    "text": "The scores_by_task() function renders a bar plot for comparing eval scores.\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_by_task\n\nevals = Data.from_file(\"evals.parquet\")\nscores_by_task(evals)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Task"
    ]
  },
  {
    "objectID": "view-scores-by-task.html#overview",
    "href": "view-scores-by-task.html#overview",
    "title": "Scores by Task",
    "section": "",
    "text": "The scores_by_task() function renders a bar plot for comparing eval scores.\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_by_task\n\nevals = Data.from_file(\"evals.parquet\")\nscores_by_task(evals)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Task"
    ]
  },
  {
    "objectID": "view-scores-by-task.html#data-preparation",
    "href": "view-scores-by-task.html#data-preparation",
    "title": "Scores by Task",
    "section": "Data Preparation",
    "text": "Data Preparation\nAbove we read the data for the plot from a parquet file. This file was in turn created by:\n\nReading logs into a data frame with evals_df().\nUsing the prepare() function to add model_info() and log_viewer() columns to the data frame.\n\nfrom inspect_ai.analysis.beta import evals_df, log_viewer, model_into, prepare\n\ndf = evals_df(\"logs\")\ndf = prepare(df, \n    model_info(),\n    log_viewer(\"eval\", {\"logs\": \"https://samples.meridianlabs.ai/\"}),\n)\ndf.to_parquet(\"evals.parquet\")\nNote that both the log viewer links and model names are optional (the plot will render without links and use raw model strings if the data isn’t prepared with log_viewer() and model_info()).",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Task"
    ]
  },
  {
    "objectID": "view-scores-by-task.html#function-reference",
    "href": "view-scores-by-task.html#function-reference",
    "title": "Scores by Task",
    "section": "Function Reference",
    "text": "Function Reference\nBar plot for comparing eval scores.\nSummarize eval scores using a bar plot. By default, scores (y) are plotted by “task_name” (fx) and “model” (x). By default, confidence intervals are also plotted (disable this with y_ci=False).\n\nSource\n\ndef scores_by_task(\n    data: Data,\n    x: str = \"model_display_name\",\n    fx: str = \"task_name\",\n    y: str = \"score_headline_value\",\n    y_stderr: str = \"score_headline_stderr\",\n    y_ci: bool | float = 0.95,\n    y_label: str | None | NotGiven = NOT_GIVEN,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nEvals data table. This is typically created using a data frame read with the inspect evals_df() function.\n\nx str\n\nName of field for x axis (defaults to “model_display_name”)\n\nfx str\n\nName of field for x facet (defaults to “task_name”)\n\ny str\n\nName of field for y axis (defaults to “score_headline_value”).\n\ny_stderr str\n\nName of field for stderr (defaults to “score_headline_metric”).\n\ny_ci bool | float\n\nConfidence interval (e.g. 0.80, 0.90, 0.95, etc.). Defaults to 0.95.\n\ny_label str | None | NotGiven\n\nY axis label (pass None for no label).\n\nwidth float | Param | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | Param | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio)\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes. By default, the y_inset_top and margin_bottom are set to 10 pixels and x_ticks is set to [].",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Task"
    ]
  },
  {
    "objectID": "view-scores-by-task.html#implementation",
    "href": "view-scores-by-task.html#implementation",
    "title": "Scores by Task",
    "section": "Implementation",
    "text": "Implementation\nThe Scores by Task example demonstrates how this view was implemented using lower level plotting components.",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores by Task"
    ]
  },
  {
    "objectID": "components-selections.html",
    "href": "components-selections.html",
    "title": "Selections",
    "section": "",
    "text": "Selections enable filtering and cross-filtering of plot data based based on Inputs and Interactors. Each Data table has a built-in selection and you can also create Selection instances for more sophisticated behaviors.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Selections"
    ]
  },
  {
    "objectID": "components-selections.html#overview",
    "href": "components-selections.html#overview",
    "title": "Selections",
    "section": "",
    "text": "Selections enable filtering and cross-filtering of plot data based based on Inputs and Interactors. Each Data table has a built-in selection and you can also create Selection instances for more sophisticated behaviors.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Selections"
    ]
  },
  {
    "objectID": "components-selections.html#filtering",
    "href": "components-selections.html#filtering",
    "title": "Selections",
    "section": "Filtering",
    "text": "Filtering\nThe most straightforward usage of selections is adding inputs which filter the data displayed in a plot. This filtering uses the built in selection of Data instances. For example, here we add a select() input to enable filtering by species:\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import dot\nfrom inspect_viz.input import select\nfrom inspect_viz.layout import vconcat\n\npenguins = Data.from_file(\"penguins.parquet\")\n\n1vconcat(\n2   select(penguins, label=\"Species\", column=\"species\"),\n   plot(\n3      dot(penguins, x=\"body_mass\", y=\"flipper_length\",\n          stroke=\"species\", symbol=\"species\"),\n      legend=\"symbol\",\n4      color_domain=\"fixed\"\n   )\n)\n\n\n1\n\nvconcat() function stacks the select input on top of the plot.\n\n2\n\nSelect input bound to “species” column.\n\n3\n\nUse of penguins in both select() and plot() automatically binds to default selection for the penguins Data object.\n\n4\n\nFixed color domain ensures that species colors remain the same even when filtered.\n\n\n\n\n\n\n\n\nFixed Domain\nThe example agove introduces an important concept when dealing with selections and filtering: \"fixed\" scale domains (in this case color_domain=\"fixed\"). Fixed scale domains instruct a plot to first calculate a scale domain in a data-driven manner, but then keep that domain fixed across subsequent updates.\nFixed domains enable stable configurations without requiring a hard-wired domain to be known in advance, preventing disorienting scale domain “jumps” that hamper comparison across filter interactions. Several of the examples below will use \"fixed\" domains to provide this stability across interactions.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Selections"
    ]
  },
  {
    "objectID": "components-selections.html#interactors",
    "href": "components-selections.html#interactors",
    "title": "Selections",
    "section": "Interactors",
    "text": "Interactors\nInteractors imbue plots with interactive behavior. Most interactors listen to input events from rendered plot SVG elements to update bound selections. Interactors take facets into account to properly handle input events across subplots.\n\nInterval\nThe interval_x() and interval_y() interactors create 1D interval brushes. The interval_xy() interactor creates a 2D brush. Interval interactors accept a pixel_size parameter that sets the brush resolution: values may snap to a grid whose bins are larger than screen pixels and this can be leveraged to optimize query latency.\nFor example, below we stack two plots vertically, a dot() plot along with a bar_x() plot that counts the sex column. We then add an interval_x() interactor that enables us to filter the dataset using selections on the dot plot.\n\nfrom inspect_viz import Data, Selection\nfrom inspect_viz.interactor import Brush, interval_x\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import bar_x, dot, regression_y\nfrom inspect_viz.transform import count\n\nathletes = Data.from_file(\"athletes.parquet\")\n\n1range = Selection.intersect()\n\nvconcat(\n   plot(\n      dot(athletes, x=\"weight\", y=\"height\", fill=\"sex\", opacity=0.1),\n      regression_y(athletes, x=\"weight\", y=\"height\", stroke=\"sex\"),\n      interval_x(\n2         target=range,\n3         brush=Brush(fill=\"none\", stroke=\"#888\")\n      ),\n      legend=\"color\"\n   ),\n   plot(\n      bar_x(\n4         athletes, filter_by=range,\n         x=count(), y=\"sex\", fill=\"sex\"\n      ), \n      y_label=None,\n      height=150,\n5      x_domain=\"fixed\"\n   )\n)\n\n\n1\n\nA Selection is a means of filtering datasets based on interactions. Here we use an “intersect” selection for application of a simple filter from dot plot to bar plot.\n\n2\n\nThe range selection is set via the interval_x() interactor (which enables using the mouse to select an x-range).\n\n3\n\nThe Brush defines the color of the interactor (in this case #888, a medium-gray).\n\n4\n\nThe range selection is consumed using the filter_by parameter.\n\n5\n\nWe set the x_domain for the bar plot to “fixed” so that the scale doesn’t change as the dataset is filtered.\n\n\n\n\n\n\n\nTry using the mouse to brush over regions on the dot plot—the bar plot will update accordingly.\n\n\nToggle\nThe toggle() interactor selects individual points (e.g., by click or shift-click) and generates a selection clause over specified fields of those points. Directives such as toggle_color(), toggle_x(), and toggle_y() simplify specification of which channel fields are included in the resulting predicates.\nThe highlight() interactor updates the rendered state of a visualization in response to a Selection. Non-selected points are set to translucent, neutral gray, or other specified visual properties. Selected points maintain normal encodings.\nThis example demonstrates using the toggle_y() and highlight() interactors to render a bar chart that can be clicked to select a subset of points on the dot plot above it. The dot plot legend also targets the same the selection to make itself interactive.\n\nfrom inspect_viz import Data, Selection\nfrom inspect_viz.interactor import highlight, toggle_y\nfrom inspect_viz.plot import legend, plot\nfrom inspect_viz.mark import bar_x, dot\nfrom inspect_viz.layout import vconcat\nfrom inspect_viz.transform import count, date_month_day\n\nseattle = Data.from_file(\"seattle-weather.parquet\")\n\n1weather = Selection.single()\n\nvconcat(\n    plot(\n        dot(\n            data=seattle,\n2            filter_by=weather,\n            x=date_month_day(\"date\"),\n            y=\"temp_max\",\n            fill=\"weather\",\n            fill_opacity=0.7,\n3            r=\"precipitation\",\n        ),\n4        legend=legend(\"color\", target=weather),\n        x_tick_format=\"%b\",\n        color_domain=\"fixed\",\n        r_domain=\"fixed\", \n        r_range=[2, 10]\n    ),\n    plot(\n        bar_x(seattle, x=count(), y=\"weather\", fill=\"weather\"),\n5        toggle_y(target=weather),\n6        highlight(by=weather),\n        x_domain=\"fixed\",\n        y_label=None,\n        height=200\n    )\n)\n\n\n1\n\nSingle selection (filter out all other points).\n\n2\n\nDot plot should filter by the selection.\n\n3\n\nShow precipitation level using dot radius.\n\n4\n\nClicks on the legend target the same selection\n\n5\n\ntoggle_y() interactor to filter by weather.\n\n6\n\nhighlight() interactor to fade out unselected bars.\n\n\n\n\n\n\n\nTry clicking either the legend or the bar plot elements to filter the dot plot.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Selections"
    ]
  },
  {
    "objectID": "components-selections.html#cross-filtering",
    "href": "components-selections.html#cross-filtering",
    "title": "Selections",
    "section": "Cross Filtering",
    "text": "Cross Filtering\nIn many cases you’ll want to have an input or interactor that both consumes and produces the same selection (i.e. filtered based on interactions with other inputs or interactors, but also able to provide its own filtering).\n\nInputs\nThis example demonstrates crossfiltering across inputs. We plot shot types taken during the 2023 WNBA season, providing a select() input that filters by team, and another select() input that filters by player (which in turn is also filtered by the currently selected team). Click on the numbers at right for additional explanation of the code.\n\nfrom inspect_viz import Data, Selection\nfrom inspect_viz.input import select\nfrom inspect_viz.layout import vconcat, hconcat\nfrom inspect_viz.mark import bar_x \nfrom inspect_viz.plot import plot\nfrom inspect_viz.transform import count\n\nshots = Data.from_file(\"wnba-shots-2023.parquet\")\n\n1filter = Selection.crossfilter()\n\nvconcat(\n   hconcat(\n      select(\n         shots, label=\"Team\", column=\"team_name\", \n2         target=filter\n      ),\n      select(\n         shots, label=\"Athlete\", column=\"athlete_name\", \n3         filter_by=filter, target=filter\n      )\n   ),\n   plot(\n      bar_x(\n         shots, filter_by=filter,\n         x=count(), y=\"category\", fill=\"category\"\n      ),\n      y_label=None,\n4      color_domain=\"fixed\",\n      y_domain=[\"Jump\", \"Layup\", \"Hook\"],\n      height=200,\n      margin_left=60\n   )\n)\n\n\n1\n\nCreate a crossfilter selection, which enables inputs to both consume and produce the same selection (conditioning their available choices on other inputs).\n\n2\n\nThe team select box targets the filter selection (filtering both the choices in the athelte select box and what is displayed in the plot).\n\n3\n\nThe athlete select box is both filtered by and targets the filter selection, enabling it to both confine itself to the selected team as well as filter what is displayed in the plot.\n\n4\n\nAs different teams and players are selected, the y-axis may take on differnet values and ordering. These options ensure that the y-axis remains stable across selections.\n\n\n\n\n\n\n\n\n\nInteractors\nThis example demonstrates crossfiltering across plot interactors. We plot histograms showing arrival delay and departure time for flights. When you select a range in one plot, the other plot updates to show only the data within that selection—and vice versa. This bidirectional filtering is achieved using Selection.crossfilter(), which ensures each plot’s selection affects all other plots except itself. Click on the numbers at right for additional explanation of the code.\n\nfrom inspect_viz import Data, Selection\nfrom inspect_viz.mark import rect_y\nfrom inspect_viz.layout import vconcat\nfrom inspect_viz.plot import plot\nfrom inspect_viz.transform import count, bin\nfrom inspect_viz.interactor import interval_x\n\nflights = Data.from_file(\"flights.parquet\")\n\n1brush = Selection.crossfilter()\n\n2def flights_plot(x, label):\n   return plot(\n      rect_y(\n         flights, filter_by=brush, \n         x=bin(x), y=count(), fill=\"steelblue\"\n      ),\n3      interval_x(target=brush),\n      height=200,\n      x_label=label,\n4      x_domain=\"fixed\",\n      y_tick_format=\"s\"\n   )\n\nvconcat(\n   flights_plot(\"delay\", \"Arrival Delay (min)\"),\n   flights_plot(\"time\", \"Departure Time (hour)\")\n)\n\n\n1\n\nCreate a crossfilter selection, which ensures each plot’s selection affects all other plots except itself.\n\n2\n\nOur two plots are identical save for the x value and the x_label so factor out into a function.\n\n3\n\nThe interval_x() interactor enables horizontal selection (targeting the crossfiltering brush).\n\n4\n\nUse a \"fixed\" domain so that the x-axis remains stable even when being filtered.\n\n\n\n\n\n\n\nTry selecting a horizontal range on either or both of the bar plots.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Selections"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inspect Viz",
    "section": "",
    "text": "Welcome to Inspect Viz, a data visualisation library for Inspect AI. Inspect Viz provides flexible tools for high quality interactive visualisations from Inspect evaluations.\nHere’s an Inspect Viz plot that compares benchmarks scores over time for various providers1:\n\n\n\n\n\nUse the filters to switch benchmarks and restrict to models from various organization(s). Hover over the points to get additional details on them or view the underlying Inspect log for the evals.\n\n\nFirst, install the inspect_viz package from GitHub as follows:\npip install git+https://github.com/meridianlabs-ai/inspect_viz\nYou can author visualisations in any Jupyter Notebook then include them in documents as static images or in websites as interactive Jupyter Widgets (see Publishing for details).",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Inspect Viz",
    "section": "",
    "text": "Welcome to Inspect Viz, a data visualisation library for Inspect AI. Inspect Viz provides flexible tools for high quality interactive visualisations from Inspect evaluations.\nHere’s an Inspect Viz plot that compares benchmarks scores over time for various providers1:\n\n\n\n\n\nUse the filters to switch benchmarks and restrict to models from various organization(s). Hover over the points to get additional details on them or view the underlying Inspect log for the evals.\n\n\nFirst, install the inspect_viz package from GitHub as follows:\npip install git+https://github.com/meridianlabs-ai/inspect_viz\nYou can author visualisations in any Jupyter Notebook then include them in documents as static images or in websites as interactive Jupyter Widgets (see Publishing for details).",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#views",
    "href": "index.html#views",
    "title": "Inspect Viz",
    "section": "Views",
    "text": "Views\nInspect Viz Views are pre-built plots that work with data created by the Inspect log data frame reading functions. For example, the scores_by_factor() view enables you to compare scores across models and a boolean factor:\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_by_factor\n\nevals = Data.from_file(\"evals-hint.parquet\")\nscores_by_factor(evals, \"task_arg_hint\", (\"No hint\", \"Hint\"))\n\n\n\n\nThe tool_calls() view enables you to visualize tool calls by sample:\n\nfrom inspect_viz.view.beta import tool_calls\n\ntools = Data.from_file(\"cybench_tools.parquet\")\ntool_calls(tools)\n\n\n\n\nAvailable views include:\n\n\n\n\n\n\n\nView\nDescription\n\n\n\n\nscores_by_task()\nBar plot for comparing eval scores (with confidence intervals) across models and tasks.\n\n\nscores_by_factor()\nBar bar plot for comparing eval scores by model and a boolean factor (e.g. no hint vs. hint).\n\n\nscores_timeline()\nScatter plot with eval scores by model, organization, and release date. Filterable by evaluation and organization.\n\n\nscores_heatmap()\nHeatmap with values for comparing scores across model and task.\n\n\nscores_with_baseline()\nBar plot for comparing model scores on a single eval, with one or more baselines overlaid.\n\n\ntool_calls()\nHeat map visualising tool calls over evaluation turns.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#plots",
    "href": "index.html#plots",
    "title": "Inspect Viz",
    "section": "Plots",
    "text": "Plots\nWhile pre-built views are useful, you also may want to create your own custom plots. Plots in inspect_viz are composed of one or more marks, which can do either higher level plotting (e.g. dot(), bar_x(), bar_y(), area(), heatmap(), etc.) or lower level drawing on the plot canvas (e.g. text(), image(), arrow(), etc.)\n\nDot Plot\nHere is an example of a simple dot plot using the Palmer Penquins dataset:\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import dot\n\n1penguins = Data.from_file(\"penguins.parquet\")\n\nplot(\n    dot(\n        penguins, \n2        x=\"body_mass\", y=\"flipper_length\",\n3        stroke=\"species\", symbol=\"species\"\n    ),\n    grid=True,\n4    legend=\"symbol\"\n)\n\n\n1\n\nRead the dataset from a parquet file. You can can also use Data.from_dataframe() to read data from any Pandas, Polars, or PyArrow data frame.\n\n2\n\nPlot using a dot() mark. The plot() function takes one or more marks or interactors.\n\n3\n\nMap the “species” column to the stroke and symbol scales of the plot (causing each species to have its own color and symbol).\n\n4\n\nAdd a legend to the plot as a key to our scale mappings.\n\n\n\n\n\n\n\n\n\nBar Plot\nHere is a simple horizontal bar plot that counts the number of each species:\n\nfrom inspect_viz.mark import bar_x\nfrom inspect_viz.transform import count\n\nplot(\n    bar_x(penguins, x=count(), y=\"species\", fill=\"species\"),\n    y_label=None,\n    height=200,\n    margin_left=60\n)\n\n\n\n\nThe x axis for this plot is not mapped to a column, but rather to a count() transform ( transforms enable you to perform computations on columns for plotting). The fill option gives each species it’s own color. We also specify that we don’t want a y_label (as the species names serve that purpose) and a smaller than normal height.\n\n\n\n\n\n\nTip\n\n\n\nInspect Viz is built on top of the Mosaic data visualization system which is in turn built on Observable Plot.\nThe Inspect Viz Python API typically maps quite closely to the Observable Plot JavaScript API. Once you start creating your own plots and are using Google or an LLM to help with development, asking how to do things in Observable Plot will typically yield actionable advice.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#tables",
    "href": "index.html#tables",
    "title": "Inspect Viz",
    "section": "Tables",
    "text": "Tables\nYou can also display data in a tabular layout using the table() function:\n\nfrom inspect_viz.table import table\n\ntable(penguins)\n\n\n\n\nYou can sort and filter tables by column, use a scrolling or paginated display, and customize several other aspects of table appearance and behavior.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#links",
    "href": "index.html#links",
    "title": "Inspect Viz",
    "section": "Links",
    "text": "Links\nInspect Viz supports creating direct links from visualizations to published Inspect log transcripts. Links can be made at the eval level, or to individual samples, messages, or events. For example, this plot produced with scores_with_baseline() includes a link to the underlying logs in its tooltips:\n\nfrom inspect_viz.view.beta import scores_with_baseline\nscores_with_baseline(evals, baseline=0.91)\n\n\n\n\nThe pre-built Views all support linking when a log_viewer column is available in the dataset. To learn more about ammending datasets with viewer URLs as well as adding linking support to your own plots see the article on Links.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#filters",
    "href": "index.html#filters",
    "title": "Inspect Viz",
    "section": "Filters",
    "text": "Filters\nUse inputs to enable filtering datasets and dynamically updating plots. For example, here we add a select() input that filters on the species column:\n\nfrom inspect_viz.input import select\nfrom inspect_viz.layout import vconcat\n\nvconcat(\n   select(penguins, label=\"Species\", column=\"species\"),\n   plot(\n      dot(penguins, x=\"body_mass\", y=\"flipper_length\",  \n          stroke=\"species\", symbol=\"species\"),\n      legend=\"symbol\",\n      color_domain=\"fixed\"\n   )\n)\n\n\n\n\nWe’ve introduced a few new things here:\n\nThe vconcat() function from the layout module lets us stack inputs on top of our plot.\nThe select() function from the input module binds a select box to the species column.\nThe color_domain=\"fixed\" argument to plot() indicates that we want to preserve species colors even when the plot is filtered.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#marks",
    "href": "index.html#marks",
    "title": "Inspect Viz",
    "section": "Marks",
    "text": "Marks\nSo far the plots we’ve created include only a single mark, however many of the more interesting plots you’ll create will include multiple marks.\nFor example, here we explore the relationships between the height, weight, and sex of olympic athletes using dot() and regression_y() marks:\n\nfrom inspect_viz.mark import regression_y\n\nathletes = Data.from_file(\"athletes.parquet\")\n\nplot(\n    dot(athletes, x=\"weight\", y=\"height\", fill=\"sex\", opacity=0.1),\n    regression_y(athletes, x=\"weight\", y=\"height\", stroke=\"sex\"),\n    legend=\"color\"\n)\n\n\n\n\nNote that we set the opacity of the dot mark to 0.1 to help mitigate oversaturation that results from large numbers of data points being stacked on top of eachother.\nMarks can also be used to draw lines, arrows, text, or images on a plot.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#params",
    "href": "index.html#params",
    "title": "Inspect Viz",
    "section": "Params",
    "text": "Params\nAs illustrated above, inputs can be used to filter dataset selections. Inputs can also be used to set Param values that make various aspects of plots dynamic. For example, here is a density plot of flight delays which uses a slider() input to vary the amount of smooth ing by setting the kernel bandwidth:\n\nfrom inspect_viz import Param\nfrom inspect_viz.input import slider\nfrom inspect_viz.mark import density_y\n\nflights = Data.from_file(\"flights.parquet\")\n\n1bandwidth = Param(0.1)\n\nvconcat(\n   slider(\n2      label=\"Bandwidth (σ)\", target=bandwidth,\n      min=0.1, max=100, step=0.1\n   ),\n   plot(\n      density_y(\n3         flights, x=\"delay\", fill=\"steelblue\", bandwidth=bandwidth\n      ),\n      x_domain=\"fixed\",\n      y_axis=None,\n      height=250,\n   )\n)\n\n\n1\n\nCreate a bandwidth parameter with a default value of 0.1.\n\n2\n\nBind the slider() to the bandwidth parameter.\n\n3\n\nApply the bandwidth to the plot (plot automatically redraws when the bandwidth changes).",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#selections",
    "href": "index.html#selections",
    "title": "Inspect Viz",
    "section": "Selections",
    "text": "Selections\nAbove in Filtering we began exploring dataset selections. Inputs are one way to set selections, but you can also set selections through direct interaction with plots.\nFor example, below we stack two plots vertically, the dot() plot from above along with a bar_x() plot that counts the sex column. We then add an interval_x() interactor that enables us to filter the dataset using selections on the dot plot.\nThere are a number of new things introduced here, click on the numbers near the right margin for additional explanation.\n\nfrom inspect_viz import Selection\nfrom inspect_viz.interactor import Brush, interval_x\n\n1range = Selection.intersect()\n\nvconcat(\n   plot(\n      dot(athletes, x=\"weight\", y=\"height\", fill=\"sex\", opacity=0.1),\n      regression_y(athletes, x=\"weight\", y=\"height\", stroke=\"sex\"),\n      interval_x(\n2         target=range,\n3         brush=Brush(fill=\"none\", stroke=\"#888\")\n      ),\n      legend=\"color\"\n   ),\n   plot(\n      bar_x(\n4         athletes, filter_by=range,\n         x=count(), y=\"sex\", fill=\"sex\"\n      ), \n      y_label=None,\n      height=150,\n5      x_domain=\"fixed\"\n   )\n)\n\n\n1\n\nA Selection is a means of filtering datasets based on interactions. Here we use an “intersect” selection for application of a simple filter from dot plot to bar plot.\n\n2\n\nThe range selection is set via the interval_x() interactor (which enables using the mouse to select an x-range).\n\n3\n\nThe Brush defines the color of the interactor (in this case #888, a medium-gray).\n\n4\n\nThe range selection is consumed using the filter_by parameter.\n\n5\n\nWe set the x_domain for the bar plot to “fixed” so that the scale doesn’t change as the dataset is filtered.\n\n\n\n\n\n\n\nTry using the mouse to brush over regions on the dot plot—the bar plot will update accordingly.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "Inspect Viz",
    "section": "Data",
    "text": "Data\nIn the examples above we made Data available by reading from a parquet file. We can also read data from any Python Data Frame (e.g. Pandas, Polars, PyArrow, etc.). For example:\nimport pandas as pd\nfrom inspect_viz import Data\n\n# read directly from file\npenguins = Data.from_file(\"penguins.parquet\")\n\n# read from Pandas DF (i.e. to preprocess first)\ndf = pd.read_parquet(\"penguins.parquet\")\npenguins = Data.from_dataframe(df)\nYou might wonder why is there a special Data class in Inspect Viz rather than using data frames directly? This is because Inpsect Viz is an interactive system where data can be dynamically filtered and transformed as part of plotting—the Data therefore needs to be sent to the web browser rather than remaining only in the Python session. This has a couple of important implications:\n\nData transformations should be done using standard Python Data Frame operations prior to reading into Data for Inspect Viz.\nSince Data is embedded in the web page, you will want to filter it down to only the columns required for plotting (as you don’t want the additional columns making the web page larger than is necessary).\n\n\nData Selections\nOne other important thing to understand is that Data has a built in selection which is used in filtering operations on the client. This means that if you want your inputs and plots to stay synchoronized, you should pass the same Data instance to all of them (i.e. import into Data once and then share that reference). For example:\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import dot\nfrom inspect_viz.input import select\nfrom inspect_viz.layout import vconcat\n\n# we import penguins once and then pass it to select() and dot()\npenguins = Data.from_file(\"penguins.parquet\")\n\nvconcat( \n   select(penguins, label=\"Species\", column=\"species\"),\n   plot(\n      dot(penguins, x=\"body_mass\", y=\"flipper_length\",\n          stroke=\"species\", symbol=\"species\"),\n      legend=\"symbol\",\n      color_domain=\"fixed\"  \n   )\n)",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#crossfilter",
    "href": "index.html#crossfilter",
    "title": "Inspect Viz",
    "section": "Crossfilter",
    "text": "Crossfilter\nIn many cases you’ll want to have an input or interactor that both consumes and produces the same selection (i.e. filtered based on interactions with other inputs or interactors, but also able to provide its own filtering).\n\nInputs\nThis example demonstrates crossfiltering across inputs. We plot shot types taken during the 2023 WNBA season, providing a select() input that filters by team, and another select() input that filters by player (which in turn is also filtered by the currently selected team). Click on the numbers at right for additional explanation of the code.\n\nfrom inspect_viz.layout import hconcat\n\nshots = Data.from_file(\"wnba-shots-2023.parquet\")\n\n1filter = Selection.crossfilter()\n\nvconcat(\n   hconcat(\n      select(\n         shots, label=\"Team\", column=\"team_name\", \n2         target=filter\n      ),\n      select(\n         shots, label=\"Athlete\", column=\"athlete_name\", \n3         filter_by=filter, target=filter\n      )\n   ),\n   plot(\n      bar_x(\n         shots, filter_by=filter,\n         x=count(), y=\"category\", fill=\"category\"\n      ),\n      y_label=None,\n4      color_domain=\"fixed\",\n      y_domain=[\"Jump\", \"Layup\", \"Hook\"],\n      height=200,\n      margin_left=60\n   )\n)\n\n\n1\n\nCreate a crossfilter selection, which enables inputs to both consume and produce the same selection (conditioning their available choices on other inputs).\n\n2\n\nThe team select box targets the filter selection (filtering both the choices in the athelte select box and what is displayed in the plot).\n\n3\n\nThe athlete select box is both filtered by and targets the filter selection, enabling it to both confine itself to the selected team as well as filter what is displayed in the plot.\n\n4\n\nAs different teams and players are selected, the y-axis may take on differnet values and ordering. These options ensure that the y-axis remains stable across selections.\n\n\n\n\n\n\n\n\n\nInteractors\nThis example demonstrates crossfiltering across plot interactors. We plot histograms showing arrival delay and departure time for flights. When you select a range in one plot, the other plot updates to show only the data within that selection—and vice versa. This bidirectional filtering is achieved using Selection.crossfilter(), which ensures each plot’s selection affects all other plots except itself. Click on the numbers at right for additional explanation of the code.\n\nfrom inspect_viz.mark import rect_y\nfrom inspect_viz.transform import count, bin\n\nflights = Data.from_file(\"flights.parquet\")\n\n1brush = Selection.crossfilter()\n\n2def flights_plot(x, label):\n   return plot(\n      rect_y(\n         flights, filter_by=brush, \n         x=bin(x), y=count(), fill=\"steelblue\"\n      ),\n3      interval_x(target=brush),\n      height=200,\n      x_label=label,\n4      x_domain=\"fixed\",\n      y_tick_format=\"s\"\n   )\n\nvconcat(\n   flights_plot(\"delay\", \"Arrival Delay (min)\"),\n   flights_plot(\"time\", \"Departure Time (hour)\")\n)\n\n\n1\n\nCreate a crossfilter selection, which ensures each plot’s selection affects all other plots except itself.\n\n2\n\nOur two plots are identical save for the x value and the x_label so factor out into a function.\n\n3\n\nThe interval_x() interactor enables horizontal selection (targeting the crossfiltering brush).\n\n4\n\nUse a \"fixed\" domain so that the x-axis remains stable even when being filtered.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#learning-more",
    "href": "index.html#learning-more",
    "title": "Inspect Viz",
    "section": "Learning More",
    "text": "Learning More\nUse these resources to learn more about using Inspect Viz:\n\nViews describes the various available pre-built views and how to customize them.\nComponents goes into further depth on the main concepts and components of the library.\nPublishing covers publishing Inspect Viz content as standalone plots, notebooks, websites, and dashboards.\nReference provides details on the available marks, interactors, transforms, and inputs.\nExamples demonstrates more advanced plotting and interactivity features.",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Inspect Viz",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis plot was inspired by and includes data from the Epoch AI Benchmarking Hub↩︎",
    "crumbs": [
      "Getting Started",
      "Welcome"
    ]
  },
  {
    "objectID": "components-inputs.html",
    "href": "components-inputs.html",
    "title": "Inputs",
    "section": "",
    "text": "Inputs are used to create interactive visualisations by targeting either Param values or Selection ranges. Available inputs include:\nAll inputs can write updates to a provided Param or Selection. Param values are updated to match the input value. Selections are provided a predicate clause. This linking can be bidirectional: an input component will also subscribe to a param and track its value updates.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Inputs"
    ]
  },
  {
    "objectID": "components-inputs.html#select",
    "href": "components-inputs.html#select",
    "title": "Inputs",
    "section": "Select",
    "text": "Select\nThe select() input is used to select one more more values from a list. The list can be sourced from a data column (via the column parameter) or be static (via the options parameter). Here is a select input bound to a column (this input targets the default Selection associated with the passed Data):\n\nfrom inspect_viz import Data\nfrom inspect_viz.input import select\n\npenguins = Data.from_file(\"penguins.parquet\")\n\nselect(penguins, label=\"Species\", column=\"species\")\n\n\n\n\nNote that by default the select has no value so does not filtering (represented by the default “All” selection). If you want a select() to have an initial value then specify it using the value parameter (or pass ‘auto’ to select the first value):\n\nselect(penguins, label=\"Species\", column=\"species\", value=\"auto\")\n\n\n\n\nHere is a select input with explicit options (this input targets a Param):\n\nfrom inspect_viz import Param\n\nfruit = Param(\"Apple\")\n\nselect(label=\"Fruit\", options=[\"Apple\", \"Orange\", \"Banana\"], target=fruit)\n\n\n\n\nPass multiple=True to enable multiple inputs. In this case values are specified via typing/autocomplete rather than a drop down menu.\n\nathletes = Data.from_file(\"athletes.parquet\")\n\nselect(athletes, label=\"Sports\", column=\"sport\", multiple=True)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Inputs"
    ]
  },
  {
    "objectID": "components-inputs.html#slider",
    "href": "components-inputs.html#slider",
    "title": "Inputs",
    "section": "Slider",
    "text": "Slider\nThe slider() input enables specificiation of either a single numeric value or a range of values. Here we enable the selection of a maximum body mass for a column:\n\nfrom inspect_viz.input import slider\n\nslider(penguins, label=\"Max Body Mass\", column=\"body_mass\")\n\n\n\n\nPass select=\"interval\" to specify an interval rather than single value:\n\nslider(penguins, label=\"Body Mass Range\", column=\"body_mass\", select=\"interval\")\n\n\n\n\nSliders can also target a Param and have explicit min, max, and step values:\n\nbias = Param(0.5)\n\nslider(label=\"Bias\", min=0, max=1.0, step=0.1, target=bias)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Inputs"
    ]
  },
  {
    "objectID": "components-inputs.html#search",
    "href": "components-inputs.html#search",
    "title": "Inputs",
    "section": "Search",
    "text": "Search\nThe search() input enables filtering a dataset based on text matching. For example, this input filters by WNBA player name\n\nfrom inspect_viz.input import search\n\nplayers = Data.from_file(\"wnba-shots-2023.parquet\")\n\nsearch(players, label=\"Athlete\", column=\"athlete_name\")",
    "crumbs": [
      "Getting Started",
      "Components",
      "Inputs"
    ]
  },
  {
    "objectID": "components-inputs.html#checkbox",
    "href": "components-inputs.html#checkbox",
    "title": "Inputs",
    "section": "Checkbox",
    "text": "Checkbox\nThe checkbox() input enables toggling a binary value. You can either target boolean Param values or provide custom values mapped to checked and unchecked.\n\nfrom inspect_viz.input import checkbox\n\nenabled = Param(True)\n\ncheckbox(label=\"Enabled\", target=enabled)\n\n\n\n\nHere we provide custom values that map to checked and unchecked states:\n\nbias = Param(0.1)\n\ncheckbox(label=\"Use Bias\", values=[0.0, 0.1], target=bias)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Inputs"
    ]
  },
  {
    "objectID": "components-inputs.html#radio-group",
    "href": "components-inputs.html#radio-group",
    "title": "Inputs",
    "section": "Radio Group",
    "text": "Radio Group\nThe radio_group() is an alternative to select() which displays all of the available options rather than collapsing them into a menu:\n\nfrom inspect_viz.input import radio_group\n\npenguins = Data.from_file(\"penguins.parquet\")\n\nradio_group(penguins, label=\"Species\", column=\"species\")\n\n\n\n\nOr targeting a Param:\n\nfruit = Param(\"Apple\")\n\nradio_group(label=\"Fruit\", options=[\"Apple\", \"Orange\", \"Banana\"], target=fruit)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Inputs"
    ]
  },
  {
    "objectID": "components-inputs.html#checkbox-group",
    "href": "components-inputs.html#checkbox-group",
    "title": "Inputs",
    "section": "Checkbox Group",
    "text": "Checkbox Group\nThe checkbox_group() provides an interface to select multiple values (similar to select(..., multiple=True)):\n\nfrom inspect_viz.input import checkbox_group\n\npenguins = Data.from_file(\"penguins.parquet\")\n\ncheckbox_group(penguins, label=\"Species\", column=\"species\")\n\n\n\n\nYou can also use checkbox_group() with a Param:\n\nfruit = Param([\"Apple\", \"Orange\"])\n\ncheckbox_group(label=\"Fruit\", options=[\"Apple\", \"Orange\", \"Banana\"], target=fruit)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Inputs"
    ]
  },
  {
    "objectID": "examples/inspect/scores-timeline/index.html",
    "href": "examples/inspect/scores-timeline/index.html",
    "title": "Scores Timeline",
    "section": "",
    "text": "This example illustrates the code behind the scores_timeline() pre-built view function. If you want to include this plot in your notebooks or websites you should start with that function rather than the lower-level code below.\nThe example also relies on some data preparation steps to annotate the raw evals data with shorter model names and a “frontier” column which drives the inclusion of text labels for scores that set a new high water mark.\n\n\n\nCode\n\nfrom inspect_viz import Data, Selection\nfrom inspect_viz.input import checkbox_group, select\nfrom inspect_viz.layout import vconcat, vspace\nfrom inspect_viz.plot import plot, legend\nfrom inspect_viz.mark import dot, rule_x, text\nfrom inspect_viz.table import table\nfrom inspect_viz.transform import ci_bounds\n\n# read data\n1evals = Data.from_file(\"benchmarks.parquet\")\n\n# transforms to compute ci bounds from score and stderr columns\n2ci_lower, ci_upper = ci_bounds(\n    0.95, \n    score=\"score_headline_value\", \n    stderr=\"score_headline_stderr\"\n)\n\nvconcat(\n    # select benchmark\n    select(evals, label=\"Eval: \", column=\"task_name\", value=\"GPQA Diamond\", width=425),\n    \n    # filter models by organization(s)\n    checkbox_group(evals, column=\"model_organization_name\"),\n    \n    # dot plot w/ error bars\n    vspace(15),\n    plot(\n        # benchmark score\n        dot(\n            evals,\n            x=\"model_release_date\",\n            y=\"score_headline_value\",\n            r=3,\n            fill=\"model_organization_name\",\n3            channels= {\n                \"Model\": \"model_display_name\", \n                \"Scorer\": \"score_headline_name\", \n                \"Stderr\": \"score_headline_stderr\",\n                \"Log Viewer\": \"log_viewer\"\n            }\n        ),\n        # confidence interval\n        rule_x( \n            evals,\n            x=\"model_release_date\",\n            y=\"score_headline_value\",\n            y1=ci_lower,\n            y2=ci_upper,\n            stroke=\"model_organization_name\",\n4            stroke_opacity=0.4,\n            marker=\"tick-x\",\n        ), \n        # frontier annotation\n        text(\n            evals,\n5            text=\"model_display_name\",\n            x=\"model_release_date\",\n            y=\"score_headline_value\",\n            line_anchor=\"middle\",\n            frame_anchor=\"right\",\n6            filter=\"frontier\",\n            dx=-4,\n            fill=\"model_organization_name\",\n        ),\n7        legend=legend(\"color\", target=evals.selection),\n8        x_domain=\"fixed\",\n        y_domain=[0,1.0],\n        x_label=\"Release Date\",\n        y_label=\"Score\",\n        color_label=\"Organization\",\n        color_domain=\"fixed\"\n    )\n)\n\n\n\n1\n\nBenchmark data sourced from Epoch AI.\n\n2\n\nCreate transforms used to compute the confidence intervals for each point.\n\n3\n\nAdditional channels are added to the tooltip.\n\n4\n\nConfidence interval: compute dynamically using ci_value(), color by organization, and reduce opacity.\n\n5\n\nText annotations are automatically moved to avoid collisions.\n\n6\n\nOnly show annotations for records with frontier=True.\n\n7\n\nSpecifying target makes the legend clickable.\n\n8\n\nDomains: x_domain fixed so that the axes don’t jump around for organization selections; y_domain should always span up to 1.0.\n\n\n\n\n\n\n\nThis plot was inspired by and includes data from the Epoch AI Benchmarking Hub.",
    "crumbs": [
      "Examples",
      "Inspect",
      "Scores Timeline"
    ]
  },
  {
    "objectID": "examples/inspect/scores-heatmap/index.html",
    "href": "examples/inspect/scores-heatmap/index.html",
    "title": "Scores Heatmap",
    "section": "",
    "text": "This example illustrates the code behind the scores_heatmap() pre-built view function. If you want to include this plot in your notebooks or websites you should start with that function rather than the lower-level code below.\n\n\n\nCode\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot\nfrom inspect_viz.mark import cell, text\n\nevals_data = Data.from_file(\"evals.parquet\")\n\nplot(\n1    cell(\n        evals_data,                                                         \n        x=\"task_name\",                                                      \n        y=\"model\",\n2        fill=\"score_headline_value\",\n        tip=True,\n3        inset=1,\n4        sort={\n            \"y\": {\"value\": \"fill\", \"reduce\": \"sum\", \"reverse\": True},\n            \"x\": {\"value\": \"fill\", \"reduce\": \"sum\", \"reverse\": False},\n        },\n    ),\n5    text(\n        evals_data,\n        x=\"task_name\",\n        y=\"model\",\n        text=\"score_headline_value\",\n        fill=\"white\",\n        styles={\"font_weight\": 600},\n    ),\n6    padding=0,\n    color_scheme=\"viridis\",\n    height=250,\n    margin_left=150,\n    x_label=None,\n    y_label=None\n)\n\n\n\n1\n\nThe cell mark draws the cells, position each cell along the x and y axis using the fields specified in x and y.\n\n2\n\nThe cell’s color is determined using the field specified in the fill.\n\n3\n\nThe cell inset controls the space between cells.\n\n4\n\nSorting of the cells is important in a heatmap to cause colors to be grouped along the x and y axis. In this case, we sort using the sum of the rows and columns, place the highest values at the top righ and lowest values at the bottom left.\n\n5\n\nPlace the value as text centered in the cell.\n\n6\n\nRemove plot padding so the inset along controls spacing between cells.",
    "crumbs": [
      "Examples",
      "Inspect",
      "Scores Heatmap"
    ]
  },
  {
    "objectID": "examples/inspect/scores-by-factor/index.html",
    "href": "examples/inspect/scores-by-factor/index.html",
    "title": "Scores by Factor",
    "section": "",
    "text": "This example illustrates the code behind the scores_by_factor() pre-built view function. If you want to include this plot in your notebooks or websites you should start with that function rather than the lower-level code below.\n\n\n\nCode\n\nfrom inspect_viz import Data\nfrom inspect_viz.mark import frame, rule_y\nfrom inspect_viz.plot import legend, plot\nfrom inspect_viz.transform import ci_bounds, sql\n\nevals = Data.from_file(\"evals.csv\")\n\n# factor colors/labels\n1fx_colors = [\"#3266ae\", \"#a6c0e5\"]\nfx_labels = [\"No hint\", \"Hint\"]\n\n# confidence interval tranforms\nci_lower, ci_upper = ci_bounds(\n    0.95, \n    score=\"score_headline_value\", \n    stderr=\"score_headline_stderr\"\n)\n\n# compute plot height (65 pixels per model)\n2height = 65 * len(evals.column_unique(\"model_display_name\"))\n\nplot(\n3    frame(\"left\", inset_top=5, inset_bottom=5),\n    rule_y(\n        evals,\n        x=\"score_headline_value\",\n        y=\"task_arg_hint\",\n        fy=\"model_display_name\",\n4        sort={\"fy\": \"-x\"},\n        stroke=sql(f\"IF(NOT task_arg_hint, '{fx_labels[0]}', '{fx_labels[1]}')\"), \n        stroke_width=3,\n        stroke_linecap=\"round\",\n        marker_end=\"circle\",\n        tip=True,\n        channels={\n            \"Model\": \"model_display_name\", \n            \"Hint\": \"task_arg_hint\",\n            \"Score\": \"score_headline_value\", \n            \"Stderr\": \"score_headline_stderr\"\n        },\n    ),\n    rule_y(\n        evals,\n5        x1=ci_lower,\n        x2=ci_upper,\n        y=\"task_arg_hint\",\n        fy=\"model_display_name\",\n        stroke=f\"{fx_colors[0]}20\",\n        stroke_width=15,\n    ),\n6    legend=legend(\"color\", target=evals.selection),\n    x_label=\"Score\",\n7    y_label=None,\n    y_ticks=[],\n    y_tick_size=0,\n    fy_label=None,\n    fy_axis=\"left\",\n8    color_domain=fx_labels,\n    color_range=fx_colors,\n    margin_top=0,\n9    margin_left=100,\n    height=height\n)\n\n\n\n1\n\nFactors need to define a dark/light color and labels for the their False and True states.\n\n2\n\nCompute plot height based on number of unique models.\n\n3\n\nSets off each model with their own horizonal axis line.\n\n4\n\nOrder models on y axis from highest to lowest score.\n\n5\n\nConfidence interval using specified stderr column.\n\n6\n\nClickable legend to filter view by factor value.\n\n7\n\nY-axis labels and ticks already covered by factor and frame().\n\n8\n\nMap legend and colors map to factor.\n\n9\n\nLeave room for model names.",
    "crumbs": [
      "Examples",
      "Inspect",
      "Scores by Factor"
    ]
  },
  {
    "objectID": "examples/general/athletes-errorbars/index.html",
    "href": "examples/general/athletes-errorbars/index.html",
    "title": "Athletes (Error Bars)",
    "section": "",
    "text": "Confidence intervals of Olympic athlete heights, in meters. Data are batched into groups of 10 samples per sport. Use the samples slider to see how the intervals update as the sample size increases (as in online aggregation). For each sport, the numbers on the right show the maximum number of athletes in the full dataset.\n\n\n\nCode\n\nimport pandas as pd\nimport numpy as np\n\nfrom inspect_viz import Data, Param, Selection\nfrom inspect_viz.mark import error_bar_x, text\nfrom inspect_viz.plot import plot, legend\nfrom inspect_viz.transform import count\nfrom inspect_viz.input import slider\nfrom inspect_viz.layout import hconcat, vconcat, vspace\n\n# prepare data (create batch column so we can target various numbers of samples)\ndf = pd.read_parquet(\"athletes.parquet\")\ndf = df[df['height'].notna()]\ndf['row_num'] = df.groupby('sport').cumcount() + 1\ndf['batch'] = 10 * np.ceil(df['row_num'] / 10).astype(int)\ndf = df.drop('row_num', axis=1)\ndf = df.reset_index(drop=True)\n\nathletes = Data.from_dataframe(df)\n\nci = Param(0.95)\nquery = Selection.single()\n\nvconcat(\n    hconcat(\n        slider(\n            athletes, label=\"Samples\", select=\"interval\", target=query, \n            column=\"batch\", step=10, value=(0,20)\n        ),\n        slider(\n            label=\"Conf.\", target=ci, \n            min=0.5, max=0.999, value=0.95, step=0.001\n        )\n    ),\n    plot(\n        error_bar_x(\n            athletes, filter_by=query, ci=ci, \n            x=\"height\", y=\"sport\", stroke=\"sex\", stroke_width=1,\n            marker=\"tick\", sort={ \"y\": \"-x\"}\n        ),\n        text(\n            athletes, text=count(), y=\"sport\", dx=25,\n            frame_anchor=\"right\", font_size=8, fill=\"#999\"\n        ),\n        legend=legend(\"color\", location=\"bottom\"),\n        x_domain=[1.5,2.1],\n        y_domain=\"fixed\",\n        y_grid=True,\n        y_label=None,\n        margin_top=0,\n        margin_left=105\n    )\n)",
    "crumbs": [
      "Examples",
      "General",
      "Athletes (Error Bars)"
    ]
  },
  {
    "objectID": "examples/general/athletes-regression/index.html",
    "href": "examples/general/athletes-regression/index.html",
    "title": "Athletes (Regression)",
    "section": "",
    "text": "Use the drop downs to filter by sport or sex. Select a range on the plot to filter the table and see the regression lines for the selected range. Hover over the table to highlight the corresponding point on the plot.\n\n\n\nCode\n\nfrom inspect_viz import Data, Selection\nfrom inspect_viz.input import search, select\nfrom inspect_viz.interactor import Brush, interval_xy\nfrom inspect_viz.layout import hconcat, vconcat\nfrom inspect_viz.mark import TextStyles, dot, regression_y, text\nfrom inspect_viz.plot import plot\nfrom inspect_viz.table import column, table\n\nathletes = Data.from_file(\"athletes.parquet\")\n\ncategory = Selection.intersect()\nquery = Selection.intersect(include=category)\nhover = Selection.intersect(empty=True)\n\nvconcat(\n    hconcat(\n        select(athletes, label=\"Sport\", column=\"sport\", target=category),\n        select(athletes, label=\"Sex\", column=\"sex\", target=category),\n    ),\n    plot(\n        text(\n            text=[\"Olympic Athletes\"],\n            frame_anchor=\"top\",\n            styles=TextStyles(font_size=14),\n            dy=-20\n        ),\n        dot(\n            athletes,\n            filter_by=query,\n            x=\"weight\",\n            y=\"height\",\n            fill=\"sex\",\n            r=2,\n            opacity=0.1,\n        ),\n        regression_y(athletes, filter_by=query, x=\"weight\", y=\"height\", stroke=\"sex\"),\n        interval_xy(target=query, brush=Brush(fill_opacity=0, stroke=\"black\")),\n        dot(\n            athletes,\n            filter_by=hover,\n            x=\"weight\",\n            y=\"height\",\n            fill=\"sex\",\n            stroke=\"currentColor\",\n            stroke_width=1,\n            r=3\n        ),\n        xy_domain=\"fixed\",\n        r_domain=\"fixed\",\n        color_domain=\"fixed\"\n    ),\n    table(\n        athletes, \n        filter_by=query, \n        target=hover, \n        columns=[\n            column(\"name\", width=200), \n            \"sex\", \n            \"height\", \n            \"weight\", \n            \"sport\"\n        ],\n    )\n)",
    "crumbs": [
      "Examples",
      "General",
      "Athletes (Regression)"
    ]
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Inspect Viz Examples",
    "section": "",
    "text": "These examples demonstrate various plotting and interactivity features. If you are just beginning to use Inspect Viz you review the Getting Started article before exploring these examples.",
    "crumbs": [
      "Examples"
    ]
  },
  {
    "objectID": "examples/index.html#inspect",
    "href": "examples/index.html#inspect",
    "title": "Inspect Viz Examples",
    "section": "Inspect",
    "text": "Inspect\nThese examples demonstrates creating visualisations from Inspect log files (leveraging the functions in inspect_ai.analysis module for creation of data frames from logs).\n\n\n\n\n\n\n\nScores by Task\nBar plot summarizing eval scores by model and task.\n\n\nScores by Factor\nBar plot for comparing eval scores by model and a boolean factor (e.g. no hint vs. hint).\n\n\nScores Timeline\nEval scores for various models, with release date on the x-axis.\n\n\nScores Heatmap\nHeatmap with values for comparing scores across model and task.\n\n\nScores with Baseline\nVisualise model scores on a single evaluation, with one or more baselines.\n\n\nTool Calls\nVisualise tool usage over a series of turns.",
    "crumbs": [
      "Examples"
    ]
  },
  {
    "objectID": "examples/index.html#general",
    "href": "examples/index.html#general",
    "title": "Inspect Viz Examples",
    "section": "General",
    "text": "General\nThese examples demonstrate general plotting techniques using a variety of other examples datasets.\n\n\n\n\n\n\n\nPenguins Explorer\nDot plots, tables, color and symbol channels, filtering inputs.\n\n\nBias Parameter\nArea plots; slider inputs; channel expressions.\n\n\nSeattle Weather\nDot plots; bar plots; color and radius channels; x-interval selections, interactive legend.\n\n\nAthletes (Regression)\nDot plots; regression lines; tables, filtering inputs, xy selections.\n\n\nAthletes (Error Bars)\nError bars; text annotations; params, slider inputs.",
    "crumbs": [
      "Examples"
    ]
  },
  {
    "objectID": "view-scores-timeline.html",
    "href": "view-scores-timeline.html",
    "title": "Scores Timeline",
    "section": "",
    "text": "The scores_timeline() function plots eval scores by model, organization, and release date1:\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_timeline\n\nevals = Data.from_file(\"benchmarks.parquet\")\nscores_timeline(evals)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Timeline"
    ]
  },
  {
    "objectID": "view-scores-timeline.html#overview",
    "href": "view-scores-timeline.html#overview",
    "title": "Scores Timeline",
    "section": "",
    "text": "The scores_timeline() function plots eval scores by model, organization, and release date1:\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_timeline\n\nevals = Data.from_file(\"benchmarks.parquet\")\nscores_timeline(evals)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Timeline"
    ]
  },
  {
    "objectID": "view-scores-timeline.html#data-preparation",
    "href": "view-scores-timeline.html#data-preparation",
    "title": "Scores Timeline",
    "section": "Data Preparation",
    "text": "Data Preparation\nAbove we read the data for the plot from a parquet file. This file was in turn created by:\n\nReading logs into a data frame with evals_df().\nUsing the prepare() function to add model_info(), frontier() and log_viewer() columns to the data frame.\n\nfrom inspect_ai.analysis.beta import (\n    evals_df, frontier, log_viewer, model_into, prepare\n)\n\ndf = evals_df(\"logs\")\ndf = prepare(df, \n    model_info(),\n    frontier(),\n    log_viewer(\"eval\", {\"logs\": \"https://samples.meridianlabs.ai/\"}),\n)\ndf.to_parquet(\"benchmarks.parquet\")",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Timeline"
    ]
  },
  {
    "objectID": "view-scores-timeline.html#function-reference",
    "href": "view-scores-timeline.html#function-reference",
    "title": "Scores Timeline",
    "section": "Function Reference",
    "text": "Function Reference\nEval scores by model, organization, and release date.\n\nSource\n\ndef scores_timeline(\n    data: Data,\n    organizations: list[str] | None = None,\n    ci: float | bool = 0.95,\n    x_label: str = \"Release Date\",\n    y_label: str = \"Score\",\n    eval_label: str = \"Eval\",\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nData read using evals_df() and amended with model metadata using the model_info() prepare operation (see Data Preparation for details).\n\norganizations list[str] | None\n\nList of organizations to include (in order of desired presentation).\n\nci float | bool\n\nConfidence interval (defaults to 0.95, pass False for no confidence intervals)\n\nx_label str\n\nx-axis label\n\ny_label str\n\ny-axis label\n\neval_label str\n\nEval select label.\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes. By default, the x_domain is set to “fixed”, the y_domain is set to [0,1.0], color_label is set to “Organizations”, and color_domain is set to organizations.",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Timeline"
    ]
  },
  {
    "objectID": "view-scores-timeline.html#implementation",
    "href": "view-scores-timeline.html#implementation",
    "title": "Scores Timeline",
    "section": "Implementation",
    "text": "Implementation\nThe Scores Timeline example demonstrates how this view was implemented using lower level plotting components.",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Timeline"
    ]
  },
  {
    "objectID": "view-scores-timeline.html#footnotes",
    "href": "view-scores-timeline.html#footnotes",
    "title": "Scores Timeline",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis plot was inspired by and includes data from the Epoch AI Benchmarking Hub↩︎",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Timeline"
    ]
  },
  {
    "objectID": "view-scores-with-baseline.html",
    "href": "view-scores-with-baseline.html",
    "title": "Scores with Baseline",
    "section": "",
    "text": "The scores_with_baseline() function creates a horizontal bar plot for comparing the scores of different models on a single evaluation, with one or more baselines overlaid as vertical lines.\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_with_baseline, Baseline\n\nevals = Data.from_file(\"agi-lsat-ar.parquet\")\nscores_with_baseline(evals, baseline=0.697)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Baseline"
    ]
  },
  {
    "objectID": "view-scores-with-baseline.html#overview",
    "href": "view-scores-with-baseline.html#overview",
    "title": "Scores with Baseline",
    "section": "",
    "text": "The scores_with_baseline() function creates a horizontal bar plot for comparing the scores of different models on a single evaluation, with one or more baselines overlaid as vertical lines.\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_with_baseline, Baseline\n\nevals = Data.from_file(\"agi-lsat-ar.parquet\")\nscores_with_baseline(evals, baseline=0.697)",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Baseline"
    ]
  },
  {
    "objectID": "view-scores-with-baseline.html#data-preparation",
    "href": "view-scores-with-baseline.html#data-preparation",
    "title": "Scores with Baseline",
    "section": "Data Preparation",
    "text": "Data Preparation\nAbove we read the data for the plot from a parquet file. This file was in turn created by:\n\nReading logs into a data frame with evals_df().\nUsing the prepare() function to add model_info() and log_viewer() columns to the data frame.\n\nfrom inspect_ai.analysis.beta import evals_df, log_viewer, model_into, prepare\n\ndf = evals_df(\"logs\")\ndf = prepare(df, \n    model_info(),\n    log_viewer(\"eval\", {\"logs\": \"https://samples.meridianlabs.ai/\"}),\n)\ndf.to_parquet(\"agi-lsat-ar.parquet\")\nNote that both the log viewer links and model names are optional (the plot will render without links and use raw model strings if the data isn’t prepared with log_viewer() and model_info()).",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Baseline"
    ]
  },
  {
    "objectID": "view-scores-with-baseline.html#function-reference",
    "href": "view-scores-with-baseline.html#function-reference",
    "title": "Scores with Baseline",
    "section": "Function Reference",
    "text": "Function Reference\nBar plot for comparing the scores of different models on a single evaluation.\nSummarize eval scores using a bar plot. By default, scores (y) are plotted by “task_name” (fx) and “model” (x). By default, confidence intervals are also plotted (disable this with y_ci=False).\n\nSource\n\ndef scores_with_baseline(\n    data: Data,\n    *,\n    x: str = \"score_headline_value\",\n    y: str = \"model_display_name\",\n    width: float | None = None,\n    height: float | None = None,\n    baseline: int | float | Baseline | list[Baseline] | None = None,\n    sort: Literal[\"asc\", \"desc\"] | None = None,\n    x_label: str | None | NotGiven = None,\n    y_label: str | None | NotGiven = None,\n    fill: str | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\ndata Data\n\nEvals data table. This is typically created using a data frame read with the inspect evals_df() function.\n\nx str\n\nName of field for x axis (defaults to “score_headline_value”).\n\ny str\n\nName of field for x axis (defaults to “model_display_name”)\n\nwidth float | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio)\n\nbaseline int | float | Baseline | list[Baseline] | None\n\nBaseline value or values to draw on the plot. This can be a single value, a Baseline dictionary, or a list of Baseline dictionaries. If None, no baseline is drawn.\n\nsort Literal['asc', 'desc'] | None\n\nSort order for the bars (sorts using the ‘x’ value). Can be “asc” or “desc”. Defaults to “asc”.\n\nx_label str | None | NotGiven\n\nx-axis label (defaults to None).\n\ny_label str | None | NotGiven\n\nx-axis label (defaults to None).\n\nfill str | None\n\nThe fill color for the bars. Defaults to “#416AD0”. Pass any valid css color value (hex, rgb, named colors, etc.).\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes. By default, the y_inset_top and margin_bottom are set to 10 pixels and x_ticks is set to [].",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Baseline"
    ]
  },
  {
    "objectID": "view-scores-with-baseline.html#implementation",
    "href": "view-scores-with-baseline.html#implementation",
    "title": "Scores with Baseline",
    "section": "Implementation",
    "text": "Implementation\nThe Scores with Baseline example demonstrates how this view was implemented using lower level plotting components.",
    "crumbs": [
      "Getting Started",
      "Views",
      "Scores Baseline"
    ]
  },
  {
    "objectID": "components-links.html",
    "href": "components-links.html",
    "title": "Links",
    "section": "",
    "text": "Inspect Viz supports creating direct links from visualizations to published Inspect log transcripts. Links can be made at the eval level, or to individual samples, messages, or events.\nThe basic steps required for creating links to logs from visualizations are:\n\nPublish your log directory using the inspect view bundle command.\nRead logs into a data frame using the log dataframe functions, then ammend the data frame with log viewer URLs that point to the published bundle (we’ll cover how to do this below).\nInclude the log viewer URLs as a custom channels on your plot marks as appropriate. The link will be available within the tooltip for your mark.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Links"
    ]
  },
  {
    "objectID": "components-links.html#overview",
    "href": "components-links.html#overview",
    "title": "Links",
    "section": "",
    "text": "Inspect Viz supports creating direct links from visualizations to published Inspect log transcripts. Links can be made at the eval level, or to individual samples, messages, or events.\nThe basic steps required for creating links to logs from visualizations are:\n\nPublish your log directory using the inspect view bundle command.\nRead logs into a data frame using the log dataframe functions, then ammend the data frame with log viewer URLs that point to the published bundle (we’ll cover how to do this below).\nInclude the log viewer URLs as a custom channels on your plot marks as appropriate. The link will be available within the tooltip for your mark.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Links"
    ]
  },
  {
    "objectID": "components-links.html#step-1-publish-logs",
    "href": "components-links.html#step-1-publish-logs",
    "title": "Links",
    "section": "Step 1: Publish Logs",
    "text": "Step 1: Publish Logs\nYou can use the command inspect view bundle (or the bundle_log_dir() function from Python) to create a self contained directory with the log viewer and a set of logs for display. This directory can then be deployed to any static web server (GitHub Pages, S3 buckets, Netlify, etc.) to provide a standalone version of the viewer.\nFor example, to bundle the logs directory to a directory named logs-www:\n$ inspect view bundle --log-dir logs --output-dir logs-www\nYou can then deploy logs-www to any static web host.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Links"
    ]
  },
  {
    "objectID": "components-links.html#step-2-prepare-data",
    "href": "components-links.html#step-2-prepare-data",
    "title": "Links",
    "section": "Step 2: Prepare Data",
    "text": "Step 2: Prepare Data\nNext, you’ll want to ammend the data frame that you’ve read with e.g. evals_df() or samples_df() with log viewer URLs that point to the published logs.\nYou can do this using the prepare() and log_viewer() functions from the inspect_ai.analysis module. For example, if you have previously published your “logs” directory to https://example.com/logs/:\nfrom inspect_viz import Data\nfrom inspect_ai.analysis.beta import evals_df, prepare, log_viewer\n\n# read evals and ammend with log viewer URL\ndf = evals_df(\"logs\")\ndf = prepare(df, log_viewer(\"evals\", {\n    \"logs\": \"https://example.com/logs/\"\n}))\n\n# read as inspect viz data\nevals = Data.from_dataframe(df)",
    "crumbs": [
      "Getting Started",
      "Components",
      "Links"
    ]
  },
  {
    "objectID": "components-links.html#step-3-link-channel",
    "href": "components-links.html#step-3-link-channel",
    "title": "Links",
    "section": "Step 3: Link Channel",
    "text": "Step 3: Link Channel\nOnce your data is prepared, you need to ensure that links are incorporated onto plots.\n\nCustom Plot\nIf you are creating a custom plot, you should add a mapping to the “log_viewer” column to your mark’s channels. For example:\n\nfrom inspect_viz import Data\nfrom inspect_viz.plot import plot, legend\nfrom inspect_viz.mark import bar_y\n\nevals = Data.from_file(\"evals.parquet\")\n\nplot(\n    bar_y( \n        evals, x=\"model\", fx=\"task_name\",\n        y=\"score_headline_value\",\n1        channels={ \"Log Viewer\": \"log_viewer\" },\n        fill=\"model\",\n    ),\n    legend=legend(\"color\", location=\"bottom\"),\n    x_label=None, x_ticks=[], fx_label=None,\n    y_label=\"score\", y_domain=[0, 1.0]\n)\n\n\n1\n\nAdd Log Viewer channel mapped to the log_viewer column created with the prepare() function above.\n\n\n\n\n\n\nBuilt-In Views\nThe built-in Views already support the log_viewer column, so links appear automatically when using those functions. For example:\n\nfrom inspect_viz import Data\nfrom inspect_viz.view.beta import scores_with_baseline\n\nevals = Data.from_file(\"agi-lsat-ar.parquet\")\nscores_with_baseline(evals)\n\n\n\n\nIf you mouse over the bars you will see a log viewer link which you can click to navigate to the log.",
    "crumbs": [
      "Getting Started",
      "Components",
      "Links"
    ]
  },
  {
    "objectID": "reference/inspect_viz.plot.html",
    "href": "reference/inspect_viz.plot.html",
    "title": "inspect_viz.plot",
    "section": "",
    "text": "Create a plot.\n\nSource\n\ndef plot(\n    *plot: Mark | Interactor | Legend | Sequence[Mark | Interactor | Legend],\n    x_label: str | Param | None | NotGiven = NOT_GIVEN,\n    fx_label: str | Param | None | NotGiven = NOT_GIVEN,\n    y_label: str | Param | None | NotGiven = NOT_GIVEN,\n    fy_label: str | Param | None | NotGiven = NOT_GIVEN,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    name: str | None = None,\n    legend: Literal[\"color\", \"opacity\", \"symbol\"] | Legend | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\n*plot Mark | Interactor | Legend | Sequence[Mark | Interactor | Legend]\n\nPlot elements (marks, interactors, legends)\n\nx_label str | Param | None | NotGiven\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value. Pass None for no x_label.\n\nfx_label str | Param | None | NotGiven\n\nA textual label to show on the axis or legend; if None, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\n\ny_label str | Param | None | NotGiven\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value. Pass None for no y_label.\n\nfy_label str | Param | None | NotGiven\n\nA textual label to show on the axis or legend; if None, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\n\nwidth float | Param | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | Param | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio)\n\nname str | None\n\nA unique name for the plot. The name is used by standalone legend components to to lookup the plot and access scale mappings.\n\nlegend Literal['color', 'opacity', 'symbol'] | Legend | None\n\nPlot legend.\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes.\n\n\n\n\n\nPlot attributes.\n\nSource\n\nclass PlotAttributes(TypedDict, total=False)\n\n\n\naspect_ratio float | bool | None | Param | None\n\nThe desired aspect ratio of the x and y scales, affecting the default height. Given an aspect ratio of dx / dy, and assuming that the x and y scales represent equivalent units (say, degrees Celsius or meters), computes a default height such that dx pixels along x represents the same variation as dy pixels along y. Note: when faceting, set the fx and fy scales’ round option to false for an exact aspect ratio.\n\nmargin float | Param | None\n\nShorthand to set the same default for all four margins: margin_top, margin_right, margin_bottom, and margin_left. Otherwise, the default margins depend on the maximum margins of the plot’s marks. While most marks default to zero margins (because they are drawn inside the chart area), Plot’s axis marks have non-zero default margins.\n\nmargin_top float | Param | None\n\nThe top margin; the distance in pixels between the top edges of the inner and outer plot area. Defaults to the maximum top margin of the plot’s marks.\n\nmargin_right float | Param | None\n\nThe right margin; the distance in pixels between the right edges of the inner and outer plot area. Defaults to the maximum right margin of the plot’s marks.\n\nmargin_bottom float | Param | None\n\nThe bottom margin; the distance in pixels between the bottom edges of the inner and outer plot area. Defaults to the maximum bottom margin of the plot’s marks.\n\nmargin_left float | Param | None\n\nThe left margin; the distance in pixels between the left edges of the inner and outer plot area. Defaults to the maximum left margin of the plot’s marks.\n\nmargins dict[str, float | Param] | None\n\nA shorthand object notation for setting multiple margin values. The object keys are margin names (top, right, etc).\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\nalign float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\npadding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\naxis Literal['top', 'right', 'bottom', 'left', 'both'] | bool | None | Param\n\nThe side of the frame on which to place the implicit axis: top or bottom for x or fx, or left or right for y or fy. The default depends on the scale:\n\nx - bottom\ny - left\nfx - top if there is a bottom x axis, and otherwise bottom\nfy - right if there is a left y axis, and otherwise right\n\nIf both, an implicit axis will be rendered on both sides of the plot (top and bottom for x or fx, or left and right for y or fy). If null, the implicit axis is suppressed.\nFor position axes only.\n\ngrid bool | str | Param\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color.\n\naria_label str | None\n\nThe aria-label attribute on the SVG root.\n\naria_description str | None\n\nThe aria-description attribute on the SVG root.\n\nclip Literal['frame', 'sphere'] | bool | None | Param\n\nThe default clip for all marks.\n\nx_scale PositionScale | None | Param | None\n\nThe x scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled.\nFor quantitative data (numbers), defaults to linear; for temporal data (dates), defaults to utc; for ordinal data (strings or booleans), defaults to point for position scales, categorical for color scales, and otherwise ordinal. However, the radius scale defaults to sqrt, and the length and opacity scales default to linear; these scales are intended for quantitative data. The plot’s marks may also impose a scale type; for example, the barY mark requires that x is a band scale.\n\nx_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nLinear scales have a default domain of [0, 1]. Log scales have a default domain of [1, 10] and cannot include zero. Radius scales have a default domain from 0 to the median first quartile of associated channels. Length have a default domain from 0 to the median median of associated channels. Opacity scales have a default domain from 0 to the maximum value of associated channels.\n\nx_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale.\n\nx_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\nx_inset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\nx_inset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\nx_inset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nx_clamp bool | Param | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\nx_round bool | Param | None\n\nIf true, round the output value to the nearest integer (pixel); useful for crisp edges when rendering.\nFor position scales only.\n\nx_align float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\nx_padding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\nx_padding_inner float | Param | None\n\nFor a band scale, how much of the range to reserve to separate adjacent bands.\n\nx_padding_outer float | Param | None\n\nFor a band scale, how much of the range to reserve to inset first and last bands.\n\nx_axis Literal['top', 'bottom', 'both'] | bool | None | Param | None\n\nThe side of the frame on which to place the implicit axis: top or bottom for x. Defaults to bottom for an x scale.\nIf both, an implicit axis will be rendered on both sides of the plot (top and bottom for x). If null, the implicit axis is suppressed.\n\nx_ticks float | Interval | Sequence[str | float | bool] | Param | None\n\nThe desired approximate number of axis ticks, or an explicit array of tick values, or an interval such as day or month.\n\nx_tick_size float | Param | None\n\nThe length of axis tick marks in pixels; negative values extend in the opposite direction. Defaults to 6 for x and y axes and color and opacity ramp legends, and 0 for fx and fy axes.\n\nx_tick_spacing float | Param | None\n\nThe desired approximate spacing between adjacent axis ticks, affecting the default ticks; defaults to 80 pixels for x and fx, and 35 pixels for y and fy.\n\nx_tick_padding float | Param | None\n\nThe distance between an axis tick mark and its associated text label (in pixels); often defaults to 3, but may be affected by x_tick_size and x_tick_rotate.\n\nx_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\nx_tick_rotate float | Param | None\n\nThe rotation angle of axis tick labels in degrees clocksize; defaults to 0.\n\nx_grid bool | str | Interval | list[str | float] | Param\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines.\n\nx_line bool | Param | None\n\nIf true, draw a line along the axis; if false (default), do not.\n\nx_label_anchor Literal['right', 'left', 'center'] | Param | None\n\nWhere to place the axis label relative to the plot’s frame. For vertical position scales (y and fy), may be top, bottom, or center; for horizontal position scales (x and fx), may be left, right, or center. Defaults to center for ordinal scales (including fx and fy), and otherwise top for y, and right for x.\n\nx_label_arrow LabelArrow | Param | None\n\nWhether to apply a directional arrow such as → or ↑ to the x-axis scale label. If auto (the default), the presence of the arrow depends on whether the scale is ordinal.\n\nx_label_offset float | Param | None\n\nThe axis label position offset (in pixels); default depends on margins and orientation.\n\nx_font_variant str | Param | None\n\nThe font-variant attribute for axis ticks; defaults to tabular-nums for quantitative axes.\n\nx_aria_label str | Param | None\n\nA short label representing the axis in the accessibility tree.\n\nx_aria_description str | Param | None\n\nA textual description for the axis in the accessibility tree.\n\nx_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\nx_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\nx_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\nx_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\nx_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\nx_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\ny_scale PositionScale | None | Param | None\n\nThe y scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled.\nFor quantitative data (numbers), defaults to linear; for temporal data (dates), defaults to utc; for ordinal data (strings or booleans), defaults to point for position scales, The plot’s marks may also impose a scale type; for example, the barY mark requires that x is a band scale.\n\ny_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nLinear scales have a default domain of [0, 1]. Log scales have a default domain of [1, 10] and cannot include zero.\n\ny_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale.\n\ny_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\ny_inset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\ny_inset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\ny_inset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\ny_clamp bool | Param | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\ny_round bool | Param | None\n\nIf true, round the output value to the nearest integer (pixel); useful for crisp edges when rendering.\nFor position scales only.\n\ny_align float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\ny_padding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\ny_padding_inner float | Param | None\n\nFor a band scale, how much of the range to reserve to separate adjacent bands.\n\ny_padding_outer float | Param | None\n\nFor a band scale, how much of the range to reserve to inset first and last bands.\n\ny_axis Literal['left', 'right', 'both'] | bool | None | Param | None\n\nThe side of the frame on which to place the implicit axis: left or right for y. Defaults to left for a y scale.\nIf both, an implicit axis will be rendered on both sides of the plot (left and right for y). If null, the implicit axis is suppressed.\n\ny_ticks float | Interval | Sequence[str | float | bool] | Param | None\n\nThe desired approximate number of axis ticks, or an explicit array of tick values, or an interval such as day or month.\n\ny_tick_size float | Param | None\n\nThe length of axis tick marks in pixels; negative values extend in the opposite direction. Defaults to 6 for x and y axes and color and opacity ramp legends, and 0 for fx and fy axes.\n\ny_tick_spacing float | Param | None\n\nThe desired approximate spacing between adjacent axis ticks, affecting the default ticks; defaults to 80 pixels for x and fx, and 35 pixels for y and fy.\n\ny_tick_padding float | Param | None\n\nThe distance between an axis tick mark and its associated text label (in pixels); often defaults to 3, but may be affected by y_tick_size and y_tick_rotate.\n\ny_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\ny_tick_rotate float | Param | None\n\nThe rotation angle of axis tick labels in degrees clocksize; defaults to 0.\n\ny_grid bool | str | Interval | list[str | float] | Param\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines.\n\ny_line bool | Param | None\n\nIf true, draw a line along the axis; if false (default), do not.\n\ny_label_anchor Literal['top', 'bottom', 'center'] | Param | None\n\nWhere to place the axis label relative to the plot’s frame. For vertical position scales (y and fy), may be top, bottom, or center; for horizontal position scales (x and fx), may be left, right, or center. Defaults to center for ordinal scales (including fx and fy), and otherwise top for y, and right for x.\n\ny_label_arrow LabelArrow | Param | None\n\nWhether to apply a directional arrow such as → or ↑ to the x-axis scale label. If auto (the default), the presence of the arrow depends on whether the scale is ordinal.\n\ny_label_offset float | Param | None\n\nThe axis label position offset (in pixels); default depends on margins and orientation.\n\ny_font_variant str | Param | None\n\nThe font-variant attribute for axis ticks; defaults to tabular-nums for quantitative axes.\n\ny_aria_label str | Param | None\n\nA short label representing the axis in the accessibility tree.\n\ny_aria_description str | Param | None\n\nA textual description for the axis in the accessibility tree.\n\ny_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\ny_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range. Note that by default, when the y scale is continuous, the max value points to the top of the screen, whereas ordinal values are ranked from top to bottom.\n\ny_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\ny_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\ny_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\ny_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\nxy_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nSet the x and y scale domains.\n\nfacet_margin float | Param | None\n\nShorthand to set the same default for all four facet margins: margin_top, margin_right, margin_bottom, and margin_left.\n\nfacet_margin_top float | Param | None\n\nThe top facet margin; the (minimum) distance in pixels between the top edges of the inner and outer plot area.\n\nfacet_margin_bottom float | Param | None\n\nThe right facet margin; the (minimum) distance in pixels between the right edges of the inner and outer plot area.\n\nfacet_margin_left float | Param | None\n\nThe bottom facet margin; the (minimum) distance in pixels between the bottom edges of the inner and outer plot area.\n\nfacet_margin_right float | Param | None\n\nThe left facet margin; the (minimum) distance in pixels between the left edges of the inner and outer plot area.\n\nfacet_grid bool | str | Interval | Sequence[str | float | bool] | Param | None\n\nDefault axis grid for fx and fy scales; typically set to true to enable.\n\nfacet_label str | None | Param | None\n\nDefault axis label for fx and fy scales; typically set to null to disable.\n\nfx_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\n\nfx_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and the plot’s dimensions. For ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale.\n\nfx_inset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\nfx_inset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\nfx_inset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nfx_round bool | Param | None\n\nIf true, round the output value to the nearest integer (pixel); useful for crisp edges when rendering.\nFor position scales only.\n\nfx_align float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\nfx_padding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\nfx_padding_inner float | Param | None\n\nFor a band scale, how much of the range to reserve to separate adjacent bands.\n\nfx_padding_outer float | Param | None\n\nFor a band scale, how much of the range to reserve to inset first and last bands.\n\nfx_axis Literal['top', 'bottom', 'both'] | bool | None | Param | None\n\nThe side of the frame on which to place the implicit axis: top or bottom for fx. Defaults to top if there is a bottom x axis, and otherwise bottom.\nIf both, an implicit axis will be rendered on both sides of the plot (top and bottom for fx). If null, the implicit axis is suppressed.\n\nfx_ticks float | Interval | Sequence[str | float | bool] | Param | None\n\nThe desired approximate number of axis ticks, or an explicit array of tick values, or an interval such as day or month.\n\nfx_tick_size float | Param | None\n\nThe length of axis tick marks in pixels; negative values extend in the opposite direction. Defaults to 6 for x and y axes and color and opacity ramp legends, and 0 for fx and fy axes.\n\nfx_tick_spacing float | Param | None\n\nThe desired approximate spacing between adjacent axis ticks, affecting the default ticks; defaults to 80 pixels for x and fx, and 35 pixels for y and fy.\n\nfx_tick_padding float | Param | None\n\nThe distance between an axis tick mark and its associated text label (in pixels); often defaults to 3, but may be affected by fx_tick_size and fx_tick_rotate.\n\nfx_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\nfx_tick_rotate float | Param | None\n\nThe rotation angle of axis tick labels in degrees clocksize; defaults to 0.\n\nfx_grid bool | str | Interval | Sequence[str | float | bool] | Param | None\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines. See also the grid mark.\nFor axes only.\n\nfx_line bool | Param | None\n\nIf true, draw a line along the axis; if false (default), do not.\n\nfx_label_anchor Literal['right', 'left', 'center'] | Param | None\n\nWhere to place the axis label relative to the plot’s frame. For vertical position scales (y and fy), may be top, bottom, or center; for horizontal position scales (x and fx), may be left, right, or center. Defaults to center for ordinal scales (including fx and fy), and otherwise top for y, and right for x.\n\nfx_label_offset float | Param | None\n\nThe axis label position offset (in pixels); default depends on margins and orientation.\n\nfx_font_variant str | Param | None\n\nThe font-variant attribute for axis ticks; defaults to tabular-nums for quantitative axes.\n\nfx_aria_label str | Param | None\n\nA short label representing the axis in the accessibility tree.\n\nfx_aria_description str | Param | None\n\nA textual description for the axis in the accessibility tree.\n\nfx_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\nfy_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\n\nfy_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and the plot’s dimensions. For ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale.\n\nfy_inset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\nfy_inset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\nfy_inset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\nfy_round bool | Param | None\n\nIf true, round the output value to the nearest integer (pixel); useful for crisp edges when rendering.\nFor position scales only.\n\nfy_align float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\nfy_padding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\nfy_padding_inner float | Param | None\n\nFor a band scale, how much of the range to reserve to separate adjacent bands.\n\nfy_padding_outer float | Param | None\n\nFor a band scale, how much of the range to reserve to inset first and last bands.\n\nfy_axis Literal['left', 'right', 'both'] | bool | None | Param | None\n\nThe side of the frame on which to place the implicit axis: left or right for fy. Defaults to left for an fy scale.\nIf both, an implicit axis will be rendered on both sides of the plot (left and right for fy). If null, the implicit axis is suppressed.\n\nfy_ticks float | Interval | Sequence[str | float | bool] | Param | None\n\nThe desired approximate number of axis ticks, or an explicit array of tick values, or an interval such as day or month.\n\nfy_tick_size float | Param | None\n\nThe length of axis tick marks in pixels; negative values extend in the opposite direction. Defaults to 6 for x and y axes and color and opacity ramp legends, and 0 for fx and fy axes.\n\nfy_tick_spacing float | Param | None\n\nThe desired approximate spacing between adjacent axis ticks, affecting the default ticks; defaults to 80 pixels for x and fx, and 35 pixels for y and fy.\n\nfy_tick_padding float | Param | None\n\nThe distance between an axis tick mark and its associated text label (in pixels); often defaults to 3, but may be affected by fy_tick_size and fy_tick_rotate.\n\nfy_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\nfy_tick_rotate float | Param | None\n\nThe rotation angle of axis tick labels in degrees clocksize; defaults to 0.\n\nfy_grid bool | str | Interval | Sequence[str | float | bool] | Param | None\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines. See also the grid mark.\nFor axes only.\n\nfy_line bool | Param | None\n\nIf true, draw a line along the axis; if false (default), do not.\n\nfy_label_anchor Literal['top', 'bottom', 'center'] | Param | None\n\nWhere to place the axis label relative to the plot’s frame. For vertical position scales (y and fy), may be top, bottom, or center; for horizontal position scales (x and fx), may be left, right, or center. Defaults to center for ordinal scales (including fx and fy), and otherwise top for y, and right for x.\n\nfy_label_offset float | Param | None\n\nThe axis label position offset (in pixels); default depends on margins and orientation.\n\nfy_font_variant str | Param | None\n\nThe font-variant attribute for axis ticks; defaults to tabular-nums for quantitative axes.\n\nfy_aria_label str | Param | None\n\nA short label representing the axis in the accessibility tree.\n\nfy_aria_description str | Param | None\n\nA textual description for the axis in the accessibility tree.\n\nfy_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\ncolor_scale ColorScale | None | Param | None\n\nThe color scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled.\nFor quantitative data (numbers), defaults to linear; for temporal data (dates), defaults to utc; for ordinal data (strings or booleans), defaults to point for position scales, categorical for color scales, and otherwise ordinal.\n\ncolor_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\n\ncolor_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain. For other ordinal data, it is an array (or iterable) of output values in the same order as the domain.\n\ncolor_clamp bool | Param | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\ncolor_n float | Param | None\n\nFor a quantile scale, the number of quantiles (creates n - 1 thresholds); for a quantize scale, the approximate number of thresholds; defaults to 5.\n\ncolor_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\ncolor_scheme ColorScheme | Param | None\n\nIf specified, shorthand for setting the color_range or color_interpolate option of a color scale.\n\ncolor_interpolate Interpolate | Param | None\n\nHow to interpolate color range values. For quantitative scales only. This attribute can be used to specify a color space for interpolating colors specified in the color_range.\n\ncolor_pivot Any | Param | None\n\nFor a diverging color scale, the input value (abstract value) that divides the domain into two parts; defaults to 0 for diverging scales, dividing the domain into negative and positive parts; defaults to 1 for diverging-log scales. By default, diverging scales are symmetric around the pivot; see the symmetric option.\n\ncolor_symmetric bool | Param | None\n\nFor a diverging color scale, if true (the default), extend the domain to ensure that the lower part of the domain (below the pivot) is commensurate with the upper part of the domain (above the pivot).\nA symmetric diverging color scale may not use all of its output range; this reduces contrast but ensures that deviations both below and above the pivot are represented proportionally. Otherwise if false, the full output range will be used; this increases contrast but values on opposite sides of the pivot may not be meaningfully compared.\n\ncolor_label str | None | Param | None\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\nFor axes and legends only.\n\ncolor_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\ncolor_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\ncolor_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\ncolor_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\ncolor_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow and diverging-pow scales only.\n\ncolor_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log and diverging-log scales only.\n\ncolor_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog and diverging-symlog scales only.\n\nopacity_scale ContinuousScale | None | Param | None\n\nThe opacity scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled. The opacity scale defaults to linear; this scales is intended for quantitative data.\n\nopacity_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nOpacity scales have a default domain from 0 to the maximum value of associated channels.\n\nopacity_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values).\nOpacity scales have a default range of [0, 1].\n\nopacity_clamp bool | Param | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\nopacity_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\nopacity_label str | None | Param | None\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\nFor axes and legends only.\n\nopacity_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\nopacity_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\nopacity_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\nopacity_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\nopacity_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\nopacity_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\nopacity_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\nsymbol_scale Literal['ordinal', 'categorical', 'threshold', 'quantile', 'quantize'] | None | Param\n\nThe symbol scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled. Defaults to an ordinal scale type.\n\nsymbol_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. As symbol scales are discrete, the domain is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\n\nsymbol_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale. For other ordinal data, such as for a color scale, it is an array (or iterable) of output values in the same order as the domain.\nSymbol scales have a default range of categorical symbols; the choice of symbols depends on whether the associated dot mark is filled or stroked.\n\nr_scale ContinuousScale | None | Param | None\n\nThe r (radius) scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled. The radius scale defaults to sqrt; this scale is intended for quantitative data.\n\nr_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nRadius scales have a default domain from 0 to the median first quartile of associated channels.\n\nr_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale. For other ordinal data, such as for a color scale, it is an array (or iterable) of output values in the same order as the domain.\nRadius scales have a default range of [0, 3].\n\nr_clamp Any | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\nr_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\nr_label str | None | Param | None\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\n\nr_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\nr_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\nr_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\nr_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\nr_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\nlength_scale ContinuousScale | None | Param | None\n\nThe length scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled. The length scale defaults to linear, as this scale is intended for quantitative data.\n\nlength_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nLinear scales have a default domain of [0, 1]. Log scales have a default domain of [1, 10] and cannot include zero. Radius scales have a default domain from 0 to the median first quartile of associated channels. Length have a default domain from 0 to the median median of associated channels. Opacity scales have a default domain from 0 to the maximum value of associated channels.\n\nlength_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale. For other ordinal data, such as for a color scale, it is an array (or iterable) of output values in the same order as the domain.\nLength scales have a default range of [0, 12].\n\nlength_clamp Any | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\nlength_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\nlength_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\nlength_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\nlength_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\nlength_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\nlength_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\nprojection_type Projection | None | Param | None\n\nThe desired projection; one of:\n\na named built-in projection such as albers-usa\nnull, for no projection\n\nNamed projections are scaled and translated to fit the domain to the plot’s frame (minus insets).\n\nprojection_domain object | Param | None\n\nA GeoJSON object to fit to the plot’s frame (minus insets); defaults to a Sphere for spherical projections (outline of the the whole globe).\n\nprojection_rotate Sequence[float | Param] | Param | None\n\nA rotation of the sphere before projection; defaults to [0, 0, 0]. Specified as Euler angles λ (yaw, or reference longitude), φ (pitch, or reference latitude), and optionally γ (roll), in degrees.\n\nprojection_parallels Sequence[float | Param] | Param | None\n\nThe standard parallels. For conic projections only.\n\nprojection_precision float | Param | None\n\nThe projection’s sampling threshold.\n\nprojection_clip bool | float | Literal['frame'] | None | Param | None\n\nThe projection’s clipping method; one of:\n\nframe or true (default) - clip to the plot’s frame (including margins but not insets)\na number - clip to a circle of the given radius in degrees centered around the origin\nnull or false - do not clip\n\nSome projections (such as armadillo and berghaus) require spherical clipping: in that case set the marks’ clip option to sphere.\n\nprojection_inset float | Param | None\n\nShorthand to set the same default for all four projection insets. All insets typically default to zero, though not always. A positive inset reduces effective area, while a negative inset increases it.\n\nprojection_inset_top float | Param | None\n\nInsets the top edge of the projection by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\nprojection_inset_right float | Param | None\n\nInsets the right edge of the projection by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\nprojection_inset_bottom float | Param | None\n\nInsets the bottom edge of the projection by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\nprojection_inset_left float | Param | None\n\nInsets the left edge of the projection by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.plot"
    ]
  },
  {
    "objectID": "reference/inspect_viz.plot.html#plot",
    "href": "reference/inspect_viz.plot.html#plot",
    "title": "inspect_viz.plot",
    "section": "",
    "text": "Create a plot.\n\nSource\n\ndef plot(\n    *plot: Mark | Interactor | Legend | Sequence[Mark | Interactor | Legend],\n    x_label: str | Param | None | NotGiven = NOT_GIVEN,\n    fx_label: str | Param | None | NotGiven = NOT_GIVEN,\n    y_label: str | Param | None | NotGiven = NOT_GIVEN,\n    fy_label: str | Param | None | NotGiven = NOT_GIVEN,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    name: str | None = None,\n    legend: Literal[\"color\", \"opacity\", \"symbol\"] | Legend | None = None,\n    **attributes: Unpack[PlotAttributes],\n) -&gt; Component\n\n*plot Mark | Interactor | Legend | Sequence[Mark | Interactor | Legend]\n\nPlot elements (marks, interactors, legends)\n\nx_label str | Param | None | NotGiven\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value. Pass None for no x_label.\n\nfx_label str | Param | None | NotGiven\n\nA textual label to show on the axis or legend; if None, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\n\ny_label str | Param | None | NotGiven\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value. Pass None for no y_label.\n\nfy_label str | Param | None | NotGiven\n\nA textual label to show on the axis or legend; if None, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\n\nwidth float | Param | None\n\nThe outer width of the plot in pixels, including margins. Defaults to 700.\n\nheight float | Param | None\n\nThe outer height of the plot in pixels, including margins. The default is width / 1.618 (the golden ratio)\n\nname str | None\n\nA unique name for the plot. The name is used by standalone legend components to to lookup the plot and access scale mappings.\n\nlegend Literal['color', 'opacity', 'symbol'] | Legend | None\n\nPlot legend.\n\n**attributes Unpack[PlotAttributes]\n\nAdditional PlotAttributes.\n\n\n\n\n\nPlot attributes.\n\nSource\n\nclass PlotAttributes(TypedDict, total=False)\n\n\n\naspect_ratio float | bool | None | Param | None\n\nThe desired aspect ratio of the x and y scales, affecting the default height. Given an aspect ratio of dx / dy, and assuming that the x and y scales represent equivalent units (say, degrees Celsius or meters), computes a default height such that dx pixels along x represents the same variation as dy pixels along y. Note: when faceting, set the fx and fy scales’ round option to false for an exact aspect ratio.\n\nmargin float | Param | None\n\nShorthand to set the same default for all four margins: margin_top, margin_right, margin_bottom, and margin_left. Otherwise, the default margins depend on the maximum margins of the plot’s marks. While most marks default to zero margins (because they are drawn inside the chart area), Plot’s axis marks have non-zero default margins.\n\nmargin_top float | Param | None\n\nThe top margin; the distance in pixels between the top edges of the inner and outer plot area. Defaults to the maximum top margin of the plot’s marks.\n\nmargin_right float | Param | None\n\nThe right margin; the distance in pixels between the right edges of the inner and outer plot area. Defaults to the maximum right margin of the plot’s marks.\n\nmargin_bottom float | Param | None\n\nThe bottom margin; the distance in pixels between the bottom edges of the inner and outer plot area. Defaults to the maximum bottom margin of the plot’s marks.\n\nmargin_left float | Param | None\n\nThe left margin; the distance in pixels between the left edges of the inner and outer plot area. Defaults to the maximum left margin of the plot’s marks.\n\nmargins dict[str, float | Param] | None\n\nA shorthand object notation for setting multiple margin values. The object keys are margin names (top, right, etc).\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\nalign float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\npadding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\naxis Literal['top', 'right', 'bottom', 'left', 'both'] | bool | None | Param\n\nThe side of the frame on which to place the implicit axis: top or bottom for x or fx, or left or right for y or fy. The default depends on the scale:\n\nx - bottom\ny - left\nfx - top if there is a bottom x axis, and otherwise bottom\nfy - right if there is a left y axis, and otherwise right\n\nIf both, an implicit axis will be rendered on both sides of the plot (top and bottom for x or fx, or left and right for y or fy). If null, the implicit axis is suppressed.\nFor position axes only.\n\ngrid bool | str | Param\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color.\n\naria_label str | None\n\nThe aria-label attribute on the SVG root.\n\naria_description str | None\n\nThe aria-description attribute on the SVG root.\n\nclip Literal['frame', 'sphere'] | bool | None | Param\n\nThe default clip for all marks.\n\nx_scale PositionScale | None | Param | None\n\nThe x scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled.\nFor quantitative data (numbers), defaults to linear; for temporal data (dates), defaults to utc; for ordinal data (strings or booleans), defaults to point for position scales, categorical for color scales, and otherwise ordinal. However, the radius scale defaults to sqrt, and the length and opacity scales default to linear; these scales are intended for quantitative data. The plot’s marks may also impose a scale type; for example, the barY mark requires that x is a band scale.\n\nx_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nLinear scales have a default domain of [0, 1]. Log scales have a default domain of [1, 10] and cannot include zero. Radius scales have a default domain from 0 to the median first quartile of associated channels. Length have a default domain from 0 to the median median of associated channels. Opacity scales have a default domain from 0 to the maximum value of associated channels.\n\nx_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale.\n\nx_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\nx_inset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\nx_inset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\nx_inset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nx_clamp bool | Param | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\nx_round bool | Param | None\n\nIf true, round the output value to the nearest integer (pixel); useful for crisp edges when rendering.\nFor position scales only.\n\nx_align float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\nx_padding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\nx_padding_inner float | Param | None\n\nFor a band scale, how much of the range to reserve to separate adjacent bands.\n\nx_padding_outer float | Param | None\n\nFor a band scale, how much of the range to reserve to inset first and last bands.\n\nx_axis Literal['top', 'bottom', 'both'] | bool | None | Param | None\n\nThe side of the frame on which to place the implicit axis: top or bottom for x. Defaults to bottom for an x scale.\nIf both, an implicit axis will be rendered on both sides of the plot (top and bottom for x). If null, the implicit axis is suppressed.\n\nx_ticks float | Interval | Sequence[str | float | bool] | Param | None\n\nThe desired approximate number of axis ticks, or an explicit array of tick values, or an interval such as day or month.\n\nx_tick_size float | Param | None\n\nThe length of axis tick marks in pixels; negative values extend in the opposite direction. Defaults to 6 for x and y axes and color and opacity ramp legends, and 0 for fx and fy axes.\n\nx_tick_spacing float | Param | None\n\nThe desired approximate spacing between adjacent axis ticks, affecting the default ticks; defaults to 80 pixels for x and fx, and 35 pixels for y and fy.\n\nx_tick_padding float | Param | None\n\nThe distance between an axis tick mark and its associated text label (in pixels); often defaults to 3, but may be affected by x_tick_size and x_tick_rotate.\n\nx_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\nx_tick_rotate float | Param | None\n\nThe rotation angle of axis tick labels in degrees clocksize; defaults to 0.\n\nx_grid bool | str | Interval | list[str | float] | Param\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines.\n\nx_line bool | Param | None\n\nIf true, draw a line along the axis; if false (default), do not.\n\nx_label_anchor Literal['right', 'left', 'center'] | Param | None\n\nWhere to place the axis label relative to the plot’s frame. For vertical position scales (y and fy), may be top, bottom, or center; for horizontal position scales (x and fx), may be left, right, or center. Defaults to center for ordinal scales (including fx and fy), and otherwise top for y, and right for x.\n\nx_label_arrow LabelArrow | Param | None\n\nWhether to apply a directional arrow such as → or ↑ to the x-axis scale label. If auto (the default), the presence of the arrow depends on whether the scale is ordinal.\n\nx_label_offset float | Param | None\n\nThe axis label position offset (in pixels); default depends on margins and orientation.\n\nx_font_variant str | Param | None\n\nThe font-variant attribute for axis ticks; defaults to tabular-nums for quantitative axes.\n\nx_aria_label str | Param | None\n\nA short label representing the axis in the accessibility tree.\n\nx_aria_description str | Param | None\n\nA textual description for the axis in the accessibility tree.\n\nx_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\nx_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\nx_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\nx_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\nx_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\nx_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\ny_scale PositionScale | None | Param | None\n\nThe y scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled.\nFor quantitative data (numbers), defaults to linear; for temporal data (dates), defaults to utc; for ordinal data (strings or booleans), defaults to point for position scales, The plot’s marks may also impose a scale type; for example, the barY mark requires that x is a band scale.\n\ny_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nLinear scales have a default domain of [0, 1]. Log scales have a default domain of [1, 10] and cannot include zero.\n\ny_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale.\n\ny_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\ny_inset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\ny_inset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\ny_inset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\ny_clamp bool | Param | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\ny_round bool | Param | None\n\nIf true, round the output value to the nearest integer (pixel); useful for crisp edges when rendering.\nFor position scales only.\n\ny_align float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\ny_padding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\ny_padding_inner float | Param | None\n\nFor a band scale, how much of the range to reserve to separate adjacent bands.\n\ny_padding_outer float | Param | None\n\nFor a band scale, how much of the range to reserve to inset first and last bands.\n\ny_axis Literal['left', 'right', 'both'] | bool | None | Param | None\n\nThe side of the frame on which to place the implicit axis: left or right for y. Defaults to left for a y scale.\nIf both, an implicit axis will be rendered on both sides of the plot (left and right for y). If null, the implicit axis is suppressed.\n\ny_ticks float | Interval | Sequence[str | float | bool] | Param | None\n\nThe desired approximate number of axis ticks, or an explicit array of tick values, or an interval such as day or month.\n\ny_tick_size float | Param | None\n\nThe length of axis tick marks in pixels; negative values extend in the opposite direction. Defaults to 6 for x and y axes and color and opacity ramp legends, and 0 for fx and fy axes.\n\ny_tick_spacing float | Param | None\n\nThe desired approximate spacing between adjacent axis ticks, affecting the default ticks; defaults to 80 pixels for x and fx, and 35 pixels for y and fy.\n\ny_tick_padding float | Param | None\n\nThe distance between an axis tick mark and its associated text label (in pixels); often defaults to 3, but may be affected by y_tick_size and y_tick_rotate.\n\ny_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\ny_tick_rotate float | Param | None\n\nThe rotation angle of axis tick labels in degrees clocksize; defaults to 0.\n\ny_grid bool | str | Interval | list[str | float] | Param\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines.\n\ny_line bool | Param | None\n\nIf true, draw a line along the axis; if false (default), do not.\n\ny_label_anchor Literal['top', 'bottom', 'center'] | Param | None\n\nWhere to place the axis label relative to the plot’s frame. For vertical position scales (y and fy), may be top, bottom, or center; for horizontal position scales (x and fx), may be left, right, or center. Defaults to center for ordinal scales (including fx and fy), and otherwise top for y, and right for x.\n\ny_label_arrow LabelArrow | Param | None\n\nWhether to apply a directional arrow such as → or ↑ to the x-axis scale label. If auto (the default), the presence of the arrow depends on whether the scale is ordinal.\n\ny_label_offset float | Param | None\n\nThe axis label position offset (in pixels); default depends on margins and orientation.\n\ny_font_variant str | Param | None\n\nThe font-variant attribute for axis ticks; defaults to tabular-nums for quantitative axes.\n\ny_aria_label str | Param | None\n\nA short label representing the axis in the accessibility tree.\n\ny_aria_description str | Param | None\n\nA textual description for the axis in the accessibility tree.\n\ny_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\ny_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range. Note that by default, when the y scale is continuous, the max value points to the top of the screen, whereas ordinal values are ranked from top to bottom.\n\ny_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\ny_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\ny_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\ny_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\nxy_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nSet the x and y scale domains.\n\nfacet_margin float | Param | None\n\nShorthand to set the same default for all four facet margins: margin_top, margin_right, margin_bottom, and margin_left.\n\nfacet_margin_top float | Param | None\n\nThe top facet margin; the (minimum) distance in pixels between the top edges of the inner and outer plot area.\n\nfacet_margin_bottom float | Param | None\n\nThe right facet margin; the (minimum) distance in pixels between the right edges of the inner and outer plot area.\n\nfacet_margin_left float | Param | None\n\nThe bottom facet margin; the (minimum) distance in pixels between the bottom edges of the inner and outer plot area.\n\nfacet_margin_right float | Param | None\n\nThe left facet margin; the (minimum) distance in pixels between the left edges of the inner and outer plot area.\n\nfacet_grid bool | str | Interval | Sequence[str | float | bool] | Param | None\n\nDefault axis grid for fx and fy scales; typically set to true to enable.\n\nfacet_label str | None | Param | None\n\nDefault axis label for fx and fy scales; typically set to null to disable.\n\nfx_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\n\nfx_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and the plot’s dimensions. For ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale.\n\nfx_inset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\nfx_inset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\nfx_inset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nfx_round bool | Param | None\n\nIf true, round the output value to the nearest integer (pixel); useful for crisp edges when rendering.\nFor position scales only.\n\nfx_align float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\nfx_padding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\nfx_padding_inner float | Param | None\n\nFor a band scale, how much of the range to reserve to separate adjacent bands.\n\nfx_padding_outer float | Param | None\n\nFor a band scale, how much of the range to reserve to inset first and last bands.\n\nfx_axis Literal['top', 'bottom', 'both'] | bool | None | Param | None\n\nThe side of the frame on which to place the implicit axis: top or bottom for fx. Defaults to top if there is a bottom x axis, and otherwise bottom.\nIf both, an implicit axis will be rendered on both sides of the plot (top and bottom for fx). If null, the implicit axis is suppressed.\n\nfx_ticks float | Interval | Sequence[str | float | bool] | Param | None\n\nThe desired approximate number of axis ticks, or an explicit array of tick values, or an interval such as day or month.\n\nfx_tick_size float | Param | None\n\nThe length of axis tick marks in pixels; negative values extend in the opposite direction. Defaults to 6 for x and y axes and color and opacity ramp legends, and 0 for fx and fy axes.\n\nfx_tick_spacing float | Param | None\n\nThe desired approximate spacing between adjacent axis ticks, affecting the default ticks; defaults to 80 pixels for x and fx, and 35 pixels for y and fy.\n\nfx_tick_padding float | Param | None\n\nThe distance between an axis tick mark and its associated text label (in pixels); often defaults to 3, but may be affected by fx_tick_size and fx_tick_rotate.\n\nfx_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\nfx_tick_rotate float | Param | None\n\nThe rotation angle of axis tick labels in degrees clocksize; defaults to 0.\n\nfx_grid bool | str | Interval | Sequence[str | float | bool] | Param | None\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines. See also the grid mark.\nFor axes only.\n\nfx_line bool | Param | None\n\nIf true, draw a line along the axis; if false (default), do not.\n\nfx_label_anchor Literal['right', 'left', 'center'] | Param | None\n\nWhere to place the axis label relative to the plot’s frame. For vertical position scales (y and fy), may be top, bottom, or center; for horizontal position scales (x and fx), may be left, right, or center. Defaults to center for ordinal scales (including fx and fy), and otherwise top for y, and right for x.\n\nfx_label_offset float | Param | None\n\nThe axis label position offset (in pixels); default depends on margins and orientation.\n\nfx_font_variant str | Param | None\n\nThe font-variant attribute for axis ticks; defaults to tabular-nums for quantitative axes.\n\nfx_aria_label str | Param | None\n\nA short label representing the axis in the accessibility tree.\n\nfx_aria_description str | Param | None\n\nA textual description for the axis in the accessibility tree.\n\nfx_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\nfy_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\n\nfy_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and the plot’s dimensions. For ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale.\n\nfy_inset float | Param | None\n\nShorthand to set the same default for all four insets: inset_top, inset_right, inset_bottom, and inset_left. All insets typically default to zero, though not always (say when using bin transform). A positive inset reduces effective area, while a negative inset increases it.\n\nfy_inset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\nfy_inset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\nfy_round bool | Param | None\n\nIf true, round the output value to the nearest integer (pixel); useful for crisp edges when rendering.\nFor position scales only.\n\nfy_align float | Param | None\n\nHow to distribute unused space in the range for point and band scales. A number in [0, 1], such as:\n\n0 - use the start of the range, putting unused space at the end\n0.5 (default) - use the middle, distributing unused space evenly\n1 use the end, putting unused space at the start\n\nFor ordinal position scales only.\n\nfy_padding float | Param | None\n\nFor band scales, how much of the range to reserve to separate adjacent bands; defaults to 0.1 (10%). For point scales, the amount of inset for the first and last value as a proportion of the bandwidth; defaults to 0.5 (50%).\nFor ordinal position scales only.\n\nfy_padding_inner float | Param | None\n\nFor a band scale, how much of the range to reserve to separate adjacent bands.\n\nfy_padding_outer float | Param | None\n\nFor a band scale, how much of the range to reserve to inset first and last bands.\n\nfy_axis Literal['left', 'right', 'both'] | bool | None | Param | None\n\nThe side of the frame on which to place the implicit axis: left or right for fy. Defaults to left for an fy scale.\nIf both, an implicit axis will be rendered on both sides of the plot (left and right for fy). If null, the implicit axis is suppressed.\n\nfy_ticks float | Interval | Sequence[str | float | bool] | Param | None\n\nThe desired approximate number of axis ticks, or an explicit array of tick values, or an interval such as day or month.\n\nfy_tick_size float | Param | None\n\nThe length of axis tick marks in pixels; negative values extend in the opposite direction. Defaults to 6 for x and y axes and color and opacity ramp legends, and 0 for fx and fy axes.\n\nfy_tick_spacing float | Param | None\n\nThe desired approximate spacing between adjacent axis ticks, affecting the default ticks; defaults to 80 pixels for x and fx, and 35 pixels for y and fy.\n\nfy_tick_padding float | Param | None\n\nThe distance between an axis tick mark and its associated text label (in pixels); often defaults to 3, but may be affected by fy_tick_size and fy_tick_rotate.\n\nfy_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\nfy_tick_rotate float | Param | None\n\nThe rotation angle of axis tick labels in degrees clocksize; defaults to 0.\n\nfy_grid bool | str | Interval | Sequence[str | float | bool] | Param | None\n\nWhether to show a grid aligned with the scale’s ticks. If true, show a grid with the currentColor stroke; if a string, show a grid with the specified stroke color; if an approximate number of ticks, an interval, or an array of tick values, show corresponding grid lines. See also the grid mark.\nFor axes only.\n\nfy_line bool | Param | None\n\nIf true, draw a line along the axis; if false (default), do not.\n\nfy_label_anchor Literal['top', 'bottom', 'center'] | Param | None\n\nWhere to place the axis label relative to the plot’s frame. For vertical position scales (y and fy), may be top, bottom, or center; for horizontal position scales (x and fx), may be left, right, or center. Defaults to center for ordinal scales (including fx and fy), and otherwise top for y, and right for x.\n\nfy_label_offset float | Param | None\n\nThe axis label position offset (in pixels); default depends on margins and orientation.\n\nfy_font_variant str | Param | None\n\nThe font-variant attribute for axis ticks; defaults to tabular-nums for quantitative axes.\n\nfy_aria_label str | Param | None\n\nA short label representing the axis in the accessibility tree.\n\nfy_aria_description str | Param | None\n\nA textual description for the axis in the accessibility tree.\n\nfy_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\ncolor_scale ColorScale | None | Param | None\n\nThe color scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled.\nFor quantitative data (numbers), defaults to linear; for temporal data (dates), defaults to utc; for ordinal data (strings or booleans), defaults to point for position scales, categorical for color scales, and otherwise ordinal.\n\ncolor_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\n\ncolor_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain. For other ordinal data, it is an array (or iterable) of output values in the same order as the domain.\n\ncolor_clamp bool | Param | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\ncolor_n float | Param | None\n\nFor a quantile scale, the number of quantiles (creates n - 1 thresholds); for a quantize scale, the approximate number of thresholds; defaults to 5.\n\ncolor_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\ncolor_scheme ColorScheme | Param | None\n\nIf specified, shorthand for setting the color_range or color_interpolate option of a color scale.\n\ncolor_interpolate Interpolate | Param | None\n\nHow to interpolate color range values. For quantitative scales only. This attribute can be used to specify a color space for interpolating colors specified in the color_range.\n\ncolor_pivot Any | Param | None\n\nFor a diverging color scale, the input value (abstract value) that divides the domain into two parts; defaults to 0 for diverging scales, dividing the domain into negative and positive parts; defaults to 1 for diverging-log scales. By default, diverging scales are symmetric around the pivot; see the symmetric option.\n\ncolor_symmetric bool | Param | None\n\nFor a diverging color scale, if true (the default), extend the domain to ensure that the lower part of the domain (below the pivot) is commensurate with the upper part of the domain (above the pivot).\nA symmetric diverging color scale may not use all of its output range; this reduces contrast but ensures that deviations both below and above the pivot are represented proportionally. Otherwise if false, the full output range will be used; this increases contrast but values on opposite sides of the pivot may not be meaningfully compared.\n\ncolor_label str | None | Param | None\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\nFor axes and legends only.\n\ncolor_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\ncolor_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\ncolor_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\ncolor_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\ncolor_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow and diverging-pow scales only.\n\ncolor_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log and diverging-log scales only.\n\ncolor_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog and diverging-symlog scales only.\n\nopacity_scale ContinuousScale | None | Param | None\n\nThe opacity scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled. The opacity scale defaults to linear; this scales is intended for quantitative data.\n\nopacity_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nOpacity scales have a default domain from 0 to the maximum value of associated channels.\n\nopacity_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values).\nOpacity scales have a default range of [0, 1].\n\nopacity_clamp bool | Param | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\nopacity_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\nopacity_label str | None | Param | None\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\nFor axes and legends only.\n\nopacity_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\nopacity_reverse bool | Param | None\n\nWhether to reverse the scale’s encoding; equivalent to reversing either the domain or range.\n\nopacity_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\nopacity_tick_format str | None | Param | None\n\nHow to format inputs (abstract values) for axis tick labels; one of:\n\na d3-format string for numeric scales\na d3-time-format string for temporal scales\n\n\nopacity_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\nopacity_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\nopacity_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\nsymbol_scale Literal['ordinal', 'categorical', 'threshold', 'quantile', 'quantize'] | None | Param\n\nThe symbol scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled. Defaults to an ordinal scale type.\n\nsymbol_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. As symbol scales are discrete, the domain is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\n\nsymbol_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale. For other ordinal data, such as for a color scale, it is an array (or iterable) of output values in the same order as the domain.\nSymbol scales have a default range of categorical symbols; the choice of symbols depends on whether the associated dot mark is filled or stroked.\n\nr_scale ContinuousScale | None | Param | None\n\nThe r (radius) scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled. The radius scale defaults to sqrt; this scale is intended for quantitative data.\n\nr_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nRadius scales have a default domain from 0 to the median first quartile of associated channels.\n\nr_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale. For other ordinal data, such as for a color scale, it is an array (or iterable) of output values in the same order as the domain.\nRadius scales have a default range of [0, 3].\n\nr_clamp Any | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\nr_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\nr_label str | None | Param | None\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\n\nr_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\nr_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\nr_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\nr_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\nr_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\nlength_scale ContinuousScale | None | Param | None\n\nThe length scale type, affecting how the scale encodes abstract data, say by applying a mathematical transformation. If null, the scale is disabled. The length scale defaults to linear, as this scale is intended for quantitative data.\n\nlength_domain Literal['fixed'] | Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s inputs (abstract values). By default inferred from channel values. For continuous data (numbers and dates), it is typically [min, max]; it can be [max, min] to reverse the scale. For ordinal data (strings or booleans), it is an array (or iterable) of values is the desired order, defaulting to natural ascending order.\nLinear scales have a default domain of [0, 1]. Log scales have a default domain of [1, 10] and cannot include zero. Radius scales have a default domain from 0 to the median first quartile of associated channels. Length have a default domain from 0 to the median median of associated channels. Opacity scales have a default domain from 0 to the maximum value of associated channels.\n\nlength_range Sequence[str | float | bool] | Param | None\n\nThe extent of the scale’s outputs (visual values). By default inferred from the scale’s type and domain, and for position scales, the plot’s dimensions. For continuous data (numbers and dates), and for ordinal position scales (point and band), it is typically [min, max]; it can be [max, min] to reverse the scale. For other ordinal data, such as for a color scale, it is an array (or iterable) of output values in the same order as the domain.\nLength scales have a default range of [0, 12].\n\nlength_clamp Any | None\n\nIf true, values below the domain minimum are treated as the domain minimum, and values above the domain maximum are treated as the domain maximum.\nClamping is useful for focusing on a subset of the data while ensuring that extreme values remain visible, but use caution: clamped values may need an annotation to avoid misinterpretation. Clamping typically requires setting an explicit domain since if the domain is inferred, no values will be outside the domain.\nFor continuous scales only.\n\nlength_nice bool | float | Interval | Param | None\n\nIf true, or a tick count or interval, extend the domain to nice round values. Defaults to 1, 2 or 5 times a power of 10 for linear scales, and nice time intervals for utc and time scales. Pass an interval such as minute, wednesday or month to specify what constitutes a nice interval.\nFor continuous scales only.\n\nlength_percent bool | Param | None\n\nIf true, shorthand for a transform suitable for percentages, mapping proportions in [0, 1] to [0, 100].\n\nlength_zero bool | Param | None\n\nWhether the domain must include zero. If the domain minimum is positive, it will be set to zero; otherwise if the domain maximum is negative, it will be set to zero.\nFor quantitative scales only.\n\nlength_exponent float | Param | None\n\nA power scale’s exponent (e.g., 0.5 for sqrt); defaults to 1 for a linear scale. For pow scales only.\n\nlength_base float | Param | None\n\nA log scale’s base; defaults to 10. Does not affect the scale’s encoding, but rather the default ticks. For log scales only.\n\nlength_constant float | Param | None\n\nA symlog scale’s constant, expressing the magnitude of the linear region around the origin; defaults to 1. For symlog scales only.\n\nprojection_type Projection | None | Param | None\n\nThe desired projection; one of:\n\na named built-in projection such as albers-usa\nnull, for no projection\n\nNamed projections are scaled and translated to fit the domain to the plot’s frame (minus insets).\n\nprojection_domain object | Param | None\n\nA GeoJSON object to fit to the plot’s frame (minus insets); defaults to a Sphere for spherical projections (outline of the the whole globe).\n\nprojection_rotate Sequence[float | Param] | Param | None\n\nA rotation of the sphere before projection; defaults to [0, 0, 0]. Specified as Euler angles λ (yaw, or reference longitude), φ (pitch, or reference latitude), and optionally γ (roll), in degrees.\n\nprojection_parallels Sequence[float | Param] | Param | None\n\nThe standard parallels. For conic projections only.\n\nprojection_precision float | Param | None\n\nThe projection’s sampling threshold.\n\nprojection_clip bool | float | Literal['frame'] | None | Param | None\n\nThe projection’s clipping method; one of:\n\nframe or true (default) - clip to the plot’s frame (including margins but not insets)\na number - clip to a circle of the given radius in degrees centered around the origin\nnull or false - do not clip\n\nSome projections (such as armadillo and berghaus) require spherical clipping: in that case set the marks’ clip option to sphere.\n\nprojection_inset float | Param | None\n\nShorthand to set the same default for all four projection insets. All insets typically default to zero, though not always. A positive inset reduces effective area, while a negative inset increases it.\n\nprojection_inset_top float | Param | None\n\nInsets the top edge of the projection by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\nprojection_inset_right float | Param | None\n\nInsets the right edge of the projection by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\nprojection_inset_bottom float | Param | None\n\nInsets the bottom edge of the projection by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\nprojection_inset_left float | Param | None\n\nInsets the left edge of the projection by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.plot"
    ]
  },
  {
    "objectID": "reference/inspect_viz.plot.html#legend",
    "href": "reference/inspect_viz.plot.html#legend",
    "title": "inspect_viz.plot",
    "section": "Legend",
    "text": "Legend\n\nlegend\nCreate a legend.\n\nSource\n\ndef legend(\n    legend: Literal[\"color\", \"opacity\", \"symbol\"],\n    location: Literal[\"bottom\", \"left\", \"right\", \"top\"] = \"right\",\n    columns: Literal[\"auto\"] | int | None = \"auto\",\n    label: str | None = None,\n    target: Selection | None = None,\n    field: str | None = None,\n    width: float | None = None,\n    height: float | None = None,\n    tick_size: float | None = None,\n    margin_bottom: float | None = None,\n    margin_left: float | None = None,\n    margin_right: float | None = None,\n    margin_top: float | None = None,\n    for_plot: str | None = None,\n) -&gt; Legend\n\nlegend Literal['color', 'opacity', 'symbol']\n\nLegend type (\"color\", \"opacity\", or \"symbol\").\n\nlocation Literal['bottom', 'left', 'right', 'top']\n\nThe legend location (used for display only when passing a legend to theplot() function). Also affects default value for columns.\n\ncolumns Literal['auto'] | int | None\n\nThe number of columns to use to layout a discrete legend (defaults to “auto”, which uses 1 column for location “left” or “right”)\n\nlabel str | None\n\nThe legend label.\n\ntarget Selection | None\n\nThe target selection. If specified, the legend is interactive, using a toggle interaction for discrete legends or an intervalX interaction for continuous legends.\n\nfield str | None\n\nThe data field over which to generate output selection clauses. If unspecified, a matching field is retrieved from existing plot marks.\n\nwidth float | None\n\nWidth of the legend in pixels.\n\nheight float | None\n\nHeight of the legend in pixels.\n\ntick_size float | None\n\nThe size of legend ticks in a continuous legend, in pixels.\n\nmargin_bottom float | None\n\nThe bottom margin of the legend component, in pixels.\n\nmargin_left float | None\n\nThe left margin of the legend component, in pixels.\n\nmargin_right float | None\n\nThe right margin of the legend component, in pixels.\n\nmargin_top float | None\n\nThe top margin of the legend component, in pixels.\n\nfor_plot str | None\n\nThe name of the plot this legend applies to. A plot must include a name attribute to be referenced. Note that this is not use when passing a legend to the plot() function.\n\n\n\n\nLegend\nPlot legend (create legends using the legend() function).\n\nSource\n\nclass Legend(Component)",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.plot"
    ]
  },
  {
    "objectID": "reference/inspect_viz.plot.html#export",
    "href": "reference/inspect_viz.plot.html#export",
    "title": "inspect_viz.plot",
    "section": "Export",
    "text": "Export\n\nto_html\nGenreate an HTML snippet for a plot or other component.\n\nSource\n\ndef to_html(component: Component, dependencies: bool = True) -&gt; str\n\ncomponent Component\n\nCompontent to export.\n\ndependencies bool\n\nInclude JavaScript dependencies required for Jupyter widget rendering. Dependencies should only be included once per web-page, so if you already have them on a page you might want to disable including them when generating HTML.\n\n\n\n\nwrite_html\nWrite an HTML file for a plot or other component.\n\nSource\n\ndef write_html(\n    file: str | Path, component: Component, dependencies: bool = True\n) -&gt; None\n\nfile str | Path\n\nTarget filename.\n\ncomponent Component\n\nCompontent to export.\n\ndependencies bool\n\nInclude JavaScript dependencies required for Jupyter widget rendering. Dependencies should only be included once per web-page, so if you already have them on a page you might want to disable including them when generating HTML.\n\n\n\n\nwrite_png\nExport a plot or table to a PNG.\n\nSource\n\ndef write_png(\n    file: str | Path, component: Component, scale: int = 2, padding: int = 8\n) -&gt; None\n\nfile str | Path\n\nTarget filename.\n\ncomponent Component\n\nComponent to export.\n\nscale int\n\nDevice scale to capture plot at. Use 2 (the default) for retina quality images suitable for high resolution displays or print output)\n\npadding int\n\nPadding (in pixels) around plot.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.plot"
    ]
  },
  {
    "objectID": "reference/inspect_viz.plot.html#defaults",
    "href": "reference/inspect_viz.plot.html#defaults",
    "title": "inspect_viz.plot",
    "section": "Defaults",
    "text": "Defaults\n\nplot_defaults\nSet global plot defaults.\nNote that this function should be called once at the outset (subsequent calls to it do not reset the defaults).\n\nSource\n\ndef plot_defaults(**defaults: Unpack[PlotDefaults]) -&gt; None\n\n**defaults Unpack[PlotDefaults]\n\nKeyword args from PlotDefaults\n\n\n\n\nPlotDefaults\nDefault options for plots.\nUse the plot_defaults() function to set global defaults for plot options.\n\nSource\n\nclass PlotDefaults(PlotAttributes, total=False)\n\nAttributes\n\nx_label str | Param\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\n\nfx_label str | Param\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\nFor axes and legends only.\n\ny_label str | Param\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\n\nfy_label str | Param\n\nA textual label to show on the axis or legend; if null, show no label. By default the scale label is inferred from channel definitions, possibly with an arrow (↑, →, ↓, or ←) to indicate the direction of increasing value.\nFor axes and legends only.\n\nwidth float | Param\n\nThe outer width of the plot in pixels, including margins. Defaults to 640.\n\nheight float | Param\n\nThe outer height of the plot in pixels, including margins. The default depends on the plot’s scales, and the plot’s width if an aspectRatio is specified. For example, if the y scale is linear and there is no fy scale, it might be 396.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.plot"
    ]
  },
  {
    "objectID": "reference/inspect_viz.plot.html#types",
    "href": "reference/inspect_viz.plot.html#types",
    "title": "inspect_viz.plot",
    "section": "Types",
    "text": "Types\n\nPositionScale\nHow a scale encodes abstract data, say by applying a mathematical transformation.\n\nSource\n\nPositionScale: TypeAlias = Literal[\n    \"linear\",\n    \"log\",\n    \"pow\",\n    \"sqrt\",\n    \"symlog\",\n    \"utc\",\n    \"time\",\n    \"point\",\n    \"band\",\n    \"ordinal\",\n    \"threshold\",\n    \"quantile\",\n    \"quantize\",\n    \"identity\",\n]\n\n\nProjection\nBuilt-in projection types.\nNamed projections are scaled and translated to fit the domain to the plot’s frame (minus insets).\n\nSource\n\nProjection: TypeAlias = Literal[\n    \"albers\",\n    \"albers-usa\",\n    \"azimuthal-equal-area\",\n    \"azimuthal-equidistant\",\n    \"conic-conformal\",\n    \"conic-equal-area\",\n    \"conic-equidistant\",\n    \"equal-earth\",\n    \"equirectangular\",\n    \"gnomonic\",\n    \"identity\",\n    \"mercator\",\n    \"natural-earth1\",\n    \"orthographic\",\n    \"stereographic\",\n    \"transverse-mercator\",\n]\n\n\nContinuousScale\nContinuous scaling transformations.\n\nSource\n\nContinuousScale: TypeAlias = Literal[\n    \"linear\",\n    \"log\",\n    \"pow\",\n    \"sqrt\",\n    \"symlog\",\n    \"utc\",\n    \"time\",\n    \"identity\",\n]\n\n\nColorScale\nColor scale tranformations.\n\nSource\n\nColorScale: TypeAlias = Literal[\n    \"linear\",\n    \"log\",\n    \"pow\",\n    \"sqrt\",\n    \"symlog\",\n    \"utc\",\n    \"time\",\n    \"ordinal\",\n    \"categorical\",\n    \"threshold\",\n    \"quantile\",\n    \"quantize\",\n    \"diverging\",\n    \"diverging-log\",\n    \"diverging-pow\",\n    \"diverging-symlog\",\n    \"cyclical\",\n    \"sequential\",\n    \"rainbow\",\n    \"sinebow\",\n]\n\n\nColorScheme\nColor schemes.\n\nSource\n\nColorScheme: TypeAlias = Literal[\n    \"accent\",\n    \"blues\",\n    \"brbg\",\n    \"bugn\",\n    \"bupu\",\n    \"category10\",\n    \"dark2\",\n    \"gnbu\",\n    \"greens\",\n    \"greys\",\n    \"magma\",\n    \"oranges\",\n    \"orrd\",\n    \"paired\",\n    \"pastel1\",\n    \"pastel2\",\n    \"piyg\",\n    \"plasma\",\n    \"prgn\",\n    \"pubu\",\n    \"pubugn\",\n    \"puor\",\n    \"purd\",\n    \"purples\",\n    \"rdbu\",\n    \"rdgy\",\n    \"rdpu\",\n    \"rdylbu\",\n    \"rdylgn\",\n    \"reds\",\n    \"set1\",\n    \"set2\",\n    \"set3\",\n    \"spectral\",\n    \"tableau10\",\n    \"turbo\",\n    \"viridis\",\n    \"warm\",\n    \"cool\",\n    \"cubehelix\",\n    \"rainbow\",\n    \"sinebow\",\n]\n\n\nInterpolate\nHow to interpolate color range values.\n\nSource\n\nInterpolate: TypeAlias = Literal[\n    \"rgb\",\n    \"hsl\",\n    \"lab\",\n    \"hcl\",\n    \"cubehelix\",\n]\n\n\nLabelArrow\nWhether to apply a directional arrow to an axis scale label.\n\nSource\n\nLabelArrow = (\n    Literal[\n        \"auto\",\n        \"up\",\n        \"right\",\n        \"down\",\n        \"left\",\n        \"none\",\n    ]\n    | bool\n    | None\n)",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.plot"
    ]
  },
  {
    "objectID": "reference/inspect_viz.mark.html",
    "href": "reference/inspect_viz.mark.html",
    "title": "inspect_viz.mark",
    "section": "",
    "text": "A dot mark that draws circles, or other symbols, as in a scatterplot.\n\nSource\n\ndef dot(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    rotate: Channel | float | Param | None = None,\n    symbol: ChannelSpec | Param | Symbol | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nHorizontal position channel specifying the dot’s center.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the dot’s center.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of dots; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 4.5 pixels when using the symbol channel, and otherwise 3 pixels. Dots with a nonpositive radius are not drawn.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate Channel | float | Param | None\n\nThe rotation angle of dots in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nsymbol ChannelSpec | Param | Symbol | None\n\nCategorical column to bind symbols to or CSS color string.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA horizontal dot mark that draws circles, or other symbols.\nLike dot, except that y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …].\nIf an interval is specified, such as day, y is transformed to the middle of the interval.\n\nSource\n\ndef dot_x(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelIntervalSpec | None = None,\n    z: Channel | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    interval: Interval | None = None,\n    filter_by: Selection | None = None,\n    rotate: Channel | float | Param | None = None,\n    symbol: ChannelSpec | Param | Symbol | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel specifying the dot’s center.\n\ny ChannelIntervalSpec | None\n\nThe vertical position of the dot’s center,typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of dots; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 4.5 pixels when using the symbol channel, and otherwise 3 pixels. Dots with a nonpositive radius are not drawn.\n\ninterval Interval | None\n\nAn interval (such as day or a number), to transform y values to the middle of the interval.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate Channel | float | Param | None\n\nThe rotation angle of dots in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nsymbol ChannelSpec | Param | Symbol | None\n\nCategorical column to bind symbols to or CSS color string.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA vertical dot mark that draws circles, or other symbols.\nLike dot, except that x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …].\nIf an interval is specified, such as day, x is transformed to the middle of the interval.\n\nSource\n\ndef dot_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    x: ChannelIntervalSpec | None = None,\n    z: Channel | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    interval: Interval | None = None,\n    filter_by: Selection | None = None,\n    rotate: Channel | float | Param | None = None,\n    symbol: ChannelSpec | Param | Symbol | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the dot’s center.\n\nx ChannelIntervalSpec | None\n\nThe horizontal position of the dot’s center, typically bound to the x scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of dots; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 4.5 pixels when using the symbol channel, and otherwise 3 pixels. Dots with a nonpositive radius are not drawn.\n\ninterval Interval | None\n\nAn interval (such as day or a number), to transform x values to the middle of the interval.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate Channel | float | Param | None\n\nThe rotation angle of dots in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nsymbol ChannelSpec | Param | Symbol | None\n\nCategorical column to bind symbols to or CSS color string.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA circle mark that draws circles as in a scatterplot.\nLike dot, but with the symbol fixed to be a circle.\n\nSource\n\ndef circle(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: ChannelSpec | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nHorizontal position channel specifying the circle’s center.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the circle’s center.\n\nz ChannelSpec | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of circles; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 3 pixels. Circles with a nonpositive radius are not drawn.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle of circles in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA hexagon mark that draws hexagons as in a scatterplot.\nLike dot, but with the symbol fixed to be a hexagon.\n\nSource\n\ndef hexagon(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: ChannelSpec | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nHorizontal position channel specifying the hexagon’s center.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the hexagon’s center.\n\nz ChannelSpec | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of hexagons; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 4.5 pixels. Hexagons with a nonpositive radius are not drawn.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle of hexagons in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA line mark that connects control points.\nPoints along the line are connected in input order. If there are multiple series via the z, fill, or stroke channel, series are drawn in input order such that the last series is drawn on top.\n\nSource\n\ndef line(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe required horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param\n\nThe required vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\ntension float | Param | None\n\nThe tension option for bundle, cardinal and Catmull-Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA horizontal line mark that connects control points.\nLike line, except that y defaults to the zero-based index of the data [0, 1, 2, …].\n\nSource\n\ndef line_x(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe required horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\ntension float | Param | None\n\nThe tension option for bundle, cardinal and Catmull-Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA vertical line mark that connects control points.\nLike line, except that x defaults to the zero-based index of the data [0, 1, 2, …].\n\nSource\n\ndef line_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    x: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe required vertical position channel, typically bound to the y scale.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\ntension float | Param | None\n\nThe tension option for bundle, cardinal and Catmull-Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nAn area mark defined by a baseline (x1, y1) and a topline (x2, y2).\nThe x1 and y1 channels specify the area’s baseline; the x2 and y2 channels specify the area’s topline. Both the baseline and topline are typically bound to the same scales as their respective dimensions.\nIf x2 is not specified, it defaults to x1. If y2 is not specified, it defaults to y1. Typically either x2 or y2 is unspecified, creating either a horizontal or vertical area.\n\nSource\n\ndef area(\n    data: Data,\n    x1: ChannelSpec | Param,\n    y1: ChannelSpec | Param,\n    x2: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    curve: Curve | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx1 ChannelSpec | Param\n\nThe required primary (starting, often left) horizontal position channel, representing the area’s baseline, typically bound to the x scale.\n\ny1 ChannelSpec | Param\n\nThe required primary (starting, often bottom) vertical position channel, representing the area’s baseline, typically bound to the y scale.\n\nx2 ChannelSpec | Param | None\n\nThe optional secondary (ending, often right) horizontal position channel, representing the area’s topline, typically bound to the x scale; if not specified, x1 is used.\n\ny2 ChannelSpec | Param | None\n\nThe optional secondary (ending, often top) vertical position channel, representing the area’s topline, typically bound to the y scale; if not specified, y1 is used.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into (possibly stacked) series to be drawn as separate areas; defaults to fill if a channel, or stroke if a channel.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of: - null (default) for input order - a named stack order method such as inside-out or sum - a field name, for natural order of the corresponding values - a function of data, for natural order of the corresponding values - an array of explicit z values in the desired order\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA horizontal area mark.\nThe x channel specifies the area’s length (or width); it is typically bound to the x scale. The y channel specifies the area’s vertical position; it is typically bound to the y scale and defaults to the zero-based index of the data [0, 1, 2, …].\nIf neither x1 nor x2 is specified, an implicit stackX transform is applied and x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …]. Otherwise, if only one of x1 or x2 is specified, the other defaults to x, which defaults to zero.\n\nSource\n\ndef area_x(\n    data: Data,\n    x: ChannelSpec | Param,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    curve: Curve | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position (or length) channel, typically bound to the x scale. If neither x1 nor x2 is specified, an implicit stackX transform is applied and x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …]. Otherwise, if only one of x1 or x2 is specified, the other defaults to x, which defaults to zero.\n\nx1 ChannelSpec | Param | None\n\nThe required primary (starting, often left) horizontal position channel, representing the area’s baseline, typically bound to the x scale. For areaX, setting this option disables the implicit stackX transform.\n\nx2 ChannelSpec | Param | None\n\nThe optional secondary (ending, often right) horizontal position channel, representing the area’s topline, typically bound to the x scale; if not specified, x1 is used. For areaX, setting this option disables the implicit stackX transform.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into (possibly stacked) series to be drawn as separate areas; defaults to fill if a channel, or stroke if a channel.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of:\n\nnull (default) for input order\na named stack order method such as inside-out or sum\na field name, for natural order of the corresponding values\na function of data, for natural order of the corresponding values\nan array of explicit z values in the desired order\n\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA vertical area mark.\nThe y channel specifies the area’s height (or length); it is typically bound to the y scale. The x channel specifies the area’s horizontal position; it is typically bound to the x scale and defaults to the zero-based index of the data [0, 1, 2, …].\nIf neither y1 nor y2 is specified, an implicit stackY transform is applied and y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …]. Otherwise, if only one of y1 or y2 is specified, the other defaults to y, which defaults to zero.\n\nSource\n\ndef area_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    x: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    curve: Curve | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position (or length) channel, typically bound to the y scale. If neither y1 nor y2 is specified, an implicit stackY transform is applied and y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …]. Otherwise, if only one of y1 or y2 is specified, the other defaults to y, which defaults to zero.\n\ny1 ChannelSpec | Param | None\n\nThe required primary (starting, often bottom) vertical position channel, representing the area’s baseline, typically bound to the y scale. For areaY, setting this option disables the implicit stackY transform.\n\ny2 ChannelSpec | Param | None\n\nThe optional secondary (ending, often top) vertical position channel, representing the area’s topline, typically bound to the y scale; if not specified, y1 is used. For areaY, setting this option disables the implicit stackY transform.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into (possibly stacked) series to be drawn as separate areas; defaults to fill if a channel, or stroke if a channel.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of:\n\nnull (default) for input order\na named stack order method such as inside-out or sum\na field name, for natural order of the corresponding values\na function of data, for natural order of the corresponding values\nan array of explicit z values in the desired order\n\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA horizontal bar mark.\nThe required x values should be quantitative or temporal, and the optional y values should be ordinal.\nIf neither x1 nor x2 nor interval is specified, an implicit stackX transform is applied and x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …]. Otherwise if an interval is specified, then x1 and x2 are derived from x, representing the lower and upper bound of the containing interval, respectively. Otherwise, if only one of x1 or x2 is specified, the other defaults to x, which defaults to zero.\nThe optional y ordinal channel specifies the vertical position; it is typically bound to the y scale, which must be a band scale. If the y channel is not specified, the bar will span the vertical extent of the plot’s frame.\nIf y is quantitative, use the rectX mark instead. If x is ordinal, use the cell mark instead.”\n\nSource\n\ndef bar_x(\n    data: Data,\n    x: ChannelIntervalSpec | Param,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y: ChannelIntervalSpec | Param | None = None,\n    interval: Interval | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    z: Channel | Param | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: str | float | Param | None = None,\n    ry: str | float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelIntervalSpec | Param\n\nThe horizontal position (or length/width) channel, typically bound to the x scale. If neither x1 nor x2 nor interval is specified, an implicit stackX transform is applied and x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …]. Otherwise if an interval is specified, then x1 and x2 are derived from x, representing the lower and upper bound of the containing interval, respectively. Otherwise, if only one of x1 or x2 is specified, the other defaults to x, which defaults to zero.\n\nx1 ChannelSpec | Param | None\n\nThe required primary (starting, often left) horizontal position channel, typically bound to the x scale. Setting this option disables the implicit stackX transform. If x represents ordinal values, use a cell mark instead.\n\nx2 ChannelSpec | Param | None\n\nThe required secondary (ending, often right) horizontal position channel, typically bound to the x scale. Setting this option disables the implicit stackX transform. If x represents ordinal values, use a cell mark instead.\n\ny ChannelIntervalSpec | Param | None\n\nThe optional vertical position of the bar; a ordinal channel typically bound to the y scale. If not specified, the bar spans the vertical extent of the frame; otherwise the y scale must be a band scale. If y represents quantitative or temporal values, use a rectX mark instead.\n\ninterval Interval | None\n\nHow to convert a continuous value (x for barX, or y for barY) into an interval (x1 and x2 for barX, or y1 and y2 for barY); one of:\n\na named time interval such as day (for date intervals)\na number (for number intervals), defining intervals at integer multiples of n\n\nSetting this option disables the implicit stack transform (stackX for barX, or stackY for barY).\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of:\n\nnull (default) for input order\na named stack order method such as inside-out or sum\na field name, for natural order of the corresponding values\na function of data, for natural order of the corresponding values\nan array of explicit z values in the desired order\n\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\nz Channel | Param | None\n\nThe z channel defines the series of each value in the stack. Used when the order is sum, appearance, inside-out, or an explicit array of z values.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nrx str | float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the rect width. If rx is not specified, it defaults to ry if present, and otherwise draws square corners.\n\nry str | float | Param | None\n\nThe rounded corner [y-radius][], either in pixels or as a percentage of the rect height. If ry is not specified, it defaults to rx if present, and otherwise draws square corners.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA vertical bar mark.\nThe required y values should be quantitative or temporal, and the optional x values should be ordinal.\nIf neither y1 nor y2 nor interval is specified, an implicit stackY transform is applied and y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …]. Otherwise if an interval is specified, then y1 and y2 are derived from y, representing the lower and upper bound of the containing interval, respectively. Otherwise, if only one of y1 or y2 is specified, the other defaults to y, which defaults to zero.\nThe optional x ordinal channel specifies the horizontal position; it is typically bound to the x scale, which must be a band scale. If the x channel is not specified, the bar will span the horizontal extent of the plot’s frame.\nIf x is quantitative, use the rectY mark instead. If y is ordinal, use the cell mark instead.\n\nSource\n\ndef bar_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    x: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    z: Channel | Param | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: str | float | Param | None = None,\n    ry: str | float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position (or length/height) channel, typically bound to the y scale. If neither y1 nor y2 nor interval is specified, an implicit stackY transform is applied and y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …]. Otherwise if an interval is specified, then y1 and y2 are derived from y, representing the lower and upper bound of the containing interval, respectively. Otherwise, if only one of y1 or y2 is specified, the other defaults to y, which defaults to zero.\n\ny1 ChannelSpec | Param | None\n\nThe required primary (starting, often bottom) vertical position channel, typically bound to the y scale. Setting this option disables the implicit stackY transform. If y represents ordinal values, use a cell mark instead.\n\ny2 ChannelSpec | Param | None\n\nThe required secondary (ending, often top) vertical position channel, typically bound to the y scale. Setting this option disables the implicit stackY transform. If y represents ordinal values, use a cell mark instead.\n\nx ChannelSpec | Param | None\n\nThe optional horizontal position of the bar; a ordinal channel typically bound to the x scale. If not specified, the bar spans the horizontal extent of the frame; otherwise the x scale must be a band scale. If x represents quantitative or temporal values, use a rectY mark instead.\n\ninterval Interval | None\n\nHow to convert a continuous value (x for barX, or y for barY) into an interval (x1 and x2 for barX, or y1 and y2 for barY); one of:\n\na named time interval such as day (for date intervals)\na number (for number intervals), defining intervals at integer multiples of n\n\nSetting this option disables the implicit stack transform (stackX for barX, or stackY for barY).\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of:\n\nnull (default) for input order\na named stack order method such as inside-out or sum\na field name, for natural order of the corresponding values\na function of data, for natural order of the corresponding values\nan array of explicit z values in the desired order\n\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\nz Channel | Param | None\n\nThe z channel defines the series of each value in the stack. Used when the order is sum, appearance, inside-out, or an explicit array of z values.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nrx str | float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the rect width. If rx is not specified, it defaults to ry if present, and otherwise draws square corners.\n\nry str | float | Param | None\n\nThe rounded corner [y-radius][], either in pixels or as a percentage of the rect height. If ry is not specified, it defaults to rx if present, and otherwise draws square corners.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nCreate a heatmap mark for density visualization with optimized defaults.\nThe heatmap mark is essentially a raster mark with different default options optimized for density visualization. It bins spatial data into a raster grid and applies kernel density smoothing to create smooth density surfaces from point data.\n\nSource\n\ndef heatmap(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    filter_by: Selection | None = None,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    pixel_size: float | Param | None = None,\n    pad: float | Param | None = None,\n    interpolate: Interpolate | Param | None = None,\n    bandwidth: float | Param | None = None,\n    image_rendering: str | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale. Domain values are binned into a grid with width horizontal bins.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale. Domain values are binned into a grid with height vertical bins.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nwidth float | Param | None\n\nThe width (number of columns) of the grid, in actual pixels.\n\nheight float | Param | None\n\nThe height (number of rows) of the grid, in actual pixels.\n\npixel_size float | Param | None\n\nThe effective screen size of a raster pixel, used to determine the height and width of the raster from the frame’s dimensions; defaults to 1.\n\npad float | Param | None\n\nThe bin padding, one of 1 (default) to include extra padding for the final bin, or 0 to make the bins flush with the maximum domain value.\n\ninterpolate Interpolate | Param | None\n\nThe spatial interpolation method; one of: - none - do not perform interpolation (the default) - linear - apply proportional linear interpolation across adjacent bins - nearest - assign each pixel to the closest sample’s value (Voronoi diagram) - barycentric - apply barycentric interpolation over the Delaunay triangulation - random-walk - apply a random walk from each pixel\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels; defaults to 20.\n\nimage_rendering str | Param | None\n\nThe image-rendering attribute; defaults to auto (bilinear). May be set to pixelated to disable bilinear interpolation for a sharper image.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.mark"
    ]
  },
  {
    "objectID": "reference/inspect_viz.mark.html#basic",
    "href": "reference/inspect_viz.mark.html#basic",
    "title": "inspect_viz.mark",
    "section": "",
    "text": "A dot mark that draws circles, or other symbols, as in a scatterplot.\n\nSource\n\ndef dot(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    rotate: Channel | float | Param | None = None,\n    symbol: ChannelSpec | Param | Symbol | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nHorizontal position channel specifying the dot’s center.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the dot’s center.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of dots; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 4.5 pixels when using the symbol channel, and otherwise 3 pixels. Dots with a nonpositive radius are not drawn.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate Channel | float | Param | None\n\nThe rotation angle of dots in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nsymbol ChannelSpec | Param | Symbol | None\n\nCategorical column to bind symbols to or CSS color string.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA horizontal dot mark that draws circles, or other symbols.\nLike dot, except that y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …].\nIf an interval is specified, such as day, y is transformed to the middle of the interval.\n\nSource\n\ndef dot_x(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelIntervalSpec | None = None,\n    z: Channel | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    interval: Interval | None = None,\n    filter_by: Selection | None = None,\n    rotate: Channel | float | Param | None = None,\n    symbol: ChannelSpec | Param | Symbol | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel specifying the dot’s center.\n\ny ChannelIntervalSpec | None\n\nThe vertical position of the dot’s center,typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of dots; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 4.5 pixels when using the symbol channel, and otherwise 3 pixels. Dots with a nonpositive radius are not drawn.\n\ninterval Interval | None\n\nAn interval (such as day or a number), to transform y values to the middle of the interval.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate Channel | float | Param | None\n\nThe rotation angle of dots in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nsymbol ChannelSpec | Param | Symbol | None\n\nCategorical column to bind symbols to or CSS color string.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA vertical dot mark that draws circles, or other symbols.\nLike dot, except that x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …].\nIf an interval is specified, such as day, x is transformed to the middle of the interval.\n\nSource\n\ndef dot_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    x: ChannelIntervalSpec | None = None,\n    z: Channel | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    interval: Interval | None = None,\n    filter_by: Selection | None = None,\n    rotate: Channel | float | Param | None = None,\n    symbol: ChannelSpec | Param | Symbol | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the dot’s center.\n\nx ChannelIntervalSpec | None\n\nThe horizontal position of the dot’s center, typically bound to the x scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of dots; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 4.5 pixels when using the symbol channel, and otherwise 3 pixels. Dots with a nonpositive radius are not drawn.\n\ninterval Interval | None\n\nAn interval (such as day or a number), to transform x values to the middle of the interval.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate Channel | float | Param | None\n\nThe rotation angle of dots in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nsymbol ChannelSpec | Param | Symbol | None\n\nCategorical column to bind symbols to or CSS color string.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA circle mark that draws circles as in a scatterplot.\nLike dot, but with the symbol fixed to be a circle.\n\nSource\n\ndef circle(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: ChannelSpec | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nHorizontal position channel specifying the circle’s center.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the circle’s center.\n\nz ChannelSpec | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of circles; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 3 pixels. Circles with a nonpositive radius are not drawn.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle of circles in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA hexagon mark that draws hexagons as in a scatterplot.\nLike dot, but with the symbol fixed to be a hexagon.\n\nSource\n\ndef hexagon(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: ChannelSpec | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nHorizontal position channel specifying the hexagon’s center.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the hexagon’s center.\n\nz ChannelSpec | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nr ChannelSpec | float | Param | None\n\nThe radius of hexagons; either a channel or constant. When a number, it is interpreted as a constant radius in pixels. Otherwise it is interpreted as a channel, typically bound to the r channel, which defaults to the sqrt type for proportional symbols. The radius defaults to 4.5 pixels. Hexagons with a nonpositive radius are not drawn.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle of hexagons in degrees clockwise; either a channel or a constant. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 0°, pointing up.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA line mark that connects control points.\nPoints along the line are connected in input order. If there are multiple series via the z, fill, or stroke channel, series are drawn in input order such that the last series is drawn on top.\n\nSource\n\ndef line(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe required horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param\n\nThe required vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\ntension float | Param | None\n\nThe tension option for bundle, cardinal and Catmull-Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA horizontal line mark that connects control points.\nLike line, except that y defaults to the zero-based index of the data [0, 1, 2, …].\n\nSource\n\ndef line_x(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe required horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\ntension float | Param | None\n\nThe tension option for bundle, cardinal and Catmull-Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA vertical line mark that connects control points.\nLike line, except that x defaults to the zero-based index of the data [0, 1, 2, …].\n\nSource\n\ndef line_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    x: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe required vertical position channel, typically bound to the y scale.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\ntension float | Param | None\n\nThe tension option for bundle, cardinal and Catmull-Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nAn area mark defined by a baseline (x1, y1) and a topline (x2, y2).\nThe x1 and y1 channels specify the area’s baseline; the x2 and y2 channels specify the area’s topline. Both the baseline and topline are typically bound to the same scales as their respective dimensions.\nIf x2 is not specified, it defaults to x1. If y2 is not specified, it defaults to y1. Typically either x2 or y2 is unspecified, creating either a horizontal or vertical area.\n\nSource\n\ndef area(\n    data: Data,\n    x1: ChannelSpec | Param,\n    y1: ChannelSpec | Param,\n    x2: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    curve: Curve | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx1 ChannelSpec | Param\n\nThe required primary (starting, often left) horizontal position channel, representing the area’s baseline, typically bound to the x scale.\n\ny1 ChannelSpec | Param\n\nThe required primary (starting, often bottom) vertical position channel, representing the area’s baseline, typically bound to the y scale.\n\nx2 ChannelSpec | Param | None\n\nThe optional secondary (ending, often right) horizontal position channel, representing the area’s topline, typically bound to the x scale; if not specified, x1 is used.\n\ny2 ChannelSpec | Param | None\n\nThe optional secondary (ending, often top) vertical position channel, representing the area’s topline, typically bound to the y scale; if not specified, y1 is used.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into (possibly stacked) series to be drawn as separate areas; defaults to fill if a channel, or stroke if a channel.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of: - null (default) for input order - a named stack order method such as inside-out or sum - a field name, for natural order of the corresponding values - a function of data, for natural order of the corresponding values - an array of explicit z values in the desired order\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA horizontal area mark.\nThe x channel specifies the area’s length (or width); it is typically bound to the x scale. The y channel specifies the area’s vertical position; it is typically bound to the y scale and defaults to the zero-based index of the data [0, 1, 2, …].\nIf neither x1 nor x2 is specified, an implicit stackX transform is applied and x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …]. Otherwise, if only one of x1 or x2 is specified, the other defaults to x, which defaults to zero.\n\nSource\n\ndef area_x(\n    data: Data,\n    x: ChannelSpec | Param,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    curve: Curve | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position (or length) channel, typically bound to the x scale. If neither x1 nor x2 is specified, an implicit stackX transform is applied and x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …]. Otherwise, if only one of x1 or x2 is specified, the other defaults to x, which defaults to zero.\n\nx1 ChannelSpec | Param | None\n\nThe required primary (starting, often left) horizontal position channel, representing the area’s baseline, typically bound to the x scale. For areaX, setting this option disables the implicit stackX transform.\n\nx2 ChannelSpec | Param | None\n\nThe optional secondary (ending, often right) horizontal position channel, representing the area’s topline, typically bound to the x scale; if not specified, x1 is used. For areaX, setting this option disables the implicit stackX transform.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into (possibly stacked) series to be drawn as separate areas; defaults to fill if a channel, or stroke if a channel.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of:\n\nnull (default) for input order\na named stack order method such as inside-out or sum\na field name, for natural order of the corresponding values\na function of data, for natural order of the corresponding values\nan array of explicit z values in the desired order\n\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA vertical area mark.\nThe y channel specifies the area’s height (or length); it is typically bound to the y scale. The x channel specifies the area’s horizontal position; it is typically bound to the x scale and defaults to the zero-based index of the data [0, 1, 2, …].\nIf neither y1 nor y2 is specified, an implicit stackY transform is applied and y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …]. Otherwise, if only one of y1 or y2 is specified, the other defaults to y, which defaults to zero.\n\nSource\n\ndef area_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    x: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    curve: Curve | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position (or length) channel, typically bound to the y scale. If neither y1 nor y2 is specified, an implicit stackY transform is applied and y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …]. Otherwise, if only one of y1 or y2 is specified, the other defaults to y, which defaults to zero.\n\ny1 ChannelSpec | Param | None\n\nThe required primary (starting, often bottom) vertical position channel, representing the area’s baseline, typically bound to the y scale. For areaY, setting this option disables the implicit stackY transform.\n\ny2 ChannelSpec | Param | None\n\nThe optional secondary (ending, often top) vertical position channel, representing the area’s topline, typically bound to the y scale; if not specified, y1 is used. For areaY, setting this option disables the implicit stackY transform.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into (possibly stacked) series to be drawn as separate areas; defaults to fill if a channel, or stroke if a channel.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of:\n\nnull (default) for input order\na named stack order method such as inside-out or sum\na field name, for natural order of the corresponding values\na function of data, for natural order of the corresponding values\nan array of explicit z values in the desired order\n\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\ncurve Curve | Param | None\n\nThe curve (interpolation) method for connecting adjacent points.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA horizontal bar mark.\nThe required x values should be quantitative or temporal, and the optional y values should be ordinal.\nIf neither x1 nor x2 nor interval is specified, an implicit stackX transform is applied and x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …]. Otherwise if an interval is specified, then x1 and x2 are derived from x, representing the lower and upper bound of the containing interval, respectively. Otherwise, if only one of x1 or x2 is specified, the other defaults to x, which defaults to zero.\nThe optional y ordinal channel specifies the vertical position; it is typically bound to the y scale, which must be a band scale. If the y channel is not specified, the bar will span the vertical extent of the plot’s frame.\nIf y is quantitative, use the rectX mark instead. If x is ordinal, use the cell mark instead.”\n\nSource\n\ndef bar_x(\n    data: Data,\n    x: ChannelIntervalSpec | Param,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y: ChannelIntervalSpec | Param | None = None,\n    interval: Interval | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    z: Channel | Param | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: str | float | Param | None = None,\n    ry: str | float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelIntervalSpec | Param\n\nThe horizontal position (or length/width) channel, typically bound to the x scale. If neither x1 nor x2 nor interval is specified, an implicit stackX transform is applied and x defaults to the identity function, assuming that data = [x₀, x₁, x₂, …]. Otherwise if an interval is specified, then x1 and x2 are derived from x, representing the lower and upper bound of the containing interval, respectively. Otherwise, if only one of x1 or x2 is specified, the other defaults to x, which defaults to zero.\n\nx1 ChannelSpec | Param | None\n\nThe required primary (starting, often left) horizontal position channel, typically bound to the x scale. Setting this option disables the implicit stackX transform. If x represents ordinal values, use a cell mark instead.\n\nx2 ChannelSpec | Param | None\n\nThe required secondary (ending, often right) horizontal position channel, typically bound to the x scale. Setting this option disables the implicit stackX transform. If x represents ordinal values, use a cell mark instead.\n\ny ChannelIntervalSpec | Param | None\n\nThe optional vertical position of the bar; a ordinal channel typically bound to the y scale. If not specified, the bar spans the vertical extent of the frame; otherwise the y scale must be a band scale. If y represents quantitative or temporal values, use a rectX mark instead.\n\ninterval Interval | None\n\nHow to convert a continuous value (x for barX, or y for barY) into an interval (x1 and x2 for barX, or y1 and y2 for barY); one of:\n\na named time interval such as day (for date intervals)\na number (for number intervals), defining intervals at integer multiples of n\n\nSetting this option disables the implicit stack transform (stackX for barX, or stackY for barY).\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of:\n\nnull (default) for input order\na named stack order method such as inside-out or sum\na field name, for natural order of the corresponding values\na function of data, for natural order of the corresponding values\nan array of explicit z values in the desired order\n\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\nz Channel | Param | None\n\nThe z channel defines the series of each value in the stack. Used when the order is sum, appearance, inside-out, or an explicit array of z values.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nrx str | float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the rect width. If rx is not specified, it defaults to ry if present, and otherwise draws square corners.\n\nry str | float | Param | None\n\nThe rounded corner [y-radius][], either in pixels or as a percentage of the rect height. If ry is not specified, it defaults to rx if present, and otherwise draws square corners.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nA vertical bar mark.\nThe required y values should be quantitative or temporal, and the optional x values should be ordinal.\nIf neither y1 nor y2 nor interval is specified, an implicit stackY transform is applied and y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …]. Otherwise if an interval is specified, then y1 and y2 are derived from y, representing the lower and upper bound of the containing interval, respectively. Otherwise, if only one of y1 or y2 is specified, the other defaults to y, which defaults to zero.\nThe optional x ordinal channel specifies the horizontal position; it is typically bound to the x scale, which must be a band scale. If the x channel is not specified, the bar will span the horizontal extent of the plot’s frame.\nIf x is quantitative, use the rectY mark instead. If y is ordinal, use the cell mark instead.\n\nSource\n\ndef bar_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    x: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    filter_by: Selection | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    z: Channel | Param | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: str | float | Param | None = None,\n    ry: str | float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position (or length/height) channel, typically bound to the y scale. If neither y1 nor y2 nor interval is specified, an implicit stackY transform is applied and y defaults to the identity function, assuming that data = [y₀, y₁, y₂, …]. Otherwise if an interval is specified, then y1 and y2 are derived from y, representing the lower and upper bound of the containing interval, respectively. Otherwise, if only one of y1 or y2 is specified, the other defaults to y, which defaults to zero.\n\ny1 ChannelSpec | Param | None\n\nThe required primary (starting, often bottom) vertical position channel, typically bound to the y scale. Setting this option disables the implicit stackY transform. If y represents ordinal values, use a cell mark instead.\n\ny2 ChannelSpec | Param | None\n\nThe required secondary (ending, often top) vertical position channel, typically bound to the y scale. Setting this option disables the implicit stackY transform. If y represents ordinal values, use a cell mark instead.\n\nx ChannelSpec | Param | None\n\nThe optional horizontal position of the bar; a ordinal channel typically bound to the x scale. If not specified, the bar spans the horizontal extent of the frame; otherwise the x scale must be a band scale. If x represents quantitative or temporal values, use a rectY mark instead.\n\ninterval Interval | None\n\nHow to convert a continuous value (x for barX, or y for barY) into an interval (x1 and x2 for barX, or y1 and y2 for barY); one of:\n\na named time interval such as day (for date intervals)\na number (for number intervals), defining intervals at integer multiples of n\n\nSetting this option disables the implicit stack transform (stackX for barX, or stackY for barY).\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks, say to produce a streamgraph; defaults to null for a zero baseline (y = 0 for stackY, and x = 0 for stackX). If the wiggle offset is used, the default order changes to inside-out.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of:\n\nnull (default) for input order\na named stack order method such as inside-out or sum\na field name, for natural order of the corresponding values\na function of data, for natural order of the corresponding values\nan array of explicit z values in the desired order\n\nIf the wiggle offset is used, as for a streamgraph, the default changes to inside-out.\n\nz Channel | Param | None\n\nThe z channel defines the series of each value in the stack. Used when the order is sum, appearance, inside-out, or an explicit array of z values.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nrx str | float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the rect width. If rx is not specified, it defaults to ry if present, and otherwise draws square corners.\n\nry str | float | Param | None\n\nThe rounded corner [y-radius][], either in pixels or as a percentage of the rect height. If ry is not specified, it defaults to rx if present, and otherwise draws square corners.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\n\nCreate a heatmap mark for density visualization with optimized defaults.\nThe heatmap mark is essentially a raster mark with different default options optimized for density visualization. It bins spatial data into a raster grid and applies kernel density smoothing to create smooth density surfaces from point data.\n\nSource\n\ndef heatmap(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    filter_by: Selection | None = None,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    pixel_size: float | Param | None = None,\n    pad: float | Param | None = None,\n    interpolate: Interpolate | Param | None = None,\n    bandwidth: float | Param | None = None,\n    image_rendering: str | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale. Domain values are binned into a grid with width horizontal bins.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale. Domain values are binned into a grid with height vertical bins.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nwidth float | Param | None\n\nThe width (number of columns) of the grid, in actual pixels.\n\nheight float | Param | None\n\nThe height (number of rows) of the grid, in actual pixels.\n\npixel_size float | Param | None\n\nThe effective screen size of a raster pixel, used to determine the height and width of the raster from the frame’s dimensions; defaults to 1.\n\npad float | Param | None\n\nThe bin padding, one of 1 (default) to include extra padding for the final bin, or 0 to make the bins flush with the maximum domain value.\n\ninterpolate Interpolate | Param | None\n\nThe spatial interpolation method; one of: - none - do not perform interpolation (the default) - linear - apply proportional linear interpolation across adjacent bins - nearest - assign each pixel to the closest sample’s value (Voronoi diagram) - barycentric - apply barycentric interpolation over the Delaunay triangulation - random-walk - apply a random walk from each pixel\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels; defaults to 20.\n\nimage_rendering str | Param | None\n\nThe image-rendering attribute; defaults to auto (bilinear). May be set to pixelated to disable bilinear interpolation for a sharper image.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.mark"
    ]
  },
  {
    "objectID": "reference/inspect_viz.mark.html#statistical",
    "href": "reference/inspect_viz.mark.html#statistical",
    "title": "inspect_viz.mark",
    "section": "Statistical",
    "text": "Statistical\n\ndensity\nCreate a 2D density mark that shows smoothed point cloud densities.\nThe density mark bins the data, counts the number of records that fall into each bin, and smooths the resulting counts, then plots the smoothed distribution, by default using a circular dot mark. The density mark calculates density values that can be mapped to encoding channels such as fill or r using the special field name “density”.\n\nSource\n\ndef density(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    type: Literal[\"dot\", \"circle\", \"hexagon\", \"cell\", \"text\"] | Param | None = None,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    pixel_size: float | Param | None = None,\n    pad: float | Param | None = None,\n    bandwidth: float | Param | None = None,\n    interpolate: Interpolate | Param | None = None,\n    symbol: Symbol | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    styles: TextStyles | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale. Domain values are binned into a grid with width horizontal bins.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale. Domain values are binned into a grid with height vertical bins.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ntype Literal['dot', 'circle', 'hexagon', 'cell', 'text'] | Param | None\n\nThe base mark type to use for rendering; defaults to “dot”.\n\nwidth float | Param | None\n\nThe number of horizontal bins for density calculation.\n\nheight float | Param | None\n\nThe number of vertical bins for density calculation.\n\npixel_size float | Param | None\n\nThe size of each pixel for the grid, in data units.\n\npad float | Param | None\n\nThe bin padding, one of 1 (default) to include extra padding for the final bin, or 0 to make the bins flush with the maximum domain value.\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels.\n\ninterpolate Interpolate | Param | None\n\nThe spatial interpolation method; one of: - none - do not perform interpolation (the default) - linear - apply proportional linear interpolation across adjacent bins - nearest - assign each pixel to the closest sample’s value (Voronoi diagram) - barycentric - apply barycentric interpolation over the Delaunay triangulation - random-walk - apply a random walk from each pixel\n\nsymbol Symbol | Param | None\n\nThe symbol type for dots; defaults to “circle”.\n\nr ChannelSpec | float | Param | None\n\nThe radius channel, typically bound to the radius scale.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor position for legend placement.\n\nstyles TextStyles | None\n\nText styles to apply.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ndensity_x\nA densityX mark that visualizes smoothed point cloud densities along the x dimension.\nThe mark bins the data, counts the number of records that fall into each bin, smooths the resulting counts, and then plots the smoothed distribution, by default using an areaX mark.\nSet the type property to use a different base mark type.\n\nSource\n\ndef density_x(\n    data: Data,\n    y: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    type: Literal[\"areaX\", \"lineX\", \"dotX\", \"textX\"] | Param | None = None,\n    stack: bool | Param | None = None,\n    bandwidth: float | Param | None = None,\n    bins: float | Param | None = None,\n    normalize: bool | Literal[\"max\", \"sum\", \"none\"] | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ntype Literal['areaX', 'lineX', 'dotX', 'textX'] | Param | None\n\nThe basic mark type to use to render 1D density values. Defaults to an areaX mark; lineX, dotX, and textX marks are also supported.\n\nstack bool | Param | None\n\nFlag indicating if densities should be stacked. Defaults to False.\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels.\n\nbins float | Param | None\n\nThe number of bins over which to discretize the data prior to smoothing. Defaults to 1024.\n\nnormalize bool | Literal['max', 'sum', 'none'] | Param | None\n\nNormalization method for density estimates. If False or 'none' (the default), the density estimates are smoothed weighted counts. If True or 'sum', density estimates are divided by the sum of the total point mass. If 'max', estimates are divided by the maximum smoothed value.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ndensity_y\nA densityY mark that visualizes smoothed point cloud densities along the y dimension.\nThe mark bins the data, counts the number of records that fall into each bin, smooths the resulting counts, and then plots the smoothed distribution, by default using an areaY mark.\nSet the type property to use a different base mark type.\n\nSource\n\ndef density_y(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    type: Literal[\"areaY\", \"lineY\", \"dotY\", \"circle\", \"hexagon\", \"textY\"]\n    | Param\n    | None = None,\n    stack: bool | Param | None = None,\n    bandwidth: float | Param | None = None,\n    bins: float | Param | None = None,\n    normalize: bool | Literal[\"max\", \"sum\", \"none\"] | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ntype Literal['areaY', 'lineY', 'dotY', 'circle', 'hexagon', 'textY'] | Param | None\n\nThe basic mark type to use to render 1D density values. Defaults to an areaY mark; lineY, dotY, circle, hexagon, and textY marks are also supported.\n\nstack bool | Param | None\n\nFlag indicating if densities should be stacked. Defaults to False.\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels.\n\nbins float | Param | None\n\nThe number of bins over which to discretize the data prior to smoothing. Defaults to 1024.\n\nnormalize bool | Literal['max', 'sum', 'none'] | Param | None\n\nNormalization method for density estimates. If False or 'none' (the default), the density estimates are smoothed weighted counts. If True or 'sum', density estimates are divided by the sum of the total point mass. If 'max', estimates are divided by the maximum smoothed value.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ncontour\nCreate a contour mark that draws contour lines of equal value.\nThe contour mark creates isolines showing contours of equal value. It bins the given data into a 2D grid, computes density estimates, and draws contour lines at specified threshold levels. The contour mark is useful for visualizing the density or distribution of 2D point data.\n\nSource\n\ndef contour(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    filter_by: Selection | None = None,\n    thresholds: float | list[float] | Param | None = None,\n    bandwidth: float | Param | None = None,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    pixel_size: float | Param | None = None,\n    pad: float | Param | None = None,\n    interpolate: Interpolate | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale. Domain values are binned into a grid with width horizontal bins.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale. Domain values are binned into a grid with height vertical bins.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nthresholds float | list[float] | Param | None\n\nThe number of contour thresholds to subdivide the domain into discrete level sets; defaults to 10. Can be a count or an array of threshold values.\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels.\n\nwidth float | Param | None\n\nThe width (number of columns) of the grid, in actual pixels.\n\nheight float | Param | None\n\nThe height (number of rows) of the grid, in actual pixels.\n\npixel_size float | Param | None\n\nThe effective screen size of a raster pixel, used to determine the height and width of the raster from the frame’s dimensions; defaults to 1.\n\npad float | Param | None\n\nThe bin padding, one of 1 (default) to include extra padding for the final bin, or 0 to make the bins flush with the maximum domain value.\n\ninterpolate Interpolate | Param | None\n\nThe spatial interpolation method; one of: - none - do not perform interpolation (the default) - linear - apply proportional linear interpolation across adjacent bins - nearest - assign each pixel to the closest sample’s value (Voronoi diagram) - barycentric - apply barycentric interpolation over the Delaunay triangulation - random-walk - apply a random walk from each pixel\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nregression_y\nA vertical regression mark.\nThe regressionY mark draws a regression line with optional confidence bands showing the relationship between variables. The x variable is the independent variable and y is the dependent variable.\n\nSource\n\ndef regression_y(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    ci: float | Param | None = None,\n    precision: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe independent variable horizontal position channel (defaults to zero-based index).\n\ny ChannelSpec | Param | None\n\nThe dependent variable vertical position channel (defaults to identity function).\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series, producing independent regressions for each group.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nci float | Param | None\n\nThe confidence interval in (0, 1), or 0 to hide bands; defaults to 0.95.\n\nprecision float | Param | None\n\nThe distance in pixels between samples of the confidence band; defaults to 4.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\nerror_bar_x\nA horizontal error bar mark.\nThe errorBarX mark draws horizontal error bars showing confidence intervals or uncertainty around data points. The error bars extend horizontally from the central value.\n\nSource\n\ndef error_bar_x(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param | None = None,\n    ci: float | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe dependent variable horizontal position channel (required).\n\ny ChannelSpec | Param | None\n\nThe independent variable vertical position channel (optional).\n\nci float | Param | None\n\nThe confidence interval in (0, 1); defaults to 0.95.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nThe marker symbol to use at all positions along the error bar.\n\nmarker_start Marker | bool | Param | None\n\nThe marker symbol to use at the start of the error bar.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker symbol to use at the middle of the error bar.\n\nmarker_end Marker | bool | Param | None\n\nThe marker symbol to use at the end of the error bar.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\nerror_bar_y\nA vertical error bar mark.\nThe errorBarY mark draws vertical error bars showing confidence intervals or uncertainty around data points. The error bars extend vertically from the central value.\n\nSource\n\ndef error_bar_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    x: ChannelSpec | Param | None = None,\n    ci: float | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe dependent variable vertical position channel (required).\n\nx ChannelSpec | Param | None\n\nThe independent variable horizontal position channel (optional).\n\nci float | Param | None\n\nThe confidence interval in (0, 1); defaults to 0.95.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nThe marker symbol to use at all positions along the error bar.\n\nmarker_start Marker | bool | Param | None\n\nThe marker symbol to use at the start of the error bar.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker symbol to use at the middle of the error bar.\n\nmarker_end Marker | bool | Param | None\n\nThe marker symbol to use at the end of the error bar.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.mark"
    ]
  },
  {
    "objectID": "reference/inspect_viz.mark.html#grid",
    "href": "reference/inspect_viz.mark.html#grid",
    "title": "inspect_viz.mark",
    "section": "Grid",
    "text": "Grid\n\ncell\nA cell mark that draws axis-aligned rectangles for categorical data.\nCells are typically used to create heatmaps and other grid-based visualizations where both x and y represent categorical or ordinal data.\n\nSource\n\ndef cell(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: float | Param | None = None,\n    ry: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\nrx float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the cell width.\n\nry float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage of the cell height.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ncell_x\nA cellX mark that draws axis-aligned rectangles with ordinal positioning.\nThe x values should be ordinal (categories), and the optional y values should also be ordinal.\n\nSource\n\ndef cell_x(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: float | Param | None = None,\n    ry: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\nrx float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the cell width.\n\nry float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage of the cell height.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ncell_y\nA cellY mark that draws axis-aligned rectangles with ordinal positioning.\nThe y values should be ordinal (categories), and the optional x values should also be ordinal.\n\nSource\n\ndef cell_y(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: float | Param | None = None,\n    ry: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\nrx float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the cell width.\n\nry float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage of the cell height.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ngrid_x\nA horizontal grid mark.\nThe gridX mark draws horizontal grid lines across the plot area. It is primarily used for adding visual reference lines along the x-axis.\n\nSource\n\ndef grid_x(\n    x: ChannelSpec | Param | None = None,\n    y: ChannelIntervalSpec | None = None,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    anchor: str | Param | None = None,\n    color: ChannelSpec | str | Param | None = None,\n    ticks: int | Sequence[Any] | Param | None = None,\n    tick_spacing: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelIntervalSpec | None\n\nShorthand for specifying both the primary and secondary vertical position of the tick as the bounds of the containing interval; can only be used in conjunction with the interval option.\n\ny1 ChannelSpec | Param | None\n\nThe primary (starting, often bottom) vertical position of the grid line.\n\ny2 ChannelSpec | Param | None\n\nThe secondary (ending, often top) vertical position of the grid line.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\nanchor str | Param | None\n\nThe side of the frame on which to place the grid (top or bottom).\n\ncolor ChannelSpec | str | Param | None\n\nShorthand for setting both fill and stroke color.\n\nticks int | Sequence[Any] | Param | None\n\nThe desired number of ticks, or an array of tick values, or null to disable ticks.\n\ntick_spacing float | Param | None\n\nThe desired spacing between ticks in pixels.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions (including stroke, stroke_width, stroke_opacity, stroke_dasharray).\n\n\n\n\ngrid_y\nA vertical grid mark.\nThe gridY mark draws vertical grid lines across the plot area. It is primarily used for adding visual reference lines along the y-axis.\n\nSource\n\ndef grid_y(\n    y: ChannelSpec | Param | None = None,\n    x: ChannelIntervalSpec | None = None,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    anchor: str | Param | None = None,\n    color: ChannelSpec | str | Param | None = None,\n    ticks: int | Sequence[Any] | Param | None = None,\n    tick_spacing: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nx ChannelIntervalSpec | None\n\nShorthand for specifying both the primary and secondary horizontal position of the tick as the bounds of the containing interval; can only be used in conjunction with the interval option.\n\nx1 ChannelSpec | Param | None\n\nThe primary (starting, often left) horizontal position of the grid line.\n\nx2 ChannelSpec | Param | None\n\nThe secondary (ending, often right) horizontal position of the grid line.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\nanchor str | Param | None\n\nThe side of the frame on which to place the grid (left or right).\n\ncolor ChannelSpec | str | Param | None\n\nShorthand for setting both fill and stroke color.\n\nticks int | Sequence[Any] | Param | None\n\nThe desired number of ticks, or an array of tick values, or null to disable ticks.\n\ntick_spacing float | Param | None\n\nThe desired spacing between ticks in pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions (including stroke, stroke_width, stroke_opacity, stroke_dasharray).\n\n\n\n\ngrid_fx\nA horizontal facet grid mark.\nThe gridFx mark draws horizontal grid lines for faceted plots. It is primarily used for adding visual reference lines along the fx-axis in faceted visualizations.\n\nSource\n\ndef grid_fx(\n    x: ChannelSpec | Param | None = None,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    anchor: str | Param | None = None,\n    color: ChannelSpec | str | Param | None = None,\n    ticks: int | Sequence[Any] | Param | None = None,\n    tick_spacing: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny1 ChannelSpec | Param | None\n\nThe primary (starting, often bottom) vertical position of the grid line.\n\ny2 ChannelSpec | Param | None\n\nThe secondary (ending, often top) vertical position of the grid line.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\nanchor str | Param | None\n\nThe side of the frame on which to place the grid (top or bottom).\n\ncolor ChannelSpec | str | Param | None\n\nShorthand for setting both fill and stroke color.\n\nticks int | Sequence[Any] | Param | None\n\nThe desired number of ticks, or an array of tick values, or null to disable ticks.\n\ntick_spacing float | Param | None\n\nThe desired spacing between ticks in pixels.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions (including stroke, stroke_width, stroke_opacity, stroke_dasharray).\n\n\n\n\ngrid_fy\nA vertical facet grid mark.\nThe gridFy mark draws vertical grid lines for faceted plots. It is primarily used for adding visual reference lines along the fy-axis in faceted visualizations.\n\nSource\n\ndef grid_fy(\n    y: ChannelSpec | Param | None = None,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    anchor: str | Param | None = None,\n    color: ChannelSpec | str | Param | None = None,\n    ticks: int | Sequence[Any] | Param | None = None,\n    tick_spacing: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nx1 ChannelSpec | Param | None\n\nThe primary (starting, often left) horizontal position of the grid line.\n\nx2 ChannelSpec | Param | None\n\nThe secondary (ending, often right) horizontal position of the grid line.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\nanchor str | Param | None\n\nThe side of the frame on which to place the grid (left or right).\n\ncolor ChannelSpec | str | Param | None\n\nShorthand for setting both fill and stroke color.\n\nticks int | Sequence[Any] | Param | None\n\nThe desired number of ticks, or an array of tick values, or null to disable ticks.\n\ntick_spacing float | Param | None\n\nThe desired spacing between ticks in pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions (including stroke, stroke_width, stroke_opacity, stroke_dasharray).\n\n\n\n\nhexbin\nCreate a hexbin mark for hexagonal binning of point data.\nThe hexbin mark bins two-dimensional point data into hexagonal bins and displays aggregated values for each bin. This is useful for visualizing density patterns in large datasets and for creating hexagonal heatmaps.\nThe mark creates a hexagonal grid and counts or aggregates data points within each hexagon, then renders the results using the specified mark type.\n\nSource\n\ndef hexbin(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    bin_width: float | Param | None = None,\n    type: Literal[\"hexagon\", \"dot\", \"text\"] | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    styles: TextStyles | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale. Specifies the data to be binned horizontally.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale. Specifies the data to be binned vertically.\n\nz Channel | Param | None\n\nHow to subdivide bins. Defaults to the fill channel, if any, or the stroke channel, if any. If null, bins will not be subdivided.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nbin_width float | Param | None\n\nThe distance between centers of neighboring hexagons, in pixels; defaults to 20.\n\ntype Literal['hexagon', 'dot', 'text'] | Param | None\n\nThe basic mark type to use for hex-binned values. Defaults to a hexagon mark; dot and text marks are also supported.\n\nr ChannelSpec | float | Param | None\n\nThe radius of dots or hexagons; either a channel or constant.\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle in degrees clockwise.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor position for legend placement.\n\nstyles TextStyles | None\n\nText styles to apply when using text mark type.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nhexgrid\nCreate a hexgrid mark that displays a hexagonal grid overlay.\nThe hexgrid mark creates a hexagonal grid pattern, typically used as a background or reference grid for hexbin visualizations. This is a decoration mark that shows the underlying hexagonal structure without requiring data.\nThe hexgrid mark is designed to complement hexbin marks by showing the grid structure. It’s a stroke-only mark where fill is not supported.\n\nSource\n\ndef hexgrid(\n    bin_width: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\nbin_width float | Param | None\n\nThe distance between centers of neighboring hexagons, in pixels; defaults to 20. Should match the bin_width of any corresponding hexbin mark for proper alignment.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions. Note that this is a stroke-only mark, so fill options will not be effective.\n\n\n\n\nwaffle_x\nA waffleX mark that creates horizontal waffle charts.\nWaffle charts are a form of unit chart where data is represented as a grid of small squares or rectangles, useful for showing part-to-whole relationships and making proportions more tangible.\n\nSource\n\ndef waffle_x(\n    data: Data,\n    x: ChannelIntervalSpec | Param,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y: ChannelIntervalSpec | Param | None = None,\n    z: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    multiple: float | Param | None = None,\n    unit: float | Param | None = None,\n    gap: float | Param | None = None,\n    round: bool | Param | None = None,\n    interval: Interval | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: float | Param | None = None,\n    ry: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelIntervalSpec | Param\n\nThe horizontal position channel, typically bound to the x scale.\n\nx1 ChannelSpec | Param | None\n\nThe starting horizontal position channel, typically bound to the x scale.\n\nx2 ChannelSpec | Param | None\n\nThe ending horizontal position channel, typically bound to the x scale.\n\ny ChannelIntervalSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nz ChannelSpec | Param | None\n\nThe z channel defines the series of each value in the stack.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\nmultiple float | Param | None\n\nThe number of units per tile; defaults to 1.\n\nunit float | Param | None\n\nThe size of each unit in the waffle; defaults to 1.\n\ngap float | Param | None\n\nThe gap between waffle units; defaults to 1.\n\nround bool | Param | None\n\nWhether to round values to the nearest unit; defaults to false.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\nrx float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage.\n\nry float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nwaffle_y\nA waffleY mark that creates vertical waffle charts.\nWaffle charts are a form of unit chart where data is represented as a grid of small squares or rectangles, useful for showing part-to-whole relationships and making proportions more tangible.\n\nSource\n\ndef waffle_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    x: ChannelSpec | Param | None = None,\n    z: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    multiple: float | Param | None = None,\n    unit: float | Param | None = None,\n    gap: float | Param | None = None,\n    round: bool | Param | None = None,\n    interval: Interval | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: float | Param | None = None,\n    ry: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale.\n\ny1 ChannelSpec | Param | None\n\nThe starting vertical position channel, typically bound to the y scale.\n\ny2 ChannelSpec | Param | None\n\nThe ending vertical position channel, typically bound to the y scale.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\nz ChannelSpec | Param | None\n\nThe z channel defines the series of each value in the stack.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\nmultiple float | Param | None\n\nThe number of units per tile; defaults to 1.\n\nunit float | Param | None\n\nThe size of each unit in the waffle; defaults to 1.\n\ngap float | Param | None\n\nThe gap between waffle units; defaults to 1.\n\nround bool | Param | None\n\nWhether to round values to the nearest unit; defaults to false.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\nrx float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage.\n\nry float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.mark"
    ]
  },
  {
    "objectID": "reference/inspect_viz.mark.html#specialized",
    "href": "reference/inspect_viz.mark.html#specialized",
    "title": "inspect_viz.mark",
    "section": "Specialized",
    "text": "Specialized\n\nraster\nCreate a raster mark for spatial samples with optional interpolation and smoothing.\nThe raster mark bins spatial data into a raster grid and optionally applies spatial interpolation and kernel density smoothing. The raster mark is useful for visualizing continuous spatial phenomena from discrete sample points.\n\nSource\n\ndef raster(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    filter_by: Selection | None = None,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    pixel_size: float | Param | None = None,\n    pad: float | Param | None = None,\n    interpolate: Interpolate | Param | None = None,\n    bandwidth: float | Param | None = None,\n    image_rendering: str | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale. Domain values are binned into a grid with width horizontal bins.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale. Domain values are binned into a grid with height vertical bins.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nwidth float | Param | None\n\nThe width (number of columns) of the grid, in actual pixels.\n\nheight float | Param | None\n\nThe height (number of rows) of the grid, in actual pixels.\n\npixel_size float | Param | None\n\nThe effective screen size of a raster pixel, used to determine the height and width of the raster from the frame’s dimensions; defaults to 1.\n\npad float | Param | None\n\nThe bin padding, one of 1 (default) to include extra padding for the final bin, or 0 to make the bins flush with the maximum domain value.\n\ninterpolate Interpolate | Param | None\n\nThe spatial interpolation method; one of: - none - do not perform interpolation (the default) - linear - apply proportional linear interpolation across adjacent bins - nearest - assign each pixel to the closest sample’s value (Voronoi diagram) - barycentric - apply barycentric interpolation over the Delaunay triangulation - random-walk - apply a random walk from each pixel\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels.\n\nimage_rendering str | Param | None\n\nThe image-rendering attribute; defaults to auto (bilinear). May be set to pixelated to disable bilinear interpolation for a sharper image.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nraster_tile\nCreate an experimental raster tile mark with tiling and prefetching for scalable rasters.\nThe rasterTile mark is an experimental version of the raster mark that supports tiling and prefetching for better performance with large datasets. It provides scalable raster visualization with efficient memory usage.\n\nSource\n\ndef raster_tile(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    filter_by: Selection | None = None,\n    origin: list[float] | Param | None = None,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    pixel_size: float | Param | None = None,\n    pad: float | Param | None = None,\n    interpolate: Interpolate | Param | None = None,\n    bandwidth: float | Param | None = None,\n    image_rendering: str | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale. Domain values are binned into a grid with width horizontal bins.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale. Domain values are binned into a grid with height vertical bins.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\norigin list[float] | Param | None\n\nThe coordinates of the tile origin in the x and y data domains; defaults to [0, 0].\n\nwidth float | Param | None\n\nThe width (number of columns) of the grid, in actual pixels.\n\nheight float | Param | None\n\nThe height (number of rows) of the grid, in actual pixels.\n\npixel_size float | Param | None\n\nThe effective screen size of a raster pixel, used to determine the height and width of the raster from the frame’s dimensions; defaults to 1.\n\npad float | Param | None\n\nThe bin padding, one of 1 (default) to include extra padding for the final bin, or 0 to make the bins flush with the maximum domain value.\n\ninterpolate Interpolate | Param | None\n\nThe spatial interpolation method; one of: - none - do not perform interpolation (the default) - linear - apply proportional linear interpolation across adjacent bins - nearest - assign each pixel to the closest sample’s value (Voronoi diagram) - barycentric - apply barycentric interpolation over the Delaunay triangulation - random-walk - apply a random walk from each pixel\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels.\n\nimage_rendering str | Param | None\n\nThe image-rendering attribute; defaults to auto (bilinear). May be set to pixelated to disable bilinear interpolation for a sharper image.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nvector\nA vector mark that draws arrows or other directional shapes.\nVectors are typically used to represent direction and magnitude in data, such as wind vectors, force fields, or gradients.\n\nSource\n\ndef vector(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    length: ChannelSpec | float | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    shape: Literal[\"arrow\", \"spike\"] | Param | None = None,\n    anchor: Literal[\"start\", \"middle\", \"end\"] | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nr ChannelSpec | float | Param | None\n\nThe radius or magnitude channel; either a constant or a channel.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\nlength ChannelSpec | float | Param | None\n\nThe length of the vector; either a constant or a channel.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise; either a constant or a channel.\n\nshape Literal['arrow', 'spike'] | Param | None\n\nThe shape of the vector; one of “arrow” or “spike”.\n\nanchor Literal['start', 'middle', 'end'] | Param | None\n\nThe anchor position; one of “start”, “middle”, or “end”.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor position for legend placement.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nvector_x\nA vectorX mark that draws horizontal directional vectors.\nVectorX marks are oriented primarily along the x-axis and are useful for showing horizontal flow or direction.\n\nSource\n\ndef vector_x(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    length: ChannelSpec | float | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    shape: Literal[\"arrow\", \"spike\"] | Param | None = None,\n    anchor: Literal[\"start\", \"middle\", \"end\"] | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nr ChannelSpec | float | Param | None\n\nThe radius or magnitude channel; either a constant or a channel.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\nlength ChannelSpec | float | Param | None\n\nThe length of the vector; either a constant or a channel.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise; either a constant or a channel.\n\nshape Literal['arrow', 'spike'] | Param | None\n\nThe shape of the vector; one of “arrow” or “spike”.\n\nanchor Literal['start', 'middle', 'end'] | Param | None\n\nThe anchor position; one of “start”, “middle”, or “end”.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor position for legend placement.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nvector_y\nA vectorY mark that draws vertical directional vectors.\nVectorY marks are oriented primarily along the y-axis and are useful for showing vertical flow or direction.\n\nSource\n\ndef vector_y(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    length: ChannelSpec | float | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    shape: Literal[\"arrow\", \"spike\"] | Param | None = None,\n    anchor: Literal[\"start\", \"middle\", \"end\"] | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nr ChannelSpec | float | Param | None\n\nThe radius or magnitude channel; either a constant or a channel.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\nlength ChannelSpec | float | Param | None\n\nThe length of the vector; either a constant or a channel.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise; either a constant or a channel.\n\nshape Literal['arrow', 'spike'] | Param | None\n\nThe shape of the vector; one of “arrow” or “spike”.\n\nanchor Literal['start', 'middle', 'end'] | Param | None\n\nThe anchor position; one of “start”, “middle”, or “end”.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor position for legend placement.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nspike\nA spike mark that draws spike-shaped directional indicators.\nSpikes are a specialized type of vector that typically appear as thin lines or needles, useful for showing precise directional data or impulses.\n\nSource\n\ndef spike(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    length: ChannelSpec | float | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    shape: Literal[\"arrow\", \"spike\"] | Param | None = None,\n    anchor: Literal[\"start\", \"middle\", \"end\"] | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    filter_by: Selection | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nr ChannelSpec | float | Param | None\n\nThe radius or magnitude channel; either a constant or a channel.\n\nlength ChannelSpec | float | Param | None\n\nThe length of the spike; either a constant or a channel.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise; either a constant or a channel.\n\nshape Literal['arrow', 'spike'] | Param | None\n\nThe shape of the spike; one of “arrow” or “spike”.\n\nanchor Literal['start', 'middle', 'end'] | Param | None\n\nThe anchor position; one of “start”, “middle”, or “end”.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor position for legend placement.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\narrow\nAn arrow mark.\nThe arrow mark draws arrows between two points, with customizable arrowheads and curved paths. It is useful for indicating direction, flow, or relationships between data points.\n\nSource\n\ndef arrow(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    x1: ChannelSpec | Param | None = None,\n    y1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    bend: float | bool | Param | None = None,\n    head_angle: float | Param | None = None,\n    head_length: float | Param | None = None,\n    inset: float | Param | None = None,\n    inset_start: float | Param | None = None,\n    inset_end: float | Param | None = None,\n    sweep: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, shorthand for both x1 and x2.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, shorthand for both y1 and y2.\n\nx1 ChannelSpec | Param | None\n\nThe starting horizontal position of the arrow.\n\ny1 ChannelSpec | Param | None\n\nThe starting vertical position of the arrow.\n\nx2 ChannelSpec | Param | None\n\nThe ending horizontal position of the arrow.\n\ny2 ChannelSpec | Param | None\n\nThe ending vertical position of the arrow.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nbend float | bool | Param | None\n\nThe angle between straight line and outgoing tangent (±90°, use True for 22.5°).\n\nhead_angle float | Param | None\n\nHow pointy the arrowhead is in degrees (0°-180°, defaults to 60°).\n\nhead_length float | Param | None\n\nSize of arrowhead relative to stroke width.\n\ninset float | Param | None\n\nShorthand for both inset_start and inset_end.\n\ninset_start float | Param | None\n\nStarting inset in pixels (defaults to 0).\n\ninset_end float | Param | None\n\nEnding inset in pixels (defaults to 0).\n\nsweep float | Param | None\n\nSweep order (1=clockwise, -1=anticlockwise, 0=no bend).\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\nlink\nCreate a link mark that draws line segments between pairs of points.\nThe link mark connects pairs of points with line segments. It supports both simple positioning using x and y (which serve as shorthand for x1/x2 and y1/y2), and explicit positioning using x1/y1 and x2/y2 coordinates for full control over link endpoints.\nFor vertical links, specify x (or x1 and x2) for the horizontal position and y1 and y2 for the vertical endpoints. For horizontal links, specify y (or y1 and y2) for the vertical position and x1 and x2 for the horizontal endpoints.\n\nSource\n\ndef link(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    x1: ChannelSpec | Param | None = None,\n    y1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position for vertical links; shorthand for x1 and x2.\n\ny ChannelSpec | Param | None\n\nThe vertical position for horizontal links; shorthand for y1 and y2.\n\nx1 ChannelSpec | Param | None\n\nThe starting horizontal position; also sets default for x2.\n\ny1 ChannelSpec | Param | None\n\nThe starting vertical position; also sets default for y2.\n\nx2 ChannelSpec | Param | None\n\nThe ending horizontal position; also sets default for x1.\n\ny2 ChannelSpec | Param | None\n\nThe ending vertical position; also sets default for y1.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve interpolation method for connecting adjacent points. Recommended for links: linear, step, step-after, step-before, bump-x, bump-y.\n\ntension float | Param | None\n\nThe tension option only has an effect on bundle, cardinal and Catmull–Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ndelaunay_link\nCreate a Delaunay link mark that draws links for each edge of the Delaunay triangulation.\nThe delaunayLink mark computes the Delaunay triangulation of the data and draws a line segment for each edge of the triangulation. This is useful for visualizing spatial relationships and adjacencies in scattered point data.\n\nSource\n\ndef delaunay_link(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping to produce multiple (possibly overlapping) triangulations.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve interpolation method; defaults to linear.\n\ntension float | Param | None\n\nThe tension option only has an effect on bundle, cardinal and Catmull–Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ndelaunay_mesh\nCreate a Delaunay mesh mark that draws a mesh of the Delaunay triangulation.\nThe delaunayMesh mark computes the Delaunay triangulation of the data and draws filled triangular polygons for each triangle in the triangulation. This creates a continuous mesh surface useful for spatial interpolation and surface visualization.\n\nSource\n\ndef delaunay_mesh(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping to produce multiple (possibly overlapping) triangulations.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve interpolation method; defaults to linear.\n\ntension float | Param | None\n\nThe tension option only has an effect on bundle, cardinal and Catmull–Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nvoronoi\nCreate a Voronoi mark that draws polygons for each cell of the Voronoi tessellation.\nThe voronoi mark computes the Voronoi tessellation (also known as Thiessen polygons) of the data points and draws filled polygons for each cell. Each cell contains all points that are closer to the cell’s generator point than to any other generator.\n\nSource\n\ndef voronoi(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping to produce multiple tessellations.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve interpolation method; defaults to linear.\n\ntension float | Param | None\n\nThe tension option only has an effect on bundle, cardinal and Catmull–Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nvoronoi_mesh\nCreate a Voronoi mesh mark that draws a mesh for the cell boundaries of the Voronoi tessellation.\nThe voronoiMesh mark computes the Voronoi tessellation of the data points and draws line segments for the boundaries between cells. This creates a mesh of cell edges useful for visualizing the spatial partitioning without filled polygons.\n\nSource\n\ndef voronoi_mesh(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping to produce multiple tessellations.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve interpolation method; defaults to linear.\n\ntension float | Param | None\n\nThe tension option only has an effect on bundle, cardinal and Catmull–Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nhull\nCreate a hull mark that draws a convex hull around points.\nThe hull mark computes the convex hull of the data points and draws a polygon representing the smallest convex shape that contains all the points. This is useful for showing the overall extent or boundary of a point cloud.\n\nSource\n\ndef hull(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    curve: Curve | Param | None = None,\n    tension: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping to produce multiple hulls; defaults to fill or stroke channel if not specified.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nmarker Marker | bool | Param | None\n\nShorthand to set the same default for marker_start, marker_mid, and marker_end.\n\nmarker_start Marker | bool | Param | None\n\nThe marker for the starting point of a line segment.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker for any middle (interior) points of a line segment.\n\nmarker_end Marker | bool | Param | None\n\nThe marker for the ending point of a line segment.\n\ncurve Curve | Param | None\n\nThe curve interpolation method; defaults to linear.\n\ntension float | Param | None\n\nThe tension option only has an effect on bundle, cardinal and Catmull–Rom splines.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ndense_line\nCreate a dense line mark that plots line densities rather than point densities.\nThe denseLine mark forms a binned raster grid and “draws” straight lines into it, creating a density visualization of line segments rather than individual points. This is useful for visualizing the density of linear features, trajectories, or paths in spatial data.\nThe mark bins the data into a 2D grid and renders density values as a raster image. Unlike traditional line marks that use curve interpolation, dense lines operate on a pixel grid to accumulate line density information.\n\nSource\n\ndef dense_line(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    bandwidth: float | Param | None = None,\n    normalize: bool | Param | None = None,\n    interpolate: Interpolate | Param | None = None,\n    width: float | Param | None = None,\n    height: float | Param | None = None,\n    pixel_size: float | Param | None = None,\n    pad: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale. Domain values are binned into a grid with width horizontal bins.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale. Domain values are binned into a grid with height vertical bins.\n\nz Channel | Param | None\n\nAn ordinal channel for grouping data into series to be drawn as separate lines.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nbandwidth float | Param | None\n\nThe kernel density bandwidth for smoothing, in pixels.\n\nnormalize bool | Param | None\n\nFlag to perform approximate arc length normalization of line segments to prevent artifacts due to overcounting steep lines; defaults to True.\n\ninterpolate Interpolate | Param | None\n\nThe spatial interpolation method; one of: - none - do not perform interpolation (the default) - linear - apply proportional linear interpolation across adjacent bins - nearest - assign each pixel to the closest sample’s value (Voronoi diagram) - barycentric - apply barycentric interpolation over the Delaunay triangulation - random-walk - apply a random walk from each pixel\n\nwidth float | Param | None\n\nThe width (number of columns) of the grid, in actual pixels.\n\nheight float | Param | None\n\nThe height (number of rows) of the grid, in actual pixels.\n\npixel_size float | Param | None\n\nThe effective screen size of a raster pixel, used to determine the height and width of the raster from the frame’s dimensions; defaults to 1.\n\npad float | Param | None\n\nThe bin padding, one of 1 (default) to include extra padding for the final bin, or 0 to make the bins flush with the maximum domain value.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions. Note that fill and fillOpacity can use the special value “density” to map computed density values to visual properties.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.mark"
    ]
  },
  {
    "objectID": "reference/inspect_viz.mark.html#decoration",
    "href": "reference/inspect_viz.mark.html#decoration",
    "title": "inspect_viz.mark",
    "section": "Decoration",
    "text": "Decoration\n\nframe\nCreate a frame mark that draws a rectangular outline around the plot area.\nThe frame mark draws a rectangular border around the plot’s frame area. By default, it draws a complete rectangular outline, but when an anchor is specified, it draws only a line on the given side (ignoring rx, ry, fill, and fillOpacity).\nThe frame mark is commonly used for visual separation of facets, providing backgrounds for plot areas, or creating borders around visualizations.\n\nSource\n\ndef frame(\n    anchor: Literal[\"top\", \"right\", \"bottom\", \"left\"] | Param | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: str | float | Param | None = None,\n    ry: str | float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\nanchor Literal['top', 'right', 'bottom', 'left'] | Param | None\n\nControls how the frame is drawn. If null (default), draws a complete rectangular outline. If specified, draws a line only on the given side (top, right, bottom, or left), ignoring rx, ry, fill, and fillOpacity.\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels. A positive value insets towards the bottom edge (reducing effective area), while a negative value insets away from the bottom edge (increasing it).\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels. A positive value insets towards the left edge (reducing effective area), while a negative value insets away from the left edge (increasing it).\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels. A positive value insets towards the top edge (reducing effective area), while a negative value insets away from the top edge (increasing it).\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels. A positive value insets towards the right edge (reducing effective area), while a negative value insets away from the right edge (increasing it).\n\nrx str | float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the frame width. If rx is not specified, it defaults to ry if present, and otherwise draws square corners.\n\nry str | float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage of the frame height. If ry is not specified, it defaults to rx if present, and otherwise draws square corners.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\naxis_x\nA horizontal axis mark.\nThe axisX mark draws a horizontal axis at the bottom or top of the plot (or both). It is primarily used for displaying scales and reference lines along the x-axis.\n\nSource\n\ndef axis_x(\n    x: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    text: ChannelSpec | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    line_anchor: str | Param | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    text_stroke: ChannelSpec | Param | None = None,\n    text_stroke_opacity: ChannelSpec | float | Param | None = None,\n    text_stroke_width: ChannelSpec | float | Param | None = None,\n    styles: TextStyles | None = None,\n    anchor: str | Param | None = None,\n    color: ChannelSpec | str | Param | None = None,\n    ticks: int | Sequence[Any] | Param | None = None,\n    tick_spacing: float | Param | None = None,\n    tick_size: float | Param | None = None,\n    tick_padding: float | Param | None = None,\n    tick_format: str | Param | None = None,\n    tick_rotate: float | Param | None = None,\n    label: str | Param | None = None,\n    label_offset: float | Param | None = None,\n    label_anchor: str | Param | None = None,\n    label_arrow: str | bool | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\ntext ChannelSpec | Param | None\n\nThe text channel for tick labels.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame.\n\nline_anchor str | Param | None\n\nThe line anchor controls how text is aligned relative to its anchor point.\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle of the axis in degrees clockwise.\n\ntext_stroke ChannelSpec | Param | None\n\nThe stroke color for text labels.\n\ntext_stroke_opacity ChannelSpec | float | Param | None\n\nThe stroke opacity for text labels.\n\ntext_stroke_width ChannelSpec | float | Param | None\n\nThe stroke width for text labels.\n\nstyles TextStyles | None\n\nTextStyles to apply to axis text.\n\nanchor str | Param | None\n\nThe side of the frame on which to place the axis (top or bottom).\n\ncolor ChannelSpec | str | Param | None\n\nShorthand for setting both fill and stroke color.\n\nticks int | Sequence[Any] | Param | None\n\nThe desired number of ticks, or an array of tick values, or null to disable ticks.\n\ntick_spacing float | Param | None\n\nThe desired spacing between ticks in pixels.\n\ntick_size float | Param | None\n\nThe length of tick marks in pixels.\n\ntick_padding float | Param | None\n\nThe distance between the tick mark and its label in pixels.\n\ntick_format str | Param | None\n\nA d3-format string for formatting tick labels.\n\ntick_rotate float | Param | None\n\nThe rotation angle of tick labels in degrees clockwise.\n\nlabel str | Param | None\n\nThe axis label text.\n\nlabel_offset float | Param | None\n\nThe distance between the axis and its label in pixels.\n\nlabel_anchor str | Param | None\n\nThe label anchor position.\n\nlabel_arrow str | bool | Param | None\n\nWhether to show an arrow on the axis label.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\naxis_y\nA vertical axis mark.\nThe axisY mark draws a vertical axis at the left or right of the plot (or both). It is primarily used for displaying scales and reference lines along the y-axis.\n\nSource\n\ndef axis_y(\n    y: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    text: ChannelSpec | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    line_anchor: str | Param | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    text_stroke: ChannelSpec | Param | None = None,\n    text_stroke_opacity: ChannelSpec | float | Param | None = None,\n    text_stroke_width: ChannelSpec | float | Param | None = None,\n    styles: TextStyles | None = None,\n    anchor: str | Param | None = None,\n    color: ChannelSpec | str | Param | None = None,\n    ticks: int | Sequence[Any] | Param | None = None,\n    tick_spacing: float | Param | None = None,\n    tick_size: float | Param | None = None,\n    tick_padding: float | Param | None = None,\n    tick_format: str | Param | None = None,\n    tick_rotate: float | Param | None = None,\n    label: str | Param | None = None,\n    label_offset: float | Param | None = None,\n    label_anchor: str | Param | None = None,\n    label_arrow: str | bool | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\ntext ChannelSpec | Param | None\n\nThe text channel for tick labels.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame.\n\nline_anchor str | Param | None\n\nThe line anchor controls how text is aligned relative to its anchor point.\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle of the axis in degrees clockwise.\n\ntext_stroke ChannelSpec | Param | None\n\nThe stroke color for text labels.\n\ntext_stroke_opacity ChannelSpec | float | Param | None\n\nThe stroke opacity for text labels.\n\ntext_stroke_width ChannelSpec | float | Param | None\n\nThe stroke width for text labels.\n\nstyles TextStyles | None\n\nTextStyles to apply to axis text.\n\nanchor str | Param | None\n\nThe side of the frame on which to place the axis (left or right).\n\ncolor ChannelSpec | str | Param | None\n\nShorthand for setting both fill and stroke color.\n\nticks int | Sequence[Any] | Param | None\n\nThe desired number of ticks, or an array of tick values, or null to disable ticks.\n\ntick_spacing float | Param | None\n\nThe desired spacing between ticks in pixels.\n\ntick_size float | Param | None\n\nThe length of tick marks in pixels.\n\ntick_padding float | Param | None\n\nThe distance between the tick mark and its label in pixels.\n\ntick_format str | Param | None\n\nA d3-format string for formatting tick labels.\n\ntick_rotate float | Param | None\n\nThe rotation angle of tick labels in degrees clockwise.\n\nlabel str | Param | None\n\nThe axis label text.\n\nlabel_offset float | Param | None\n\nThe distance between the axis and its label in pixels.\n\nlabel_anchor str | Param | None\n\nThe label anchor position.\n\nlabel_arrow str | bool | Param | None\n\nWhether to show an arrow on the axis label.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\naxis_fx\nA horizontal facet axis mark.\nThe axisFx mark draws a horizontal axis for faceted plots. It is primarily used for displaying scales and reference lines along the fx-axis in faceted visualizations.\n\nSource\n\ndef axis_fx(\n    x: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    text: ChannelSpec | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    line_anchor: str | Param | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    text_stroke: ChannelSpec | Param | None = None,\n    text_stroke_opacity: ChannelSpec | float | Param | None = None,\n    text_stroke_width: ChannelSpec | float | Param | None = None,\n    styles: TextStyles | None = None,\n    anchor: str | Param | None = None,\n    color: ChannelSpec | str | Param | None = None,\n    ticks: int | Sequence[Any] | Param | None = None,\n    tick_spacing: float | Param | None = None,\n    tick_size: float | Param | None = None,\n    tick_padding: float | Param | None = None,\n    tick_format: str | Param | None = None,\n    tick_rotate: float | Param | None = None,\n    label: str | Param | None = None,\n    label_offset: float | Param | None = None,\n    label_anchor: str | Param | None = None,\n    label_arrow: str | bool | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\ntext ChannelSpec | Param | None\n\nThe text channel for tick labels.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame.\n\nline_anchor str | Param | None\n\nThe line anchor controls how text is aligned relative to its anchor point.\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle of the axis in degrees clockwise.\n\ntext_stroke ChannelSpec | Param | None\n\nThe stroke color for text labels.\n\ntext_stroke_opacity ChannelSpec | float | Param | None\n\nThe stroke opacity for text labels.\n\ntext_stroke_width ChannelSpec | float | Param | None\n\nThe stroke width for text labels.\n\nstyles TextStyles | None\n\nTextStyles to apply to axis text.\n\nanchor str | Param | None\n\nThe side of the frame on which to place the axis (top or bottom).\n\ncolor ChannelSpec | str | Param | None\n\nShorthand for setting both fill and stroke color.\n\nticks int | Sequence[Any] | Param | None\n\nThe desired number of ticks, or an array of tick values, or null to disable ticks.\n\ntick_spacing float | Param | None\n\nThe desired spacing between ticks in pixels.\n\ntick_size float | Param | None\n\nThe length of tick marks in pixels.\n\ntick_padding float | Param | None\n\nThe distance between the tick mark and its label in pixels.\n\ntick_format str | Param | None\n\nA d3-format string for formatting tick labels.\n\ntick_rotate float | Param | None\n\nThe rotation angle of tick labels in degrees clockwise.\n\nlabel str | Param | None\n\nThe axis label text.\n\nlabel_offset float | Param | None\n\nThe distance between the axis and its label in pixels.\n\nlabel_anchor str | Param | None\n\nThe label anchor position.\n\nlabel_arrow str | bool | Param | None\n\nWhether to show an arrow on the axis label.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\naxis_fy\nA vertical facet axis mark.\nThe axisFy mark draws a vertical axis for faceted plots. It is primarily used for displaying scales and reference lines along the fy-axis in faceted visualizations.\n\nSource\n\ndef axis_fy(\n    y: ChannelSpec | Param | None = None,\n    interval: Interval | None = None,\n    text: ChannelSpec | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    line_anchor: str | Param | None = None,\n    rotate: ChannelSpec | float | Param | None = None,\n    text_stroke: ChannelSpec | Param | None = None,\n    text_stroke_opacity: ChannelSpec | float | Param | None = None,\n    text_stroke_width: ChannelSpec | float | Param | None = None,\n    styles: TextStyles | None = None,\n    anchor: str | Param | None = None,\n    color: ChannelSpec | str | Param | None = None,\n    ticks: int | Sequence[Any] | Param | None = None,\n    tick_spacing: float | Param | None = None,\n    tick_size: float | Param | None = None,\n    tick_padding: float | Param | None = None,\n    tick_format: str | Param | None = None,\n    tick_rotate: float | Param | None = None,\n    label: str | Param | None = None,\n    label_offset: float | Param | None = None,\n    label_anchor: str | Param | None = None,\n    label_arrow: str | bool | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\ntext ChannelSpec | Param | None\n\nThe text channel for tick labels.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame.\n\nline_anchor str | Param | None\n\nThe line anchor controls how text is aligned relative to its anchor point.\n\nrotate ChannelSpec | float | Param | None\n\nThe rotation angle of the axis in degrees clockwise.\n\ntext_stroke ChannelSpec | Param | None\n\nThe stroke color for text labels.\n\ntext_stroke_opacity ChannelSpec | float | Param | None\n\nThe stroke opacity for text labels.\n\ntext_stroke_width ChannelSpec | float | Param | None\n\nThe stroke width for text labels.\n\nstyles TextStyles | None\n\nTextStyles to apply to axis text.\n\nanchor str | Param | None\n\nThe side of the frame on which to place the axis (left or right).\n\ncolor ChannelSpec | str | Param | None\n\nShorthand for setting both fill and stroke color.\n\nticks int | Sequence[Any] | Param | None\n\nThe desired number of ticks, or an array of tick values, or null to disable ticks.\n\ntick_spacing float | Param | None\n\nThe desired spacing between ticks in pixels.\n\ntick_size float | Param | None\n\nThe length of tick marks in pixels.\n\ntick_padding float | Param | None\n\nThe distance between the tick mark and its label in pixels.\n\ntick_format str | Param | None\n\nA d3-format string for formatting tick labels.\n\ntick_rotate float | Param | None\n\nThe rotation angle of tick labels in degrees clockwise.\n\nlabel str | Param | None\n\nThe axis label text.\n\nlabel_offset float | Param | None\n\nThe distance between the axis and its label in pixels.\n\nlabel_anchor str | Param | None\n\nThe label anchor position.\n\nlabel_arrow str | bool | Param | None\n\nWhether to show an arrow on the axis label.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\nrule_x\nA ruleX mark that draws horizontal rule lines.\nRuleX marks are horizontal lines that span the full extent of the plot area, typically used for reference lines, grid lines, or highlighting specific values.\n\nSource\n\ndef rule_x(\n    data: Data | None = None,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelIntervalSpec | Param | None = None,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    interval: Interval | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    inset: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data | None\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelIntervalSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\ny1 ChannelSpec | Param | None\n\nThe primary (starting, often bottom) vertical position of the tick; a channel bound to the y scale.\n\ny2 ChannelSpec | Param | None\n\nThe secondary (ending, often top) vertical position of the tick; a channel bound to the y scale.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\nmarker Marker | bool | Param | None\n\nThe marker symbol to use at all positions along the rule.\n\nmarker_start Marker | bool | Param | None\n\nThe marker symbol to use at the start of the rule.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker symbol to use at the middle of the rule.\n\nmarker_end Marker | bool | Param | None\n\nThe marker symbol to use at the end of the rule.\n\ninset float | Param | None\n\nSet top and bottom insets.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nrule_y\nA ruleY mark that draws vertical rule lines.\nRuleY marks are vertical lines that span the full extent of the plot area, typically used for reference lines, grid lines, or highlighting specific values.\n\nSource\n\ndef rule_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    x: ChannelIntervalSpec | Param | None = None,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    interval: Interval | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    inset: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale.\n\nx ChannelIntervalSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\nx1 ChannelSpec | Param | None\n\nThe primary (starting, often left) horizontal position of the tick; a channel bound to the x scale.\n\nx2 ChannelSpec | Param | None\n\nThe secondary (ending, often right) horizontal position of the tick; a channel bound to the x scale.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval.\n\nmarker Marker | bool | Param | None\n\nThe marker symbol to use at all positions along the rule.\n\nmarker_start Marker | bool | Param | None\n\nThe marker symbol to use at the start of the rule.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker symbol to use at the middle of the rule.\n\nmarker_end Marker | bool | Param | None\n\nThe marker symbol to use at the end of the rule.\n\ninset float | Param | None\n\nSet left and right insets.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ntick_x\nA tickX mark that draws horizontal tick marks.\nTickX marks are horizontal lines typically used for marking positions along the x-axis or creating horizontal reference lines.\n\nSource\n\ndef tick_x(\n    data: Data,\n    x: ChannelSpec | Param,\n    y: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\nmarker Marker | bool | Param | None\n\nThe marker symbol to use at all positions along the tick.\n\nmarker_start Marker | bool | Param | None\n\nThe marker symbol to use at the start of the tick.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker symbol to use at the middle of the tick.\n\nmarker_end Marker | bool | Param | None\n\nThe marker symbol to use at the end of the tick.\n\ninset float | Param | None\n\nShorthand to set the same default for top and bottom insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ntick_y\nA tickY mark that draws vertical tick marks.\nTickY marks are vertical lines typically used for marking positions along the y-axis or creating vertical reference lines.\n\nSource\n\ndef tick_y(\n    data: Data,\n    y: ChannelSpec | Param,\n    x: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    marker: Marker | bool | Param | None = None,\n    marker_start: Marker | bool | Param | None = None,\n    marker_mid: Marker | bool | Param | None = None,\n    marker_end: Marker | bool | Param | None = None,\n    inset: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position channel, typically bound to the y scale.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\nmarker Marker | bool | Param | None\n\nThe marker symbol to use at all positions along the tick.\n\nmarker_start Marker | bool | Param | None\n\nThe marker symbol to use at the start of the tick.\n\nmarker_mid Marker | bool | Param | None\n\nThe marker symbol to use at the middle of the tick.\n\nmarker_end Marker | bool | Param | None\n\nThe marker symbol to use at the end of the tick.\n\ninset float | Param | None\n\nShorthand to set the same default for left and right insets.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nrect\nA rect mark that draws axis-aligned rectangles.\nBoth x and y should be quantitative or temporal; rect does not perform grouping, so use rectX or rectY for ordinal data.\n\nSource\n\ndef rect(\n    data: Data,\n    x: ChannelIntervalSpec | Param | None = None,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y: ChannelIntervalSpec | Param | None = None,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    interval: Interval | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: float | Param | None = None,\n    ry: float | Param | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelIntervalSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\nx1 ChannelSpec | Param | None\n\nThe starting horizontal position channel, typically bound to the x scale.\n\nx2 ChannelSpec | Param | None\n\nThe ending horizontal position channel, typically bound to the x scale.\n\ny ChannelIntervalSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\ny1 ChannelSpec | Param | None\n\nThe starting vertical position channel, typically bound to the y scale.\n\ny2 ChannelSpec | Param | None\n\nThe ending vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nThe z channel defines the series of each value in the stack\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval; one of: - a named time interval such as day (for date intervals) - a number (for number intervals), defining intervals at integer multiples of n\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\nrx float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the rect width.\n\nry float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage of the rect height.\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of: - null (default) for input order - a named stack order method such as inside-out or sum - a field name, for natural order of the corresponding values - a function of data, for natural order of the corresponding values - an array of explicit z values in the desired order.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nrect_x\nA rectX mark that draws axis-aligned rectangles.\nThe x values should be quantitative or temporal, and the optional y values should be ordinal.\n\nSource\n\ndef rect_x(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y: ChannelIntervalSpec | Param | None = None,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    interval: Interval | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: float | Param | None = None,\n    ry: float | Param | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\nx1 ChannelSpec | Param | None\n\nThe starting horizontal position channel, typically bound to the x scale.\n\nx2 ChannelSpec | Param | None\n\nThe ending horizontal position channel, typically bound to the x scale.\n\ny ChannelIntervalSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\ny1 ChannelSpec | Param | None\n\nThe starting vertical position channel, typically bound to the y scale.\n\ny2 ChannelSpec | Param | None\n\nThe ending vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nThe z channel defines the series of each value in the stack.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval; one of: - a named time interval such as day (for date intervals) - a number (for number intervals), defining intervals at integer multiples of n\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\nrx float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the rect width.\n\nry float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage of the rect height.\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of: - null (default) for input order - a named stack order method such as inside-out or sum - a field name, for natural order of the corresponding values - a function of data, for natural order of the corresponding values - an array of explicit z values in the desired order\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\nrect_y\nA rectY mark that draws axis-aligned rectangles.\nThe y values should be quantitative or temporal, and the optional x values should be ordinal.\n\nSource\n\ndef rect_y(\n    data: Data,\n    x: ChannelIntervalSpec | Param | None = None,\n    x1: ChannelSpec | Param | None = None,\n    x2: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    y1: ChannelSpec | Param | None = None,\n    y2: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    interval: Interval | None = None,\n    inset: float | Param | None = None,\n    inset_top: float | Param | None = None,\n    inset_right: float | Param | None = None,\n    inset_bottom: float | Param | None = None,\n    inset_left: float | Param | None = None,\n    rx: float | Param | None = None,\n    ry: float | Param | None = None,\n    offset: Literal[\"center\", \"normalize\", \"wiggle\"] | Param | None = None,\n    order: Literal[\"value\", \"x\", \"y\", \"z\", \"sum\", \"appearance\", \"inside-out\"]\n    | str\n    | Sequence[float | bool]\n    | Param\n    | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelIntervalSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\nx1 ChannelSpec | Param | None\n\nThe starting horizontal position channel, typically bound to the x scale.\n\nx2 ChannelSpec | Param | None\n\nThe ending horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\ny1 ChannelSpec | Param | None\n\nThe starting vertical position channel, typically bound to the y scale.\n\ny2 ChannelSpec | Param | None\n\nThe ending vertical position channel, typically bound to the y scale.\n\nz Channel | Param | None\n\nThe z channel defines the series of each value in the stack.\n\nfilter_by Selection | None\n\nA selection to filter the data.\n\ninterval Interval | None\n\nHow to convert a continuous value into an interval; one of: - a named time interval such as day (for date intervals) - a number (for number intervals), defining intervals at integer multiples of n\n\ninset float | Param | None\n\nShorthand to set the same default for all four insets.\n\ninset_top float | Param | None\n\nInsets the top edge by the specified number of pixels.\n\ninset_right float | Param | None\n\nInsets the right edge by the specified number of pixels.\n\ninset_bottom float | Param | None\n\nInsets the bottom edge by the specified number of pixels.\n\ninset_left float | Param | None\n\nInsets the left edge by the specified number of pixels.\n\nrx float | Param | None\n\nThe rounded corner x-radius, either in pixels or as a percentage of the rect width.\n\nry float | Param | None\n\nThe rounded corner y-radius, either in pixels or as a percentage of the rect height.\n\noffset Literal['center', 'normalize', 'wiggle'] | Param | None\n\nAfter stacking, an optional offset can be applied to translate and scale stacks.\n\norder Literal['value', 'x', 'y', 'z', 'sum', 'appearance', 'inside-out'] | str | Sequence[float | bool] | Param | None\n\nThe order in which stacks are layered; one of: - null (default) for input order - a named stack order method such as inside-out or sum - a field name, for natural order of the corresponding values - a function of data, for natural order of the corresponding values - an array of explicit z values in the desired order\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.\n\n\n\n\ntext\nA text mark that displays textual labels.\n\nSource\n\ndef text(\n    data: Data | None = None,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    text: Channel | Param | None = None,\n    filter_by: Selection | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    line_anchor: LineAnchor | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    styles: TextStyles | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data | None\n\nThe data source for the mark (not required if not binding text to a column).\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel specifying the text’s anchor point, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel specifying the text’s anchor point, typically bound to the y scale.\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\ntext Channel | Param | None\n\nThe text contents channel, possibly with line breaks (, , or . To place a single piece of text specify the text as a string[] (e.g. [\"My Text\"]).\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y, along with textAnchor and lineAnchor, based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\nline_anchor LineAnchor | Param | None\n\nThe line anchor controls how text is aligned (typically vertically) relative to its anchor point; it is one of top, bottom, or middle. If the frame anchor is top, top-left, or top-right, the default line anchor is top; if the frame anchor is bottom, bottom-right, or bottom-left, the default is bottom; otherwise it is middle.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise; a constant or a channel; defaults to 0°. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel.\n\nstyles TextStyles | None\n\nTextStyles to apply.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\ntext_x\nA horizontal text mark that displays textual labels.\nLike text, except that y defaults to the zero-based index of the data [0, 1, 2, …].\nIf an interval is specified, such as day, y is transformed to the middle of the interval.\n\nSource\n\ndef text_x(\n    data: Data | None,\n    x: ChannelSpec | Param,\n    y: ChannelIntervalSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    text: Channel | Param | None = None,\n    interval: Interval | Param | None = None,\n    filter_by: Selection | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    line_anchor: LineAnchor | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    styles: TextStyles | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data | None\n\nThe data source for the mark.\n\nx ChannelSpec | Param\n\nThe horizontal position channel specifying the text’s anchor point, typically bound to the x scale.\n\ny ChannelIntervalSpec | Param | None\n\nThe vertical position channel specifying the text’s anchor point, typically bound to the y scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\ntext Channel | Param | None\n\nThe text contents channel, possibly with line breaks (, , or . If not specified, defaults to the zero-based index [0, 1, 2, …].\n\ninterval Interval | Param | None\n\nAn interval (such as day or a number), to transform y values to the middle of the interval.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y, along with textAnchor and lineAnchor, based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\nline_anchor LineAnchor | Param | None\n\nThe line anchor controls how text is aligned (typically vertically) relative to its anchor point; it is one of top, bottom, or middle. If the frame anchor is top, top-left, or top-right, the default line anchor is top; if the frame anchor is bottom, bottom-right, or bottom-left, the default is bottom; otherwise it is middle.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise; a constant or a channel; defaults to 0°. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel.\n\nstyles TextStyles | None\n\nTextStyles to apply.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\ntext_y\nA vertical text mark that displays textual labels.\nLike text, except that x defaults to the zero-based index of the data [0, 1, 2, …].\nIf an interval is specified, such as day, x is transformed to the middle of the interval.\n\nSource\n\ndef text_y(\n    data: Data | None,\n    y: ChannelSpec | Param,\n    x: ChannelIntervalSpec | Param | None = None,\n    z: Channel | Param | None = None,\n    text: Channel | Param | None = None,\n    interval: Interval | Param | None = None,\n    filter_by: Selection | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    line_anchor: LineAnchor | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    styles: TextStyles | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data | None\n\nThe data source for the mark.\n\ny ChannelSpec | Param\n\nThe vertical position channel specifying the text’s anchor point, typically bound to the y scale.\n\nx ChannelIntervalSpec | Param | None\n\nThe horizontal position channel specifying the text’s anchor point, typically bound to the x scale; defaults to the zero-based index of the data [0, 1, 2, …].\n\nz Channel | Param | None\n\nAn optional ordinal channel for grouping data into series.\n\ntext Channel | Param | None\n\nThe text contents channel, possibly with line breaks (, , or . If not specified, defaults to the zero-based index [0, 1, 2, …].\n\ninterval Interval | Param | None\n\nAn interval (such as day or a number), to transform x values to the middle of the interval.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor specifies defaults for x and y, along with textAnchor and lineAnchor, based on the plot’s frame; it may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\nline_anchor LineAnchor | Param | None\n\nThe line anchor controls how text is aligned (typically vertically) relative to its anchor point; it is one of top, bottom, or middle. If the frame anchor is top, top-left, or top-right, the default line anchor is top; if the frame anchor is bottom, bottom-right, or bottom-left, the default is bottom; otherwise it is middle.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise; a constant or a channel; defaults to 0°. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel.\n\nstyles TextStyles | None\n\nTextStyles to apply.\n\n**options Unpack[MarkOptions]\n\nAdditional MarkOptions.\n\n\n\n\nimage\nCreate an image mark for displaying images in visualizations.\nThe image mark displays raster images (PNG, JPEG, etc.) at specified positions and sizes. Images can be positioned using x/y coordinates, sized with width/height, and styled with various options including aspect ratio preservation and rendering modes.\nThis mark is useful for: - Adding logos, icons, or other imagery to visualizations - Creating image-based scatter plots or dashboards - Displaying photographs or other raster content within plots\n\nSource\n\ndef image(\n    data: Data,\n    x: ChannelSpec | Param | None = None,\n    y: ChannelSpec | Param | None = None,\n    filter_by: Selection | None = None,\n    width: Channel | float | Param | None = None,\n    height: Channel | float | Param | None = None,\n    r: Channel | float | Param | None = None,\n    rotate: Channel | float | Param | None = None,\n    src: Channel | str | Param | None = None,\n    preserve_aspect_ratio: str | Param | None = None,\n    cross_origin: str | Param | None = None,\n    frame_anchor: FrameAnchor | Param | None = None,\n    image_rendering: str | Param | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\nx ChannelSpec | Param | None\n\nThe horizontal position channel, typically bound to the x scale.\n\ny ChannelSpec | Param | None\n\nThe vertical position channel, typically bound to the y scale.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\nwidth Channel | float | Param | None\n\nThe image width in pixels. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 16 if neither width nor height are set.\n\nheight Channel | float | Param | None\n\nThe image height in pixels. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel. Defaults to 16 if neither width nor height are set.\n\nr Channel | float | Param | None\n\nThe image clip radius for circular images. If null (default), images are not clipped; when a number, it is interpreted as a constant in pixels; otherwise it is interpreted as a channel.\n\nrotate Channel | float | Param | None\n\nThe rotation angle in degrees clockwise.\n\nsrc Channel | str | Param | None\n\nThe required image URL (or relative path). If a string that starts with a dot, slash, or URL protocol it is assumed to be a constant; otherwise it is interpreted as a channel.\n\npreserve_aspect_ratio str | Param | None\n\nThe image aspect ratio; defaults to “xMidYMid meet”. To crop the image instead of scaling it to fit, use “xMidYMid slice”.\n\ncross_origin str | Param | None\n\nThe cross-origin behavior for loading images from external domains.\n\nframe_anchor FrameAnchor | Param | None\n\nThe frame anchor position for legend placement.\n\nimage_rendering str | Param | None\n\nThe image-rendering attribute; defaults to “auto” (bilinear). May be set to “pixelated” to disable bilinear interpolation for a sharper image.\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.mark"
    ]
  },
  {
    "objectID": "reference/inspect_viz.mark.html#geographic",
    "href": "reference/inspect_viz.mark.html#geographic",
    "title": "inspect_viz.mark",
    "section": "Geographic",
    "text": "Geographic\n\ngeo\nCreate a geo mark for rendering geographic data.\nThe geo mark renders geographic data, typically GeoJSON objects, with support for map projections and geographic styling. It’s designed for displaying geographic features like countries, states, cities, or any spatial geometry.\n\nSource\n\ndef geo(\n    data: Data,\n    geometry: Channel | Param | None = None,\n    r: ChannelSpec | float | Param | None = None,\n    filter_by: Selection | None = None,\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\ndata Data\n\nThe data source for the mark.\n\ngeometry Channel | Param | None\n\nA channel for the geometry to render; defaults to identity, assuming data is a GeoJSON object or iterable of GeoJSON objects. Supports various geographic data types and transformations.\n\nr ChannelSpec | float | Param | None\n\nThe radius channel for point geometries, typically bound to the radius scale.\n\nfilter_by Selection | None\n\nSelection to filter by (defaults to data source selection).\n\n**options Unpack[MarkOptions]\n\nAdditional mark options from MarkOptions. Note that clip can be set to “sphere” for projection-aware clipping when using spherical projections.\n\n\n\n\ngraticule\nCreate a graticule mark that renders a global coordinate grid.\nThe graticule mark renders a 10° global graticule (coordinate grid) showing lines of longitude and latitude. This provides a reference grid for geographic visualizations and helps users understand the projection and scale.\nThis mark is particularly useful for: - Adding coordinate reference lines to world maps - Showing distortion in map projections - Providing spatial reference for geographic data\n\nSource\n\ndef graticule(\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\n**options Unpack[MarkOptions]\n\nOptions from MarkOptions. Note that this mark is designed for use with spherical projections only.\n\n\n\n\nsphere\nCreate a sphere mark that renders the outline of the projection sphere.\nThe sphere mark renders the outline of the sphere on the projection’s plane. This is typically used with spherical projections to show the boundary of the projected world. The sphere mark automatically generates the appropriate geometry for the current projection.\nThis mark is particularly useful for: - Adding a border around world maps with spherical projections - Showing the extent of the projection - Creating a background for geographic visualizations\n\nSource\n\ndef sphere(\n    **options: Unpack[MarkOptions],\n) -&gt; Mark\n\n**options Unpack[MarkOptions]\n\nOptions from MarkOptions. Note that this mark is designed for use with spherical projections only.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.mark"
    ]
  },
  {
    "objectID": "reference/inspect_viz.mark.html#types",
    "href": "reference/inspect_viz.mark.html#types",
    "title": "inspect_viz.mark",
    "section": "Types",
    "text": "Types\n\nMark\nPlot mark (create marks using mark functions, e.g. dot(), bar_x(), etc.).\n\nSource\n\nclass Mark(Component)\n\n\nMarkOptions\nShared options for all marks.\n\nSource\n\nclass MarkOptions(TypedDict, total=False)\n\nAttributes\n\nfilter Channel\n\nApplies a transform to filter the mark’s index according to the given channel values; only truthy values are retained.\n\nselect Literal['first', 'last', 'maxX', 'maxY', 'minX', 'minY', 'nearest', 'nearestX', 'nearestY']\n\nApplies a filter transform after data is loaded to highlight selected values only. For example, first and last select the first or last values of series only (using the z channel to separate series). Meanwhile, nearestX and nearestY select the point nearest to the pointer along the x or y channel dimension. Unlike Mosaic selections, a mark level select is internal to the mark only, and does not populate a param or selection value to be shared across clients.\n\nreverse bool | Param\n\nApplies a transform to reverse the order of the mark’s index, say for reverse input order.\n\nsort SortOrder\n\nSort order for a plot mark’s index.\n\nfx Channel\n\nThe horizontal facet position channel, for mark-level faceting, bound to the fx scale\n\nfy Channel\n\nThe vertical facet position channel, for mark-level faceting, bound to the fy scale.\n\nfacet Literal['auto', 'include', 'exclude', 'super'] | bool | None | Param\n\nWhether to enable or disable faceting.\n\nauto (default) - automatically determine if this mark should be faceted\ninclude (or True) - draw the subset of the mark’s data in the current facet\nexclude - draw the subset of the mark’s data not in the current facet\nsuper - draw this mark in a single frame that covers all facets\nnull (or False) - repeat this mark’s data across all facets (i.e., no faceting)\n\nWhen a mark uses super faceting, it is not allowed to use position scales (x, y, fx, or fy); super faceting is intended for decorations, such as labels and legends.\nWhen top-level faceting is used, the default auto setting is equivalent to include when the mark data is strictly equal to the top-level facet data; otherwise it is equivalent to null. When the include or exclude facet mode is chosen, the mark data must be parallel to the top-level facet data: the data must have the same length and order. If the data are not parallel, then the wrong data may be shown in each facet. The default auto therefore requires strict equality for safety, and using the facet data as mark data is recommended when using the exclude facet mode.\nWhen mark-level faceting is used, the default auto setting is equivalent to include: the mark will be faceted if either the fx or fy channel option (or both) is specified. The null or false option will disable faceting, while exclude draws the subset of the mark’s data not in the current facet.\n\nfacet_anchor Literal['top', 'right', 'bottom', 'left', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'top-empty', 'right-empty', 'bottom-empty', 'left-empty', 'empty'] | None | Param\n\nHow to place the mark with respect to facets.\n\nNone (default for most marks) - display the mark in each non-empty facet\ntop, right, bottom, or left - display the mark only in facets on the given side\ntop-empty, right-empty, bottom-empty, or left-empty (default for axis marks) - display the mark only in facets that have empty space on the given side: either the margin, or an empty facet\nempty - display the mark in empty facets only\n\n\nmargin float | Param\n\nShorthand to set the same default for all four mark margins.\n\nmargin_top float | Param\n\nThe mark’s top margin.\n\nmargin_right float | Param\n\nThe mark’s right margin.\n\nmargin_bottom float | Param\n\nThe mark’s bottom margin.\n\nmargin_left float | Param\n\nThe mark’s left margin.\n\naria_description str | Param\n\nARIA description (https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-description).\n\naria_hidden str | Param\n\nARIA hidden (https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-hidden).\n\naria_label Channel\n\nARIA label (https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-label/).\n\npointer_events str | Param\n\nPointer events (https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events).\n\ntitle Channel\n\nThe title; a channel specifying accessible, short textual descriptions as strings (possibly with newlines). If the tip option is specified, the title will be displayed with an interactive tooltip instead of using the SVG title element.\n\ntip Union[bool, TipPointer, TipOptions, Param]\n\nWhether to generate a tooltip for this mark, and any tip options.\n\nchannels dict[str, str]\n\nAdditional named channels, for example to include in a tooltip.\nConsists of (channel name, data field name) key-value pairs.\n\nclip Literal['frame', 'sphere'] | bool | None | Param\n\nHow to clip the mark.\n\nframe or True - clip to the plot’s frame (inner area)\nsphere - clip to the projected sphere (e.g., front hemisphere)\nNone or False - do not clip\n\nThe sphere clip option requires a geographic projection.\n\ndx float | Param\n\nThe horizontal offset in pixels; a constant option. On low-density screens, an additional 0.5px offset may be applied for crisp edges.\n\ndy float | Param\n\nThe vertical offset in pixels; a constant option. On low-density screens, an additional 0.5px offset may be applied for crisp edges.\n\nfill ChannelSpec | Param\n\nA constant CSS color string, or a channel typically bound to the color scale. If all channel values are valid CSS colors, by default the channel will not be bound to the color scale, interpreting the colors literally.\n\nfill_opacity ChannelSpec | Param\n\nA constant number between 0 and 1, or a channel typically bound to the opacity scale. If all channel values are numbers in [0, 1], by default the channel will not be bound to the opacity scale, interpreting the opacities literally.\n\nstroke ChannelSpec | Param\n\nA constant CSS color string, or a channel typically bound to the color scale. If all channel values are valid CSS colors, by default the channel will not be bound to the color scale, interpreting the colors literally.\n\nstroke_dasharray str | float | Param\n\nA constant number indicating the length in pixels of alternating dashes and gaps, or a constant string of numbers separated by spaces or commas (e.g., 10 2 for dashes of 10 pixels separated by gaps of 2 pixels), or none (the default) for no dashing.\n\nstroke_dashoffset str | float | Param\n\nA constant indicating the offset in pixels of the first dash along the stroke; defaults to zero.\n\nstroke_linecap str | Param\n\nA constant specifying how to cap stroked paths, such as butt, round, or square (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linecap).\n\nstroke_linejoin str | Param\n\nA constant specifying how to join stroked paths, such as bevel, miter, miter-clip, or round (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linejoin)\n\nstroke_miterlimit float | Param\n\nA constant number specifying how to limit the length of miter joins on stroked paths.\n\nstroke_opacity ChannelSpec\n\nA constant between 0 and 1, or a channel typically bound to the opacity scale. If all channel values are numbers in [0, 1], by default the channel will not be bound to the opacity scale, interpreting the opacities literally.\n\nstroke_width ChannelSpec\n\nA constant number in pixels, or a channel.\n\nopacity ChannelSpec\n\nA constant between 0 and 1, or a channel typically bound to the opacity scale. If all channel values are numbers in [0, 1], by default the channel will not be bound to the opacity scale, interpreting the opacities literally. For faster rendering, prefer the stroke_opacity or fill_opacity option.\n\nmix_blend_mode str | Param\n\nA constant string specifying how to blend content such as multiply (https://developer.mozilla.org/en-US/docs/Web/CSS/filter).\n\nimage_filter str | Param\n\nA constant string used to adjust the rendering of images, such as blur(5px) (https://developer.mozilla.org/en-US/docs/Web/CSS/filter).\n\npaint_order str | Param\n\nA constant string specifying the order in which the * fill, stroke, and any markers are drawn; defaults to normal, which draws the fill, then stroke, then markers; defaults to stroke for the text mark to create a “halo” around text to improve legibility.\n\nshape_rendering str | Param\n\nA constant string such as crispEdges (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).\n\nhref Channel\n\na channel specifying URLs for clickable links. May be used in conjunction with the target option to open links in another window.\n\ntarget str | Param\n\nA constant string specifying the target window (_e.g. *_blank*) for clickable links; used in conjunction with the href option (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/target).\n\n\n\n\n\nChannel\nData channel for visualization.\n\nSource\n\nChannel: TypeAlias = (\n    str | Transform | Sequence[int | float | bool | str] | int | float | bool | None\n)\n\n\nChannelSpec\nData channel spec for visualization.\n\nSource\n\nChannelSpec: TypeAlias = Channel | ChannelWithScale\n\n\nChannelIntervalSpec\nIn some contexts, when specifying a mark channel’s value, you can provide a {value, interval} object to specify an associated interval.\n\nSource\n\nChannelIntervalSpec: TypeAlias = ChannelSpec | ChannelWithInterval\n\n\nChannelWithInterval\nChannel with associated interval.\n\nSource\n\nclass ChannelWithInterval(TypedDict)\n\n\nChannelWithScale\nChannel with label and scale to override the scale that would normally be associated with the channel.\n\nSource\n\nclass ChannelWithScale(TypedDict)\n\n\nChannelName\nKnown channel names.\n\nSource\n\nChannelName: TypeAlias = Literal[\n    \"ariaLabel\",\n    \"fill\",\n    \"fillOpacity\",\n    \"fontSize\",\n    \"fx\",\n    \"fy\",\n    \"geometry\",\n    \"height\",\n    \"href\",\n    \"length\",\n    \"opacity\",\n    \"path\",\n    \"r\",\n    \"rotate\",\n    \"src\",\n    \"stroke\",\n    \"strokeOpacity\",\n    \"strokeWidth\",\n    \"symbol\",\n    \"text\",\n    \"title\",\n    \"weight\",\n    \"width\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"z\",\n]\n\n\nTipOptions\nOptions for the tip mark.\n\nSource\n\nclass TipOptions(TypedDict, total=False)\n\nAttributes\n\npointer TipPointer\n\nThe pointer mode for the tip (x, y, or xy)\n\nx ChannelSpec\n\nThe horizontal position channel specifying the tip’s anchor, typically bound to the x scale.\n\nx1 ChannelSpec\n\nThe starting horizontal position channel specifying the tip’s anchor, typically bound to the x scale.\n\nx2 ChannelSpec\n\nThe ending horizontal position channel specifying the tip’s anchor, typically bound to the x scale.\n\ny ChannelSpec\n\nThe vertical position channel specifying the tip’s anchor, typically bound to the y scale.\n\ny1 ChannelSpec\n\nThe starting vertical position channel specifying the tip’s anchor, typically bound to the y scale.\n\ny2 ChannelSpec\n\nThe ending vertical position channel specifying the tip’s anchor, typically bound to the y scale.\n\nframe_anchor FrameAnchor | Param\n\nThe frame anchor specifies defaults for x and y based on the plot’s frame.\nIt may be one of the four sides (top, right, bottom, left), one of the four corners (top-left, top-right, bottom-right, bottom-left), or the middle of the frame.\n\nanchor FrameAnchor | Param\n\nThe tip anchor specifies how to orient the tip box relative to its anchor position.\nThe tip anchor refers to the part of the tip box that is attached to the anchor point. For example, the top-left anchor places the top-left corner of tip box near the anchor position, hence placing the tip box below and to the right of the anchor position.\n\npreferred_anchor FrameAnchor | Param\n\nIf an explicit tip anchor is not specified, an anchor is chosen automatically such that the tip fits within the plot’s frame. If the preferred anchor fits, it is chosen.\n\nformat dict[ChannelName, bool | str | Param]\n\nHow channel values are formatted for display.\nIf a format is a string, it is interpreted as a (UTC) time format for temporal channels, and otherwise a number format.\n\n\n\n\n\nTipPointer\nThe pointer mode for the tip; corresponds to pointerX, pointerY, and pointer.\n\nSource\n\nTipPointer: TypeAlias = Literal[\"x\", \"y\", \"xy\"]\n\n\nCurve\nThe curve (interpolation) method for connecting adjacent points.\n\nSource\n\nCurve: TypeAlias = Literal[\n    \"basis\",\n    \"basis-closed\",\n    \"basis-open\",\n    \"bundle\",\n    \"bump-x\",\n    \"bump-y\",\n    \"cardinal\",\n    \"cardinal-closed\",\n    \"cardinal-open\",\n    \"catmull-rom\",\n    \"catmull-rom-closed\",\n    \"catmull-rom-open\",\n    \"linear\",\n    \"linear-closed\",\n    \"monotone-x\",\n    \"monotone-y\",\n    \"natural\",\n    \"step\",\n    \"step-after\",\n    \"step-before\",\n]\n\n\nSymbol\nSymbol type for dot or density plot.\n\nSource\n\nSymbol: TypeAlias = Literal[\n    \"asterisk\",\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"diamond2\",\n    \"hexagon\",\n    \"plus\",\n    \"square\",\n    \"square2\",\n    \"star\",\n    \"times\",\n    \"triangle\",\n    \"triangle2\",\n    \"wye\",\n]\n\n\nMarker\nSymbols used as plot markers.\n\nSource\n\nMarker: TypeAlias = Literal[\n    \"arrow\",\n    \"arrow-reverse\",\n    \"dot\",\n    \"circle\",\n    \"circle-fill\",\n    \"circle-stroke\",\n    \"tick\",\n    \"tick-x\",\n    \"tick-y\",\n]\n\n\nInterpolate\nThe spatial interpolation method.\n\nnone - do not perform interpolation (the default)\nlinear - apply proportional linear interpolation across adjacent bins\nnearest - assign each pixel to the closest sample’s value (Voronoi diagram)\nbarycentric - apply barycentric interpolation over the Delaunay triangulation\nrandom-walk - apply a random walk from each pixel\n\n\nSource\n\nInterpolate: TypeAlias = Literal[\n    \"none\", \"linear\", \"nearest\", \"barycentric\", \"random-walk\"\n]\n\n\nFrameAnchor\nDefaults for x and y based on the plot’s frame.\n\nSource\n\nFrameAnchor: TypeAlias = Literal[\n    \"middle\",\n    \"top-left\",\n    \"top\",\n    \"top-right\",\n    \"right\",\n    \"bottom-right\",\n    \"bottom\",\n    \"bottom-left\",\n    \"left\",\n]\n\n\nLineAnchor\nThe line anchor controls how text is aligned (typically vertically) relative to its anchor point.\n\nSource\n\nLineAnchor = Literal[\"top\", \"bottom\", \"middle\"]\n\n\nTextOverflow\nHow to truncate (or wrap) lines of text longer than the given line_width; one of:\n\nnull (default) preserve overflowing characters (and wrap if needed);\nclip or clip-end remove characters from the end;\nclip-start remove characters from the start;\nellipsis or ellipsis-end replace characters from the end with an ellipsis (…);\nellipsis-start replace characters from the start with an ellipsis (…);\nellipsis-middle replace characters from the middle with an ellipsis (…).\n\nIf no title was specified, if text requires truncation, a title containing the non-truncated text will be implicitly added.\n\nSource\n\nTextOverflow: TypeAlias = (\n    Literal[\n        \"clip\",\n        \"ellipsis\",\n        \"clip-start\",\n        \"clip-end\",\n        \"ellipsis-start\",\n        \"ellipsis-middle\",\n        \"ellipsis-end\",\n    ]\n    | None\n)\n\n\nTextStyles\nText styling options.\n\nSource\n\nclass TextStyles(TypedDict, total=False)\n\nAttributes\n\ntext_anchor Literal['start', 'middle', 'end'] | Param\n\nThe text anchor controls how text is aligned (typically horizontally) relative to its anchor point; it is one of start, end, or middle. If the frame anchor is left, top-left, or bottom-left, the default text anchor is start; if the frame anchor is right, top-right, or bottom-right, the default is end; otherwise it is middle.\n\nline_height float | Param\n\nThe line height in ems; defaults to 1. The line height affects the (typically vertical) separation between adjacent baselines of text, as well as the separation between the text and its anchor point.\n\nline_width float | Param\n\nThe line width in ems (e.g., 10 for about 20 characters); defaults to infinity, disabling wrapping and clipping. If text_overflow is null, lines will be wrapped at the specified length. If a line is split at a soft hyphen (­), a hyphen (-) will be displayed at the end of the line. If text_overflow is not null, lines will be clipped according to the given strategy.\n\ntext_overflow TextOverflow | Param\n\nText overflow behavior.\n\nmonospace bool | Param\n\nIf True, changes the default font_family to monospace, and uses simplified monospaced text metrics calculations.\n\nfont_family str | Param\n\nThe font-family; a constant; defaults to the plot’s font family, which is typically system-ui\n\nfont_size Channel | float | Param\n\nThe font size in pixels; either a constant or a channel; defaults to the plot’s font size, which is typically 10. When a number, it is interpreted as a constant; otherwise it is interpreted as a channel.\n\nfont_variant str | Param\n\nThe font variant; a constant; if the text channel contains numbers or dates, defaults to tabular-nums to facilitate comparing numbers; otherwise defaults to the plot’s font style, which is typically normal.\n\nfont_weight float | Param\n\nThe font weight; a constant; defaults to the plot’s font weight, which is typically normal.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.mark"
    ]
  },
  {
    "objectID": "reference/inspect_viz.html",
    "href": "reference/inspect_viz.html",
    "title": "inspect_viz",
    "section": "",
    "text": "Data\nData source for visualizations.\nData sources can be created from any standard Python data frame (e.g. Pandas, Polars, etc.) or from a path pointing to a data file in a standard format (e.g. csv, parquet, etc.)\n\nSource\n\nclass Data\n\nAttributes\n\ncolumns list[str]\n\nColumn names for data source.\n\n\n\n\nMethods\n\nfrom_dataframe\n\nCreate Data from a standard Python data frame (e.g. Pandas, Polars, PyArrow, etc.).\n\nSource\n\n@classmethod\ndef from_dataframe(cls, df: IntoDataFrame) -&gt; \"Data\"\n\ndf IntoDataFrame\n\nData frame to read.\n\n\n\nfrom_file\n\nCreate Data from a data file (e.g. csv, parquet, feather, etc.).\n\nSource\n\n@classmethod\ndef from_file(cls, file: str | PathLike[str]) -&gt; \"Data\"\n\nfile str | PathLike[str]\n\nFile to read data from. Supported formats include csv, json, xslx, parquet, feather, sas7bdat, dta, and fwf.\n\n\n\n\n\n\n\nComponent\nData visualization component (input, plot, mark, table, layout, etc.).\nVisualization components are Jupyter widgets that can be used in any notebook or Jupyter based publishing system.\nSee the documentation on inputs, plots, marks, and interactors for details on available components.\n\nSource\n\nclass Component(AnyWidget)\n\n\nSelection\nSelection that can be filtered by inputs and other selections.\nSelection types include:\n\nSelection.intersect() for intersecting clauses (logical “and”)\nSelection.union() for unionone clauses (logical “or”)\nSelection.single() for a single clause only\nSelection.crossfilter() for a cross-filtered intersection\n\n\nSource\n\nclass Selection(str)\n\nMethods\n\nintersect\n\nCreate a new Selection instance with an intersect (conjunction) resolution strategy.\n\nSource\n\n@classmethod\ndef intersect(\n    cls,\n    cross: bool = False,\n    empty: bool = False,\n    include: Union[\"Selection\", list[\"Selection\"]] | None = None,\n) -&gt; \"Selection\"\n\ncross bool\n\nBoolean flag indicating cross-filtered resolution. If true, selection clauses will not be applied to the clients they are associated with.\n\nempty bool\n\nBoolean flag indicating if a lack of clauses should correspond to an empty selection with no records. This setting determines the default selection state.\n\ninclude Union[Selection, list[Selection]] | None\n\nUpstream selections whose clauses should be included as part of the new selection. Any clauses published to upstream selections will be relayed to the new selection.\n\n\n\nunion\n\nCreate a new Selection instance with a union (disjunction) resolution strategy.\n\nSource\n\n@classmethod\ndef union(\n    cls,\n    cross: bool = False,\n    empty: bool = False,\n    include: Union[\"Selection\", list[\"Selection\"]] | None = None,\n) -&gt; \"Selection\"\n\ncross bool\n\nBoolean flag indicating cross-filtered resolution. If true, selection clauses will not be applied to the clients they are associated with.\n\nempty bool\n\nBoolean flag indicating if a lack of clauses should correspond to an empty selection with no records. This setting determines the default selection state.\n\ninclude Union[Selection, list[Selection]] | None\n\nUpstream selections whose clauses should be included as part of the new selection. Any clauses published to upstream selections will be relayed to the new selection.\n\n\n\nsingle\n\nCreate a new Selection instance with a singular resolution strategy that keeps only the most recent selection clause.\n\nSource\n\n@classmethod\ndef single(\n    cls,\n    cross: bool = False,\n    empty: bool = False,\n    include: Union[\"Selection\", list[\"Selection\"]] | None = None,\n) -&gt; \"Selection\"\n\ncross bool\n\nBoolean flag indicating cross-filtered resolution. If true, selection clauses will not be applied to the clients they are associated with.\n\nempty bool\n\nBoolean flag indicating if a lack of clauses should correspond to an empty selection with no records. This setting determines the default selection state.\n\ninclude Union[Selection, list[Selection]] | None\n\nUpstream selections whose clauses should be included as part of the new selection. Any clauses published to upstream selections will be relayed to the new selection.\n\n\n\ncrossfilter\n\nCreate a new Selection instance with a cross-filtered intersect resolution strategy.\n\nSource\n\n@classmethod\ndef crossfilter(\n    cls,\n    empty: bool = False,\n    include: Union[\"Selection\", list[\"Selection\"]] | None = None,\n) -&gt; \"Selection\"\n\nempty bool\n\nBoolean flag indicating if a lack of clauses should correspond to an empty selection with no records. This setting determines the default selection state.\n\ninclude Union[Selection, list[Selection]] | None\n\nUpstream selections whose clauses should be included as part of the new selection. Any clauses published to upstream selections will be relayed to the new selection.\n\n\n\n\n\n\n\nParam\nParameter that can be bound from inputs.\n\nSource\n\nclass Param(str)\n\nAttributes\n\nid str\n\nUnique id (automatically generated).\n\ndefault ParamValue\n\nDefault value.\n\n\n\n\n\nParamValue\nType alias for parameter values (scalar or sequence of scalars).\n\nSource\n\nParamValue: TypeAlias = (\n    int | float | bool | str | datetime | Sequence[int | float | bool | str]\n)",
    "crumbs": [
      "Reference",
      "Python API"
    ]
  },
  {
    "objectID": "reference/inspect_viz.layout.html",
    "href": "reference/inspect_viz.layout.html",
    "title": "inspect_viz.layout",
    "section": "",
    "text": "hconcat\nHorizontally concatenate components in a row layout.\n\nSource\n\ndef hconcat(*component: Component) -&gt; Component\n\n*component Component\n\nComponents to concatenate.\n\n\n\n\nvconcat\nVertically concatenate components in a column layout.\n\nSource\n\ndef vconcat(*component: Component) -&gt; Component\n\n*component Component\n\nComponents to concatenate.\n\n\n\n\nhspace\nHorizontal space to place between widgets.\n\nSource\n\ndef hspace(hspace: float | str = 10) -&gt; Component\n\nhspace float | str\n\nAmount of space. Number values indicate screen pixels. String values may use CSS units (em, pt, px, etc).\n\n\n\n\nvspace\nVeritcal space to place between widgets.\n\nSource\n\ndef vspace(vspace: float | str = 10) -&gt; Component\n\nvspace float | str\n\nAmount of space. Number values indicate screen pixels. String values may use CSS units (em, pt, px, etc).",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.layout"
    ]
  },
  {
    "objectID": "reference/inspect_viz.interactor.html",
    "href": "reference/inspect_viz.interactor.html",
    "title": "inspect_viz.interactor",
    "section": "",
    "text": "Select a continuous 1D interval selection over the x scale domain.\n\nSource\n\ndef interval_x(\n    target: Selection,\n    field: str | None = None,\n    pixel_size: float | None = None,\n    peers: bool | None = None,\n    brush: Brush | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form field BETWEEN lo AND hi is added for the currently selected interval [lo, hi].\n\nfield str | None\n\nThe name of the field (database column) over which the interval selection should be defined. If unspecified, the channel field of the first valid prior mark definition is used.\n\npixel_size float | None\n\nThe size of an interative pixel (default 1). Larger pixel sizes reduce the brush resolution, which can reduce the size of pre-aggregated materialized views.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\nbrush Brush | None\n\nCSS styles for the brush (SVG rect) element.\n\n\n\n\n\nSelect a continuous 1D interval selection over the y scale domain.\n\nSource\n\ndef interval_y(\n    target: Selection,\n    field: str | None = None,\n    pixel_size: float | None = None,\n    peers: bool | None = None,\n    brush: Brush | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form field BETWEEN lo AND hi is added for the currently selected interval [lo, hi].\n\nfield str | None\n\nThe name of the field (database column) over which the interval selection should be defined. If unspecified, the channel field of the first valid prior mark definition is used.\n\npixel_size float | None\n\nThe size of an interative pixel (default 1). Larger pixel sizes reduce the brush resolution, which can reduce the size of pre-aggregated materialized views.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\nbrush Brush | None\n\nCSS styles for the brush (SVG rect) element.\n\n\n\n\n\nSelect a continuous 2D interval selection over the x and y scale domains.\n\nSource\n\ndef interval_xy(\n    target: Selection,\n    xfield: str | None = None,\n    yfield: str | None = None,\n    pixel_size: float | None = None,\n    peers: bool | None = None,\n    brush: Brush | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (xfield BETWEEN x1 AND x2) AND (yfield BETWEEN y1 AND y2) is added for the currently selected intervals.\n\nxfield str | None\n\nThe name of the field (database column) over which the x-component of the interval selection should be defined. If unspecified, the x channel field of the first valid prior mark definition is used.\n\nyfield str | None\n\nThe name of the field (database column) over which the y-component of the interval selection should be defined. If unspecified, the y channel field of the first valid prior mark definition is used.\n\npixel_size float | None\n\nThe size of an interative pixel (default 1). Larger pixel sizes reduce the brush resolution, which can reduce the size of pre-aggregated materialized views.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\nbrush Brush | None\n\nCSS styles for the brush (SVG rect) element.\n\n\n\n\n\nSelect values from the mark closest to the pointer x location.\n\nSource\n\ndef nearest_x(\n    target: Selection,\n    channels: list[str] | None = None,\n    fields: list[str] | None = None,\n    max_radius: float | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form field = value is added for the currently nearest value.\n\nchannels list[str] | None\n\nThe encoding channels whose domain values should be selected. For example, a setting of ['color'] selects the data value backing the color channel, whereas ['x', 'z'] selects both x and z channel domain values. If unspecified, the selected channels default to match the current pointer settings: a nearestX interactor selects the ['x'] channels, while a nearest interactor selects the ['x', 'y'] channels.\n\nfields list[str] | None\n\nThe fields (database column names) to use in generated selection clause predicates. If unspecified, the fields backing the selected channels in the first valid prior mark definition are used by default.\n\nmax_radius float | None\n\nThe maximum radius of a nearest selection (default 40). Marks with (x, y) coordinates outside this radius will not be selected as nearest points.\n\n\n\n\n\nSelect values from the mark closest to the pointer y location.\n\nSource\n\ndef nearest_y(\n    target: Selection,\n    channels: list[str] | None = None,\n    fields: list[str] | None = None,\n    max_radius: float | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form field = value is added for the currently nearest value.\n\nchannels list[str] | None\n\nThe encoding channels whose domain values should be selected. For example, a setting of ['color'] selects the data value backing the color channel, whereas ['x', 'z'] selects both x and z channel domain values. If unspecified, the selected channels default to match the current pointer settings: a nearestX interactor selects the ['x'] channels, while a nearest interactor selects the ['x', 'y'] channels.\n\nfields list[str] | None\n\nThe fields (database column names) to use in generated selection clause predicates. If unspecified, the fields backing the selected channels in the first valid prior mark definition are used by default.\n\nmax_radius float | None\n\nThe maximum radius of a nearest selection (default 40). Marks with (x, y) coordinates outside this radius will not be selected as nearest points.\n\n\n\n\n\nSelect individal values.\n\nSource\n\ndef toggle(\n    target: Selection,\n    channels: list[str],\n    peers: bool | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\nchannels list[str]\n\nThe encoding channels over which to select values. For a selected mark, selection clauses will cover the backing data fields for each channel.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\n\n\n\n\nSelect individal values in the x scale domain. Clicking or touching a mark toggles its selection status.\n\nSource\n\ndef toggle_x(\n    target: Selection,\n    peers: bool | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\n\n\n\n\nToggle interactor over the \"y\" encoding channel only.\n\nSource\n\ndef toggle_y(\n    target: Selection,\n    peers: bool | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\n\n\n\n\nSelect individal values in the color scale domain. Clicking or touching a mark toggles its selection status.\n\nSource\n\ndef toggle_color(\n    target: Selection,\n    peers: bool | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\n\n\n\n\nSelect aspects of individual marks within a 2D range.\n\nSource\n\ndef region(\n    target: Selection,\n    channels: list[str],\n    peers: bool | None = None,\n    brush: Brush | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\nchannels list[str]\n\nThe encoding channels over which to select values (e.g. “x”, “y”, “color”, etc.). For a selected mark, selection clauses will cover the backing data fields for each channel.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\nbrush Brush | None\n\nCSS styles for the brush (SVG rect) element.\n\n\n\n\n\nHighlight individual visualized data points based on a Selection.\nSelected values keep their normal appearance. Unselected values are deemphasized.\n\nSource\n\ndef highlight(\n    by: Selection,\n    opacity: float | None = None,\n    fill_opacity: float | None = None,\n    stroke_opacity: float | None = None,\n    fill: str | None = None,\n    stroke: str | None = None,\n) -&gt; Interactor\n\nby Selection\n\nThe input selection. Unselected marks are deemphasized.\n\nopacity float | None\n\nThe overall opacity of deemphasized marks. By default the opacity is set to 0.2.\n\nfill_opacity float | None\n\nThe fill opacity of deemphasized marks. By default the fill opacity is unchanged.\n\nstroke_opacity float | None\n\nThe stroke opacity of deemphasized marks. By default the stroke opacity is unchanged.\n\nfill str | None\n\nThe fill color of deemphasized marks. By default the fill is unchanged.\n\nstroke str | None\n\nThe stroke color of deemphasized marks. By default the stroke is unchanged.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.interactor"
    ]
  },
  {
    "objectID": "reference/inspect_viz.interactor.html#selection",
    "href": "reference/inspect_viz.interactor.html#selection",
    "title": "inspect_viz.interactor",
    "section": "",
    "text": "Select a continuous 1D interval selection over the x scale domain.\n\nSource\n\ndef interval_x(\n    target: Selection,\n    field: str | None = None,\n    pixel_size: float | None = None,\n    peers: bool | None = None,\n    brush: Brush | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form field BETWEEN lo AND hi is added for the currently selected interval [lo, hi].\n\nfield str | None\n\nThe name of the field (database column) over which the interval selection should be defined. If unspecified, the channel field of the first valid prior mark definition is used.\n\npixel_size float | None\n\nThe size of an interative pixel (default 1). Larger pixel sizes reduce the brush resolution, which can reduce the size of pre-aggregated materialized views.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\nbrush Brush | None\n\nCSS styles for the brush (SVG rect) element.\n\n\n\n\n\nSelect a continuous 1D interval selection over the y scale domain.\n\nSource\n\ndef interval_y(\n    target: Selection,\n    field: str | None = None,\n    pixel_size: float | None = None,\n    peers: bool | None = None,\n    brush: Brush | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form field BETWEEN lo AND hi is added for the currently selected interval [lo, hi].\n\nfield str | None\n\nThe name of the field (database column) over which the interval selection should be defined. If unspecified, the channel field of the first valid prior mark definition is used.\n\npixel_size float | None\n\nThe size of an interative pixel (default 1). Larger pixel sizes reduce the brush resolution, which can reduce the size of pre-aggregated materialized views.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\nbrush Brush | None\n\nCSS styles for the brush (SVG rect) element.\n\n\n\n\n\nSelect a continuous 2D interval selection over the x and y scale domains.\n\nSource\n\ndef interval_xy(\n    target: Selection,\n    xfield: str | None = None,\n    yfield: str | None = None,\n    pixel_size: float | None = None,\n    peers: bool | None = None,\n    brush: Brush | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (xfield BETWEEN x1 AND x2) AND (yfield BETWEEN y1 AND y2) is added for the currently selected intervals.\n\nxfield str | None\n\nThe name of the field (database column) over which the x-component of the interval selection should be defined. If unspecified, the x channel field of the first valid prior mark definition is used.\n\nyfield str | None\n\nThe name of the field (database column) over which the y-component of the interval selection should be defined. If unspecified, the y channel field of the first valid prior mark definition is used.\n\npixel_size float | None\n\nThe size of an interative pixel (default 1). Larger pixel sizes reduce the brush resolution, which can reduce the size of pre-aggregated materialized views.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\nbrush Brush | None\n\nCSS styles for the brush (SVG rect) element.\n\n\n\n\n\nSelect values from the mark closest to the pointer x location.\n\nSource\n\ndef nearest_x(\n    target: Selection,\n    channels: list[str] | None = None,\n    fields: list[str] | None = None,\n    max_radius: float | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form field = value is added for the currently nearest value.\n\nchannels list[str] | None\n\nThe encoding channels whose domain values should be selected. For example, a setting of ['color'] selects the data value backing the color channel, whereas ['x', 'z'] selects both x and z channel domain values. If unspecified, the selected channels default to match the current pointer settings: a nearestX interactor selects the ['x'] channels, while a nearest interactor selects the ['x', 'y'] channels.\n\nfields list[str] | None\n\nThe fields (database column names) to use in generated selection clause predicates. If unspecified, the fields backing the selected channels in the first valid prior mark definition are used by default.\n\nmax_radius float | None\n\nThe maximum radius of a nearest selection (default 40). Marks with (x, y) coordinates outside this radius will not be selected as nearest points.\n\n\n\n\n\nSelect values from the mark closest to the pointer y location.\n\nSource\n\ndef nearest_y(\n    target: Selection,\n    channels: list[str] | None = None,\n    fields: list[str] | None = None,\n    max_radius: float | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form field = value is added for the currently nearest value.\n\nchannels list[str] | None\n\nThe encoding channels whose domain values should be selected. For example, a setting of ['color'] selects the data value backing the color channel, whereas ['x', 'z'] selects both x and z channel domain values. If unspecified, the selected channels default to match the current pointer settings: a nearestX interactor selects the ['x'] channels, while a nearest interactor selects the ['x', 'y'] channels.\n\nfields list[str] | None\n\nThe fields (database column names) to use in generated selection clause predicates. If unspecified, the fields backing the selected channels in the first valid prior mark definition are used by default.\n\nmax_radius float | None\n\nThe maximum radius of a nearest selection (default 40). Marks with (x, y) coordinates outside this radius will not be selected as nearest points.\n\n\n\n\n\nSelect individal values.\n\nSource\n\ndef toggle(\n    target: Selection,\n    channels: list[str],\n    peers: bool | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\nchannels list[str]\n\nThe encoding channels over which to select values. For a selected mark, selection clauses will cover the backing data fields for each channel.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\n\n\n\n\nSelect individal values in the x scale domain. Clicking or touching a mark toggles its selection status.\n\nSource\n\ndef toggle_x(\n    target: Selection,\n    peers: bool | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\n\n\n\n\nToggle interactor over the \"y\" encoding channel only.\n\nSource\n\ndef toggle_y(\n    target: Selection,\n    peers: bool | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\n\n\n\n\nSelect individal values in the color scale domain. Clicking or touching a mark toggles its selection status.\n\nSource\n\ndef toggle_color(\n    target: Selection,\n    peers: bool | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\n\n\n\n\nSelect aspects of individual marks within a 2D range.\n\nSource\n\ndef region(\n    target: Selection,\n    channels: list[str],\n    peers: bool | None = None,\n    brush: Brush | None = None,\n) -&gt; Interactor\n\ntarget Selection\n\nThe target selection. A clause of the form (field = value1) OR (field = value2) ... is added for the currently selected values.\n\nchannels list[str]\n\nThe encoding channels over which to select values (e.g. “x”, “y”, “color”, etc.). For a selected mark, selection clauses will cover the backing data fields for each channel.\n\npeers bool | None\n\nA flag indicating if peer (sibling) marks are excluded when cross-filtering (default true). If set, peer marks will not be filtered by this interactor’s selection in cross-filtering setups.\n\nbrush Brush | None\n\nCSS styles for the brush (SVG rect) element.\n\n\n\n\n\nHighlight individual visualized data points based on a Selection.\nSelected values keep their normal appearance. Unselected values are deemphasized.\n\nSource\n\ndef highlight(\n    by: Selection,\n    opacity: float | None = None,\n    fill_opacity: float | None = None,\n    stroke_opacity: float | None = None,\n    fill: str | None = None,\n    stroke: str | None = None,\n) -&gt; Interactor\n\nby Selection\n\nThe input selection. Unselected marks are deemphasized.\n\nopacity float | None\n\nThe overall opacity of deemphasized marks. By default the opacity is set to 0.2.\n\nfill_opacity float | None\n\nThe fill opacity of deemphasized marks. By default the fill opacity is unchanged.\n\nstroke_opacity float | None\n\nThe stroke opacity of deemphasized marks. By default the stroke opacity is unchanged.\n\nfill str | None\n\nThe fill color of deemphasized marks. By default the fill is unchanged.\n\nstroke str | None\n\nThe stroke color of deemphasized marks. By default the stroke is unchanged.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.interactor"
    ]
  },
  {
    "objectID": "reference/inspect_viz.interactor.html#navigation",
    "href": "reference/inspect_viz.interactor.html#navigation",
    "title": "inspect_viz.interactor",
    "section": "Navigation",
    "text": "Navigation\n\npan\nPan a plot along both the x and y scales.\n\nSource\n\ndef pan(\n    x: Selection | None = None,\n    y: Selection | None = None,\n    xfield: str | None = None,\n    yfield: str | None = None,\n) -&gt; Interactor\n\nx Selection | None\n\nThe output selection for the x domain. A clause of the form field BETWEEN x1 AND x2 is added for the current pan/zom interval [x1, x2].\n\ny Selection | None\n\nThe output selection for the y domain. A clause of the form field BETWEEN y1 AND y2 is added for the current pan/zom interval [y1, y2].\n\nxfield str | None\n\nThe name of the field (database column) over which the x-component of the pan/zoom interval should be defined. If unspecified, the x channel field of the first valid prior mark definition is used.\n\nyfield str | None\n\nThe name of the field (database column) over which the y-component of the pan/zoom interval should be defined. If unspecified, the y channel field of the first valid prior mark definition is used.\n\n\n\n\npan_x\nPan a plot along the x scale only.\n\nSource\n\ndef pan_x(\n    x: Selection | None = None,\n    y: Selection | None = None,\n    xfield: str | None = None,\n    yfield: str | None = None,\n) -&gt; Interactor\n\nx Selection | None\n\nThe output selection for the x domain. A clause of the form field BETWEEN x1 AND x2 is added for the current pan/zom interval [x1, x2].\n\ny Selection | None\n\nThe output selection for the y domain. A clause of the form field BETWEEN y1 AND y2 is added for the current pan/zom interval [y1, y2].\n\nxfield str | None\n\nThe name of the field (database column) over which the x-component of the pan/zoom interval should be defined. If unspecified, the x channel field of the first valid prior mark definition is used.\n\nyfield str | None\n\nThe name of the field (database column) over which the y-component of the pan/zoom interval should be defined. If unspecified, the y channel field of the first valid prior mark definition is used.\n\n\n\n\npan_y\nPan a plot along the y scale only.\n\nSource\n\ndef pan_y(\n    x: Selection | None = None,\n    y: Selection | None = None,\n    xfield: str | None = None,\n    yfield: str | None = None,\n) -&gt; Interactor\n\nx Selection | None\n\nThe output selection for the x domain. A clause of the form field BETWEEN x1 AND x2 is added for the current pan/zom interval [x1, x2].\n\ny Selection | None\n\nThe output selection for the y domain. A clause of the form field BETWEEN y1 AND y2 is added for the current pan/zom interval [y1, y2].\n\nxfield str | None\n\nThe name of the field (database column) over which the x-component of the pan/zoom interval should be defined. If unspecified, the x channel field of the first valid prior mark definition is used.\n\nyfield str | None\n\nThe name of the field (database column) over which the y-component of the pan/zoom interval should be defined. If unspecified, the y channel field of the first valid prior mark definition is used.\n\n\n\n\npan_zoom\nPan and zoom a plot along both the x and y scales.\n\nSource\n\ndef pan_zoom(\n    x: Selection | None = None,\n    y: Selection | None = None,\n    xfield: str | None = None,\n    yfield: str | None = None,\n) -&gt; Interactor\n\nx Selection | None\n\nThe output selection for the x domain. A clause of the form field BETWEEN x1 AND x2 is added for the current pan/zom interval [x1, x2].\n\ny Selection | None\n\nThe output selection for the y domain. A clause of the form field BETWEEN y1 AND y2 is added for the current pan/zom interval [y1, y2].\n\nxfield str | None\n\nThe name of the field (database column) over which the x-component of the pan/zoom interval should be defined. If unspecified, the x channel field of the first valid prior mark definition is used.\n\nyfield str | None\n\nThe name of the field (database column) over which the y-component of the pan/zoom interval should be defined. If unspecified, the y channel field of the first valid prior mark definition is used.\n\n\n\n\npan_zoom_x\nPan and zoom a plot along the x scale only.\n\nSource\n\ndef pan_zoom_x(\n    x: Selection | None = None,\n    y: Selection | None = None,\n    xfield: str | None = None,\n    yfield: str | None = None,\n) -&gt; Interactor\n\nx Selection | None\n\nThe output selection for the x domain. A clause of the form field BETWEEN x1 AND x2 is added for the current pan/zom interval [x1, x2].\n\ny Selection | None\n\nThe output selection for the y domain. A clause of the form field BETWEEN y1 AND y2 is added for the current pan/zom interval [y1, y2].\n\nxfield str | None\n\nThe name of the field (database column) over which the x-component of the pan/zoom interval should be defined. If unspecified, the x channel field of the first valid prior mark definition is used.\n\nyfield str | None\n\nThe name of the field (database column) over which the y-component of the pan/zoom interval should be defined. If unspecified, the y channel field of the first valid prior mark definition is used.\n\n\n\n\npan_zoom_y\nPan and zoom a plot along the y scale only.\n\nSource\n\ndef pan_zoom_y(\n    x: Selection | None = None,\n    y: Selection | None = None,\n    xfield: str | None = None,\n    yfield: str | None = None,\n) -&gt; Interactor\n\nx Selection | None\n\nThe output selection for the x domain. A clause of the form field BETWEEN x1 AND x2 is added for the current pan/zom interval [x1, x2].\n\ny Selection | None\n\nThe output selection for the y domain. A clause of the form field BETWEEN y1 AND y2 is added for the current pan/zom interval [y1, y2].\n\nxfield str | None\n\nThe name of the field (database column) over which the x-component of the pan/zoom interval should be defined. If unspecified, the x channel field of the first valid prior mark definition is used.\n\nyfield str | None\n\nThe name of the field (database column) over which the y-component of the pan/zoom interval should be defined. If unspecified, the y channel field of the first valid prior mark definition is used.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.interactor"
    ]
  },
  {
    "objectID": "reference/inspect_viz.interactor.html#types",
    "href": "reference/inspect_viz.interactor.html#types",
    "title": "inspect_viz.interactor",
    "section": "Types",
    "text": "Types\n\nInteractor\nInteractors imbue plots with interactive behavior, such as selecting or highlighting values, and panning or zooming the display.\n\nSource\n\nclass Interactor(Component)\n\n\nBrush\nBrush options.\n\nSource\n\nclass Brush(TypedDict, total=False)\n\nAttributes\n\nfill str\n\nThe fill color of the brush rectangle.\n\nfill_opacity float\n\nThe fill opacity of the brush rectangle.\n\nopacity float\n\nThe overall opacity of the brush rectangle.\n\nstroke str\n\nThe stroke color of the brush rectangle.\n\nstroke_dasharray str\n\nThe stroke dash array of the brush rectangle.\n\nstroke_opacity float\n\nThe stroke opacity of the brush rectangle.",
    "crumbs": [
      "Reference",
      "Python API",
      "inspect_viz.interactor"
    ]
  }
]